(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[343],{40111:function(module){eval('/* MapLibre GL JS is licensed under the 3-Clause BSD License. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v1.15.3/LICENSE.txt */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  \'use strict\';\n\n  /* eslint-disable */\n  var shared, worker, maplibregl;\n  // define gets called three times: one for each chunk. we rely on the order\n  // they\'re imported to know which is which\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \'var sharedChunk = {}; (\' + shared + \')(sharedChunk); (\' + worker + \')(sharedChunk);\';\n      var sharedChunk = {};\n      shared(sharedChunk);\n      maplibregl = chunk(sharedChunk);\n      if (typeof window !== \'undefined\') {\n        maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: \'text/javascript\'\n        }));\n      }\n    }\n  }\n  define(["exports"], function (t) {\n    "use strict";\n\n    function e(t, e) {\n      return t(e = {\n        exports: {}\n      }, e.exports), e.exports;\n    }\n    var r = n;\n    function n(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = r, this.p2y = n;\n    }\n    n.prototype.sampleCurveX = function (t) {\n      return ((this.ax * t + this.bx) * t + this.cx) * t;\n    }, n.prototype.sampleCurveY = function (t) {\n      return ((this.ay * t + this.by) * t + this.cy) * t;\n    }, n.prototype.sampleCurveDerivativeX = function (t) {\n      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n    }, n.prototype.solveCurveX = function (t, e) {\n      var r, n, i, a, o;\n      for (void 0 === e && (e = 1e-6), i = t, o = 0; o < 8; o++) {\n        if (a = this.sampleCurveX(i) - t, Math.abs(a) < e) return i;\n        var s = this.sampleCurveDerivativeX(i);\n        if (Math.abs(s) < 1e-6) break;\n        i -= a / s;\n      }\n      if ((i = t) < (r = 0)) return r;\n      if (i > (n = 1)) return n;\n      for (; r < n;) {\n        if (a = this.sampleCurveX(i), Math.abs(a - t) < e) return i;\n        t > a ? r = i : n = i, i = .5 * (n - r) + r;\n      }\n      return i;\n    }, n.prototype.solve = function (t, e) {\n      return this.sampleCurveY(this.solveCurveX(t, e));\n    };\n    var i = a;\n    function a(t, e) {\n      this.x = t, this.y = e;\n    }\n    a.prototype = {\n      clone: function () {\n        return new a(this.x, this.y);\n      },\n      add: function (t) {\n        return this.clone()._add(t);\n      },\n      sub: function (t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function (t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function (t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function (t) {\n        return this.clone()._mult(t);\n      },\n      div: function (t) {\n        return this.clone()._div(t);\n      },\n      rotate: function (t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function (t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function (t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function () {\n        return this.clone()._unit();\n      },\n      perp: function () {\n        return this.clone()._perp();\n      },\n      round: function () {\n        return this.clone()._round();\n      },\n      mag: function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function (t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function (t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function (t) {\n        var e = t.x - this.x,\n          r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function () {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function (t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function (t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function (t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function (t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function (t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function (t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function (t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function (t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function (t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function (t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function () {\n        return this._div(this.mag()), this;\n      },\n      _perp: function () {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function (t) {\n        var e = Math.cos(t),\n          r = Math.sin(t),\n          n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function (t, e) {\n        var r = Math.cos(t),\n          n = Math.sin(t),\n          i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function () {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, a.convert = function (t) {\n      return t instanceof a ? t : Array.isArray(t) ? new a(t[0], t[1]) : t;\n    };\n    var o = "undefined" != typeof self ? self : {},\n      s = Math.pow(2, 53) - 1;\n    function u(t, e, n, i) {\n      var a = new r(t, e, n, i);\n      return function (t) {\n        return a.solve(t);\n      };\n    }\n    var l = u(.25, .1, .25, 1);\n    function p(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n    function c(t, e, r) {\n      var n = r - e,\n        i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n    function h(t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) e[r] = arguments[r + 1];\n      for (var n = 0, i = e; n < i.length; n += 1) {\n        var a = i[n];\n        for (var o in a) t[o] = a[o];\n      }\n      return t;\n    }\n    var f = 1;\n    function y() {\n      return f++;\n    }\n    function d() {\n      return function t(e) {\n        return e ? (e ^ 16 * Math.random() >> e / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }\n    function m(t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }\n    function v(t, e) {\n      t.forEach(function (t) {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n    function g(t, e) {\n      return -1 !== t.indexOf(e, t.length - e.length);\n    }\n    function x(t, e, r) {\n      var n = {};\n      for (var i in t) n[i] = e.call(r || this, t[i], i, t);\n      return n;\n    }\n    function b(t, e, r) {\n      var n = {};\n      for (var i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n      return n;\n    }\n    function w(t) {\n      return Array.isArray(t) ? t.map(w) : "object" == typeof t && t ? x(t, w) : t;\n    }\n    var _ = {};\n    function A(t) {\n      _[t] || ("undefined" != typeof console && console.warn(t), _[t] = !0);\n    }\n    function S(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n    function k(t) {\n      for (var e = 0, r = 0, n = t.length, i = n - 1, a = void 0, o = void 0; r < n; i = r++) e += ((o = t[i]).x - (a = t[r]).x) * (a.y + o.y);\n      return e;\n    }\n    function I() {\n      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;\n    }\n    function z(t) {\n      var e = {};\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\"((?:[^"\\\\]|\\\\.)*)\\")))?/g, function (t, r, n, i) {\n        var a = n || i;\n        return e[r] = !a || a.toLowerCase(), "";\n      }), e["max-age"]) {\n        var r = parseInt(e["max-age"], 10);\n        isNaN(r) ? delete e["max-age"] : e["max-age"] = r;\n      }\n      return e;\n    }\n    var C = null;\n    function E(t) {\n      if (null == C) {\n        var e = t.navigator ? t.navigator.userAgent : null;\n        C = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match("Safari") && !e.match("Chrome")));\n      }\n      return C;\n    }\n    function P(t) {\n      try {\n        var e = o[t];\n        return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    var M,\n      B,\n      T,\n      V,\n      F = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date),\n      D = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame,\n      L = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame,\n      R = {\n        now: F,\n        frame: function (t) {\n          var e = D(t);\n          return {\n            cancel: function () {\n              return L(e);\n            }\n          };\n        },\n        getImageData: function (t, e) {\n          void 0 === e && (e = 0);\n          var r = o.document.createElement("canvas"),\n            n = r.getContext("2d");\n          if (!n) throw new Error("failed to create canvas 2d context");\n          return r.width = t.width, r.height = t.height, n.drawImage(t, 0, 0, t.width, t.height), n.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);\n        },\n        resolveURL: function (t) {\n          return M || (M = o.document.createElement("a")), M.href = t, M.href;\n        },\n        hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4,\n        get devicePixelRatio() {\n          return o.devicePixelRatio;\n        },\n        get prefersReducedMotion() {\n          return !!o.matchMedia && (null == B && (B = o.matchMedia("(prefers-reduced-motion: reduce)")), B.matches);\n        }\n      },\n      O = {\n        API_URL: "https://api.mapbox.com",\n        get EVENTS_URL() {\n          return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;\n        },\n        FEEDBACK_URL: "https://apps.mapbox.com/feedback",\n        REQUIRE_ACCESS_TOKEN: !0,\n        ACCESS_TOKEN: null,\n        MAX_PARALLEL_IMAGE_REQUESTS: 16,\n        REGISTERED_PROTOCOLS: {}\n      },\n      U = {\n        supported: !1,\n        testSupport: function (t) {\n          !j && V && (q ? N(t) : T = t);\n        }\n      },\n      j = !1,\n      q = !1;\n    function N(t) {\n      var e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, V), t.isContextLost()) return;\n        U.supported = !0;\n      } catch (t) {}\n      t.deleteTexture(e), j = !0;\n    }\n    o.document && ((V = o.document.createElement("img")).onload = function () {\n      T && N(T), T = null, q = !0;\n    }, V.onerror = function () {\n      j = !0, T = null;\n    }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");\n    var K = "01",\n      G = function (t, e) {\n        this._transformRequestFn = t, this._customAccessToken = e, this._createSkuToken();\n      };\n    function Z(t) {\n      return 0 === t.indexOf("mapbox:");\n    }\n    G.prototype._createSkuToken = function () {\n      var t = function () {\n        for (var t = "", e = 0; e < 10; e++) t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];\n        return {\n          token: ["1", K, t].join(""),\n          tokenExpiresAt: Date.now() + 432e5\n        };\n      }();\n      this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;\n    }, G.prototype._isSkuTokenExpired = function () {\n      return Date.now() > this._skuTokenExpiresAt;\n    }, G.prototype.transformRequest = function (t, e) {\n      return this._transformRequestFn && this._transformRequestFn(t, e) || {\n        url: t\n      };\n    }, G.prototype.normalizeStyleURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/styles/v1" + r.path, this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeGlyphsURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/fonts/v1" + r.path, this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeSourceURL = function (t, e) {\n      if (!Z(t)) return t;\n      var r = Y(t);\n      return r.path = "/v4/" + r.authority + ".json", r.params.push("secure"), this._makeAPIURL(r, this._customAccessToken || e);\n    }, G.prototype.normalizeSpriteURL = function (t, e, r, n) {\n      var i = Y(t);\n      return Z(t) ? (i.path = "/styles/v1" + i.path + "/sprite" + e + r, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += "" + e + r, $(i));\n    }, G.prototype.normalizeTileURL = function (t, e) {\n      if (this._isSkuTokenExpired() && this._createSkuToken(), t && !Z(t)) return t;\n      var r = Y(t);\n      r.path = r.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, (R.devicePixelRatio >= 2 || 512 === e ? "@2x" : "") + (U.supported ? ".webp" : "$1")), r.path = r.path.replace(/^.+\\/v4\\//, "/"), r.path = "/v4" + r.path;\n      var n = this._customAccessToken || function (t) {\n        for (var e = 0, r = t; e < r.length; e += 1) {\n          var n = r[e].match(/^access_token=(.*)$/);\n          if (n) return n[1];\n        }\n        return null;\n      }(r.params) || O.ACCESS_TOKEN;\n      return O.REQUIRE_ACCESS_TOKEN && n && this._skuToken && r.params.push("sku=" + this._skuToken), this._makeAPIURL(r, n);\n    }, G.prototype.canonicalizeTileURL = function (t, e) {\n      var r = Y(t);\n      if (!r.path.match(/(^\\/v4\\/)/) || !r.path.match(/\\.[\\w]+$/)) return t;\n      var n = "mapbox://tiles/";\n      n += r.path.replace("/v4/", "");\n      var i = r.params;\n      return e && (i = i.filter(function (t) {\n        return !t.match(/^access_token=/);\n      })), i.length && (n += "?" + i.join("&")), n;\n    }, G.prototype.canonicalizeTileset = function (t, e) {\n      for (var r = !!e && Z(e), n = [], i = 0, a = t.tiles || []; i < a.length; i += 1) {\n        var o = a[i];\n        J(o) ? n.push(this.canonicalizeTileURL(o, r)) : n.push(o);\n      }\n      return n;\n    }, G.prototype._makeAPIURL = function (t, e) {\n      var r = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",\n        n = Y(O.API_URL);\n      if (t.protocol = n.protocol, t.authority = n.authority, "http" === t.protocol) {\n        var i = t.params.indexOf("secure");\n        i >= 0 && t.params.splice(i, 1);\n      }\n      if ("/" !== n.path && (t.path = "" + n.path + t.path), !O.REQUIRE_ACCESS_TOKEN) return $(t);\n      if (!(e = e || O.ACCESS_TOKEN)) throw new Error("An API access token is required to use Mapbox GL. " + r);\n      if ("s" === e[0]) throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + r);\n      return t.params = t.params.filter(function (t) {\n        return -1 === t.indexOf("access_token");\n      }), t.params.push("access_token=" + e), $(t);\n    }, G.prototype.setTransformRequest = function (t) {\n      this._transformRequestFn = t;\n    };\n    var X = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n    function J(t) {\n      return X.test(t);\n    }\n    var H = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n    function Y(t) {\n      var e = t.match(H);\n      if (!e) throw new Error("Unable to parse URL object");\n      return {\n        protocol: e[1],\n        authority: e[2],\n        path: e[3] || "/",\n        params: e[4] ? e[4].split("&") : []\n      };\n    }\n    function $(t) {\n      var e = t.params.length ? "?" + t.params.join("&") : "";\n      return t.protocol + "://" + t.authority + t.path + e;\n    }\n    function W(t) {\n      if (!t) return null;\n      var e = t.split(".");\n      if (!e || 3 !== e.length) return null;\n      try {\n        return JSON.parse(decodeURIComponent(o.atob(e[1]).split("").map(function (t) {\n          return "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2);\n        }).join("")));\n      } catch (t) {\n        return null;\n      }\n    }\n    var Q = function (t) {\n      this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n    };\n    Q.prototype.getStorageKey = function (t) {\n      var e,\n        r = W(O.ACCESS_TOKEN);\n      return e = r && r.u ? o.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, function (t, e) {\n        return String.fromCharCode(Number("0x" + e));\n      })) : O.ACCESS_TOKEN || "", t ? "mapbox.eventData." + t + ":" + e : "mapbox.eventData:" + e;\n    }, Q.prototype.fetchEventData = function () {\n      var t = P("localStorage"),\n        e = this.getStorageKey(),\n        r = this.getStorageKey("uuid");\n      if (t) try {\n        var n = o.localStorage.getItem(e);\n        n && (this.eventData = JSON.parse(n));\n        var i = o.localStorage.getItem(r);\n        i && (this.anonId = i);\n      } catch (t) {\n        A("Unable to read from LocalStorage");\n      }\n    }, Q.prototype.saveEventData = function () {\n      var t = P("localStorage"),\n        e = this.getStorageKey(),\n        r = this.getStorageKey("uuid");\n      if (t) try {\n        o.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e, JSON.stringify(this.eventData));\n      } catch (t) {\n        A("Unable to write to LocalStorage");\n      }\n    }, Q.prototype.processRequests = function (t) {}, Q.prototype.postEvent = function (t, e, r, n) {\n      var i = this;\n      if (O.EVENTS_URL) {\n        var a = Y(O.EVENTS_URL);\n        a.params.push("access_token=" + (n || O.ACCESS_TOKEN || ""));\n        var o = {\n            event: this.type,\n            created: new Date(t).toISOString(),\n            sdkIdentifier: "mapbox-gl-js",\n            sdkVersion: "1.15.3",\n            skuId: K,\n            userId: this.anonId\n          },\n          s = e ? h(o, e) : o,\n          u = {\n            url: $(a),\n            headers: {\n              "Content-Type": "text/plain"\n            },\n            body: JSON.stringify([s])\n          };\n        this.pendingRequest = _t(u, function (t) {\n          i.pendingRequest = null, r(t), i.saveEventData(), i.processRequests(n);\n        });\n      }\n    }, Q.prototype.queueRequest = function (t, e) {\n      this.queue.push(t), this.processRequests(e);\n    };\n    var tt,\n      et,\n      rt = function (t) {\n        function e() {\n          t.call(this, "map.load"), this.success = {}, this.skuToken = "";\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postMapLoadEvent = function (t, e, r, n) {\n          this.skuToken = r, (O.EVENTS_URL && n || O.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) {\n            return Z(t) || J(t);\n          })) && this.queueRequest({\n            id: e,\n            timestamp: Date.now()\n          }, n);\n        }, e.prototype.processRequests = function (t) {\n          var e = this;\n          if (!this.pendingRequest && 0 !== this.queue.length) {\n            var r = this.queue.shift(),\n              n = r.id,\n              i = r.timestamp;\n            n && this.success[n] || (this.anonId || this.fetchEventData(), m(this.anonId) || (this.anonId = d()), this.postEvent(i, {\n              skuToken: this.skuToken\n            }, function (t) {\n              t || n && (e.success[n] = !0);\n            }, t));\n          }\n        }, e;\n      }(Q),\n      nt = new (function (t) {\n        function e(e) {\n          t.call(this, "appUserTurnstile"), this._customAccessToken = e;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.postTurnstileEvent = function (t, e) {\n          O.EVENTS_URL && O.ACCESS_TOKEN && Array.isArray(t) && t.some(function (t) {\n            return Z(t) || J(t);\n          }) && this.queueRequest(Date.now(), e);\n        }, e.prototype.processRequests = function (t) {\n          var e = this;\n          if (!this.pendingRequest && 0 !== this.queue.length) {\n            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n            var r = W(O.ACCESS_TOKEN),\n              n = r ? r.u : O.ACCESS_TOKEN,\n              i = n !== this.eventData.tokenU;\n            m(this.anonId) || (this.anonId = d(), i = !0);\n            var a = this.queue.shift();\n            if (this.eventData.lastSuccess) {\n              var o = new Date(this.eventData.lastSuccess),\n                s = new Date(a),\n                u = (a - this.eventData.lastSuccess) / 864e5;\n              i = i || u >= 1 || u < -1 || o.getDate() !== s.getDate();\n            } else i = !0;\n            if (!i) return this.processRequests();\n            this.postEvent(a, {\n              "enabled.telemetry": !1\n            }, function (t) {\n              t || (e.eventData.lastSuccess = a, e.eventData.tokenU = n);\n            }, t);\n          }\n        }, e;\n      }(Q))(),\n      it = nt.postTurnstileEvent.bind(nt),\n      at = new rt(),\n      ot = at.postMapLoadEvent.bind(at),\n      st = 500,\n      ut = 50;\n    function lt() {\n      o.caches && !tt && (tt = o.caches.open("mapbox-tiles"));\n    }\n    function pt(t) {\n      var e = t.indexOf("?");\n      return e < 0 ? t : t.slice(0, e);\n    }\n    var ct,\n      ht = 1 / 0;\n    function ft() {\n      return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct;\n    }\n    var yt = {\n      Unknown: "Unknown",\n      Style: "Style",\n      Source: "Source",\n      Tile: "Tile",\n      Glyphs: "Glyphs",\n      SpriteImage: "SpriteImage",\n      SpriteJSON: "SpriteJSON",\n      Image: "Image"\n    };\n    "function" == typeof Object.freeze && Object.freeze(yt);\n    var dt = function (t) {\n        function e(e, r, n) {\n          401 === r && J(n) && (e += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t.call(this, e), this.status = r, this.url = n, this.name = this.constructor.name, this.message = e;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.toString = function () {\n          return this.name + ": " + this.message + " (" + this.status + "): " + this.url;\n        }, e;\n      }(Error),\n      mt = I() ? function () {\n        return self.worker && self.worker.referrer;\n      } : function () {\n        return ("blob:" === o.location.protocol ? o.parent : o).location.href;\n      };\n    function vt(t, e) {\n      var r,\n        n = new o.AbortController(),\n        i = new o.Request(t.url, {\n          method: t.method || "GET",\n          body: t.body,\n          credentials: t.credentials,\n          headers: t.headers,\n          referrer: mt(),\n          signal: n.signal\n        }),\n        a = !1,\n        s = !1,\n        u = (r = i.url).indexOf("sku=") > 0 && J(r);\n      "json" === t.type && i.headers.set("Accept", "application/json");\n      var l = function (r, n, a) {\n          if (!s) {\n            if (r && "SecurityError" !== r.message && A(r), n && a) return p(n);\n            var l = Date.now();\n            o.fetch(i).then(function (r) {\n              if (r.ok) {\n                var n = u ? r.clone() : null;\n                return p(r, n, l);\n              }\n              return e(new dt(r.statusText, r.status, t.url));\n            }).catch(function (t) {\n              20 !== t.code && e(new Error(t.message));\n            });\n          }\n        },\n        p = function (r, n, u) {\n          ("arrayBuffer" === t.type ? r.arrayBuffer() : "json" === t.type ? r.json() : r.text()).then(function (t) {\n            s || (n && u && function (t, e, r) {\n              if (lt(), tt) {\n                var n = {\n                  status: e.status,\n                  statusText: e.statusText,\n                  headers: new o.Headers()\n                };\n                e.headers.forEach(function (t, e) {\n                  return n.headers.set(e, t);\n                });\n                var i = z(e.headers.get("Cache-Control") || "");\n                i["no-store"] || (i["max-age"] && n.headers.set("Expires", new Date(r + 1e3 * i["max-age"]).toUTCString()), new Date(n.headers.get("Expires")).getTime() - r < 42e4 || function (t, e) {\n                  if (void 0 === et) try {\n                    new Response(new ReadableStream()), et = !0;\n                  } catch (t) {\n                    et = !1;\n                  }\n                  et ? e(t.body) : t.blob().then(e);\n                }(e, function (e) {\n                  var r = new o.Response(e, n);\n                  lt(), tt && tt.then(function (e) {\n                    return e.put(pt(t.url), r);\n                  }).catch(function (t) {\n                    return A(t.message);\n                  });\n                }));\n              }\n            }(i, n, u), a = !0, e(null, t, r.headers.get("Cache-Control"), r.headers.get("Expires")));\n          }).catch(function (t) {\n            s || e(new Error(t.message));\n          });\n        };\n      return u ? function (t, e) {\n        if (lt(), !tt) return e(null);\n        var r = pt(t.url);\n        tt.then(function (t) {\n          t.match(r).then(function (n) {\n            var i = function (t) {\n              if (!t) return !1;\n              var e = new Date(t.headers.get("Expires") || 0),\n                r = z(t.headers.get("Cache-Control") || "");\n              return e > Date.now() && !r["no-cache"];\n            }(n);\n            t.delete(r), i && t.put(r, n.clone()), e(null, n, i);\n          }).catch(e);\n        }).catch(e);\n      }(i, l) : l(null, null), {\n        cancel: function () {\n          s = !0, a || n.abort();\n        }\n      };\n    }\n    var gt,\n      xt,\n      bt = function (t, e) {\n        if (/:\\/\\//.test(t.url) && !/^https?:|^file:/.test(t.url)) {\n          if (I() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e);\n          if (!I()) {\n            var r = t.url.substring(0, t.url.indexOf("://"));\n            return (O.REGISTERED_PROTOCOLS[r] || vt)(t, e);\n          }\n        }\n        if (!(/^file:/.test(n = t.url) || /^file:/.test(mt()) && !/^\\w+:/.test(n))) {\n          if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal")) return vt(t, e);\n          if (I() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0);\n        }\n        var n;\n        return function (t, e) {\n          var r = new o.XMLHttpRequest();\n          for (var n in r.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (r.responseType = "arraybuffer"), t.headers) r.setRequestHeader(n, t.headers[n]);\n          return "json" === t.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t.credentials, r.onerror = function () {\n            e(new Error(r.statusText));\n          }, r.onload = function () {\n            if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n              var n = r.response;\n              if ("json" === t.type) try {\n                n = JSON.parse(r.response);\n              } catch (t) {\n                return e(t);\n              }\n              e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));\n            } else e(new dt(r.statusText, r.status, t.url));\n          }, r.send(t.body), {\n            cancel: function () {\n              return r.abort();\n            }\n          };\n        }(t, e);\n      },\n      wt = function (t, e) {\n        return bt(h(t, {\n          type: "arrayBuffer"\n        }), e);\n      },\n      _t = function (t, e) {\n        return bt(h(t, {\n          method: "POST"\n        }), e);\n      },\n      At = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";\n    gt = [], xt = 0;\n    var St = function (t, e) {\n      if (U.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), xt >= O.MAX_PARALLEL_IMAGE_REQUESTS) {\n        var r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n          cancel: function () {\n            this.cancelled = !0;\n          }\n        };\n        return gt.push(r), r;\n      }\n      xt++;\n      var n = !1,\n        i = function () {\n          if (!n) for (n = !0, xt--; gt.length && xt < O.MAX_PARALLEL_IMAGE_REQUESTS;) {\n            var t = gt.shift();\n            t.cancelled || (t.cancel = St(t.requestParameters, t.callback).cancel);\n          }\n        },\n        a = wt(t, function (t, r, n, a) {\n          i(), t ? e(t) : r && (ft() ? function (t, e) {\n            var r = new o.Blob([new Uint8Array(t)], {\n              type: "image/png"\n            });\n            o.createImageBitmap(r).then(function (t) {\n              e(null, t);\n            }).catch(function (t) {\n              e(new Error("Could not load image because of " + t.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));\n            });\n          }(r, e) : function (t, e, r, n) {\n            var i = new o.Image(),\n              a = o.URL;\n            i.onload = function () {\n              e(null, i), a.revokeObjectURL(i.src), i.onload = null, o.requestAnimationFrame(function () {\n                i.src = At;\n              });\n            }, i.onerror = function () {\n              return e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));\n            };\n            var s = new o.Blob([new Uint8Array(t)], {\n              type: "image/png"\n            });\n            i.cacheControl = r, i.expires = n, i.src = t.byteLength ? a.createObjectURL(s) : At;\n          }(r, e, n, a));\n        });\n      return {\n        cancel: function () {\n          a.cancel(), i();\n        }\n      };\n    };\n    function kt(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n    function It(t, e, r) {\n      if (r && r[t]) {\n        var n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n    var zt = function (t, e) {\n        void 0 === e && (e = {}), h(this, e), this.type = t;\n      },\n      Ct = function (t) {\n        function e(e, r) {\n          void 0 === r && (r = {}), t.call(this, "error", h({\n            error: e\n          }, r));\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n      }(zt),\n      Et = function () {};\n    Et.prototype.on = function (t, e) {\n      return this._listeners = this._listeners || {}, kt(t, e, this._listeners), this;\n    }, Et.prototype.off = function (t, e) {\n      return It(t, e, this._listeners), It(t, e, this._oneTimeListeners), this;\n    }, Et.prototype.once = function (t, e) {\n      return this._oneTimeListeners = this._oneTimeListeners || {}, kt(t, e, this._oneTimeListeners), this;\n    }, Et.prototype.fire = function (t, e) {\n      "string" == typeof t && (t = new zt(t, e || {}));\n      var r = t.type;\n      if (this.listens(r)) {\n        t.target = this;\n        for (var n = 0, i = this._listeners && this._listeners[r] ? this._listeners[r].slice() : []; n < i.length; n += 1) i[n].call(this, t);\n        for (var a = 0, o = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : []; a < o.length; a += 1) {\n          var s = o[a];\n          It(r, s, this._oneTimeListeners), s.call(this, t);\n        }\n        var u = this._eventedParent;\n        u && (h(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u.fire(t));\n      } else t instanceof Ct && console.error(t.error);\n      return this;\n    }, Et.prototype.listens = function (t) {\n      return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);\n    }, Et.prototype.setEventedParent = function (t, e) {\n      return this._eventedParent = t, this._eventedParentData = e, this;\n    };\n    var Pt = {\n        $version: 8,\n        $root: {\n          version: {\n            required: !0,\n            type: "enum",\n            values: [8]\n          },\n          name: {\n            type: "string"\n          },\n          metadata: {\n            type: "*"\n          },\n          center: {\n            type: "array",\n            value: "number"\n          },\n          zoom: {\n            type: "number"\n          },\n          bearing: {\n            type: "number",\n            default: 0,\n            period: 360,\n            units: "degrees"\n          },\n          pitch: {\n            type: "number",\n            default: 0,\n            units: "degrees"\n          },\n          light: {\n            type: "light"\n          },\n          sources: {\n            required: !0,\n            type: "sources"\n          },\n          sprite: {\n            type: "string"\n          },\n          glyphs: {\n            type: "string"\n          },\n          transition: {\n            type: "transition"\n          },\n          layers: {\n            required: !0,\n            type: "array",\n            value: "layer"\n          }\n        },\n        sources: {\n          "*": {\n            type: "source"\n          }\n        },\n        source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],\n        source_vector: {\n          type: {\n            required: !0,\n            type: "enum",\n            values: {\n              vector: {}\n            }\n          },\n          url: {\n            type: "string"\n          },\n          tiles: {\n            type: "array",\n            value: "string"\n          },\n          bounds: {\n            type: "array",\n            value: "number",\n            length: 4,\n            default: [-180, -85.051129, 180, 85.051129]\n          },\n          scheme: {\n            type: "enum",\n            values: {\n              xyz: {},\n              tms: {}\n            },\n            default: "xyz"\n          },\n          minzoom: {\n            type: "number",\n            default: 0\n          },\n          maxzoom: {\n            type: "number",\n            default: 22\n          },\n          attribution: {\n            type: "string"\n          },\n          promoteId: {\n            type: "promoteId"\n          },\n          volatile: {\n            type: "boolean",\n            default: !1\n          },\n          "*": {\n            type: "*"\n          }\n        },\n        source_raster: {\n          type: {\n            required: !0,\n            type: "enum",\n            values: {\n              raster: {}\n            }\n          },\n          url: {\n            type: "string"\n          },\n          tiles: {\n            type: "array",\n            value: "string"\n          },\n          bounds: {\n            type: "array",\n            value: "number",\n            length: 4,\n            default: [-180, -85.051129, 180, 85.051129]\n          },\n          minzoom: {\n            type: "number",\n            default: 0\n          },\n          maxzoom: {\n            type: "number",\n            default: 22\n          },\n          tileSize: {\n            type: "number",\n            default: 512,\n            units: "pixels"\n          },\n          scheme: {\n            type: "enum",\n            values: {\n              xyz: {},\n              tms: {}\n            },\n            default: "xyz"\n          },\n          attribution: {\n            type: "string"\n          },\n          volatile: {\n            type: "boolean",\n            default: !1\n          },\n          "*": {\n            type: "*"\n          }\n        },\n        source_raster_dem: {\n          type: {\n            required: !0,\n            type: "enum",\n            values: {\n              "raster-dem": {}\n            }\n          },\n          url: {\n            type: "string"\n          },\n          tiles: {\n            type: "array",\n            value: "string"\n          },\n          bounds: {\n            type: "array",\n            value: "number",\n            length: 4,\n            default: [-180, -85.051129, 180, 85.051129]\n          },\n          minzoom: {\n            type: "number",\n            default: 0\n          },\n          maxzoom: {\n            type: "number",\n            default: 22\n          },\n          tileSize: {\n            type: "number",\n            default: 512,\n            units: "pixels"\n          },\n          attribution: {\n            type: "string"\n          },\n          encoding: {\n            type: "enum",\n            values: {\n              terrarium: {},\n              mapbox: {}\n            },\n            default: "mapbox"\n          },\n          volatile: {\n            type: "boolean",\n            default: !1\n          },\n          "*": {\n            type: "*"\n          }\n        },\n        source_geojson: {\n          type: {\n            required: !0,\n            type: "enum",\n            values: {\n              geojson: {}\n            }\n          },\n          data: {\n            type: "*"\n          },\n          maxzoom: {\n            type: "number",\n            default: 18\n          },\n          attribution: {\n            type: "string"\n          },\n          buffer: {\n            type: "number",\n            default: 128,\n            maximum: 512,\n            minimum: 0\n          },\n          filter: {\n            type: "*"\n          },\n          tolerance: {\n            type: "number",\n            default: .375\n          },\n          cluster: {\n            type: "boolean",\n            default: !1\n          },\n          clusterRadius: {\n            type: "number",\n            default: 50,\n            minimum: 0\n          },\n          clusterMaxZoom: {\n            type: "number"\n          },\n          clusterMinPoints: {\n            type: "number"\n          },\n          clusterProperties: {\n            type: "*"\n          },\n          lineMetrics: {\n            type: "boolean",\n            default: !1\n          },\n          generateId: {\n            type: "boolean",\n            default: !1\n          },\n          promoteId: {\n            type: "promoteId"\n          }\n        },\n        source_video: {\n          type: {\n            required: !0,\n            type: "enum",\n            values: {\n              video: {}\n            }\n          },\n          urls: {\n            required: !0,\n            type: "array",\n            value: "string"\n          },\n          coordinates: {\n            required: !0,\n            type: "array",\n            length: 4,\n            value: {\n              type: "array",\n              length: 2,\n              value: "number"\n            }\n          }\n        },\n        source_image: {\n          type: {\n            required: !0,\n            type: "enum",\n            values: {\n              image: {}\n            }\n          },\n          url: {\n            required: !0,\n            type: "string"\n          },\n          coordinates: {\n            required: !0,\n            type: "array",\n            length: 4,\n            value: {\n              type: "array",\n              length: 2,\n              value: "number"\n            }\n          }\n        },\n        layer: {\n          id: {\n            type: "string",\n            required: !0\n          },\n          type: {\n            type: "enum",\n            values: {\n              fill: {},\n              line: {},\n              symbol: {},\n              circle: {},\n              heatmap: {},\n              "fill-extrusion": {},\n              raster: {},\n              hillshade: {},\n              background: {}\n            },\n            required: !0\n          },\n          metadata: {\n            type: "*"\n          },\n          source: {\n            type: "string"\n          },\n          "source-layer": {\n            type: "string"\n          },\n          minzoom: {\n            type: "number",\n            minimum: 0,\n            maximum: 24\n          },\n          maxzoom: {\n            type: "number",\n            minimum: 0,\n            maximum: 24\n          },\n          filter: {\n            type: "filter"\n          },\n          layout: {\n            type: "layout"\n          },\n          paint: {\n            type: "paint"\n          }\n        },\n        layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"],\n        layout_background: {\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_fill: {\n          "fill-sort-key": {\n            type: "number",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_circle: {\n          "circle-sort-key": {\n            type: "number",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_heatmap: {\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        "layout_fill-extrusion": {\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_line: {\n          "line-cap": {\n            type: "enum",\n            values: {\n              butt: {},\n              round: {},\n              square: {}\n            },\n            default: "butt",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "line-join": {\n            type: "enum",\n            values: {\n              bevel: {},\n              round: {},\n              miter: {}\n            },\n            default: "miter",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-miter-limit": {\n            type: "number",\n            default: 2,\n            requires: [{\n              "line-join": "miter"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "line-round-limit": {\n            type: "number",\n            default: 1.05,\n            requires: [{\n              "line-join": "round"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "line-sort-key": {\n            type: "number",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_symbol: {\n          "symbol-placement": {\n            type: "enum",\n            values: {\n              point: {},\n              line: {},\n              "line-center": {}\n            },\n            default: "point",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "symbol-spacing": {\n            type: "number",\n            default: 250,\n            minimum: 1,\n            units: "pixels",\n            requires: [{\n              "symbol-placement": "line"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "symbol-avoid-edges": {\n            type: "boolean",\n            default: !1,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "symbol-sort-key": {\n            type: "number",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "symbol-z-order": {\n            type: "enum",\n            values: {\n              auto: {},\n              "viewport-y": {},\n              source: {}\n            },\n            default: "auto",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-allow-overlap": {\n            type: "boolean",\n            default: !1,\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-ignore-placement": {\n            type: "boolean",\n            default: !1,\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-optional": {\n            type: "boolean",\n            default: !1,\n            requires: ["icon-image", "text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-rotation-alignment": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {},\n              auto: {}\n            },\n            default: "auto",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-size": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            units: "factor of the original icon size",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-text-fit": {\n            type: "enum",\n            values: {\n              none: {},\n              width: {},\n              height: {},\n              both: {}\n            },\n            default: "none",\n            requires: ["icon-image", "text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-text-fit-padding": {\n            type: "array",\n            value: "number",\n            length: 4,\n            default: [0, 0, 0, 0],\n            units: "pixels",\n            requires: ["icon-image", "text-field", {\n              "icon-text-fit": ["both", "width", "height"]\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-image": {\n            type: "resolvedImage",\n            tokens: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-rotate": {\n            type: "number",\n            default: 0,\n            period: 360,\n            units: "degrees",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-padding": {\n            type: "number",\n            default: 2,\n            minimum: 0,\n            units: "pixels",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-keep-upright": {\n            type: "boolean",\n            default: !1,\n            requires: ["icon-image", {\n              "icon-rotation-alignment": "map"\n            }, {\n              "symbol-placement": ["line", "line-center"]\n            }],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-offset": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-anchor": {\n            type: "enum",\n            values: {\n              center: {},\n              left: {},\n              right: {},\n              top: {},\n              bottom: {},\n              "top-left": {},\n              "top-right": {},\n              "bottom-left": {},\n              "bottom-right": {}\n            },\n            default: "center",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-pitch-alignment": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {},\n              auto: {}\n            },\n            default: "auto",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-pitch-alignment": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {},\n              auto: {}\n            },\n            default: "auto",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-rotation-alignment": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {},\n              auto: {}\n            },\n            default: "auto",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-field": {\n            type: "formatted",\n            default: "",\n            tokens: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-font": {\n            type: "array",\n            value: "string",\n            default: ["Open Sans Regular", "Arial Unicode MS Regular"],\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-size": {\n            type: "number",\n            default: 16,\n            minimum: 0,\n            units: "pixels",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-max-width": {\n            type: "number",\n            default: 10,\n            minimum: 0,\n            units: "ems",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-line-height": {\n            type: "number",\n            default: 1.2,\n            units: "ems",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-letter-spacing": {\n            type: "number",\n            default: 0,\n            units: "ems",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-justify": {\n            type: "enum",\n            values: {\n              auto: {},\n              left: {},\n              center: {},\n              right: {}\n            },\n            default: "center",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-radial-offset": {\n            type: "number",\n            units: "ems",\n            default: 0,\n            requires: ["text-field"],\n            "property-type": "data-driven",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            }\n          },\n          "text-variable-anchor": {\n            type: "array",\n            value: "enum",\n            values: {\n              center: {},\n              left: {},\n              right: {},\n              top: {},\n              bottom: {},\n              "top-left": {},\n              "top-right": {},\n              "bottom-left": {},\n              "bottom-right": {}\n            },\n            requires: ["text-field", {\n              "symbol-placement": ["point"]\n            }],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-anchor": {\n            type: "enum",\n            values: {\n              center: {},\n              left: {},\n              right: {},\n              top: {},\n              bottom: {},\n              "top-left": {},\n              "top-right": {},\n              "bottom-left": {},\n              "bottom-right": {}\n            },\n            default: "center",\n            requires: ["text-field", {\n              "!": "text-variable-anchor"\n            }],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-max-angle": {\n            type: "number",\n            default: 45,\n            units: "degrees",\n            requires: ["text-field", {\n              "symbol-placement": ["line", "line-center"]\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-writing-mode": {\n            type: "array",\n            value: "enum",\n            values: {\n              horizontal: {},\n              vertical: {}\n            },\n            requires: ["text-field", {\n              "symbol-placement": ["point"]\n            }],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-rotate": {\n            type: "number",\n            default: 0,\n            period: 360,\n            units: "degrees",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-padding": {\n            type: "number",\n            default: 2,\n            minimum: 0,\n            units: "pixels",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-keep-upright": {\n            type: "boolean",\n            default: !0,\n            requires: ["text-field", {\n              "text-rotation-alignment": "map"\n            }, {\n              "symbol-placement": ["line", "line-center"]\n            }],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-transform": {\n            type: "enum",\n            values: {\n              none: {},\n              uppercase: {},\n              lowercase: {}\n            },\n            default: "none",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-offset": {\n            type: "array",\n            value: "number",\n            units: "ems",\n            length: 2,\n            default: [0, 0],\n            requires: ["text-field", {\n              "!": "text-radial-offset"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-allow-overlap": {\n            type: "boolean",\n            default: !1,\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-ignore-placement": {\n            type: "boolean",\n            default: !1,\n            requires: ["text-field"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-optional": {\n            type: "boolean",\n            default: !1,\n            requires: ["text-field", "icon-image"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_raster: {\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        layout_hillshade: {\n          visibility: {\n            type: "enum",\n            values: {\n              visible: {},\n              none: {}\n            },\n            default: "visible",\n            "property-type": "constant"\n          }\n        },\n        filter: {\n          type: "array",\n          value: "*"\n        },\n        filter_operator: {\n          type: "enum",\n          values: {\n            "==": {},\n            "!=": {},\n            ">": {},\n            ">=": {},\n            "<": {},\n            "<=": {},\n            in: {},\n            "!in": {},\n            all: {},\n            any: {},\n            none: {},\n            has: {},\n            "!has": {},\n            within: {}\n          }\n        },\n        geometry_type: {\n          type: "enum",\n          values: {\n            Point: {},\n            LineString: {},\n            Polygon: {}\n          }\n        },\n        function: {\n          expression: {\n            type: "expression"\n          },\n          stops: {\n            type: "array",\n            value: "function_stop"\n          },\n          base: {\n            type: "number",\n            default: 1,\n            minimum: 0\n          },\n          property: {\n            type: "string",\n            default: "$zoom"\n          },\n          type: {\n            type: "enum",\n            values: {\n              identity: {},\n              exponential: {},\n              interval: {},\n              categorical: {}\n            },\n            default: "exponential"\n          },\n          colorSpace: {\n            type: "enum",\n            values: {\n              rgb: {},\n              lab: {},\n              hcl: {}\n            },\n            default: "rgb"\n          },\n          default: {\n            type: "*",\n            required: !1\n          }\n        },\n        function_stop: {\n          type: "array",\n          minimum: 0,\n          maximum: 24,\n          value: ["number", "color"],\n          length: 2\n        },\n        expression: {\n          type: "array",\n          value: "*",\n          minimum: 1\n        },\n        light: {\n          anchor: {\n            type: "enum",\n            default: "viewport",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            "property-type": "data-constant",\n            transition: !1,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            }\n          },\n          position: {\n            type: "array",\n            default: [1.15, 210, 30],\n            length: 3,\n            value: "number",\n            "property-type": "data-constant",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            }\n          },\n          color: {\n            type: "color",\n            "property-type": "data-constant",\n            default: "#ffffff",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            transition: !0\n          },\n          intensity: {\n            type: "number",\n            "property-type": "data-constant",\n            default: .5,\n            minimum: 0,\n            maximum: 1,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            transition: !0\n          }\n        },\n        paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"],\n        paint_fill: {\n          "fill-antialias": {\n            type: "boolean",\n            default: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "fill-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "fill-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            requires: [{\n              "!": "fill-pattern"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "fill-outline-color": {\n            type: "color",\n            transition: !0,\n            requires: [{\n              "!": "fill-pattern"\n            }, {\n              "fill-antialias": !0\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "fill-translate": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "fill-translate-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            requires: ["fill-translate"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "fill-pattern": {\n            type: "resolvedImage",\n            transition: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "cross-faded-data-driven"\n          }\n        },\n        "paint_fill-extrusion": {\n          "fill-extrusion-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "fill-extrusion-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            requires: [{\n              "!": "fill-extrusion-pattern"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "fill-extrusion-translate": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "fill-extrusion-translate-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            requires: ["fill-extrusion-translate"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "fill-extrusion-pattern": {\n            type: "resolvedImage",\n            transition: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "cross-faded-data-driven"\n          },\n          "fill-extrusion-height": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            units: "meters",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "fill-extrusion-base": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            units: "meters",\n            transition: !0,\n            requires: ["fill-extrusion-height"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "fill-extrusion-vertical-gradient": {\n            type: "boolean",\n            default: !0,\n            transition: !1,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          }\n        },\n        paint_line: {\n          "line-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            requires: [{\n              "!": "line-pattern"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-translate": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "line-translate-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            requires: ["line-translate"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "line-width": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-gap-width": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-offset": {\n            type: "number",\n            default: 0,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-blur": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "line-dasharray": {\n            type: "array",\n            value: "number",\n            minimum: 0,\n            transition: !0,\n            units: "line widths",\n            requires: [{\n              "!": "line-pattern"\n            }],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "cross-faded"\n          },\n          "line-pattern": {\n            type: "resolvedImage",\n            transition: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom", "feature"]\n            },\n            "property-type": "cross-faded-data-driven"\n          },\n          "line-gradient": {\n            type: "color",\n            transition: !1,\n            requires: [{\n              "!": "line-dasharray"\n            }, {\n              "!": "line-pattern"\n            }, {\n              source: "geojson",\n              has: {\n                lineMetrics: !0\n              }\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["line-progress"]\n            },\n            "property-type": "color-ramp"\n          }\n        },\n        paint_circle: {\n          "circle-radius": {\n            type: "number",\n            default: 5,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "circle-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "circle-blur": {\n            type: "number",\n            default: 0,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "circle-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "circle-translate": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "circle-translate-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            requires: ["circle-translate"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "circle-pitch-scale": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "circle-pitch-alignment": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "viewport",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "circle-stroke-width": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "circle-stroke-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "circle-stroke-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          }\n        },\n        paint_heatmap: {\n          "heatmap-radius": {\n            type: "number",\n            default: 30,\n            minimum: 1,\n            transition: !0,\n            units: "pixels",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "heatmap-weight": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            transition: !1,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "heatmap-intensity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "heatmap-color": {\n            type: "color",\n            default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],\n            transition: !1,\n            expression: {\n              interpolated: !0,\n              parameters: ["heatmap-density"]\n            },\n            "property-type": "color-ramp"\n          },\n          "heatmap-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          }\n        },\n        paint_symbol: {\n          "icon-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-halo-color": {\n            type: "color",\n            default: "rgba(0, 0, 0, 0)",\n            transition: !0,\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-halo-width": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-halo-blur": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "icon-translate": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            transition: !0,\n            units: "pixels",\n            requires: ["icon-image"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "icon-translate-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            requires: ["icon-image", "icon-translate"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            overridable: !0,\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-halo-color": {\n            type: "color",\n            default: "rgba(0, 0, 0, 0)",\n            transition: !0,\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-halo-width": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-halo-blur": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            transition: !0,\n            units: "pixels",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom", "feature", "feature-state"]\n            },\n            "property-type": "data-driven"\n          },\n          "text-translate": {\n            type: "array",\n            value: "number",\n            length: 2,\n            default: [0, 0],\n            transition: !0,\n            units: "pixels",\n            requires: ["text-field"],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "text-translate-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "map",\n            requires: ["text-field", "text-translate"],\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          }\n        },\n        paint_raster: {\n          "raster-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-hue-rotate": {\n            type: "number",\n            default: 0,\n            period: 360,\n            transition: !0,\n            units: "degrees",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-brightness-min": {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-brightness-max": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-saturation": {\n            type: "number",\n            default: 0,\n            minimum: -1,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-contrast": {\n            type: "number",\n            default: 0,\n            minimum: -1,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-resampling": {\n            type: "enum",\n            values: {\n              linear: {},\n              nearest: {}\n            },\n            default: "linear",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "raster-fade-duration": {\n            type: "number",\n            default: 300,\n            minimum: 0,\n            transition: !1,\n            units: "milliseconds",\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          }\n        },\n        paint_hillshade: {\n          "hillshade-illumination-direction": {\n            type: "number",\n            default: 335,\n            minimum: 0,\n            maximum: 359,\n            transition: !1,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "hillshade-illumination-anchor": {\n            type: "enum",\n            values: {\n              map: {},\n              viewport: {}\n            },\n            default: "viewport",\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "hillshade-exaggeration": {\n            type: "number",\n            default: .5,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "hillshade-shadow-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "hillshade-highlight-color": {\n            type: "color",\n            default: "#FFFFFF",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "hillshade-accent-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          }\n        },\n        paint_background: {\n          "background-color": {\n            type: "color",\n            default: "#000000",\n            transition: !0,\n            requires: [{\n              "!": "background-pattern"\n            }],\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          },\n          "background-pattern": {\n            type: "resolvedImage",\n            transition: !0,\n            expression: {\n              interpolated: !1,\n              parameters: ["zoom"]\n            },\n            "property-type": "cross-faded"\n          },\n          "background-opacity": {\n            type: "number",\n            default: 1,\n            minimum: 0,\n            maximum: 1,\n            transition: !0,\n            expression: {\n              interpolated: !0,\n              parameters: ["zoom"]\n            },\n            "property-type": "data-constant"\n          }\n        },\n        transition: {\n          duration: {\n            type: "number",\n            default: 300,\n            minimum: 0,\n            units: "milliseconds"\n          },\n          delay: {\n            type: "number",\n            default: 0,\n            minimum: 0,\n            units: "milliseconds"\n          }\n        },\n        "property-type": {\n          "data-driven": {\n            type: "property-type"\n          },\n          "cross-faded": {\n            type: "property-type"\n          },\n          "cross-faded-data-driven": {\n            type: "property-type"\n          },\n          "color-ramp": {\n            type: "property-type"\n          },\n          "data-constant": {\n            type: "property-type"\n          },\n          constant: {\n            type: "property-type"\n          }\n        },\n        promoteId: {\n          "*": {\n            type: "string"\n          }\n        }\n      },\n      Mt = function (t, e, r, n) {\n        this.message = (t ? t + ": " : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n      };\n    function Bt(t) {\n      var e = t.value;\n      return e ? [new Mt(t.key, e, "constants have been deprecated as of v8")] : [];\n    }\n    function Tt(t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) e[r] = arguments[r + 1];\n      for (var n = 0, i = e; n < i.length; n += 1) {\n        var a = i[n];\n        for (var o in a) t[o] = a[o];\n      }\n      return t;\n    }\n    function Vt(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n    function Ft(t) {\n      if (Array.isArray(t)) return t.map(Ft);\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        var e = {};\n        for (var r in t) e[r] = Ft(t[r]);\n        return e;\n      }\n      return Vt(t);\n    }\n    var Dt = function (t) {\n        function e(e, r) {\n          t.call(this, r), this.message = r, this.key = e;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n      }(Error),\n      Lt = function (t, e) {\n        void 0 === e && (e = []), this.parent = t, this.bindings = {};\n        for (var r = 0, n = e; r < n.length; r += 1) {\n          var i = n[r];\n          this.bindings[i[0]] = i[1];\n        }\n      };\n    Lt.prototype.concat = function (t) {\n      return new Lt(this, t);\n    }, Lt.prototype.get = function (t) {\n      if (this.bindings[t]) return this.bindings[t];\n      if (this.parent) return this.parent.get(t);\n      throw new Error(t + " not found in scope.");\n    }, Lt.prototype.has = function (t) {\n      return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n    };\n    var Rt = {\n        kind: "null"\n      },\n      Ot = {\n        kind: "number"\n      },\n      Ut = {\n        kind: "string"\n      },\n      jt = {\n        kind: "boolean"\n      },\n      qt = {\n        kind: "color"\n      },\n      Nt = {\n        kind: "object"\n      },\n      Kt = {\n        kind: "value"\n      },\n      Gt = {\n        kind: "collator"\n      },\n      Zt = {\n        kind: "formatted"\n      },\n      Xt = {\n        kind: "resolvedImage"\n      };\n    function Jt(t, e) {\n      return {\n        kind: "array",\n        itemType: t,\n        N: e\n      };\n    }\n    function Ht(t) {\n      if ("array" === t.kind) {\n        var e = Ht(t.itemType);\n        return "number" == typeof t.N ? "array<" + e + ", " + t.N + ">" : "value" === t.itemType.kind ? "array" : "array<" + e + ">";\n      }\n      return t.kind;\n    }\n    var Yt = [Rt, Ot, Ut, jt, qt, Zt, Nt, Jt(Kt), Xt];\n    function $t(t, e) {\n      if ("error" === e.kind) return null;\n      if ("array" === t.kind) {\n        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !$t(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if ("value" === t.kind) for (var r = 0, n = Yt; r < n.length; r += 1) if (!$t(n[r], e)) return null;\n      }\n      return "Expected " + Ht(t) + " but found " + Ht(e) + " instead.";\n    }\n    function Wt(t, e) {\n      return e.some(function (e) {\n        return e.kind === t.kind;\n      });\n    }\n    function Qt(t, e) {\n      return e.some(function (e) {\n        return "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t;\n      });\n    }\n    var te = e(function (t, e) {\n        var r = {\n          transparent: [0, 0, 0, 0],\n          aliceblue: [240, 248, 255, 1],\n          antiquewhite: [250, 235, 215, 1],\n          aqua: [0, 255, 255, 1],\n          aquamarine: [127, 255, 212, 1],\n          azure: [240, 255, 255, 1],\n          beige: [245, 245, 220, 1],\n          bisque: [255, 228, 196, 1],\n          black: [0, 0, 0, 1],\n          blanchedalmond: [255, 235, 205, 1],\n          blue: [0, 0, 255, 1],\n          blueviolet: [138, 43, 226, 1],\n          brown: [165, 42, 42, 1],\n          burlywood: [222, 184, 135, 1],\n          cadetblue: [95, 158, 160, 1],\n          chartreuse: [127, 255, 0, 1],\n          chocolate: [210, 105, 30, 1],\n          coral: [255, 127, 80, 1],\n          cornflowerblue: [100, 149, 237, 1],\n          cornsilk: [255, 248, 220, 1],\n          crimson: [220, 20, 60, 1],\n          cyan: [0, 255, 255, 1],\n          darkblue: [0, 0, 139, 1],\n          darkcyan: [0, 139, 139, 1],\n          darkgoldenrod: [184, 134, 11, 1],\n          darkgray: [169, 169, 169, 1],\n          darkgreen: [0, 100, 0, 1],\n          darkgrey: [169, 169, 169, 1],\n          darkkhaki: [189, 183, 107, 1],\n          darkmagenta: [139, 0, 139, 1],\n          darkolivegreen: [85, 107, 47, 1],\n          darkorange: [255, 140, 0, 1],\n          darkorchid: [153, 50, 204, 1],\n          darkred: [139, 0, 0, 1],\n          darksalmon: [233, 150, 122, 1],\n          darkseagreen: [143, 188, 143, 1],\n          darkslateblue: [72, 61, 139, 1],\n          darkslategray: [47, 79, 79, 1],\n          darkslategrey: [47, 79, 79, 1],\n          darkturquoise: [0, 206, 209, 1],\n          darkviolet: [148, 0, 211, 1],\n          deeppink: [255, 20, 147, 1],\n          deepskyblue: [0, 191, 255, 1],\n          dimgray: [105, 105, 105, 1],\n          dimgrey: [105, 105, 105, 1],\n          dodgerblue: [30, 144, 255, 1],\n          firebrick: [178, 34, 34, 1],\n          floralwhite: [255, 250, 240, 1],\n          forestgreen: [34, 139, 34, 1],\n          fuchsia: [255, 0, 255, 1],\n          gainsboro: [220, 220, 220, 1],\n          ghostwhite: [248, 248, 255, 1],\n          gold: [255, 215, 0, 1],\n          goldenrod: [218, 165, 32, 1],\n          gray: [128, 128, 128, 1],\n          green: [0, 128, 0, 1],\n          greenyellow: [173, 255, 47, 1],\n          grey: [128, 128, 128, 1],\n          honeydew: [240, 255, 240, 1],\n          hotpink: [255, 105, 180, 1],\n          indianred: [205, 92, 92, 1],\n          indigo: [75, 0, 130, 1],\n          ivory: [255, 255, 240, 1],\n          khaki: [240, 230, 140, 1],\n          lavender: [230, 230, 250, 1],\n          lavenderblush: [255, 240, 245, 1],\n          lawngreen: [124, 252, 0, 1],\n          lemonchiffon: [255, 250, 205, 1],\n          lightblue: [173, 216, 230, 1],\n          lightcoral: [240, 128, 128, 1],\n          lightcyan: [224, 255, 255, 1],\n          lightgoldenrodyellow: [250, 250, 210, 1],\n          lightgray: [211, 211, 211, 1],\n          lightgreen: [144, 238, 144, 1],\n          lightgrey: [211, 211, 211, 1],\n          lightpink: [255, 182, 193, 1],\n          lightsalmon: [255, 160, 122, 1],\n          lightseagreen: [32, 178, 170, 1],\n          lightskyblue: [135, 206, 250, 1],\n          lightslategray: [119, 136, 153, 1],\n          lightslategrey: [119, 136, 153, 1],\n          lightsteelblue: [176, 196, 222, 1],\n          lightyellow: [255, 255, 224, 1],\n          lime: [0, 255, 0, 1],\n          limegreen: [50, 205, 50, 1],\n          linen: [250, 240, 230, 1],\n          magenta: [255, 0, 255, 1],\n          maroon: [128, 0, 0, 1],\n          mediumaquamarine: [102, 205, 170, 1],\n          mediumblue: [0, 0, 205, 1],\n          mediumorchid: [186, 85, 211, 1],\n          mediumpurple: [147, 112, 219, 1],\n          mediumseagreen: [60, 179, 113, 1],\n          mediumslateblue: [123, 104, 238, 1],\n          mediumspringgreen: [0, 250, 154, 1],\n          mediumturquoise: [72, 209, 204, 1],\n          mediumvioletred: [199, 21, 133, 1],\n          midnightblue: [25, 25, 112, 1],\n          mintcream: [245, 255, 250, 1],\n          mistyrose: [255, 228, 225, 1],\n          moccasin: [255, 228, 181, 1],\n          navajowhite: [255, 222, 173, 1],\n          navy: [0, 0, 128, 1],\n          oldlace: [253, 245, 230, 1],\n          olive: [128, 128, 0, 1],\n          olivedrab: [107, 142, 35, 1],\n          orange: [255, 165, 0, 1],\n          orangered: [255, 69, 0, 1],\n          orchid: [218, 112, 214, 1],\n          palegoldenrod: [238, 232, 170, 1],\n          palegreen: [152, 251, 152, 1],\n          paleturquoise: [175, 238, 238, 1],\n          palevioletred: [219, 112, 147, 1],\n          papayawhip: [255, 239, 213, 1],\n          peachpuff: [255, 218, 185, 1],\n          peru: [205, 133, 63, 1],\n          pink: [255, 192, 203, 1],\n          plum: [221, 160, 221, 1],\n          powderblue: [176, 224, 230, 1],\n          purple: [128, 0, 128, 1],\n          rebeccapurple: [102, 51, 153, 1],\n          red: [255, 0, 0, 1],\n          rosybrown: [188, 143, 143, 1],\n          royalblue: [65, 105, 225, 1],\n          saddlebrown: [139, 69, 19, 1],\n          salmon: [250, 128, 114, 1],\n          sandybrown: [244, 164, 96, 1],\n          seagreen: [46, 139, 87, 1],\n          seashell: [255, 245, 238, 1],\n          sienna: [160, 82, 45, 1],\n          silver: [192, 192, 192, 1],\n          skyblue: [135, 206, 235, 1],\n          slateblue: [106, 90, 205, 1],\n          slategray: [112, 128, 144, 1],\n          slategrey: [112, 128, 144, 1],\n          snow: [255, 250, 250, 1],\n          springgreen: [0, 255, 127, 1],\n          steelblue: [70, 130, 180, 1],\n          tan: [210, 180, 140, 1],\n          teal: [0, 128, 128, 1],\n          thistle: [216, 191, 216, 1],\n          tomato: [255, 99, 71, 1],\n          turquoise: [64, 224, 208, 1],\n          violet: [238, 130, 238, 1],\n          wheat: [245, 222, 179, 1],\n          white: [255, 255, 255, 1],\n          whitesmoke: [245, 245, 245, 1],\n          yellow: [255, 255, 0, 1],\n          yellowgreen: [154, 205, 50, 1]\n        };\n        function n(t) {\n          return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n        }\n        function i(t) {\n          return n("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n        }\n        function a(t) {\n          return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n          var e;\n        }\n        function o(t, e, r) {\n          return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n        }\n        try {\n          e.parseCSSColor = function (t) {\n            var e,\n              s = t.replace(/ /g, "").toLowerCase();\n            if (s in r) return r[s].slice();\n            if ("#" === s[0]) return 4 === s.length ? (e = parseInt(s.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === s.length && (e = parseInt(s.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n            var u = s.indexOf("("),\n              l = s.indexOf(")");\n            if (-1 !== u && l + 1 === s.length) {\n              var p = s.substr(0, u),\n                c = s.substr(u + 1, l - (u + 1)).split(","),\n                h = 1;\n              switch (p) {\n                case "rgba":\n                  if (4 !== c.length) return null;\n                  h = a(c.pop());\n                case "rgb":\n                  return 3 !== c.length ? null : [i(c[0]), i(c[1]), i(c[2]), h];\n                case "hsla":\n                  if (4 !== c.length) return null;\n                  h = a(c.pop());\n                case "hsl":\n                  if (3 !== c.length) return null;\n                  var f = (parseFloat(c[0]) % 360 + 360) % 360 / 360,\n                    y = a(c[1]),\n                    d = a(c[2]),\n                    m = d <= .5 ? d * (y + 1) : d + y - d * y,\n                    v = 2 * d - m;\n                  return [n(255 * o(v, m, f + 1 / 3)), n(255 * o(v, m, f)), n(255 * o(v, m, f - 1 / 3)), h];\n                default:\n                  return null;\n              }\n            }\n            return null;\n          };\n        } catch (t) {}\n      }).parseCSSColor,\n      ee = function (t, e, r, n) {\n        void 0 === n && (n = 1), this.r = t, this.g = e, this.b = r, this.a = n;\n      };\n    ee.parse = function (t) {\n      if (t) {\n        if (t instanceof ee) return t;\n        if ("string" == typeof t) {\n          var e = te(t);\n          if (e) return new ee(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]);\n        }\n      }\n    }, ee.prototype.toString = function () {\n      var t = this.toArray(),\n        e = t[1],\n        r = t[2],\n        n = t[3];\n      return "rgba(" + Math.round(t[0]) + "," + Math.round(e) + "," + Math.round(r) + "," + n + ")";\n    }, ee.prototype.toArray = function () {\n      var t = this.a;\n      return 0 === t ? [0, 0, 0, 0] : [255 * this.r / t, 255 * this.g / t, 255 * this.b / t, t];\n    }, ee.black = new ee(0, 0, 0, 1), ee.white = new ee(1, 1, 1, 1), ee.transparent = new ee(0, 0, 0, 0), ee.red = new ee(1, 0, 0, 1);\n    var re = function (t, e, r) {\n      this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n        sensitivity: this.sensitivity,\n        usage: "search"\n      });\n    };\n    re.prototype.compare = function (t, e) {\n      return this.collator.compare(t, e);\n    }, re.prototype.resolvedLocale = function () {\n      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n    };\n    var ne = function (t, e, r, n, i) {\n        this.text = t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      },\n      ie = function (t) {\n        this.sections = t;\n      };\n    ie.fromString = function (t) {\n      return new ie([new ne(t, null, null, null, null)]);\n    }, ie.prototype.isEmpty = function () {\n      return 0 === this.sections.length || !this.sections.some(function (t) {\n        return 0 !== t.text.length || t.image && 0 !== t.image.name.length;\n      });\n    }, ie.factory = function (t) {\n      return t instanceof ie ? t : ie.fromString(t);\n    }, ie.prototype.toString = function () {\n      return 0 === this.sections.length ? "" : this.sections.map(function (t) {\n        return t.text;\n      }).join("");\n    }, ie.prototype.serialize = function () {\n      for (var t = ["format"], e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        if (n.image) t.push(["image", n.image.name]);else {\n          t.push(n.text);\n          var i = {};\n          n.fontStack && (i["text-font"] = ["literal", n.fontStack.split(",")]), n.scale && (i["font-scale"] = n.scale), n.textColor && (i["text-color"] = ["rgba"].concat(n.textColor.toArray())), t.push(i);\n        }\n      }\n      return t;\n    };\n    var ae = function (t) {\n      this.name = t.name, this.available = t.available;\n    };\n    function oe(t, e, r, n) {\n      return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : "Invalid rgba value [" + [t, e, r, n].join(", ") + "]: \'a\' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ") + "]: \'r\', \'g\', and \'b\' must be between 0 and 255.";\n    }\n    function se(t) {\n      if (null === t) return !0;\n      if ("string" == typeof t) return !0;\n      if ("boolean" == typeof t) return !0;\n      if ("number" == typeof t) return !0;\n      if (t instanceof ee) return !0;\n      if (t instanceof re) return !0;\n      if (t instanceof ie) return !0;\n      if (t instanceof ae) return !0;\n      if (Array.isArray(t)) {\n        for (var e = 0, r = t; e < r.length; e += 1) if (!se(r[e])) return !1;\n        return !0;\n      }\n      if ("object" == typeof t) {\n        for (var n in t) if (!se(t[n])) return !1;\n        return !0;\n      }\n      return !1;\n    }\n    function ue(t) {\n      if (null === t) return Rt;\n      if ("string" == typeof t) return Ut;\n      if ("boolean" == typeof t) return jt;\n      if ("number" == typeof t) return Ot;\n      if (t instanceof ee) return qt;\n      if (t instanceof re) return Gt;\n      if (t instanceof ie) return Zt;\n      if (t instanceof ae) return Xt;\n      if (Array.isArray(t)) {\n        for (var e, r = t.length, n = 0, i = t; n < i.length; n += 1) {\n          var a = ue(i[n]);\n          if (e) {\n            if (e === a) continue;\n            e = Kt;\n            break;\n          }\n          e = a;\n        }\n        return Jt(e || Kt, r);\n      }\n      return Nt;\n    }\n    function le(t) {\n      var e = typeof t;\n      return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof ee || t instanceof ie || t instanceof ae ? t.toString() : JSON.stringify(t);\n    }\n    ae.prototype.toString = function () {\n      return this.name;\n    }, ae.fromString = function (t) {\n      return t ? new ae({\n        name: t,\n        available: !1\n      }) : null;\n    }, ae.prototype.serialize = function () {\n      return ["image", this.name];\n    };\n    var pe = function (t, e) {\n      this.type = t, this.value = e;\n    };\n    pe.parse = function (t, e) {\n      if (2 !== t.length) return e.error("\'literal\' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");\n      if (!se(t[1])) return e.error("invalid value");\n      var r = t[1],\n        n = ue(r),\n        i = e.expectedType;\n      return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new pe(n, r);\n    }, pe.prototype.evaluate = function () {\n      return this.value;\n    }, pe.prototype.eachChild = function () {}, pe.prototype.outputDefined = function () {\n      return !0;\n    }, pe.prototype.serialize = function () {\n      return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ee ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ie ? this.value.serialize() : this.value;\n    };\n    var ce = function (t) {\n      this.name = "ExpressionEvaluationError", this.message = t;\n    };\n    ce.prototype.toJSON = function () {\n      return this.message;\n    };\n    var he = {\n        string: Ut,\n        number: Ot,\n        boolean: jt,\n        object: Nt\n      },\n      fe = function (t, e) {\n        this.type = t, this.args = e;\n      };\n    fe.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r,\n        n = 1,\n        i = t[0];\n      if ("array" === i) {\n        var a, o;\n        if (t.length > 2) {\n          var s = t[1];\n          if ("string" != typeof s || !(s in he) || "object" === s) return e.error(\'The item type argument of "array" must be one of string, number, boolean\', 1);\n          a = he[s], n++;\n        } else a = Kt;\n        if (t.length > 3) {\n          if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error(\'The length argument to "array" must be a positive integer literal\', 2);\n          o = t[2], n++;\n        }\n        r = Jt(a, o);\n      } else r = he[i];\n      for (var u = []; n < t.length; n++) {\n        var l = e.parse(t[n], n, Kt);\n        if (!l) return null;\n        u.push(l);\n      }\n      return new fe(r, u);\n    }, fe.prototype.evaluate = function (t) {\n      for (var e = 0; e < this.args.length; e++) {\n        var r = this.args[e].evaluate(t);\n        if (!$t(this.type, ue(r))) return r;\n        if (e === this.args.length - 1) throw new ce("Expected value to be of type " + Ht(this.type) + ", but found " + Ht(ue(r)) + " instead.");\n      }\n      return null;\n    }, fe.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, fe.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, fe.prototype.serialize = function () {\n      var t = this.type,\n        e = [t.kind];\n      if ("array" === t.kind) {\n        var r = t.itemType;\n        if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {\n          e.push(r.kind);\n          var n = t.N;\n          ("number" == typeof n || this.args.length > 1) && e.push(n);\n        }\n      }\n      return e.concat(this.args.map(function (t) {\n        return t.serialize();\n      }));\n    };\n    var ye = function (t) {\n      this.type = Zt, this.sections = t;\n    };\n    ye.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r = t[1];\n      if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");\n      for (var n = [], i = !1, a = 1; a <= t.length - 1; ++a) {\n        var o = t[a];\n        if (i && "object" == typeof o && !Array.isArray(o)) {\n          i = !1;\n          var s = null;\n          if (o["font-scale"] && !(s = e.parse(o["font-scale"], 1, Ot))) return null;\n          var u = null;\n          if (o["text-font"] && !(u = e.parse(o["text-font"], 1, Jt(Ut)))) return null;\n          var l = null;\n          if (o["text-color"] && !(l = e.parse(o["text-color"], 1, qt))) return null;\n          var p = n[n.length - 1];\n          p.scale = s, p.font = u, p.textColor = l;\n        } else {\n          var c = e.parse(t[a], 1, Kt);\n          if (!c) return null;\n          var h = c.type.kind;\n          if ("string" !== h && "value" !== h && "null" !== h && "resolvedImage" !== h) return e.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");\n          i = !0, n.push({\n            content: c,\n            scale: null,\n            font: null,\n            textColor: null\n          });\n        }\n      }\n      return new ye(n);\n    }, ye.prototype.evaluate = function (t) {\n      return new ie(this.sections.map(function (e) {\n        var r = e.content.evaluate(t);\n        return ue(r) === Xt ? new ne("", r, null, null, null) : new ne(le(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);\n      }));\n    }, ye.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor);\n      }\n    }, ye.prototype.outputDefined = function () {\n      return !1;\n    }, ye.prototype.serialize = function () {\n      for (var t = ["format"], e = 0, r = this.sections; e < r.length; e += 1) {\n        var n = r[e];\n        t.push(n.content.serialize());\n        var i = {};\n        n.scale && (i["font-scale"] = n.scale.serialize()), n.font && (i["text-font"] = n.font.serialize()), n.textColor && (i["text-color"] = n.textColor.serialize()), t.push(i);\n      }\n      return t;\n    };\n    var de = function (t) {\n      this.type = Xt, this.input = t;\n    };\n    de.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected two arguments.");\n      var r = e.parse(t[1], 1, Ut);\n      return r ? new de(r) : e.error("No image name provided.");\n    }, de.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t),\n        r = ae.fromString(e);\n      return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n    }, de.prototype.eachChild = function (t) {\n      t(this.input);\n    }, de.prototype.outputDefined = function () {\n      return !1;\n    }, de.prototype.serialize = function () {\n      return ["image", this.input.serialize()];\n    };\n    var me = {\n        "to-boolean": jt,\n        "to-color": qt,\n        "to-number": Ot,\n        "to-string": Ut\n      },\n      ve = function (t, e) {\n        this.type = t, this.args = e;\n      };\n    ve.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expected at least one argument.");\n      var r = t[0];\n      if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument.");\n      for (var n = me[r], i = [], a = 1; a < t.length; a++) {\n        var o = e.parse(t[a], a, Kt);\n        if (!o) return null;\n        i.push(o);\n      }\n      return new ve(n, i);\n    }, ve.prototype.evaluate = function (t) {\n      if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n      if ("color" === this.type.kind) {\n        for (var e, r, n = 0, i = this.args; n < i.length; n += 1) {\n          if (r = null, (e = i[n].evaluate(t)) instanceof ee) return e;\n          if ("string" == typeof e) {\n            var a = t.parseColor(e);\n            if (a) return a;\n          } else if (Array.isArray(e) && !(r = e.length < 3 || e.length > 4 ? "Invalid rbga value " + JSON.stringify(e) + ": expected an array containing either three or four numeric values." : oe(e[0], e[1], e[2], e[3]))) return new ee(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n        }\n        throw new ce(r || "Could not parse color from value \'" + ("string" == typeof e ? e : String(JSON.stringify(e))) + "\'");\n      }\n      if ("number" === this.type.kind) {\n        for (var o = null, s = 0, u = this.args; s < u.length; s += 1) {\n          if (null === (o = u[s].evaluate(t))) return 0;\n          var l = Number(o);\n          if (!isNaN(l)) return l;\n        }\n        throw new ce("Could not convert " + JSON.stringify(o) + " to number.");\n      }\n      return "formatted" === this.type.kind ? ie.fromString(le(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? ae.fromString(le(this.args[0].evaluate(t))) : le(this.args[0].evaluate(t));\n    }, ve.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, ve.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, ve.prototype.serialize = function () {\n      if ("formatted" === this.type.kind) return new ye([{\n        content: this.args[0],\n        scale: null,\n        font: null,\n        textColor: null\n      }]).serialize();\n      if ("resolvedImage" === this.type.kind) return new de(this.args[0]).serialize();\n      var t = ["to-" + this.type.kind];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n    var ge = ["Unknown", "Point", "LineString", "Polygon"],\n      xe = function () {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;\n      };\n    xe.prototype.id = function () {\n      return this.feature && "id" in this.feature ? this.feature.id : null;\n    }, xe.prototype.geometryType = function () {\n      return this.feature ? "number" == typeof this.feature.type ? ge[this.feature.type] : this.feature.type : null;\n    }, xe.prototype.geometry = function () {\n      return this.feature && "geometry" in this.feature ? this.feature.geometry : null;\n    }, xe.prototype.canonicalID = function () {\n      return this.canonical;\n    }, xe.prototype.properties = function () {\n      return this.feature && this.feature.properties || {};\n    }, xe.prototype.parseColor = function (t) {\n      var e = this._parseColorCache[t];\n      return e || (e = this._parseColorCache[t] = ee.parse(t)), e;\n    };\n    var be = function (t, e, r, n) {\n      this.name = t, this.type = e, this._evaluate = r, this.args = n;\n    };\n    be.prototype.evaluate = function (t) {\n      return this._evaluate(t, this.args);\n    }, be.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, be.prototype.outputDefined = function () {\n      return !1;\n    }, be.prototype.serialize = function () {\n      return [this.name].concat(this.args.map(function (t) {\n        return t.serialize();\n      }));\n    }, be.parse = function (t, e) {\n      var r,\n        n = t[0],\n        i = be.definitions[n];\n      if (!i) return e.error(\'Unknown expression "\' + n + \'". If you wanted a literal array, use ["literal", [...]].\', 0);\n      for (var a = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, s = o.filter(function (e) {\n          var r = e[0];\n          return !Array.isArray(r) || r.length === t.length - 1;\n        }), u = null, l = 0, p = s; l < p.length; l += 1) {\n        var c = p[l],\n          h = c[0],\n          f = c[1];\n        u = new qe(e.registry, e.path, null, e.scope);\n        for (var y = [], d = !1, m = 1; m < t.length; m++) {\n          var v = t[m],\n            g = Array.isArray(h) ? h[m - 1] : h.type,\n            x = u.parse(v, 1 + y.length, g);\n          if (!x) {\n            d = !0;\n            break;\n          }\n          y.push(x);\n        }\n        if (!d) if (Array.isArray(h) && h.length !== y.length) u.error("Expected " + h.length + " arguments, but found " + y.length + " instead.");else {\n          for (var b = 0; b < y.length; b++) {\n            var w = Array.isArray(h) ? h[b] : h.type,\n              _ = y[b];\n            u.concat(b + 1).checkSubtype(w, _.type);\n          }\n          if (0 === u.errors.length) return new be(n, a, f, y);\n        }\n      }\n      if (1 === s.length) (r = e.errors).push.apply(r, u.errors);else {\n        for (var A = (s.length ? s : o).map(function (t) {\n            var e;\n            return e = t[0], Array.isArray(e) ? "(" + e.map(Ht).join(", ") + ")" : "(" + Ht(e.type) + "...)";\n          }).join(" | "), S = [], k = 1; k < t.length; k++) {\n          var I = e.parse(t[k], 1 + S.length);\n          if (!I) return null;\n          S.push(Ht(I.type));\n        }\n        e.error("Expected arguments of type " + A + ", but found (" + S.join(", ") + ") instead.");\n      }\n      return null;\n    }, be.register = function (t, e) {\n      for (var r in be.definitions = e, e) t[r] = be;\n    };\n    var we = function (t, e, r) {\n      this.type = Gt, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n    };\n    function _e(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n    function Ae(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n    function Se(t, e) {\n      var r = (180 + t[0]) / 360,\n        n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n        i = Math.pow(2, e.z);\n      return [Math.round(r * i * 8192), Math.round(n * i * 8192)];\n    }\n    function ke(t, e, r) {\n      return e[1] > t[1] != r[1] > t[1] && t[0] < (r[0] - e[0]) * (t[1] - e[1]) / (r[1] - e[1]) + e[0];\n    }\n    function Ie(t, e) {\n      for (var r, n, i, a, o, s, u, l = !1, p = 0, c = e.length; p < c; p++) for (var h = e[p], f = 0, y = h.length; f < y - 1; f++) {\n        if ((a = (r = t)[0] - (n = h[f])[0]) * (u = r[1] - (i = h[f + 1])[1]) - (s = r[0] - i[0]) * (o = r[1] - n[1]) == 0 && a * s <= 0 && o * u <= 0) return !1;\n        ke(t, h[f], h[f + 1]) && (l = !l);\n      }\n      return l;\n    }\n    function ze(t, e) {\n      for (var r = 0; r < e.length; r++) if (Ie(t, e[r])) return !0;\n      return !1;\n    }\n    function Ce(t, e, r, n) {\n      var i = n[0] - r[0],\n        a = n[1] - r[1],\n        o = (t[0] - r[0]) * a - i * (t[1] - r[1]),\n        s = (e[0] - r[0]) * a - i * (e[1] - r[1]);\n      return o > 0 && s < 0 || o < 0 && s > 0;\n    }\n    function Ee(t, e, r) {\n      for (var n = 0, i = r; n < i.length; n += 1) for (var a = i[n], o = 0; o < a.length - 1; ++o) if (0 != (c = [(p = a[o + 1])[0] - (l = a[o])[0], p[1] - l[1]])[0] * (h = [(u = e)[0] - (s = t)[0], u[1] - s[1]])[1] - c[1] * h[0] && Ce(s, u, l, p) && Ce(l, p, s, u)) return !0;\n      var s, u, l, p, c, h;\n      return !1;\n    }\n    function Pe(t, e) {\n      for (var r = 0; r < t.length; ++r) if (!Ie(t[r], e)) return !1;\n      for (var n = 0; n < t.length - 1; ++n) if (Ee(t[n], t[n + 1], e)) return !1;\n      return !0;\n    }\n    function Me(t, e) {\n      for (var r = 0; r < e.length; r++) if (Pe(t, e[r])) return !0;\n      return !1;\n    }\n    function Be(t, e, r) {\n      for (var n = [], i = 0; i < t.length; i++) {\n        for (var a = [], o = 0; o < t[i].length; o++) {\n          var s = Se(t[i][o], r);\n          _e(e, s), a.push(s);\n        }\n        n.push(a);\n      }\n      return n;\n    }\n    function Te(t, e, r) {\n      for (var n = [], i = 0; i < t.length; i++) {\n        var a = Be(t[i], e, r);\n        n.push(a);\n      }\n      return n;\n    }\n    function Ve(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        var i = .5 * n,\n          a = t[0] - r[0] > i ? -n : r[0] - t[0] > i ? n : 0;\n        0 === a && (a = t[0] - r[2] > i ? -n : r[2] - t[0] > i ? n : 0), t[0] += a;\n      }\n      _e(e, t);\n    }\n    function Fe(t, e, r, n) {\n      for (var i = 8192 * Math.pow(2, n.z), a = [8192 * n.x, 8192 * n.y], o = [], s = 0, u = t; s < u.length; s += 1) for (var l = 0, p = u[s]; l < p.length; l += 1) {\n        var c = p[l],\n          h = [c.x + a[0], c.y + a[1]];\n        Ve(h, e, r, i), o.push(h);\n      }\n      return o;\n    }\n    function De(t, e, r, n) {\n      for (var i, a = 8192 * Math.pow(2, n.z), o = [8192 * n.x, 8192 * n.y], s = [], u = 0, l = t; u < l.length; u += 1) {\n        for (var p = [], c = 0, h = l[u]; c < h.length; c += 1) {\n          var f = h[c],\n            y = [f.x + o[0], f.y + o[1]];\n          _e(e, y), p.push(y);\n        }\n        s.push(p);\n      }\n      if (e[2] - e[0] <= a / 2) {\n        (i = e)[0] = i[1] = 1 / 0, i[2] = i[3] = -1 / 0;\n        for (var d = 0, m = s; d < m.length; d += 1) for (var v = 0, g = m[d]; v < g.length; v += 1) Ve(g[v], e, r, a);\n      }\n      return s;\n    }\n    we.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected one argument.");\n      var r = t[1];\n      if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");\n      var n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, jt);\n      if (!n) return null;\n      var i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, jt);\n      if (!i) return null;\n      var a = null;\n      return r.locale && !(a = e.parse(r.locale, 1, Ut)) ? null : new we(n, i, a);\n    }, we.prototype.evaluate = function (t) {\n      return new re(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n    }, we.prototype.eachChild = function (t) {\n      t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n    }, we.prototype.outputDefined = function () {\n      return !1;\n    }, we.prototype.serialize = function () {\n      var t = {};\n      return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];\n    };\n    var Le = function (t, e) {\n      this.type = jt, this.geojson = t, this.geometries = e;\n    };\n    function Re(t) {\n      if (t instanceof be) {\n        if ("get" === t.name && 1 === t.args.length) return !1;\n        if ("feature-state" === t.name) return !1;\n        if ("has" === t.name && 1 === t.args.length) return !1;\n        if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n      if (t instanceof Le) return !1;\n      var e = !0;\n      return t.eachChild(function (t) {\n        e && !Re(t) && (e = !1);\n      }), e;\n    }\n    function Oe(t) {\n      if (t instanceof be && "feature-state" === t.name) return !1;\n      var e = !0;\n      return t.eachChild(function (t) {\n        e && !Oe(t) && (e = !1);\n      }), e;\n    }\n    function Ue(t, e) {\n      if (t instanceof be && e.indexOf(t.name) >= 0) return !1;\n      var r = !0;\n      return t.eachChild(function (t) {\n        r && !Ue(t, e) && (r = !1);\n      }), r;\n    }\n    Le.parse = function (t, e) {\n      if (2 !== t.length) return e.error("\'within\' expression requires exactly one argument, but found " + (t.length - 1) + " instead.");\n      if (se(t[1])) {\n        var r = t[1];\n        if ("FeatureCollection" === r.type) for (var n = 0; n < r.features.length; ++n) {\n          var i = r.features[n].geometry.type;\n          if ("Polygon" === i || "MultiPolygon" === i) return new Le(r, r.features[n].geometry);\n        } else if ("Feature" === r.type) {\n          var a = r.geometry.type;\n          if ("Polygon" === a || "MultiPolygon" === a) return new Le(r, r.geometry);\n        } else if ("Polygon" === r.type || "MultiPolygon" === r.type) return new Le(r, r);\n      }\n      return e.error("\'within\' expression requires valid geojson object that contains polygon geometry type.");\n    }, Le.prototype.evaluate = function (t) {\n      if (null != t.geometry() && null != t.canonicalID()) {\n        if ("Point" === t.geometryType()) return function (t, e) {\n          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n            i = t.canonicalID();\n          if ("Polygon" === e.type) {\n            var a = Be(e.coordinates, n, i),\n              o = Fe(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n            for (var s = 0, u = o; s < u.length; s += 1) if (!Ie(u[s], a)) return !1;\n          }\n          if ("MultiPolygon" === e.type) {\n            var l = Te(e.coordinates, n, i),\n              p = Fe(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n            for (var c = 0, h = p; c < h.length; c += 1) if (!ze(h[c], l)) return !1;\n          }\n          return !0;\n        }(t, this.geometries);\n        if ("LineString" === t.geometryType()) return function (t, e) {\n          var r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n            i = t.canonicalID();\n          if ("Polygon" === e.type) {\n            var a = Be(e.coordinates, n, i),\n              o = De(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n            for (var s = 0, u = o; s < u.length; s += 1) if (!Pe(u[s], a)) return !1;\n          }\n          if ("MultiPolygon" === e.type) {\n            var l = Te(e.coordinates, n, i),\n              p = De(t.geometry(), r, n, i);\n            if (!Ae(r, n)) return !1;\n            for (var c = 0, h = p; c < h.length; c += 1) if (!Me(h[c], l)) return !1;\n          }\n          return !0;\n        }(t, this.geometries);\n      }\n      return !1;\n    }, Le.prototype.eachChild = function () {}, Le.prototype.outputDefined = function () {\n      return !0;\n    }, Le.prototype.serialize = function () {\n      return ["within", this.geojson];\n    };\n    var je = function (t, e) {\n      this.type = e.type, this.name = t, this.boundExpression = e;\n    };\n    je.parse = function (t, e) {\n      if (2 !== t.length || "string" != typeof t[1]) return e.error("\'var\' expression requires exactly one string literal argument.");\n      var r = t[1];\n      return e.scope.has(r) ? new je(r, e.scope.get(r)) : e.error(\'Unknown variable "\' + r + \'". Make sure "\' + r + \'" has been bound in an enclosing "let" expression before using it.\', 1);\n    }, je.prototype.evaluate = function (t) {\n      return this.boundExpression.evaluate(t);\n    }, je.prototype.eachChild = function () {}, je.prototype.outputDefined = function () {\n      return !1;\n    }, je.prototype.serialize = function () {\n      return ["var", this.name];\n    };\n    var qe = function (t, e, r, n, i) {\n      void 0 === e && (e = []), void 0 === n && (n = new Lt()), void 0 === i && (i = []), this.registry = t, this.path = e, this.key = e.map(function (t) {\n        return "[" + t + "]";\n      }).join(""), this.scope = n, this.errors = i, this.expectedType = r;\n    };\n    function Ne(t, e) {\n      for (var r, n = t.length - 1, i = 0, a = n, o = 0; i <= a;) if ((r = t[o = Math.floor((i + a) / 2)]) <= e) {\n        if (o === n || e < t[o + 1]) return o;\n        i = o + 1;\n      } else {\n        if (!(r > e)) throw new ce("Input is not a number.");\n        a = o - 1;\n      }\n      return 0;\n    }\n    qe.prototype.parse = function (t, e, r, n, i) {\n      return void 0 === i && (i = {}), e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n    }, qe.prototype._parse = function (t, e) {\n      function r(t, e, r) {\n        return "assert" === r ? new fe(e, [t]) : "coerce" === r ? new ve(e, [t]) : t;\n      }\n      if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {\n        if (0 === t.length) return this.error(\'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].\');\n        var n = t[0];\n        if ("string" != typeof n) return this.error("Expression name must be a string, but found " + typeof n + \' instead. If you wanted a literal array, use ["literal", [...]].\', 0), null;\n        var i = this.registry[n];\n        if (i) {\n          var a = i.parse(t, this);\n          if (!a) return null;\n          if (this.expectedType) {\n            var o = this.expectedType,\n              s = a.type;\n            if ("string" !== o.kind && "number" !== o.kind && "boolean" !== o.kind && "object" !== o.kind && "array" !== o.kind || "value" !== s.kind) {\n              if ("color" !== o.kind && "formatted" !== o.kind && "resolvedImage" !== o.kind || "value" !== s.kind && "string" !== s.kind) {\n                if (this.checkSubtype(o, s)) return null;\n              } else a = r(a, o, e.typeAnnotation || "coerce");\n            } else a = r(a, o, e.typeAnnotation || "assert");\n          }\n          if (!(a instanceof pe) && "resolvedImage" !== a.type.kind && function t(e) {\n            if (e instanceof je) return t(e.boundExpression);\n            if (e instanceof be && "error" === e.name) return !1;\n            if (e instanceof we) return !1;\n            if (e instanceof Le) return !1;\n            var r = e instanceof ve || e instanceof fe,\n              n = !0;\n            return e.eachChild(function (e) {\n              n = r ? n && t(e) : n && e instanceof pe;\n            }), !!n && Re(e) && Ue(e, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);\n          }(a)) {\n            var u = new xe();\n            try {\n              a = new pe(a.type, a.evaluate(u));\n            } catch (t) {\n              return this.error(t.message), null;\n            }\n          }\n          return a;\n        }\n        return this.error(\'Unknown expression "\' + n + \'". If you wanted a literal array, use ["literal", [...]].\', 0);\n      }\n      return this.error(void 0 === t ? "\'undefined\' value invalid. Use null instead." : "object" == typeof t ? \'Bare objects invalid. Use ["literal", {...}] instead.\' : "Expected an array, but found " + typeof t + " instead.");\n    }, qe.prototype.concat = function (t, e, r) {\n      var n = "number" == typeof t ? this.path.concat(t) : this.path,\n        i = r ? this.scope.concat(r) : this.scope;\n      return new qe(this.registry, n, e || null, i, this.errors);\n    }, qe.prototype.error = function (t) {\n      for (var e = [], r = arguments.length - 1; r-- > 0;) e[r] = arguments[r + 1];\n      var n = "" + this.key + e.map(function (t) {\n        return "[" + t + "]";\n      }).join("");\n      this.errors.push(new Dt(n, t));\n    }, qe.prototype.checkSubtype = function (t, e) {\n      var r = $t(t, e);\n      return r && this.error(r), r;\n    };\n    var Ke = function (t, e, r) {\n      this.type = t, this.input = e, this.labels = [], this.outputs = [];\n      for (var n = 0, i = r; n < i.length; n += 1) {\n        var a = i[n],\n          o = a[1];\n        this.labels.push(a[0]), this.outputs.push(o);\n      }\n    };\n    function Ge(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n    Ke.parse = function (t, e) {\n      if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");\n      var r = e.parse(t[1], 1, Ot);\n      if (!r) return null;\n      var n = [],\n        i = null;\n      e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);\n      for (var a = 1; a < t.length; a += 2) {\n        var o = 1 === a ? -1 / 0 : t[a],\n          s = t[a + 1],\n          u = a,\n          l = a + 1;\n        if ("number" != typeof o) return e.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', u);\n        if (n.length && n[n.length - 1][0] >= o) return e.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\', u);\n        var p = e.parse(s, l, i);\n        if (!p) return null;\n        i = i || p.type, n.push([o, p]);\n      }\n      return new Ke(i, r, n);\n    }, Ke.prototype.evaluate = function (t) {\n      var e = this.labels,\n        r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      var n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      var i = e.length;\n      return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Ne(e, n)].evaluate(t);\n    }, Ke.prototype.eachChild = function (t) {\n      t(this.input);\n      for (var e = 0, r = this.outputs; e < r.length; e += 1) t(r[e]);\n    }, Ke.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      });\n    }, Ke.prototype.serialize = function () {\n      for (var t = ["step", this.input.serialize()], e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n      return t;\n    };\n    var Ze = Object.freeze({\n        __proto__: null,\n        number: Ge,\n        color: function (t, e, r) {\n          return new ee(Ge(t.r, e.r, r), Ge(t.g, e.g, r), Ge(t.b, e.b, r), Ge(t.a, e.a, r));\n        },\n        array: function (t, e, r) {\n          return t.map(function (t, n) {\n            return Ge(t, e[n], r);\n          });\n        }\n      }),\n      Xe = 6 / 29 * 3 * (6 / 29),\n      Je = Math.PI / 180,\n      He = 180 / Math.PI;\n    function Ye(t) {\n      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Xe + 4 / 29;\n    }\n    function $e(t) {\n      return t > 6 / 29 ? t * t * t : Xe * (t - 4 / 29);\n    }\n    function We(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n    function Qe(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n    function tr(t) {\n      var e = Qe(t.r),\n        r = Qe(t.g),\n        n = Qe(t.b),\n        i = Ye((.4124564 * e + .3575761 * r + .1804375 * n) / .95047),\n        a = Ye((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * a - 16,\n        a: 500 * (i - a),\n        b: 200 * (a - Ye((.0193339 * e + .119192 * r + .9503041 * n) / 1.08883)),\n        alpha: t.a\n      };\n    }\n    function er(t) {\n      var e = (t.l + 16) / 116,\n        r = isNaN(t.a) ? e : e + t.a / 500,\n        n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * $e(e), r = .95047 * $e(r), n = 1.08883 * $e(n), new ee(We(3.2404542 * r - 1.5371385 * e - .4985314 * n), We(-.969266 * r + 1.8760108 * e + .041556 * n), We(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n    function rr(t, e, r) {\n      var n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n    var nr = {\n        forward: tr,\n        reverse: er,\n        interpolate: function (t, e, r) {\n          return {\n            l: Ge(t.l, e.l, r),\n            a: Ge(t.a, e.a, r),\n            b: Ge(t.b, e.b, r),\n            alpha: Ge(t.alpha, e.alpha, r)\n          };\n        }\n      },\n      ir = {\n        forward: function (t) {\n          var e = tr(t),\n            r = e.l,\n            n = e.a,\n            i = e.b,\n            a = Math.atan2(i, n) * He;\n          return {\n            h: a < 0 ? a + 360 : a,\n            c: Math.sqrt(n * n + i * i),\n            l: r,\n            alpha: t.a\n          };\n        },\n        reverse: function (t) {\n          var e = t.h * Je,\n            r = t.c;\n          return er({\n            l: t.l,\n            a: Math.cos(e) * r,\n            b: Math.sin(e) * r,\n            alpha: t.alpha\n          });\n        },\n        interpolate: function (t, e, r) {\n          return {\n            h: rr(t.h, e.h, r),\n            c: Ge(t.c, e.c, r),\n            l: Ge(t.l, e.l, r),\n            alpha: Ge(t.alpha, e.alpha, r)\n          };\n        }\n      },\n      ar = Object.freeze({\n        __proto__: null,\n        lab: nr,\n        hcl: ir\n      }),\n      or = function (t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n        for (var a = 0, o = i; a < o.length; a += 1) {\n          var s = o[a],\n            u = s[1];\n          this.labels.push(s[0]), this.outputs.push(u);\n        }\n      };\n    function sr(t, e, r, n) {\n      var i = n - r,\n        a = t - r;\n      return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n    }\n    or.interpolationFactor = function (t, e, n, i) {\n      var a = 0;\n      if ("exponential" === t.name) a = sr(e, t.base, n, i);else if ("linear" === t.name) a = sr(e, 1, n, i);else if ("cubic-bezier" === t.name) {\n        var o = t.controlPoints;\n        a = new r(o[0], o[1], o[2], o[3]).solve(sr(e, 1, n, i));\n      }\n      return a;\n    }, or.parse = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t.slice(3);\n      if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);\n      if ("linear" === n[0]) n = {\n        name: "linear"\n      };else if ("exponential" === n[0]) {\n        var o = n[1];\n        if ("number" != typeof o) return e.error("Exponential interpolation requires a numeric base.", 1, 1);\n        n = {\n          name: "exponential",\n          base: o\n        };\n      } else {\n        if ("cubic-bezier" !== n[0]) return e.error("Unknown interpolation type " + String(n[0]), 1, 0);\n        var s = n.slice(1);\n        if (4 !== s.length || s.some(function (t) {\n          return "number" != typeof t || t < 0 || t > 1;\n        })) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);\n        n = {\n          name: "cubic-bezier",\n          controlPoints: s\n        };\n      }\n      if (t.length - 1 < 4) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");\n      if (!(i = e.parse(i, 2, Ot))) return null;\n      var u = [],\n        l = null;\n      "interpolate-hcl" === r || "interpolate-lab" === r ? l = qt : e.expectedType && "value" !== e.expectedType.kind && (l = e.expectedType);\n      for (var p = 0; p < a.length; p += 2) {\n        var c = a[p],\n          h = a[p + 1],\n          f = p + 3,\n          y = p + 4;\n        if ("number" != typeof c) return e.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', f);\n        if (u.length && u[u.length - 1][0] >= c) return e.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\', f);\n        var d = e.parse(h, y, l);\n        if (!d) return null;\n        l = l || d.type, u.push([c, d]);\n      }\n      return "number" === l.kind || "color" === l.kind || "array" === l.kind && "number" === l.itemType.kind && "number" == typeof l.N ? new or(l, r, n, i, u) : e.error("Type " + Ht(l) + " is not interpolatable.");\n    }, or.prototype.evaluate = function (t) {\n      var e = this.labels,\n        r = this.outputs;\n      if (1 === e.length) return r[0].evaluate(t);\n      var n = this.input.evaluate(t);\n      if (n <= e[0]) return r[0].evaluate(t);\n      var i = e.length;\n      if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n      var a = Ne(e, n),\n        o = or.interpolationFactor(this.interpolation, n, e[a], e[a + 1]),\n        s = r[a].evaluate(t),\n        u = r[a + 1].evaluate(t);\n      return "interpolate" === this.operator ? Ze[this.type.kind.toLowerCase()](s, u, o) : "interpolate-hcl" === this.operator ? ir.reverse(ir.interpolate(ir.forward(s), ir.forward(u), o)) : nr.reverse(nr.interpolate(nr.forward(s), nr.forward(u), o));\n    }, or.prototype.eachChild = function (t) {\n      t(this.input);\n      for (var e = 0, r = this.outputs; e < r.length; e += 1) t(r[e]);\n    }, or.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      });\n    }, or.prototype.serialize = function () {\n      var t;\n      t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);\n      for (var e = [this.operator, t, this.input.serialize()], r = 0; r < this.labels.length; r++) e.push(this.labels[r], this.outputs[r].serialize());\n      return e;\n    };\n    var ur = function (t, e) {\n      this.type = t, this.args = e;\n    };\n    ur.parse = function (t, e) {\n      if (t.length < 2) return e.error("Expectected at least one argument.");\n      var r = null,\n        n = e.expectedType;\n      n && "value" !== n.kind && (r = n);\n      for (var i = [], a = 0, o = t.slice(1); a < o.length; a += 1) {\n        var s = e.parse(o[a], 1 + i.length, r, void 0, {\n          typeAnnotation: "omit"\n        });\n        if (!s) return null;\n        r = r || s.type, i.push(s);\n      }\n      var u = n && i.some(function (t) {\n        return $t(n, t.type);\n      });\n      return new ur(u ? Kt : r, i);\n    }, ur.prototype.evaluate = function (t) {\n      for (var e, r = null, n = 0, i = 0, a = this.args; i < a.length && (n++, (r = a[i].evaluate(t)) && r instanceof ae && !r.available && (e || (e = r.name), r = null, n === this.args.length && (r = e)), null === r); i += 1);\n      return r;\n    }, ur.prototype.eachChild = function (t) {\n      this.args.forEach(t);\n    }, ur.prototype.outputDefined = function () {\n      return this.args.every(function (t) {\n        return t.outputDefined();\n      });\n    }, ur.prototype.serialize = function () {\n      var t = ["coalesce"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n    var lr = function (t, e) {\n      this.type = e.type, this.bindings = [].concat(t), this.result = e;\n    };\n    lr.prototype.evaluate = function (t) {\n      return this.result.evaluate(t);\n    }, lr.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.bindings; e < r.length; e += 1) t(r[e][1]);\n      t(this.result);\n    }, lr.parse = function (t, e) {\n      if (t.length < 4) return e.error("Expected at least 3 arguments, but found " + (t.length - 1) + " instead.");\n      for (var r = [], n = 1; n < t.length - 1; n += 2) {\n        var i = t[n];\n        if ("string" != typeof i) return e.error("Expected string, but found " + typeof i + " instead.", n);\n        if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or \'_\'.", n);\n        var a = e.parse(t[n + 1], n + 1);\n        if (!a) return null;\n        r.push([i, a]);\n      }\n      var o = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n      return o ? new lr(r, o) : null;\n    }, lr.prototype.outputDefined = function () {\n      return this.result.outputDefined();\n    }, lr.prototype.serialize = function () {\n      for (var t = ["let"], e = 0, r = this.bindings; e < r.length; e += 1) {\n        var n = r[e];\n        t.push(n[0], n[1].serialize());\n      }\n      return t.push(this.result.serialize()), t;\n    };\n    var pr = function (t, e, r) {\n      this.type = t, this.index = e, this.input = r;\n    };\n    pr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Ot),\n        n = e.parse(t[2], 2, Jt(e.expectedType || Kt));\n      return r && n ? new pr(n.type.itemType, r, n) : null;\n    }, pr.prototype.evaluate = function (t) {\n      var e = this.index.evaluate(t),\n        r = this.input.evaluate(t);\n      if (e < 0) throw new ce("Array index out of bounds: " + e + " < 0.");\n      if (e >= r.length) throw new ce("Array index out of bounds: " + e + " > " + (r.length - 1) + ".");\n      if (e !== Math.floor(e)) throw new ce("Array index must be an integer, but found " + e + " instead.");\n      return r[e];\n    }, pr.prototype.eachChild = function (t) {\n      t(this.index), t(this.input);\n    }, pr.prototype.outputDefined = function () {\n      return !1;\n    }, pr.prototype.serialize = function () {\n      return ["at", this.index.serialize(), this.input.serialize()];\n    };\n    var cr = function (t, e) {\n      this.type = jt, this.needle = t, this.haystack = e;\n    };\n    cr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected 2 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Kt),\n        n = e.parse(t[2], 2, Kt);\n      return r && n ? Wt(r.type, [jt, Ut, Ot, Rt, Kt]) ? new cr(r, n) : e.error("Expected first argument to be of type boolean, string, number or null, but found " + Ht(r.type) + " instead") : null;\n    }, cr.prototype.evaluate = function (t) {\n      var e = this.needle.evaluate(t),\n        r = this.haystack.evaluate(t);\n      if (!r) return !1;\n      if (!Qt(e, ["boolean", "string", "number", "null"])) throw new ce("Expected first argument to be of type boolean, string, number or null, but found " + Ht(ue(e)) + " instead.");\n      if (!Qt(r, ["string", "array"])) throw new ce("Expected second argument to be of type array or string, but found " + Ht(ue(r)) + " instead.");\n      return r.indexOf(e) >= 0;\n    }, cr.prototype.eachChild = function (t) {\n      t(this.needle), t(this.haystack);\n    }, cr.prototype.outputDefined = function () {\n      return !0;\n    }, cr.prototype.serialize = function () {\n      return ["in", this.needle.serialize(), this.haystack.serialize()];\n    };\n    var hr = function (t, e, r) {\n      this.type = Ot, this.needle = t, this.haystack = e, this.fromIndex = r;\n    };\n    hr.parse = function (t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Kt),\n        n = e.parse(t[2], 2, Kt);\n      if (!r || !n) return null;\n      if (!Wt(r.type, [jt, Ut, Ot, Rt, Kt])) return e.error("Expected first argument to be of type boolean, string, number or null, but found " + Ht(r.type) + " instead");\n      if (4 === t.length) {\n        var i = e.parse(t[3], 3, Ot);\n        return i ? new hr(r, n, i) : null;\n      }\n      return new hr(r, n);\n    }, hr.prototype.evaluate = function (t) {\n      var e = this.needle.evaluate(t),\n        r = this.haystack.evaluate(t);\n      if (!Qt(e, ["boolean", "string", "number", "null"])) throw new ce("Expected first argument to be of type boolean, string, number or null, but found " + Ht(ue(e)) + " instead.");\n      if (!Qt(r, ["string", "array"])) throw new ce("Expected second argument to be of type array or string, but found " + Ht(ue(r)) + " instead.");\n      if (this.fromIndex) {\n        var n = this.fromIndex.evaluate(t);\n        return r.indexOf(e, n);\n      }\n      return r.indexOf(e);\n    }, hr.prototype.eachChild = function (t) {\n      t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n    }, hr.prototype.outputDefined = function () {\n      return !1;\n    }, hr.prototype.serialize = function () {\n      if (null != this.fromIndex && void 0 !== this.fromIndex) {\n        var t = this.fromIndex.serialize();\n        return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];\n      }\n      return ["index-of", this.needle.serialize(), this.haystack.serialize()];\n    };\n    var fr = function (t, e, r, n, i, a) {\n      this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = a;\n    };\n    fr.parse = function (t, e) {\n      if (t.length < 5) return e.error("Expected at least 4 arguments, but found only " + (t.length - 1) + ".");\n      if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");\n      var r, n;\n      e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);\n      for (var i = {}, a = [], o = 2; o < t.length - 1; o += 2) {\n        var s = t[o],\n          u = t[o + 1];\n        Array.isArray(s) || (s = [s]);\n        var l = e.concat(o);\n        if (0 === s.length) return l.error("Expected at least one branch label.");\n        for (var p = 0, c = s; p < c.length; p += 1) {\n          var h = c[p];\n          if ("number" != typeof h && "string" != typeof h) return l.error("Branch labels must be numbers or strings.");\n          if ("number" == typeof h && Math.abs(h) > Number.MAX_SAFE_INTEGER) return l.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");\n          if ("number" == typeof h && Math.floor(h) !== h) return l.error("Numeric branch labels must be integer values.");\n          if (r) {\n            if (l.checkSubtype(r, ue(h))) return null;\n          } else r = ue(h);\n          if (void 0 !== i[String(h)]) return l.error("Branch labels must be unique.");\n          i[String(h)] = a.length;\n        }\n        var f = e.parse(u, o, n);\n        if (!f) return null;\n        n = n || f.type, a.push(f);\n      }\n      var y = e.parse(t[1], 1, Kt);\n      if (!y) return null;\n      var d = e.parse(t[t.length - 1], t.length - 1, n);\n      return d ? "value" !== y.type.kind && e.concat(1).checkSubtype(r, y.type) ? null : new fr(r, n, y, i, a, d) : null;\n    }, fr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t);\n      return (ue(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n    }, fr.prototype.eachChild = function (t) {\n      t(this.input), this.outputs.forEach(t), t(this.otherwise);\n    }, fr.prototype.outputDefined = function () {\n      return this.outputs.every(function (t) {\n        return t.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }, fr.prototype.serialize = function () {\n      for (var t = this, e = ["match", this.input.serialize()], r = [], n = {}, i = 0, a = Object.keys(this.cases).sort(); i < a.length; i += 1) {\n        var o = a[i];\n        void 0 === (c = n[this.cases[o]]) ? (n[this.cases[o]] = r.length, r.push([this.cases[o], [o]])) : r[c][1].push(o);\n      }\n      for (var s = function (e) {\n          return "number" === t.inputType.kind ? Number(e) : e;\n        }, u = 0, l = r; u < l.length; u += 1) {\n        var p = l[u],\n          c = p[0],\n          h = p[1];\n        e.push(1 === h.length ? s(h[0]) : h.map(s)), e.push(this.outputs[outputIndex$1].serialize());\n      }\n      return e.push(this.otherwise.serialize()), e;\n    };\n    var yr = function (t, e, r) {\n      this.type = t, this.branches = e, this.otherwise = r;\n    };\n    yr.parse = function (t, e) {\n      if (t.length < 4) return e.error("Expected at least 3 arguments, but found only " + (t.length - 1) + ".");\n      if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");\n      var r;\n      e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);\n      for (var n = [], i = 1; i < t.length - 1; i += 2) {\n        var a = e.parse(t[i], i, jt);\n        if (!a) return null;\n        var o = e.parse(t[i + 1], i + 1, r);\n        if (!o) return null;\n        n.push([a, o]), r = r || o.type;\n      }\n      var s = e.parse(t[t.length - 1], t.length - 1, r);\n      return s ? new yr(r, n, s) : null;\n    }, yr.prototype.evaluate = function (t) {\n      for (var e = 0, r = this.branches; e < r.length; e += 1) {\n        var n = r[e],\n          i = n[1];\n        if (n[0].evaluate(t)) return i.evaluate(t);\n      }\n      return this.otherwise.evaluate(t);\n    }, yr.prototype.eachChild = function (t) {\n      for (var e = 0, r = this.branches; e < r.length; e += 1) {\n        var n = r[e],\n          i = n[1];\n        t(n[0]), t(i);\n      }\n      t(this.otherwise);\n    }, yr.prototype.outputDefined = function () {\n      return this.branches.every(function (t) {\n        return t[1].outputDefined();\n      }) && this.otherwise.outputDefined();\n    }, yr.prototype.serialize = function () {\n      var t = ["case"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n    var dr = function (t, e, r, n) {\n      this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n    };\n    function mr(t, e) {\n      return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;\n    }\n    function vr(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n    function gr(t, e, r) {\n      var n = "==" !== t && "!=" !== t;\n      return function () {\n        function i(t, e, r) {\n          this.type = jt, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;\n        }\n        return i.parse = function (t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");\n          var r = t[0],\n            a = e.parse(t[1], 1, Kt);\n          if (!a) return null;\n          if (!mr(r, a.type)) return e.concat(1).error(\'"\' + r + "\\" comparisons are not supported for type \'" + Ht(a.type) + "\'.");\n          var o = e.parse(t[2], 2, Kt);\n          if (!o) return null;\n          if (!mr(r, o.type)) return e.concat(2).error(\'"\' + r + "\\" comparisons are not supported for type \'" + Ht(o.type) + "\'.");\n          if (a.type.kind !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot compare types \'" + Ht(a.type) + "\' and \'" + Ht(o.type) + "\'.");\n          n && ("value" === a.type.kind && "value" !== o.type.kind ? a = new fe(o.type, [a]) : "value" !== a.type.kind && "value" === o.type.kind && (o = new fe(a.type, [o])));\n          var s = null;\n          if (4 === t.length) {\n            if ("string" !== a.type.kind && "string" !== o.type.kind && "value" !== a.type.kind && "value" !== o.type.kind) return e.error("Cannot use collator to compare non-string types.");\n            if (!(s = e.parse(t[3], 3, Gt))) return null;\n          }\n          return new i(a, o, s);\n        }, i.prototype.evaluate = function (i) {\n          var a = this.lhs.evaluate(i),\n            o = this.rhs.evaluate(i);\n          if (n && this.hasUntypedArgument) {\n            var s = ue(a),\n              u = ue(o);\n            if (s.kind !== u.kind || "string" !== s.kind && "number" !== s.kind) throw new ce(\'Expected arguments for "\' + t + \'" to be (string, string) or (number, number), but found (\' + s.kind + ", " + u.kind + ") instead.");\n          }\n          if (this.collator && !n && this.hasUntypedArgument) {\n            var l = ue(a),\n              p = ue(o);\n            if ("string" !== l.kind || "string" !== p.kind) return e(i, a, o);\n          }\n          return this.collator ? r(i, a, o, this.collator.evaluate(i)) : e(i, a, o);\n        }, i.prototype.eachChild = function (t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }, i.prototype.outputDefined = function () {\n          return !0;\n        }, i.prototype.serialize = function () {\n          var e = [t];\n          return this.eachChild(function (t) {\n            e.push(t.serialize());\n          }), e;\n        }, i;\n      }();\n    }\n    dr.parse = function (t, e) {\n      if (t.length <= 2 || t.length >= 5) return e.error("Expected 3 or 4 arguments, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1, Kt),\n        n = e.parse(t[2], 2, Ot);\n      if (!r || !n) return null;\n      if (!Wt(r.type, [Jt(Kt), Ut, Kt])) return e.error("Expected first argument to be of type array or string, but found " + Ht(r.type) + " instead");\n      if (4 === t.length) {\n        var i = e.parse(t[3], 3, Ot);\n        return i ? new dr(r.type, r, n, i) : null;\n      }\n      return new dr(r.type, r, n);\n    }, dr.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t),\n        r = this.beginIndex.evaluate(t);\n      if (!Qt(e, ["string", "array"])) throw new ce("Expected first argument to be of type array or string, but found " + Ht(ue(e)) + " instead.");\n      if (this.endIndex) {\n        var n = this.endIndex.evaluate(t);\n        return e.slice(r, n);\n      }\n      return e.slice(r);\n    }, dr.prototype.eachChild = function (t) {\n      t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n    }, dr.prototype.outputDefined = function () {\n      return !1;\n    }, dr.prototype.serialize = function () {\n      if (null != this.endIndex && void 0 !== this.endIndex) {\n        var t = this.endIndex.serialize();\n        return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];\n      }\n      return ["slice", this.input.serialize(), this.beginIndex.serialize()];\n    };\n    var xr = gr("==", function (t, e, r) {\n        return e === r;\n      }, vr),\n      br = gr("!=", function (t, e, r) {\n        return e !== r;\n      }, function (t, e, r, n) {\n        return !vr(0, e, r, n);\n      }),\n      wr = gr("<", function (t, e, r) {\n        return e < r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) < 0;\n      }),\n      _r = gr(">", function (t, e, r) {\n        return e > r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) > 0;\n      }),\n      Ar = gr("<=", function (t, e, r) {\n        return e <= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) <= 0;\n      }),\n      Sr = gr(">=", function (t, e, r) {\n        return e >= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) >= 0;\n      }),\n      kr = function (t, e, r, n, i) {\n        this.type = Ut, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;\n      };\n    kr.parse = function (t, e) {\n      if (3 !== t.length) return e.error("Expected two arguments.");\n      var r = e.parse(t[1], 1, Ot);\n      if (!r) return null;\n      var n = t[2];\n      if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");\n      var i = null;\n      if (n.locale && !(i = e.parse(n.locale, 1, Ut))) return null;\n      var a = null;\n      if (n.currency && !(a = e.parse(n.currency, 1, Ut))) return null;\n      var o = null;\n      if (n["min-fraction-digits"] && !(o = e.parse(n["min-fraction-digits"], 1, Ot))) return null;\n      var s = null;\n      return n["max-fraction-digits"] && !(s = e.parse(n["max-fraction-digits"], 1, Ot)) ? null : new kr(r, i, a, o, s);\n    }, kr.prototype.evaluate = function (t) {\n      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n        style: this.currency ? "currency" : "decimal",\n        currency: this.currency ? this.currency.evaluate(t) : void 0,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n      }).format(this.number.evaluate(t));\n    }, kr.prototype.eachChild = function (t) {\n      t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n    }, kr.prototype.outputDefined = function () {\n      return !1;\n    }, kr.prototype.serialize = function () {\n      var t = {};\n      return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];\n    };\n    var Ir = function (t) {\n      this.type = Ot, this.input = t;\n    };\n    Ir.parse = function (t, e) {\n      if (2 !== t.length) return e.error("Expected 1 argument, but found " + (t.length - 1) + " instead.");\n      var r = e.parse(t[1], 1);\n      return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error("Expected argument of type string or array, but found " + Ht(r.type) + " instead.") : new Ir(r) : null;\n    }, Ir.prototype.evaluate = function (t) {\n      var e = this.input.evaluate(t);\n      if ("string" == typeof e) return e.length;\n      if (Array.isArray(e)) return e.length;\n      throw new ce("Expected value to be of type string or array, but found " + Ht(ue(e)) + " instead.");\n    }, Ir.prototype.eachChild = function (t) {\n      t(this.input);\n    }, Ir.prototype.outputDefined = function () {\n      return !1;\n    }, Ir.prototype.serialize = function () {\n      var t = ["length"];\n      return this.eachChild(function (e) {\n        t.push(e.serialize());\n      }), t;\n    };\n    var zr = {\n      "==": xr,\n      "!=": br,\n      ">": _r,\n      "<": wr,\n      ">=": Sr,\n      "<=": Ar,\n      array: fe,\n      at: pr,\n      boolean: fe,\n      case: yr,\n      coalesce: ur,\n      collator: we,\n      format: ye,\n      image: de,\n      in: cr,\n      "index-of": hr,\n      interpolate: or,\n      "interpolate-hcl": or,\n      "interpolate-lab": or,\n      length: Ir,\n      let: lr,\n      literal: pe,\n      match: fr,\n      number: fe,\n      "number-format": kr,\n      object: fe,\n      slice: dr,\n      step: Ke,\n      string: fe,\n      "to-boolean": ve,\n      "to-color": ve,\n      "to-number": ve,\n      "to-string": ve,\n      var: je,\n      within: Le\n    };\n    function Cr(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3];\n      r = r.evaluate(t), n = n.evaluate(t), i = i.evaluate(t);\n      var o = a ? a.evaluate(t) : 1,\n        s = oe(r, n, i, o);\n      if (s) throw new ce(s);\n      return new ee(r / 255 * o, n / 255 * o, i / 255 * o, o);\n    }\n    function Er(t, e) {\n      return t in e;\n    }\n    function Pr(t, e) {\n      var r = e[t];\n      return void 0 === r ? null : r;\n    }\n    function Mr(t) {\n      return {\n        type: t\n      };\n    }\n    function Br(t) {\n      return {\n        result: "success",\n        value: t\n      };\n    }\n    function Tr(t) {\n      return {\n        result: "error",\n        value: t\n      };\n    }\n    function Vr(t) {\n      return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"];\n    }\n    function Fr(t) {\n      return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;\n    }\n    function Dr(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n    function Lr(t) {\n      return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t;\n    }\n    function Rr(t) {\n      return "object" == typeof t && null !== t && !Array.isArray(t);\n    }\n    function Or(t) {\n      return t;\n    }\n    function Ur(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n    function jr(t, e, r, n, i) {\n      return Ur(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n    function qr(t, e, r) {\n      if ("number" !== Lr(r)) return Ur(t.default, e.default);\n      var n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      var i = Ne(t.stops.map(function (t) {\n        return t[0];\n      }), r);\n      return t.stops[i][1];\n    }\n    function Nr(t, e, r) {\n      var n = void 0 !== t.base ? t.base : 1;\n      if ("number" !== Lr(r)) return Ur(t.default, e.default);\n      var i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n      var a = Ne(t.stops.map(function (t) {\n          return t[0];\n        }), r),\n        o = function (t, e, r, n) {\n          var i = n - r,\n            a = t - r;\n          return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n        }(r, n, t.stops[a][0], t.stops[a + 1][0]),\n        s = t.stops[a][1],\n        u = t.stops[a + 1][1],\n        l = Ze[e.type] || Or;\n      if (t.colorSpace && "rgb" !== t.colorSpace) {\n        var p = ar[t.colorSpace];\n        l = function (t, e) {\n          return p.reverse(p.interpolate(p.forward(t), p.forward(e), o));\n        };\n      }\n      return "function" == typeof s.evaluate ? {\n        evaluate: function () {\n          for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];\n          var r = s.evaluate.apply(void 0, t),\n            n = u.evaluate.apply(void 0, t);\n          if (void 0 !== r && void 0 !== n) return l(r, n, o);\n        }\n      } : l(s, u, o);\n    }\n    function Kr(t, e, r) {\n      return "color" === e.type ? r = ee.parse(r) : "formatted" === e.type ? r = ie.fromString(r.toString()) : "resolvedImage" === e.type ? r = ae.fromString(r.toString()) : Lr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Ur(r, t.default, e.default);\n    }\n    be.register(zr, {\n      error: [{\n        kind: "error"\n      }, [Ut], function (t, e) {\n        throw new ce(e[0].evaluate(t));\n      }],\n      typeof: [Ut, [Kt], function (t, e) {\n        return Ht(ue(e[0].evaluate(t)));\n      }],\n      "to-rgba": [Jt(Ot, 4), [qt], function (t, e) {\n        return e[0].evaluate(t).toArray();\n      }],\n      rgb: [qt, [Ot, Ot, Ot], Cr],\n      rgba: [qt, [Ot, Ot, Ot, Ot], Cr],\n      has: {\n        type: jt,\n        overloads: [[[Ut], function (t, e) {\n          return Er(e[0].evaluate(t), t.properties());\n        }], [[Ut, Nt], function (t, e) {\n          var r = e[1];\n          return Er(e[0].evaluate(t), r.evaluate(t));\n        }]]\n      },\n      get: {\n        type: Kt,\n        overloads: [[[Ut], function (t, e) {\n          return Pr(e[0].evaluate(t), t.properties());\n        }], [[Ut, Nt], function (t, e) {\n          var r = e[1];\n          return Pr(e[0].evaluate(t), r.evaluate(t));\n        }]]\n      },\n      "feature-state": [Kt, [Ut], function (t, e) {\n        return Pr(e[0].evaluate(t), t.featureState || {});\n      }],\n      properties: [Nt, [], function (t) {\n        return t.properties();\n      }],\n      "geometry-type": [Ut, [], function (t) {\n        return t.geometryType();\n      }],\n      id: [Kt, [], function (t) {\n        return t.id();\n      }],\n      zoom: [Ot, [], function (t) {\n        return t.globals.zoom;\n      }],\n      "heatmap-density": [Ot, [], function (t) {\n        return t.globals.heatmapDensity || 0;\n      }],\n      "line-progress": [Ot, [], function (t) {\n        return t.globals.lineProgress || 0;\n      }],\n      accumulated: [Kt, [], function (t) {\n        return void 0 === t.globals.accumulated ? null : t.globals.accumulated;\n      }],\n      "+": [Ot, Mr(Ot), function (t, e) {\n        for (var r = 0, n = 0, i = e; n < i.length; n += 1) r += i[n].evaluate(t);\n        return r;\n      }],\n      "*": [Ot, Mr(Ot), function (t, e) {\n        for (var r = 1, n = 0, i = e; n < i.length; n += 1) r *= i[n].evaluate(t);\n        return r;\n      }],\n      "-": {\n        type: Ot,\n        overloads: [[[Ot, Ot], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) - r.evaluate(t);\n        }], [[Ot], function (t, e) {\n          return -e[0].evaluate(t);\n        }]]\n      },\n      "/": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return e[0].evaluate(t) / r.evaluate(t);\n      }],\n      "%": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return e[0].evaluate(t) % r.evaluate(t);\n      }],\n      ln2: [Ot, [], function () {\n        return Math.LN2;\n      }],\n      pi: [Ot, [], function () {\n        return Math.PI;\n      }],\n      e: [Ot, [], function () {\n        return Math.E;\n      }],\n      "^": [Ot, [Ot, Ot], function (t, e) {\n        var r = e[1];\n        return Math.pow(e[0].evaluate(t), r.evaluate(t));\n      }],\n      sqrt: [Ot, [Ot], function (t, e) {\n        return Math.sqrt(e[0].evaluate(t));\n      }],\n      log10: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t)) / Math.LN10;\n      }],\n      ln: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t));\n      }],\n      log2: [Ot, [Ot], function (t, e) {\n        return Math.log(e[0].evaluate(t)) / Math.LN2;\n      }],\n      sin: [Ot, [Ot], function (t, e) {\n        return Math.sin(e[0].evaluate(t));\n      }],\n      cos: [Ot, [Ot], function (t, e) {\n        return Math.cos(e[0].evaluate(t));\n      }],\n      tan: [Ot, [Ot], function (t, e) {\n        return Math.tan(e[0].evaluate(t));\n      }],\n      asin: [Ot, [Ot], function (t, e) {\n        return Math.asin(e[0].evaluate(t));\n      }],\n      acos: [Ot, [Ot], function (t, e) {\n        return Math.acos(e[0].evaluate(t));\n      }],\n      atan: [Ot, [Ot], function (t, e) {\n        return Math.atan(e[0].evaluate(t));\n      }],\n      min: [Ot, Mr(Ot), function (t, e) {\n        return Math.min.apply(Math, e.map(function (e) {\n          return e.evaluate(t);\n        }));\n      }],\n      max: [Ot, Mr(Ot), function (t, e) {\n        return Math.max.apply(Math, e.map(function (e) {\n          return e.evaluate(t);\n        }));\n      }],\n      abs: [Ot, [Ot], function (t, e) {\n        return Math.abs(e[0].evaluate(t));\n      }],\n      round: [Ot, [Ot], function (t, e) {\n        var r = e[0].evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [Ot, [Ot], function (t, e) {\n        return Math.floor(e[0].evaluate(t));\n      }],\n      ceil: [Ot, [Ot], function (t, e) {\n        return Math.ceil(e[0].evaluate(t));\n      }],\n      "filter-==": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n          n = e[1];\n        return t.properties()[r.value] === n.value;\n      }],\n      "filter-id-==": [jt, [Kt], function (t, e) {\n        var r = e[0];\n        return t.id() === r.value;\n      }],\n      "filter-type-==": [jt, [Ut], function (t, e) {\n        var r = e[0];\n        return t.geometryType() === r.value;\n      }],\n      "filter-<": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = t.properties()[r.value],\n          a = n.value;\n        return typeof i == typeof a && i < a;\n      }],\n      "filter-id-<": [jt, [Kt], function (t, e) {\n        var r = e[0],\n          n = t.id(),\n          i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      "filter->": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = t.properties()[r.value],\n          a = n.value;\n        return typeof i == typeof a && i > a;\n      }],\n      "filter-id->": [jt, [Kt], function (t, e) {\n        var r = e[0],\n          n = t.id(),\n          i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      "filter-<=": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = t.properties()[r.value],\n          a = n.value;\n        return typeof i == typeof a && i <= a;\n      }],\n      "filter-id-<=": [jt, [Kt], function (t, e) {\n        var r = e[0],\n          n = t.id(),\n          i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      "filter->=": [jt, [Ut, Kt], function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = t.properties()[r.value],\n          a = n.value;\n        return typeof i == typeof a && i >= a;\n      }],\n      "filter-id->=": [jt, [Kt], function (t, e) {\n        var r = e[0],\n          n = t.id(),\n          i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      "filter-has": [jt, [Kt], function (t, e) {\n        return e[0].value in t.properties();\n      }],\n      "filter-has-id": [jt, [], function (t) {\n        return null !== t.id() && void 0 !== t.id();\n      }],\n      "filter-type-in": [jt, [Jt(Ut)], function (t, e) {\n        return e[0].value.indexOf(t.geometryType()) >= 0;\n      }],\n      "filter-id-in": [jt, [Jt(Kt)], function (t, e) {\n        return e[0].value.indexOf(t.id()) >= 0;\n      }],\n      "filter-in-small": [jt, [Ut, Jt(Kt)], function (t, e) {\n        var r = e[0];\n        return e[1].value.indexOf(t.properties()[r.value]) >= 0;\n      }],\n      "filter-in-large": [jt, [Ut, Jt(Kt)], function (t, e) {\n        var r = e[0],\n          n = e[1];\n        return function (t, e, r, n) {\n          for (; r <= n;) {\n            var i = r + n >> 1;\n            if (e[i] === t) return !0;\n            e[i] > t ? n = i - 1 : r = i + 1;\n          }\n          return !1;\n        }(t.properties()[r.value], n.value, 0, n.value.length - 1);\n      }],\n      all: {\n        type: jt,\n        overloads: [[[jt, jt], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) && r.evaluate(t);\n        }], [Mr(jt), function (t, e) {\n          for (var r = 0, n = e; r < n.length; r += 1) if (!n[r].evaluate(t)) return !1;\n          return !0;\n        }]]\n      },\n      any: {\n        type: jt,\n        overloads: [[[jt, jt], function (t, e) {\n          var r = e[1];\n          return e[0].evaluate(t) || r.evaluate(t);\n        }], [Mr(jt), function (t, e) {\n          for (var r = 0, n = e; r < n.length; r += 1) if (n[r].evaluate(t)) return !0;\n          return !1;\n        }]]\n      },\n      "!": [jt, [jt], function (t, e) {\n        return !e[0].evaluate(t);\n      }],\n      "is-supported-script": [jt, [Ut], function (t, e) {\n        var r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e[0].evaluate(t));\n      }],\n      upcase: [Ut, [Ut], function (t, e) {\n        return e[0].evaluate(t).toUpperCase();\n      }],\n      downcase: [Ut, [Ut], function (t, e) {\n        return e[0].evaluate(t).toLowerCase();\n      }],\n      concat: [Ut, Mr(Kt), function (t, e) {\n        return e.map(function (e) {\n          return le(e.evaluate(t));\n        }).join("");\n      }],\n      "resolved-locale": [Ut, [Gt], function (t, e) {\n        return e[0].evaluate(t).resolvedLocale();\n      }]\n    });\n    var Gr = function (t, e) {\n      this.expression = t, this._warningHistory = {}, this._evaluator = new xe(), this._defaultValue = e ? function (t) {\n        return "color" === t.type && Rr(t.default) ? new ee(0, 0, 0, 0) : "color" === t.type ? ee.parse(t.default) || null : void 0 === t.default ? null : t.default;\n      }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;\n    };\n    function Zr(t) {\n      return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in zr;\n    }\n    function Xr(t, e) {\n      var r = new qe(zr, [], e ? function (t) {\n          var e = {\n            color: qt,\n            string: Ut,\n            number: Ot,\n            enum: Ut,\n            boolean: jt,\n            formatted: Zt,\n            resolvedImage: Xt\n          };\n          return "array" === t.type ? Jt(e[t.value] || Kt, t.length) : e[t.type];\n        }(e) : void 0),\n        n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {\n          typeAnnotation: "coerce"\n        } : void 0);\n      return n ? Br(new Gr(n, e)) : Tr(r.errors);\n    }\n    Gr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this.expression.evaluate(this._evaluator);\n    }, Gr.prototype.evaluate = function (t, e, r, n, i, a) {\n      this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null;\n      try {\n        var o = this.expression.evaluate(this._evaluator);\n        if (null == o || "number" == typeof o && o != o) return this._defaultValue;\n        if (this._enumValues && !(o in this._enumValues)) throw new ce("Expected value to be one of " + Object.keys(this._enumValues).map(function (t) {\n          return JSON.stringify(t);\n        }).join(", ") + ", but found " + JSON.stringify(o) + " instead.");\n        return o;\n      } catch (t) {\n        return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue;\n      }\n    };\n    var Jr = function (t, e) {\n      this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !Oe(e.expression);\n    };\n    Jr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n    }, Jr.prototype.evaluate = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluate(t, e, r, n, i, a);\n    };\n    var Hr = function (t, e, r, n) {\n      this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !Oe(e.expression), this.interpolationType = n;\n    };\n    function Yr(t, e) {\n      if ("error" === (t = Xr(t, e)).result) return t;\n      var r = t.value.expression,\n        n = Re(r);\n      if (!n && !Vr(e)) return Tr([new Dt("", "data expressions not supported")]);\n      var i = Ue(r, ["zoom"]);\n      if (!i && !Fr(e)) return Tr([new Dt("", "zoom expressions not supported")]);\n      var a = function t(e) {\n        var r = null;\n        if (e instanceof lr) r = t(e.result);else if (e instanceof ur) for (var n = 0, i = e.args; n < i.length && !(r = t(i[n])); n += 1);else (e instanceof Ke || e instanceof or) && e.input instanceof be && "zoom" === e.input.name && (r = e);\n        return r instanceof Dt || e.eachChild(function (e) {\n          var n = t(e);\n          n instanceof Dt ? r = n : !r && n ? r = new Dt("", \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\') : r && n && r !== n && (r = new Dt("", \'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\'));\n        }), r;\n      }(r);\n      return a || i ? a instanceof Dt ? Tr([a]) : a instanceof or && !Dr(e) ? Tr([new Dt("", \'"interpolate" expressions cannot be used with this property\')]) : Br(a ? new Hr(n ? "camera" : "composite", t.value, a.labels, a instanceof or ? a.interpolation : void 0) : new Jr(n ? "constant" : "source", t.value)) : Tr([new Dt("", \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);\n    }\n    Hr.prototype.evaluateWithoutErrorHandling = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n    }, Hr.prototype.evaluate = function (t, e, r, n, i, a) {\n      return this._styleExpression.evaluate(t, e, r, n, i, a);\n    }, Hr.prototype.interpolationFactor = function (t, e, r) {\n      return this.interpolationType ? or.interpolationFactor(this.interpolationType, t, e, r) : 0;\n    };\n    var $r = function (t, e) {\n      this._parameters = t, this._specification = e, Tt(this, function t(e, r) {\n        var n,\n          i,\n          a,\n          o = "color" === r.type,\n          s = e.stops && "object" == typeof e.stops[0][0],\n          u = s || !(s || void 0 !== e.property),\n          l = e.type || (Dr(r) ? "exponential" : "interval");\n        if (o && ((e = Tt({}, e)).stops && (e.stops = e.stops.map(function (t) {\n          return [t[0], ee.parse(t[1])];\n        })), e.default = ee.parse(e.default ? e.default : r.default)), e.colorSpace && "rgb" !== e.colorSpace && !ar[e.colorSpace]) throw new Error("Unknown color space: " + e.colorSpace);\n        if ("exponential" === l) n = Nr;else if ("interval" === l) n = qr;else if ("categorical" === l) {\n          n = jr, i = Object.create(null);\n          for (var p = 0, c = e.stops; p < c.length; p += 1) {\n            var h = c[p];\n            i[h[0]] = h[1];\n          }\n          a = typeof e.stops[0][0];\n        } else {\n          if ("identity" !== l) throw new Error(\'Unknown function type "\' + l + \'"\');\n          n = Kr;\n        }\n        if (s) {\n          for (var f = {}, y = [], d = 0; d < e.stops.length; d++) {\n            var m = e.stops[d],\n              v = m[0].zoom;\n            void 0 === f[v] && (f[v] = {\n              zoom: v,\n              type: e.type,\n              property: e.property,\n              default: e.default,\n              stops: []\n            }, y.push(v)), f[v].stops.push([m[0].value, m[1]]);\n          }\n          for (var g = [], x = 0, b = y; x < b.length; x += 1) {\n            var w = b[x];\n            g.push([f[w].zoom, t(f[w], r)]);\n          }\n          var _ = {\n            name: "linear"\n          };\n          return {\n            kind: "composite",\n            interpolationType: _,\n            interpolationFactor: or.interpolationFactor.bind(void 0, _),\n            zoomStops: g.map(function (t) {\n              return t[0];\n            }),\n            evaluate: function (t, n) {\n              var i = t.zoom;\n              return Nr({\n                stops: g,\n                base: e.base\n              }, r, i).evaluate(i, n);\n            }\n          };\n        }\n        if (u) {\n          var A = "exponential" === l ? {\n            name: "exponential",\n            base: void 0 !== e.base ? e.base : 1\n          } : null;\n          return {\n            kind: "camera",\n            interpolationType: A,\n            interpolationFactor: or.interpolationFactor.bind(void 0, A),\n            zoomStops: e.stops.map(function (t) {\n              return t[0];\n            }),\n            evaluate: function (t) {\n              return n(e, r, t.zoom, i, a);\n            }\n          };\n        }\n        return {\n          kind: "source",\n          evaluate: function (t, o) {\n            var s = o && o.properties ? o.properties[e.property] : void 0;\n            return void 0 === s ? Ur(e.default, r.default) : n(e, r, s, i, a);\n          }\n        };\n      }(this._parameters, this._specification));\n    };\n    function Wr(t) {\n      var e = t.key,\n        r = t.value,\n        n = t.valueSpec || {},\n        i = t.objectElementValidators || {},\n        a = t.style,\n        o = t.styleSpec,\n        s = [],\n        u = Lr(r);\n      if ("object" !== u) return [new Mt(e, r, "object expected, " + u + " found")];\n      for (var l in r) {\n        var p = l.split(".")[0],\n          c = n[p] || n["*"],\n          h = void 0;\n        if (i[p]) h = i[p];else if (n[p]) h = Sn;else if (i["*"]) h = i["*"];else {\n          if (!n["*"]) {\n            s.push(new Mt(e, r[l], \'unknown property "\' + l + \'"\'));\n            continue;\n          }\n          h = Sn;\n        }\n        s = s.concat(h({\n          key: (e ? e + "." : e) + l,\n          value: r[l],\n          valueSpec: c,\n          style: a,\n          styleSpec: o,\n          object: r,\n          objectKey: l\n        }, r));\n      }\n      for (var f in n) i[f] || n[f].required && void 0 === n[f].default && void 0 === r[f] && s.push(new Mt(e, r, \'missing required property "\' + f + \'"\'));\n      return s;\n    }\n    function Qr(t) {\n      var e = t.value,\n        r = t.valueSpec,\n        n = t.style,\n        i = t.styleSpec,\n        a = t.key,\n        o = t.arrayElementValidator || Sn;\n      if ("array" !== Lr(e)) return [new Mt(a, e, "array expected, " + Lr(e) + " found")];\n      if (r.length && e.length !== r.length) return [new Mt(a, e, "array length " + r.length + " expected, length " + e.length + " found")];\n      if (r["min-length"] && e.length < r["min-length"]) return [new Mt(a, e, "array length at least " + r["min-length"] + " expected, length " + e.length + " found")];\n      var s = {\n        type: r.value,\n        values: r.values\n      };\n      i.$version < 7 && (s.function = r.function), "object" === Lr(r.value) && (s = r.value);\n      for (var u = [], l = 0; l < e.length; l++) u = u.concat(o({\n        array: e,\n        arrayIndex: l,\n        value: e[l],\n        valueSpec: s,\n        style: n,\n        styleSpec: i,\n        key: a + "[" + l + "]"\n      }));\n      return u;\n    }\n    function tn(t) {\n      var e = t.key,\n        r = t.value,\n        n = t.valueSpec,\n        i = Lr(r);\n      return "number" === i && r != r && (i = "NaN"), "number" !== i ? [new Mt(e, r, "number expected, " + i + " found")] : "minimum" in n && r < n.minimum ? [new Mt(e, r, r + " is less than the minimum value " + n.minimum)] : "maximum" in n && r > n.maximum ? [new Mt(e, r, r + " is greater than the maximum value " + n.maximum)] : [];\n    }\n    function en(t) {\n      var e,\n        r,\n        n,\n        i = t.valueSpec,\n        a = Vt(t.value.type),\n        o = {},\n        s = "categorical" !== a && void 0 === t.value.property,\n        u = !s,\n        l = "array" === Lr(t.value.stops) && "array" === Lr(t.value.stops[0]) && "object" === Lr(t.value.stops[0][0]),\n        p = Wr({\n          key: t.key,\n          value: t.value,\n          valueSpec: t.styleSpec.function,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            stops: function (t) {\n              if ("identity" === a) return [new Mt(t.key, t.value, \'identity function may not have a "stops" property\')];\n              var e = [],\n                r = t.value;\n              return e = e.concat(Qr({\n                key: t.key,\n                value: r,\n                valueSpec: t.valueSpec,\n                style: t.style,\n                styleSpec: t.styleSpec,\n                arrayElementValidator: c\n              })), "array" === Lr(r) && 0 === r.length && e.push(new Mt(t.key, r, "array must have at least one stop")), e;\n            },\n            default: function (t) {\n              return Sn({\n                key: t.key,\n                value: t.value,\n                valueSpec: i,\n                style: t.style,\n                styleSpec: t.styleSpec\n              });\n            }\n          }\n        });\n      return "identity" === a && s && p.push(new Mt(t.key, t.value, \'missing required property "property"\')), "identity" === a || t.value.stops || p.push(new Mt(t.key, t.value, \'missing required property "stops"\')), "exponential" === a && t.valueSpec.expression && !Dr(t.valueSpec) && p.push(new Mt(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (u && !Vr(t.valueSpec) ? p.push(new Mt(t.key, t.value, "property functions not supported")) : s && !Fr(t.valueSpec) && p.push(new Mt(t.key, t.value, "zoom functions not supported"))), "categorical" !== a && !l || void 0 !== t.value.property || p.push(new Mt(t.key, t.value, \'"property" property is required\')), p;\n      function c(t) {\n        var e = [],\n          a = t.value,\n          s = t.key;\n        if ("array" !== Lr(a)) return [new Mt(s, a, "array expected, " + Lr(a) + " found")];\n        if (2 !== a.length) return [new Mt(s, a, "array length 2 expected, length " + a.length + " found")];\n        if (l) {\n          if ("object" !== Lr(a[0])) return [new Mt(s, a, "object expected, " + Lr(a[0]) + " found")];\n          if (void 0 === a[0].zoom) return [new Mt(s, a, "object stop key must have zoom")];\n          if (void 0 === a[0].value) return [new Mt(s, a, "object stop key must have value")];\n          if (n && n > Vt(a[0].zoom)) return [new Mt(s, a[0].zoom, "stop zoom values must appear in ascending order")];\n          Vt(a[0].zoom) !== n && (n = Vt(a[0].zoom), r = void 0, o = {}), e = e.concat(Wr({\n            key: s + "[0]",\n            value: a[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: tn,\n              value: h\n            }\n          }));\n        } else e = e.concat(h({\n          key: s + "[0]",\n          value: a[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, a));\n        return Zr(Ft(a[1])) ? e.concat([new Mt(s + "[1]", a[1], "expressions are not allowed in function stops.")]) : e.concat(Sn({\n          key: s + "[1]",\n          value: a[1],\n          valueSpec: i,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n      function h(t, n) {\n        var s = Lr(t.value),\n          u = Vt(t.value),\n          l = null !== t.value ? t.value : n;\n        if (e) {\n          if (s !== e) return [new Mt(t.key, l, s + " stop domain type must match previous stop domain type " + e)];\n        } else e = s;\n        if ("number" !== s && "string" !== s && "boolean" !== s) return [new Mt(t.key, l, "stop domain value must be a number, string, or boolean")];\n        if ("number" !== s && "categorical" !== a) {\n          var p = "number expected, " + s + " found";\n          return Vr(i) && void 0 === a && (p += \'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\'), [new Mt(t.key, l, p)];\n        }\n        return "categorical" !== a || "number" !== s || isFinite(u) && Math.floor(u) === u ? "categorical" !== a && "number" === s && void 0 !== r && u < r ? [new Mt(t.key, l, "stop domain values must appear in ascending order")] : (r = u, "categorical" === a && u in o ? [new Mt(t.key, l, "stop domain values must be unique")] : (o[u] = !0, [])) : [new Mt(t.key, l, "integer expected, found " + u)];\n      }\n    }\n    function rn(t) {\n      var e = ("property" === t.expressionContext ? Yr : Xr)(Ft(t.value), t.valueSpec);\n      if ("error" === e.result) return e.value.map(function (e) {\n        return new Mt("" + t.key + e.key, t.value, e.message);\n      });\n      var r = e.value.expression || e.value._styleExpression.expression;\n      if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new Mt(t.key, t.value, \'Invalid data expression for "\' + t.propertyKey + \'". Output values must be contained as literals within the expression.\')];\n      if ("property" === t.expressionContext && "layout" === t.propertyType && !Oe(r)) return [new Mt(t.key, t.value, \'"feature-state" data expressions are not supported with layout properties.\')];\n      if ("filter" === t.expressionContext && !Oe(r)) return [new Mt(t.key, t.value, \'"feature-state" data expressions are not supported with filters.\')];\n      if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {\n        if (!Ue(r, ["zoom", "feature-state"])) return [new Mt(t.key, t.value, \'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];\n        if ("cluster-initial" === t.expressionContext && !Re(r)) return [new Mt(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];\n      }\n      return [];\n    }\n    function nn(t) {\n      var e = t.key,\n        r = t.value,\n        n = t.valueSpec,\n        i = [];\n      return Array.isArray(n.values) ? -1 === n.values.indexOf(Vt(r)) && i.push(new Mt(e, r, "expected one of [" + n.values.join(", ") + "], " + JSON.stringify(r) + " found")) : -1 === Object.keys(n.values).indexOf(Vt(r)) && i.push(new Mt(e, r, "expected one of [" + Object.keys(n.values).join(", ") + "], " + JSON.stringify(r) + " found")), i;\n    }\n    function an(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n      switch (t[0]) {\n        case "has":\n          return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];\n        case "in":\n          return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));\n        case "!in":\n        case "!has":\n        case "none":\n          return !1;\n        case "==":\n        case "!=":\n        case ">":\n        case ">=":\n        case "<":\n        case "<=":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n        case "any":\n        case "all":\n          for (var e = 0, r = t.slice(1); e < r.length; e += 1) {\n            var n = r[e];\n            if (!an(n) && "boolean" != typeof n) return !1;\n          }\n          return !0;\n        default:\n          return !0;\n      }\n    }\n    $r.deserialize = function (t) {\n      return new $r(t._parameters, t._specification);\n    }, $r.serialize = function (t) {\n      return {\n        _parameters: t._parameters,\n        _specification: t._specification\n      };\n    };\n    var on = {\n      type: "boolean",\n      default: !1,\n      transition: !1,\n      "property-type": "data-driven",\n      expression: {\n        interpolated: !1,\n        parameters: ["zoom", "feature"]\n      }\n    };\n    function sn(t) {\n      if (null == t) return {\n        filter: function () {\n          return !0;\n        },\n        needGeometry: !1\n      };\n      an(t) || (t = ln(t));\n      var e = Xr(t, on);\n      if ("error" === e.result) throw new Error(e.value.map(function (t) {\n        return t.key + ": " + t.message;\n      }).join(", "));\n      return {\n        filter: function (t, r, n) {\n          return e.value.evaluate(t, r, {}, n);\n        },\n        needGeometry: function t(e) {\n          if (!Array.isArray(e)) return !1;\n          if ("within" === e[0]) return !0;\n          for (var r = 1; r < e.length; r++) if (t(e[r])) return !0;\n          return !1;\n        }(t)\n      };\n    }\n    function un(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function ln(t) {\n      if (!t) return !0;\n      var e,\n        r = t[0];\n      return t.length <= 1 ? "any" !== r : "==" === r ? pn(t[1], t[2], "==") : "!=" === r ? fn(pn(t[1], t[2], "==")) : "<" === r || ">" === r || "<=" === r || ">=" === r ? pn(t[1], t[2], r) : "any" === r ? (e = t.slice(1), ["any"].concat(e.map(ln))) : "all" === r ? ["all"].concat(t.slice(1).map(ln)) : "none" === r ? ["all"].concat(t.slice(1).map(ln).map(fn)) : "in" === r ? cn(t[1], t.slice(2)) : "!in" === r ? fn(cn(t[1], t.slice(2))) : "has" === r ? hn(t[1]) : "!has" === r ? fn(hn(t[1])) : "within" !== r || t;\n    }\n    function pn(t, e, r) {\n      switch (t) {\n        case "$type":\n          return ["filter-type-" + r, e];\n        case "$id":\n          return ["filter-id-" + r, e];\n        default:\n          return ["filter-" + r, t, e];\n      }\n    }\n    function cn(t, e) {\n      if (0 === e.length) return !1;\n      switch (t) {\n        case "$type":\n          return ["filter-type-in", ["literal", e]];\n        case "$id":\n          return ["filter-id-in", ["literal", e]];\n        default:\n          return e.length > 200 && !e.some(function (t) {\n            return typeof t != typeof e[0];\n          }) ? ["filter-in-large", t, ["literal", e.sort(un)]] : ["filter-in-small", t, ["literal", e]];\n      }\n    }\n    function hn(t) {\n      switch (t) {\n        case "$type":\n          return !0;\n        case "$id":\n          return ["filter-has-id"];\n        default:\n          return ["filter-has", t];\n      }\n    }\n    function fn(t) {\n      return ["!", t];\n    }\n    function yn(t) {\n      return an(Ft(t.value)) ? rn(Tt({}, t, {\n        expressionContext: "filter",\n        valueSpec: {\n          value: "boolean"\n        }\n      })) : function t(e) {\n        var r = e.value,\n          n = e.key;\n        if ("array" !== Lr(r)) return [new Mt(n, r, "array expected, " + Lr(r) + " found")];\n        var i,\n          a = e.styleSpec,\n          o = [];\n        if (r.length < 1) return [new Mt(n, r, "filter array must have at least 1 element")];\n        switch (o = o.concat(nn({\n          key: n + "[0]",\n          value: r[0],\n          valueSpec: a.filter_operator,\n          style: e.style,\n          styleSpec: e.styleSpec\n        })), Vt(r[0])) {\n          case "<":\n          case "<=":\n          case ">":\n          case ">=":\n            r.length >= 2 && "$type" === Vt(r[1]) && o.push(new Mt(n, r, \'"$type" cannot be use with operator "\' + r[0] + \'"\'));\n          case "==":\n          case "!=":\n            3 !== r.length && o.push(new Mt(n, r, \'filter array for operator "\' + r[0] + \'" must have 3 elements\'));\n          case "in":\n          case "!in":\n            r.length >= 2 && "string" !== (i = Lr(r[1])) && o.push(new Mt(n + "[1]", r[1], "string expected, " + i + " found"));\n            for (var s = 2; s < r.length; s++) i = Lr(r[s]), "$type" === Vt(r[1]) ? o = o.concat(nn({\n              key: n + "[" + s + "]",\n              value: r[s],\n              valueSpec: a.geometry_type,\n              style: e.style,\n              styleSpec: e.styleSpec\n            })) : "string" !== i && "number" !== i && "boolean" !== i && o.push(new Mt(n + "[" + s + "]", r[s], "string, number, or boolean expected, " + i + " found"));\n            break;\n          case "any":\n          case "all":\n          case "none":\n            for (var u = 1; u < r.length; u++) o = o.concat(t({\n              key: n + "[" + u + "]",\n              value: r[u],\n              style: e.style,\n              styleSpec: e.styleSpec\n            }));\n            break;\n          case "has":\n          case "!has":\n            i = Lr(r[1]), 2 !== r.length ? o.push(new Mt(n, r, \'filter array for "\' + r[0] + \'" operator must have 2 elements\')) : "string" !== i && o.push(new Mt(n + "[1]", r[1], "string expected, " + i + " found"));\n            break;\n          case "within":\n            i = Lr(r[1]), 2 !== r.length ? o.push(new Mt(n, r, \'filter array for "\' + r[0] + \'" operator must have 2 elements\')) : "object" !== i && o.push(new Mt(n + "[1]", r[1], "object expected, " + i + " found"));\n        }\n        return o;\n      }(t);\n    }\n    function dn(t, e) {\n      var r = t.key,\n        n = t.style,\n        i = t.styleSpec,\n        a = t.value,\n        o = t.objectKey,\n        s = i[e + "_" + t.layerType];\n      if (!s) return [];\n      var u = o.match(/^(.*)-transition$/);\n      if ("paint" === e && u && s[u[1]] && s[u[1]].transition) return Sn({\n        key: r,\n        value: a,\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      });\n      var l,\n        p = t.valueSpec || s[o];\n      if (!p) return [new Mt(r, a, \'unknown property "\' + o + \'"\')];\n      if ("string" === Lr(a) && Vr(p) && !p.tokens && (l = /^{([^}]+)}$/.exec(a))) return [new Mt(r, a, \'"\' + o + \'" does not support interpolation syntax\\nUse an identity property function instead: `{ "type": "identity", "property": \' + JSON.stringify(l[1]) + " }`.")];\n      var c = [];\n      return "symbol" === t.layerType && ("text-field" === o && n && !n.glyphs && c.push(new Mt(r, a, \'use of "text-field" requires a style "glyphs" property\')), "text-font" === o && Rr(Ft(a)) && "identity" === Vt(a.type) && c.push(new Mt(r, a, \'"text-font" does not support identity functions\'))), c.concat(Sn({\n        key: t.key,\n        value: a,\n        valueSpec: p,\n        style: n,\n        styleSpec: i,\n        expressionContext: "property",\n        propertyType: e,\n        propertyKey: o\n      }));\n    }\n    function mn(t) {\n      return dn(t, "paint");\n    }\n    function vn(t) {\n      return dn(t, "layout");\n    }\n    function gn(t) {\n      var e = [],\n        r = t.value,\n        n = t.key,\n        i = t.style,\n        a = t.styleSpec;\n      r.type || r.ref || e.push(new Mt(n, r, \'either "type" or "ref" is required\'));\n      var o,\n        s = Vt(r.type),\n        u = Vt(r.ref);\n      if (r.id) for (var l = Vt(r.id), p = 0; p < t.arrayIndex; p++) {\n        var c = i.layers[p];\n        Vt(c.id) === l && e.push(new Mt(n, r.id, \'duplicate layer id "\' + r.id + \'", previously used at line \' + c.id.__line__));\n      }\n      if ("ref" in r) ["type", "source", "source-layer", "filter", "layout"].forEach(function (t) {\n        t in r && e.push(new Mt(n, r[t], \'"\' + t + \'" is prohibited for ref layers\'));\n      }), i.layers.forEach(function (t) {\n        Vt(t.id) === u && (o = t);\n      }), o ? o.ref ? e.push(new Mt(n, r.ref, "ref cannot reference another ref layer")) : s = Vt(o.type) : e.push(new Mt(n, r.ref, \'ref layer "\' + u + \'" not found\'));else if ("background" !== s) if (r.source) {\n        var h = i.sources && i.sources[r.source],\n          f = h && Vt(h.type);\n        h ? "vector" === f && "raster" === s ? e.push(new Mt(n, r.source, \'layer "\' + r.id + \'" requires a raster source\')) : "raster" === f && "raster" !== s ? e.push(new Mt(n, r.source, \'layer "\' + r.id + \'" requires a vector source\')) : "vector" !== f || r["source-layer"] ? "raster-dem" === f && "hillshade" !== s ? e.push(new Mt(n, r.source, "raster-dem source can only be used with layer type \'hillshade\'.")) : "line" !== s || !r.paint || !r.paint["line-gradient"] || "geojson" === f && h.lineMetrics || e.push(new Mt(n, r, \'layer "\' + r.id + \'" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.\')) : e.push(new Mt(n, r, \'layer "\' + r.id + \'" must specify a "source-layer"\')) : e.push(new Mt(n, r.source, \'source "\' + r.source + \'" not found\'));\n      } else e.push(new Mt(n, r, \'missing required property "source"\'));\n      return e = e.concat(Wr({\n        key: n,\n        value: r,\n        valueSpec: a.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          "*": function () {\n            return [];\n          },\n          type: function () {\n            return Sn({\n              key: n + ".type",\n              value: r.type,\n              valueSpec: a.layer.type,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              object: r,\n              objectKey: "type"\n            });\n          },\n          filter: yn,\n          layout: function (t) {\n            return Wr({\n              layer: r,\n              key: t.key,\n              value: t.value,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              objectElementValidators: {\n                "*": function (t) {\n                  return vn(Tt({\n                    layerType: s\n                  }, t));\n                }\n              }\n            });\n          },\n          paint: function (t) {\n            return Wr({\n              layer: r,\n              key: t.key,\n              value: t.value,\n              style: t.style,\n              styleSpec: t.styleSpec,\n              objectElementValidators: {\n                "*": function (t) {\n                  return mn(Tt({\n                    layerType: s\n                  }, t));\n                }\n              }\n            });\n          }\n        }\n      }));\n    }\n    function xn(t) {\n      var e = t.value,\n        r = t.key,\n        n = Lr(e);\n      return "string" !== n ? [new Mt(r, e, "string expected, " + n + " found")] : [];\n    }\n    var bn = {\n      promoteId: function (t) {\n        var e = t.key,\n          r = t.value;\n        if ("string" === Lr(r)) return xn({\n          key: e,\n          value: r\n        });\n        var n = [];\n        for (var i in r) n.push.apply(n, xn({\n          key: e + "." + i,\n          value: r[i]\n        }));\n        return n;\n      }\n    };\n    function wn(t) {\n      var e = t.value,\n        r = t.key,\n        n = t.styleSpec,\n        i = t.style;\n      if (!e.type) return [new Mt(r, e, \'"type" is required\')];\n      var a,\n        o = Vt(e.type);\n      switch (o) {\n        case "vector":\n        case "raster":\n        case "raster-dem":\n          return Wr({\n            key: r,\n            value: e,\n            valueSpec: n["source_" + o.replace("-", "_")],\n            style: t.style,\n            styleSpec: n,\n            objectElementValidators: bn\n          });\n        case "geojson":\n          if (a = Wr({\n            key: r,\n            value: e,\n            valueSpec: n.source_geojson,\n            style: i,\n            styleSpec: n,\n            objectElementValidators: bn\n          }), e.cluster) for (var s in e.clusterProperties) {\n            var u = e.clusterProperties[s],\n              l = u[0],\n              p = "string" == typeof l ? [l, ["accumulated"], ["get", s]] : l;\n            a.push.apply(a, rn({\n              key: r + "." + s + ".map",\n              value: u[1],\n              expressionContext: "cluster-map"\n            })), a.push.apply(a, rn({\n              key: r + "." + s + ".reduce",\n              value: p,\n              expressionContext: "cluster-reduce"\n            }));\n          }\n          return a;\n        case "video":\n          return Wr({\n            key: r,\n            value: e,\n            valueSpec: n.source_video,\n            style: i,\n            styleSpec: n\n          });\n        case "image":\n          return Wr({\n            key: r,\n            value: e,\n            valueSpec: n.source_image,\n            style: i,\n            styleSpec: n\n          });\n        case "canvas":\n          return [new Mt(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];\n        default:\n          return nn({\n            key: r + ".type",\n            value: e.type,\n            valueSpec: {\n              values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]\n            },\n            style: i,\n            styleSpec: n\n          });\n      }\n    }\n    function _n(t) {\n      var e = t.value,\n        r = t.styleSpec,\n        n = r.light,\n        i = t.style,\n        a = [],\n        o = Lr(e);\n      if (void 0 === e) return a;\n      if ("object" !== o) return a.concat([new Mt("light", e, "object expected, " + o + " found")]);\n      for (var s in e) {\n        var u = s.match(/^(.*)-transition$/);\n        a = a.concat(u && n[u[1]] && n[u[1]].transition ? Sn({\n          key: s,\n          value: e[s],\n          valueSpec: r.transition,\n          style: i,\n          styleSpec: r\n        }) : n[s] ? Sn({\n          key: s,\n          value: e[s],\n          valueSpec: n[s],\n          style: i,\n          styleSpec: r\n        }) : [new Mt(s, e[s], \'unknown property "\' + s + \'"\')]);\n      }\n      return a;\n    }\n    var An = {\n      "*": function () {\n        return [];\n      },\n      array: Qr,\n      boolean: function (t) {\n        var e = t.value,\n          r = t.key,\n          n = Lr(e);\n        return "boolean" !== n ? [new Mt(r, e, "boolean expected, " + n + " found")] : [];\n      },\n      number: tn,\n      color: function (t) {\n        var e = t.key,\n          r = t.value,\n          n = Lr(r);\n        return "string" !== n ? [new Mt(e, r, "color expected, " + n + " found")] : null === te(r) ? [new Mt(e, r, \'color expected, "\' + r + \'" found\')] : [];\n      },\n      constants: Bt,\n      enum: nn,\n      filter: yn,\n      function: en,\n      layer: gn,\n      object: Wr,\n      source: wn,\n      light: _n,\n      string: xn,\n      formatted: function (t) {\n        return 0 === xn(t).length ? [] : rn(t);\n      },\n      resolvedImage: function (t) {\n        return 0 === xn(t).length ? [] : rn(t);\n      }\n    };\n    function Sn(t) {\n      var e = t.value,\n        r = t.valueSpec,\n        n = t.styleSpec;\n      return r.expression && Rr(Vt(e)) ? en(t) : r.expression && Zr(Ft(e)) ? rn(t) : r.type && An[r.type] ? An[r.type](t) : Wr(Tt({}, t, {\n        valueSpec: r.type ? n[r.type] : r\n      }));\n    }\n    function kn(t) {\n      var e = t.value,\n        r = t.key,\n        n = xn(t);\n      return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new Mt(r, e, \'"glyphs" url must include a "{fontstack}" token\')), -1 === e.indexOf("{range}") && n.push(new Mt(r, e, \'"glyphs" url must include a "{range}" token\'))), n;\n    }\n    function In(t, e) {\n      void 0 === e && (e = Pt);\n      var r = [];\n      return r = r.concat(Sn({\n        key: "",\n        value: t,\n        valueSpec: e.$root,\n        styleSpec: e,\n        style: t,\n        objectElementValidators: {\n          glyphs: kn,\n          "*": function () {\n            return [];\n          }\n        }\n      })), t.constants && (r = r.concat(Bt({\n        key: "constants",\n        value: t.constants,\n        style: t,\n        styleSpec: e\n      }))), zn(r);\n    }\n    function zn(t) {\n      return [].concat(t).sort(function (t, e) {\n        return t.line - e.line;\n      });\n    }\n    function Cn(t) {\n      return function () {\n        for (var e = [], r = arguments.length; r--;) e[r] = arguments[r];\n        return zn(t.apply(this, e));\n      };\n    }\n    In.source = Cn(wn), In.light = Cn(_n), In.layer = Cn(gn), In.filter = Cn(yn), In.paintProperty = Cn(mn), In.layoutProperty = Cn(vn);\n    var En = In,\n      Pn = En.light,\n      Mn = En.paintProperty,\n      Bn = En.layoutProperty;\n    function Tn(t, e) {\n      var r = !1;\n      if (e && e.length) for (var n = 0, i = e; n < i.length; n += 1) t.fire(new Ct(new Error(i[n].message))), r = !0;\n      return r;\n    }\n    var Vn = Fn;\n    function Fn(t, e, r) {\n      var n = this.cells = [];\n      if (t instanceof ArrayBuffer) {\n        this.arrayBuffer = t;\n        var i = new Int32Array(this.arrayBuffer);\n        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n        for (var a = 0; a < this.d * this.d; a++) {\n          var o = i[3 + a],\n            s = i[3 + a + 1];\n          n.push(o === s ? null : i.subarray(o, s));\n        }\n        var u = i[3 + n.length + 1];\n        this.keys = i.subarray(i[3 + n.length], u), this.bboxes = i.subarray(u), this.insert = this._insertReadonly;\n      } else {\n        this.d = e + 2 * r;\n        for (var l = 0; l < this.d * this.d; l++) n.push([]);\n        this.keys = [], this.bboxes = [];\n      }\n      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n      var p = r / e * t;\n      this.min = -p, this.max = t + p;\n    }\n    Fn.prototype.insert = function (t, e, r, n, i) {\n      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n    }, Fn.prototype._insertReadonly = function () {\n      throw "Cannot insert into a GridIndex created from an ArrayBuffer.";\n    }, Fn.prototype._insertCell = function (t, e, r, n, i, a) {\n      this.cells[i].push(a);\n    }, Fn.prototype.query = function (t, e, r, n, i) {\n      var a = this.min,\n        o = this.max;\n      if (t <= a && e <= a && o <= r && o <= n && !i) return Array.prototype.slice.call(this.keys);\n      var s = [];\n      return this._forEachCell(t, e, r, n, this._queryCell, s, {}, i), s;\n    }, Fn.prototype._queryCell = function (t, e, r, n, i, a, o, s) {\n      var u = this.cells[i];\n      if (null !== u) for (var l = this.keys, p = this.bboxes, c = 0; c < u.length; c++) {\n        var h = u[c];\n        if (void 0 === o[h]) {\n          var f = 4 * h;\n          (s ? s(p[f + 0], p[f + 1], p[f + 2], p[f + 3]) : t <= p[f + 2] && e <= p[f + 3] && r >= p[f + 0] && n >= p[f + 1]) ? (o[h] = !0, a.push(l[h])) : o[h] = !1;\n        }\n      }\n    }, Fn.prototype._forEachCell = function (t, e, r, n, i, a, o, s) {\n      for (var u = this._convertToCellCoord(t), l = this._convertToCellCoord(e), p = this._convertToCellCoord(r), c = this._convertToCellCoord(n), h = u; h <= p; h++) for (var f = l; f <= c; f++) {\n        var y = this.d * f + h;\n        if ((!s || s(this._convertFromCellCoord(h), this._convertFromCellCoord(f), this._convertFromCellCoord(h + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, y, a, o, s)) return;\n      }\n    }, Fn.prototype._convertFromCellCoord = function (t) {\n      return (t - this.padding) / this.scale;\n    }, Fn.prototype._convertToCellCoord = function (t) {\n      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n    }, Fn.prototype.toArrayBuffer = function () {\n      if (this.arrayBuffer) return this.arrayBuffer;\n      for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;\n      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n      for (var a = e, o = 0; o < t.length; o++) {\n        var s = t[o];\n        i[3 + o] = a, i.set(s, a), a += s.length;\n      }\n      return i[3 + t.length] = a, i.set(this.keys, a), i[3 + t.length + 1] = a += this.keys.length, i.set(this.bboxes, a), a += this.bboxes.length, i.buffer;\n    };\n    var Dn = o.ImageData,\n      Ln = o.ImageBitmap,\n      Rn = {};\n    function On(t, e, r) {\n      void 0 === r && (r = {}), Object.defineProperty(e, "_classRegistryKey", {\n        value: t,\n        writeable: !1\n      }), Rn[t] = {\n        klass: e,\n        omit: r.omit || [],\n        shallow: r.shallow || []\n      };\n    }\n    for (var Un in On("Object", Object), Vn.serialize = function (t, e) {\n      var r = t.toArrayBuffer();\n      return e && e.push(r), {\n        buffer: r\n      };\n    }, Vn.deserialize = function (t) {\n      return new Vn(t.buffer);\n    }, On("Grid", Vn), On("Color", ee), On("Error", Error), On("ResolvedImage", ae), On("StylePropertyFunction", $r), On("StyleExpression", Gr, {\n      omit: ["_evaluator"]\n    }), On("ZoomDependentExpression", Hr), On("ZoomConstantExpression", Jr), On("CompoundExpression", be, {\n      omit: ["_evaluate"]\n    }), zr) zr[Un]._classRegistryKey || On("Expression_" + Un, zr[Un]);\n    function jn(t) {\n      return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name);\n    }\n    function qn(t) {\n      return Ln && t instanceof Ln;\n    }\n    function Nn(t, e) {\n      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (jn(t) || qn(t)) return e && e.push(t), t;\n      if (ArrayBuffer.isView(t)) {\n        var r = t;\n        return e && e.push(r.buffer), r;\n      }\n      if (t instanceof Dn) return e && e.push(t.data.buffer), t;\n      if (Array.isArray(t)) {\n        for (var n = [], i = 0, a = t; i < a.length; i += 1) n.push(Nn(a[i], e));\n        return n;\n      }\n      if ("object" == typeof t) {\n        var o = t.constructor,\n          s = o._classRegistryKey;\n        if (!s) throw new Error("can\'t serialize object of unregistered class");\n        var u = o.serialize ? o.serialize(t, e) : {};\n        if (!o.serialize) {\n          for (var l in t) if (t.hasOwnProperty(l) && !(Rn[s].omit.indexOf(l) >= 0)) {\n            var p = t[l];\n            u[l] = Rn[s].shallow.indexOf(l) >= 0 ? p : Nn(p, e);\n          }\n          t instanceof Error && (u.message = t.message);\n        }\n        if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");\n        return "Object" !== s && (u.$name = s), u;\n      }\n      throw new Error("can\'t serialize object of type " + typeof t);\n    }\n    function Kn(t) {\n      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || jn(t) || qn(t) || ArrayBuffer.isView(t) || t instanceof Dn) return t;\n      if (Array.isArray(t)) return t.map(Kn);\n      if ("object" == typeof t) {\n        var e = t.$name || "Object",\n          r = Rn[e].klass;\n        if (!r) throw new Error("can\'t deserialize unregistered class " + e);\n        if (r.deserialize) return r.deserialize(t);\n        for (var n = Object.create(r.prototype), i = 0, a = Object.keys(t); i < a.length; i += 1) {\n          var o = a[i];\n          if ("$name" !== o) {\n            var s = t[o];\n            n[o] = Rn[e].shallow.indexOf(o) >= 0 ? s : Kn(s);\n          }\n        }\n        return n;\n      }\n      throw new Error("can\'t deserialize object of type " + typeof t);\n    }\n    var Gn = function () {\n      this.first = !0;\n    };\n    Gn.prototype.update = function (t, e) {\n      var r = Math.floor(t);\n      return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));\n    };\n    var Zn = {\n      "Latin-1 Supplement": function (t) {\n        return t >= 128 && t <= 255;\n      },\n      Arabic: function (t) {\n        return t >= 1536 && t <= 1791;\n      },\n      "Arabic Supplement": function (t) {\n        return t >= 1872 && t <= 1919;\n      },\n      "Arabic Extended-A": function (t) {\n        return t >= 2208 && t <= 2303;\n      },\n      "Hangul Jamo": function (t) {\n        return t >= 4352 && t <= 4607;\n      },\n      "Unified Canadian Aboriginal Syllabics": function (t) {\n        return t >= 5120 && t <= 5759;\n      },\n      Khmer: function (t) {\n        return t >= 6016 && t <= 6143;\n      },\n      "Unified Canadian Aboriginal Syllabics Extended": function (t) {\n        return t >= 6320 && t <= 6399;\n      },\n      "General Punctuation": function (t) {\n        return t >= 8192 && t <= 8303;\n      },\n      "Letterlike Symbols": function (t) {\n        return t >= 8448 && t <= 8527;\n      },\n      "Number Forms": function (t) {\n        return t >= 8528 && t <= 8591;\n      },\n      "Miscellaneous Technical": function (t) {\n        return t >= 8960 && t <= 9215;\n      },\n      "Control Pictures": function (t) {\n        return t >= 9216 && t <= 9279;\n      },\n      "Optical Character Recognition": function (t) {\n        return t >= 9280 && t <= 9311;\n      },\n      "Enclosed Alphanumerics": function (t) {\n        return t >= 9312 && t <= 9471;\n      },\n      "Geometric Shapes": function (t) {\n        return t >= 9632 && t <= 9727;\n      },\n      "Miscellaneous Symbols": function (t) {\n        return t >= 9728 && t <= 9983;\n      },\n      "Miscellaneous Symbols and Arrows": function (t) {\n        return t >= 11008 && t <= 11263;\n      },\n      "CJK Radicals Supplement": function (t) {\n        return t >= 11904 && t <= 12031;\n      },\n      "Kangxi Radicals": function (t) {\n        return t >= 12032 && t <= 12255;\n      },\n      "Ideographic Description Characters": function (t) {\n        return t >= 12272 && t <= 12287;\n      },\n      "CJK Symbols and Punctuation": function (t) {\n        return t >= 12288 && t <= 12351;\n      },\n      Hiragana: function (t) {\n        return t >= 12352 && t <= 12447;\n      },\n      Katakana: function (t) {\n        return t >= 12448 && t <= 12543;\n      },\n      Bopomofo: function (t) {\n        return t >= 12544 && t <= 12591;\n      },\n      "Hangul Compatibility Jamo": function (t) {\n        return t >= 12592 && t <= 12687;\n      },\n      Kanbun: function (t) {\n        return t >= 12688 && t <= 12703;\n      },\n      "Bopomofo Extended": function (t) {\n        return t >= 12704 && t <= 12735;\n      },\n      "CJK Strokes": function (t) {\n        return t >= 12736 && t <= 12783;\n      },\n      "Katakana Phonetic Extensions": function (t) {\n        return t >= 12784 && t <= 12799;\n      },\n      "Enclosed CJK Letters and Months": function (t) {\n        return t >= 12800 && t <= 13055;\n      },\n      "CJK Compatibility": function (t) {\n        return t >= 13056 && t <= 13311;\n      },\n      "CJK Unified Ideographs Extension A": function (t) {\n        return t >= 13312 && t <= 19903;\n      },\n      "Yijing Hexagram Symbols": function (t) {\n        return t >= 19904 && t <= 19967;\n      },\n      "CJK Unified Ideographs": function (t) {\n        return t >= 19968 && t <= 40959;\n      },\n      "Yi Syllables": function (t) {\n        return t >= 40960 && t <= 42127;\n      },\n      "Yi Radicals": function (t) {\n        return t >= 42128 && t <= 42191;\n      },\n      "Hangul Jamo Extended-A": function (t) {\n        return t >= 43360 && t <= 43391;\n      },\n      "Hangul Syllables": function (t) {\n        return t >= 44032 && t <= 55215;\n      },\n      "Hangul Jamo Extended-B": function (t) {\n        return t >= 55216 && t <= 55295;\n      },\n      "Private Use Area": function (t) {\n        return t >= 57344 && t <= 63743;\n      },\n      "CJK Compatibility Ideographs": function (t) {\n        return t >= 63744 && t <= 64255;\n      },\n      "Arabic Presentation Forms-A": function (t) {\n        return t >= 64336 && t <= 65023;\n      },\n      "Vertical Forms": function (t) {\n        return t >= 65040 && t <= 65055;\n      },\n      "CJK Compatibility Forms": function (t) {\n        return t >= 65072 && t <= 65103;\n      },\n      "Small Form Variants": function (t) {\n        return t >= 65104 && t <= 65135;\n      },\n      "Arabic Presentation Forms-B": function (t) {\n        return t >= 65136 && t <= 65279;\n      },\n      "Halfwidth and Fullwidth Forms": function (t) {\n        return t >= 65280 && t <= 65519;\n      }\n    };\n    function Xn(t) {\n      for (var e = 0, r = t; e < r.length; e += 1) if (Jn(r[e].charCodeAt(0))) return !0;\n      return !1;\n    }\n    function Jn(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(Zn["Bopomofo Extended"](t) || Zn.Bopomofo(t) || Zn["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || Zn["CJK Compatibility Ideographs"](t) || Zn["CJK Compatibility"](t) || Zn["CJK Radicals Supplement"](t) || Zn["CJK Strokes"](t) || !(!Zn["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Zn["CJK Unified Ideographs Extension A"](t) || Zn["CJK Unified Ideographs"](t) || Zn["Enclosed CJK Letters and Months"](t) || Zn["Hangul Compatibility Jamo"](t) || Zn["Hangul Jamo Extended-A"](t) || Zn["Hangul Jamo Extended-B"](t) || Zn["Hangul Jamo"](t) || Zn["Hangul Syllables"](t) || Zn.Hiragana(t) || Zn["Ideographic Description Characters"](t) || Zn.Kanbun(t) || Zn["Kangxi Radicals"](t) || Zn["Katakana Phonetic Extensions"](t) || Zn.Katakana(t) && 12540 !== t || !(!Zn["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Zn["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Zn["Unified Canadian Aboriginal Syllabics"](t) || Zn["Unified Canadian Aboriginal Syllabics Extended"](t) || Zn["Vertical Forms"](t) || Zn["Yijing Hexagram Symbols"](t) || Zn["Yi Syllables"](t) || Zn["Yi Radicals"](t))));\n    }\n    function Hn(t) {\n      return !(Jn(t) || function (t) {\n        return !!(Zn["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Zn["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Zn["Letterlike Symbols"](t) || Zn["Number Forms"](t) || Zn["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Zn["Control Pictures"](t) && 9251 !== t || Zn["Optical Character Recognition"](t) || Zn["Enclosed Alphanumerics"](t) || Zn["Geometric Shapes"](t) || Zn["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Zn["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Zn["CJK Symbols and Punctuation"](t) || Zn.Katakana(t) || Zn["Private Use Area"](t) || Zn["CJK Compatibility Forms"](t) || Zn["Small Form Variants"](t) || Zn["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n    function Yn(t) {\n      return t >= 1424 && t <= 2303 || Zn["Arabic Presentation Forms-A"](t) || Zn["Arabic Presentation Forms-B"](t);\n    }\n    function $n(t, e) {\n      return !(!e && Yn(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Zn.Khmer(t));\n    }\n    function Wn(t) {\n      for (var e = 0, r = t; e < r.length; e += 1) if (Yn(r[e].charCodeAt(0))) return !0;\n      return !1;\n    }\n    var Qn = null,\n      ti = "unavailable",\n      ei = null,\n      ri = function (t) {\n        t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (ti = "error"), Qn && Qn(t);\n      };\n    function ni() {\n      ii.fire(new zt("pluginStateChange", {\n        pluginStatus: ti,\n        pluginURL: ei\n      }));\n    }\n    var ii = new Et(),\n      ai = function () {\n        return ti;\n      },\n      oi = function () {\n        if ("deferred" !== ti || !ei) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");\n        ti = "loading", ni(), ei && wt({\n          url: ei\n        }, function (t) {\n          t ? ri(t) : (ti = "loaded", ni());\n        });\n      },\n      si = {\n        applyArabicShaping: null,\n        processBidirectionalText: null,\n        processStyledBidirectionalText: null,\n        isLoaded: function () {\n          return "loaded" === ti || null != si.applyArabicShaping;\n        },\n        isLoading: function () {\n          return "loading" === ti;\n        },\n        setState: function (t) {\n          ti = t.pluginStatus, ei = t.pluginURL;\n        },\n        isParsed: function () {\n          return null != si.applyArabicShaping && null != si.processBidirectionalText && null != si.processStyledBidirectionalText;\n        },\n        getPluginURL: function () {\n          return ei;\n        }\n      },\n      ui = function (t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Gn(), this.transition = {});\n      };\n    ui.prototype.isSupportedScript = function (t) {\n      return function (t, e) {\n        for (var r = 0, n = t; r < n.length; r += 1) if (!$n(n[r].charCodeAt(0), e)) return !1;\n        return !0;\n      }(t, si.isLoaded());\n    }, ui.prototype.crossFadingFactor = function () {\n      return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n    }, ui.prototype.getCrossfadeParameters = function () {\n      var t = this.zoom,\n        e = t - Math.floor(t),\n        r = this.crossFadingFactor();\n      return t > this.zoomHistory.lastIntegerZoom ? {\n        fromScale: 2,\n        toScale: 1,\n        t: e + (1 - e) * r\n      } : {\n        fromScale: .5,\n        toScale: 1,\n        t: 1 - (1 - r) * e\n      };\n    };\n    var li = function (t, e) {\n      this.property = t, this.value = e, this.expression = function (t, e) {\n        if (Rr(t)) return new $r(t, e);\n        if (Zr(t)) {\n          var r = Yr(t, e);\n          if ("error" === r.result) throw new Error(r.value.map(function (t) {\n            return t.key + ": " + t.message;\n          }).join(", "));\n          return r.value;\n        }\n        var n = t;\n        return "string" == typeof t && "color" === e.type && (n = ee.parse(t)), {\n          kind: "constant",\n          evaluate: function () {\n            return n;\n          }\n        };\n      }(void 0 === e ? t.specification.default : e, t.specification);\n    };\n    li.prototype.isDataDriven = function () {\n      return "source" === this.expression.kind || "composite" === this.expression.kind;\n    }, li.prototype.possiblyEvaluate = function (t, e, r) {\n      return this.property.possiblyEvaluate(this, t, e, r);\n    };\n    var pi = function (t) {\n      this.property = t, this.value = new li(t, void 0);\n    };\n    pi.prototype.transitioned = function (t, e) {\n      return new hi(this.property, this.value, e, h({}, t.transition, this.transition), t.now);\n    }, pi.prototype.untransitioned = function () {\n      return new hi(this.property, this.value, null, {}, 0);\n    };\n    var ci = function (t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n    };\n    ci.prototype.getValue = function (t) {\n      return w(this._values[t].value.value);\n    }, ci.prototype.setValue = function (t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new pi(this._values[t].property)), this._values[t].value = new li(this._values[t].property, null === e ? void 0 : w(e));\n    }, ci.prototype.getTransition = function (t) {\n      return w(this._values[t].transition);\n    }, ci.prototype.setTransition = function (t, e) {\n      this._values.hasOwnProperty(t) || (this._values[t] = new pi(this._values[t].property)), this._values[t].transition = w(e) || void 0;\n    }, ci.prototype.serialize = function () {\n      for (var t = {}, e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e],\n          i = this.getValue(n);\n        void 0 !== i && (t[n] = i);\n        var a = this.getTransition(n);\n        void 0 !== a && (t[n + "-transition"] = a);\n      }\n      return t;\n    }, ci.prototype.transitioned = function (t, e) {\n      for (var r = new fi(this._properties), n = 0, i = Object.keys(this._values); n < i.length; n += 1) {\n        var a = i[n];\n        r._values[a] = this._values[a].transitioned(t, e._values[a]);\n      }\n      return r;\n    }, ci.prototype.untransitioned = function () {\n      for (var t = new fi(this._properties), e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e];\n        t._values[n] = this._values[n].untransitioned();\n      }\n      return t;\n    };\n    var hi = function (t, e, r, n, i) {\n      this.property = t, this.value = e, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n    };\n    hi.prototype.possiblyEvaluate = function (t, e, r) {\n      var n = t.now || 0,\n        i = this.value.possiblyEvaluate(t, e, r),\n        a = this.prior;\n      if (a) {\n        if (n > this.end) return this.prior = null, i;\n        if (this.value.isDataDriven()) return this.prior = null, i;\n        if (n < this.begin) return a.possiblyEvaluate(t, e, r);\n        var o = (n - this.begin) / (this.end - this.begin);\n        return this.property.interpolate(a.possiblyEvaluate(t, e, r), i, function (t) {\n          if (t <= 0) return 0;\n          if (t >= 1) return 1;\n          var e = t * t,\n            r = e * t;\n          return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n        }(o));\n      }\n      return i;\n    };\n    var fi = function (t) {\n      this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n    };\n    fi.prototype.possiblyEvaluate = function (t, e, r) {\n      for (var n = new mi(this._properties), i = 0, a = Object.keys(this._values); i < a.length; i += 1) {\n        var o = a[i];\n        n._values[o] = this._values[o].possiblyEvaluate(t, e, r);\n      }\n      return n;\n    }, fi.prototype.hasTransition = function () {\n      for (var t = 0, e = Object.keys(this._values); t < e.length; t += 1) if (this._values[e[t]].prior) return !0;\n      return !1;\n    };\n    var yi = function (t) {\n      this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n    };\n    yi.prototype.getValue = function (t) {\n      return w(this._values[t].value);\n    }, yi.prototype.setValue = function (t, e) {\n      this._values[t] = new li(this._values[t].property, null === e ? void 0 : w(e));\n    }, yi.prototype.serialize = function () {\n      for (var t = {}, e = 0, r = Object.keys(this._values); e < r.length; e += 1) {\n        var n = r[e],\n          i = this.getValue(n);\n        void 0 !== i && (t[n] = i);\n      }\n      return t;\n    }, yi.prototype.possiblyEvaluate = function (t, e, r) {\n      for (var n = new mi(this._properties), i = 0, a = Object.keys(this._values); i < a.length; i += 1) {\n        var o = a[i];\n        n._values[o] = this._values[o].possiblyEvaluate(t, e, r);\n      }\n      return n;\n    };\n    var di = function (t, e, r) {\n      this.property = t, this.value = e, this.parameters = r;\n    };\n    di.prototype.isConstant = function () {\n      return "constant" === this.value.kind;\n    }, di.prototype.constantOr = function (t) {\n      return "constant" === this.value.kind ? this.value.value : t;\n    }, di.prototype.evaluate = function (t, e, r, n) {\n      return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n    };\n    var mi = function (t) {\n      this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n    };\n    mi.prototype.get = function (t) {\n      return this._values[t];\n    };\n    var vi = function (t) {\n      this.specification = t;\n    };\n    vi.prototype.possiblyEvaluate = function (t, e) {\n      return t.expression.evaluate(e);\n    }, vi.prototype.interpolate = function (t, e, r) {\n      var n = Ze[this.specification.type];\n      return n ? n(t, e, r) : t;\n    };\n    var gi = function (t, e) {\n      this.specification = t, this.overrides = e;\n    };\n    gi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      return new di(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? {\n        kind: "constant",\n        value: t.expression.evaluate(e, null, {}, r, n)\n      } : t.expression, e);\n    }, gi.prototype.interpolate = function (t, e, r) {\n      if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;\n      if (void 0 === t.value.value || void 0 === e.value.value) return new di(this, {\n        kind: "constant",\n        value: void 0\n      }, t.parameters);\n      var n = Ze[this.specification.type];\n      return n ? new di(this, {\n        kind: "constant",\n        value: n(t.value.value, e.value.value, r)\n      }, t.parameters) : t;\n    }, gi.prototype.evaluate = function (t, e, r, n, i, a) {\n      return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, a);\n    };\n    var xi = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (t, e, r, n) {\n          if (void 0 === t.value) return new di(this, {\n            kind: "constant",\n            value: void 0\n          }, e);\n          if ("constant" === t.expression.kind) {\n            var i = t.expression.evaluate(e, null, {}, r, n),\n              a = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i,\n              o = this._calculate(a, a, a, e);\n            return new di(this, {\n              kind: "constant",\n              value: o\n            }, e);\n          }\n          if ("camera" === t.expression.kind) {\n            var s = this._calculate(t.expression.evaluate({\n              zoom: e.zoom - 1\n            }), t.expression.evaluate({\n              zoom: e.zoom\n            }), t.expression.evaluate({\n              zoom: e.zoom + 1\n            }), e);\n            return new di(this, {\n              kind: "constant",\n              value: s\n            }, e);\n          }\n          return new di(this, t.expression, e);\n        }, e.prototype.evaluate = function (t, e, r, n, i, a) {\n          if ("source" === t.kind) {\n            var o = t.evaluate(e, r, n, i, a);\n            return this._calculate(o, o, o, e);\n          }\n          return "composite" === t.kind ? this._calculate(t.evaluate({\n            zoom: Math.floor(e.zoom) - 1\n          }, r, n), t.evaluate({\n            zoom: Math.floor(e.zoom)\n          }, r, n), t.evaluate({\n            zoom: Math.floor(e.zoom) + 1\n          }, r, n), e) : t.value;\n        }, e.prototype._calculate = function (t, e, r, n) {\n          return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n            from: t,\n            to: e\n          } : {\n            from: r,\n            to: e\n          };\n        }, e.prototype.interpolate = function (t) {\n          return t;\n        }, e;\n      }(gi),\n      bi = function (t) {\n        this.specification = t;\n      };\n    bi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      if (void 0 !== t.value) {\n        if ("constant" === t.expression.kind) {\n          var i = t.expression.evaluate(e, null, {}, r, n);\n          return this._calculate(i, i, i, e);\n        }\n        return this._calculate(t.expression.evaluate(new ui(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new ui(Math.floor(e.zoom), e)), t.expression.evaluate(new ui(Math.floor(e.zoom + 1), e)), e);\n      }\n    }, bi.prototype._calculate = function (t, e, r, n) {\n      return n.zoom > n.zoomHistory.lastIntegerZoom ? {\n        from: t,\n        to: e\n      } : {\n        from: r,\n        to: e\n      };\n    }, bi.prototype.interpolate = function (t) {\n      return t;\n    };\n    var wi = function (t) {\n      this.specification = t;\n    };\n    wi.prototype.possiblyEvaluate = function (t, e, r, n) {\n      return !!t.expression.evaluate(e, null, {}, r, n);\n    }, wi.prototype.interpolate = function () {\n      return !1;\n    };\n    var _i = function (t) {\n      for (var e in this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t) {\n        var r = t[e];\n        r.specification.overridable && this.overridableProperties.push(e);\n        var n = this.defaultPropertyValues[e] = new li(r, void 0),\n          i = this.defaultTransitionablePropertyValues[e] = new pi(r);\n        this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});\n      }\n    };\n    On("DataDrivenProperty", gi), On("DataConstantProperty", vi), On("CrossFadedDataDrivenProperty", xi), On("CrossFadedProperty", bi), On("ColorRampProperty", wi);\n    var Ai = function (t) {\n        function e(e, r) {\n          if (t.call(this), this.id = e.id, this.type = e.type, this._featureFilter = {\n            filter: function () {\n              return !0;\n            },\n            needGeometry: !1\n          }, "custom" !== e.type && (this.metadata = (e = e).metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), r.layout && (this._unevaluatedLayout = new yi(r.layout)), r.paint)) {\n            for (var n in this._transitionablePaint = new ci(r.paint), e.paint) this.setPaintProperty(n, e.paint[n], {\n              validate: !1\n            });\n            for (var i in e.layout) this.setLayoutProperty(i, e.layout[i], {\n              validate: !1\n            });\n            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(r.paint);\n          }\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getCrossfadeParameters = function () {\n          return this._crossfadeParameters;\n        }, e.prototype.getLayoutProperty = function (t) {\n          return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n        }, e.prototype.setLayoutProperty = function (t, e, r) {\n          void 0 === r && (r = {}), null != e && this._validate(Bn, "layers." + this.id + ".layout." + t, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n        }, e.prototype.getPaintProperty = function (t) {\n          return g(t, "-transition") ? this._transitionablePaint.getTransition(t.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t);\n        }, e.prototype.setPaintProperty = function (t, e, r) {\n          if (void 0 === r && (r = {}), null != e && this._validate(Mn, "layers." + this.id + ".paint." + t, t, e, r)) return !1;\n          if (g(t, "-transition")) return this._transitionablePaint.setTransition(t.slice(0, -"-transition".length), e || void 0), !1;\n          var n = this._transitionablePaint._values[t],\n            i = "cross-faded-data-driven" === n.property.specification["property-type"],\n            a = n.value.isDataDriven(),\n            o = n.value;\n          this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n          var s = this._transitionablePaint._values[t].value;\n          return s.isDataDriven() || a || i || this._handleOverridablePaintPropertyUpdate(t, o, s);\n        }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {}, e.prototype._handleOverridablePaintPropertyUpdate = function (t, e, r) {\n          return !1;\n        }, e.prototype.isHidden = function (t) {\n          return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;\n        }, e.prototype.updateTransitions = function (t) {\n          this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n        }, e.prototype.hasTransition = function () {\n          return this._transitioningPaint.hasTransition();\n        }, e.prototype.recalculate = function (t, e) {\n          t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n        }, e.prototype.serialize = function () {\n          var t = {\n            id: this.id,\n            type: this.type,\n            source: this.source,\n            "source-layer": this.sourceLayer,\n            metadata: this.metadata,\n            minzoom: this.minzoom,\n            maxzoom: this.maxzoom,\n            filter: this.filter,\n            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n            paint: this._transitionablePaint && this._transitionablePaint.serialize()\n          };\n          return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), b(t, function (t, e) {\n            return !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length);\n          });\n        }, e.prototype._validate = function (t, e, r, n, i) {\n          return void 0 === i && (i = {}), (!i || !1 !== i.validate) && Tn(this, t.call(En, {\n            key: e,\n            layerType: this.type,\n            objectKey: r,\n            value: n,\n            styleSpec: Pt,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            }\n          }));\n        }, e.prototype.is3D = function () {\n          return !1;\n        }, e.prototype.isTileClipped = function () {\n          return !1;\n        }, e.prototype.hasOffscreenPass = function () {\n          return !1;\n        }, e.prototype.resize = function () {}, e.prototype.isStateDependent = function () {\n          for (var t in this.paint._values) {\n            var e = this.paint.get(t);\n            if (e instanceof di && Vr(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;\n          }\n          return !1;\n        }, e;\n      }(Et),\n      Si = {\n        Int8: Int8Array,\n        Uint8: Uint8Array,\n        Int16: Int16Array,\n        Uint16: Uint16Array,\n        Int32: Int32Array,\n        Uint32: Uint32Array,\n        Float32: Float32Array\n      },\n      ki = function (t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      },\n      Ii = function () {\n        this.isTransferred = !1, this.capacity = -1, this.resize(0);\n      };\n    function zi(t, e) {\n      void 0 === e && (e = 1);\n      var r = 0,\n        n = 0;\n      return {\n        members: t.map(function (t) {\n          var i = Si[t.type].BYTES_PER_ELEMENT,\n            a = r = Ci(r, Math.max(e, i)),\n            o = t.components || 1;\n          return n = Math.max(n, i), r += i * o, {\n            name: t.name,\n            type: t.type,\n            components: o,\n            offset: a\n          };\n        }),\n        size: Ci(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n    function Ci(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n    Ii.serialize = function (t, e) {\n      return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n        length: t.length,\n        arrayBuffer: t.arrayBuffer\n      };\n    }, Ii.deserialize = function (t) {\n      var e = Object.create(this.prototype);\n      return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n    }, Ii.prototype._trim = function () {\n      this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n    }, Ii.prototype.clear = function () {\n      this.length = 0;\n    }, Ii.prototype.resize = function (t) {\n      this.reserve(t), this.length = t;\n    }, Ii.prototype.reserve = function (t) {\n      if (t > this.capacity) {\n        this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n        var e = this.uint8;\n        this._refreshViews(), e && this.uint8.set(e);\n      }\n    }, Ii.prototype._refreshViews = function () {\n      throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");\n    };\n    var Ei = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }, e;\n    }(Ii);\n    Ei.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", Ei);\n    var Pi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 4 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, t;\n      }, e;\n    }(Ii);\n    Pi.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Pi);\n    var Mi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 6 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, this.int16[s + 5] = o, t;\n      }, e;\n    }(Ii);\n    Mi.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", Mi);\n    var Bi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 4 * t,\n          u = 8 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = a, this.uint8[u + 7] = o, t;\n      }, e;\n    }(Ii);\n    Bi.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Bi);\n    var Ti = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }, e;\n    }(Ii);\n    Ti.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", Ti);\n    var Vi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l) {\n        var p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, a, o, s, u, l);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p) {\n        var c = 10 * t;\n        return this.uint16[c + 0] = e, this.uint16[c + 1] = r, this.uint16[c + 2] = n, this.uint16[c + 3] = i, this.uint16[c + 4] = a, this.uint16[c + 5] = o, this.uint16[c + 6] = s, this.uint16[c + 7] = u, this.uint16[c + 8] = l, this.uint16[c + 9] = p, t;\n      }, e;\n    }(Ii);\n    Vi.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Vi);\n    var Fi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c) {\n        var h = this.length;\n        return this.resize(h + 1), this.emplace(h, t, e, r, n, i, a, o, s, u, l, p, c);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h) {\n        var f = 12 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = a, this.uint16[f + 5] = o, this.uint16[f + 6] = s, this.uint16[f + 7] = u, this.int16[f + 8] = l, this.int16[f + 9] = p, this.int16[f + 10] = c, this.int16[f + 11] = h, t;\n      }, e;\n    }(Ii);\n    Fi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Fi);\n    var Di = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }, e;\n    }(Ii);\n    Di.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Di);\n    var Li = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }, e;\n    }(Ii);\n    Li.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Li);\n    var Ri = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u) {\n        var l = this.length;\n        return this.resize(l + 1), this.emplace(l, t, e, r, n, i, a, o, s, u);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l) {\n        var p = 10 * t,\n          c = 5 * t;\n        return this.int16[p + 0] = e, this.int16[p + 1] = r, this.int16[p + 2] = n, this.int16[p + 3] = i, this.int16[p + 4] = a, this.int16[p + 5] = o, this.uint32[c + 3] = s, this.uint16[p + 8] = u, this.uint16[p + 9] = l, t;\n      }, e;\n    }(Ii);\n    Ri.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Ri);\n    var Oi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a) {\n        var o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o) {\n        var s = 6 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, this.int16[s + 5] = o, t;\n      }, e;\n    }(Ii);\n    Oi.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Oi);\n    var Ui = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i) {\n        var a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }, e.prototype.emplace = function (t, e, r, n, i, a) {\n        var o = 4 * t,\n          s = 8 * t;\n        return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.int16[s + 6] = i, this.int16[s + 7] = a, t;\n      }, e;\n    }(Ii);\n    Ui.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Ui);\n    var ji = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 12 * t,\n          o = 3 * t;\n        return this.uint8[a + 0] = e, this.uint8[a + 1] = r, this.float32[o + 1] = n, this.float32[o + 2] = i, t;\n      }, e;\n    }(Ii);\n    ji.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", ji);\n    var qi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }, e;\n    }(Ii);\n    qi.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", qi);\n    var Ni = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m) {\n        var v = this.length;\n        return this.resize(v + 1), this.emplace(v, t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v) {\n        var g = 24 * t,\n          x = 12 * t,\n          b = 48 * t;\n        return this.int16[g + 0] = e, this.int16[g + 1] = r, this.uint16[g + 2] = n, this.uint16[g + 3] = i, this.uint32[x + 2] = a, this.uint32[x + 3] = o, this.uint32[x + 4] = s, this.uint16[g + 10] = u, this.uint16[g + 11] = l, this.uint16[g + 12] = p, this.float32[x + 7] = c, this.float32[x + 8] = h, this.uint8[b + 36] = f, this.uint8[b + 37] = y, this.uint8[b + 38] = d, this.uint32[x + 10] = m, this.int16[g + 22] = v, t;\n      }, e;\n    }(Ii);\n    Ni.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ni);\n    var Ki = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z) {\n        var C = this.length;\n        return this.resize(C + 1), this.emplace(C, t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z);\n      }, e.prototype.emplace = function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, A, S, k, I, z, C) {\n        var E = 34 * t,\n          P = 17 * t;\n        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.int16[E + 3] = i, this.int16[E + 4] = a, this.int16[E + 5] = o, this.int16[E + 6] = s, this.int16[E + 7] = u, this.uint16[E + 8] = l, this.uint16[E + 9] = p, this.uint16[E + 10] = c, this.uint16[E + 11] = h, this.uint16[E + 12] = f, this.uint16[E + 13] = y, this.uint16[E + 14] = d, this.uint16[E + 15] = m, this.uint16[E + 16] = v, this.uint16[E + 17] = g, this.uint16[E + 18] = x, this.uint16[E + 19] = b, this.uint16[E + 20] = w, this.uint16[E + 21] = _, this.uint16[E + 22] = A, this.uint32[P + 12] = S, this.float32[P + 13] = k, this.float32[P + 14] = I, this.float32[P + 15] = z, this.float32[P + 16] = C, t;\n      }, e;\n    }(Ii);\n    Ki.prototype.bytesPerElement = 68, On("StructArrayLayout8i15ui1ul4f68", Ki);\n    var Gi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }, e;\n    }(Ii);\n    Gi.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Gi);\n    var Zi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }, e;\n    }(Ii);\n    Zi.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Zi);\n    var Xi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r) {\n        var n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }, e.prototype.emplace = function (t, e, r, n) {\n        var i = 4 * t;\n        return this.uint32[2 * t + 0] = e, this.uint16[i + 2] = r, this.uint16[i + 3] = n, t;\n      }, e;\n    }(Ii);\n    Xi.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Xi);\n    var Ji = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e) {\n        var r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }, e.prototype.emplace = function (t, e, r) {\n        var n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }, e;\n    }(Ii);\n    Ji.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", Ji);\n    var Hi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t) {\n        var e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }, e.prototype.emplace = function (t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }, e;\n    }(Ii);\n    Hi.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", Hi);\n    var Yi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._refreshViews = function () {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }, e.prototype.emplaceBack = function (t, e, r, n) {\n        var i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }, e.prototype.emplace = function (t, e, r, n, i) {\n        var a = 4 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, t;\n      }, e;\n    }(Ii);\n    Yi.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Yi);\n    var $i = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorPointX: {\n          configurable: !0\n        },\n        anchorPointY: {\n          configurable: !0\n        },\n        x1: {\n          configurable: !0\n        },\n        y1: {\n          configurable: !0\n        },\n        x2: {\n          configurable: !0\n        },\n        y2: {\n          configurable: !0\n        },\n        featureIndex: {\n          configurable: !0\n        },\n        sourceLayerIndex: {\n          configurable: !0\n        },\n        bucketIndex: {\n          configurable: !0\n        },\n        anchorPoint: {\n          configurable: !0\n        }\n      };\n      return r.anchorPointX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorPointY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.x1.get = function () {\n        return this._structArray.int16[this._pos2 + 2];\n      }, r.y1.get = function () {\n        return this._structArray.int16[this._pos2 + 3];\n      }, r.x2.get = function () {\n        return this._structArray.int16[this._pos2 + 4];\n      }, r.y2.get = function () {\n        return this._structArray.int16[this._pos2 + 5];\n      }, r.featureIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 3];\n      }, r.sourceLayerIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 8];\n      }, r.bucketIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 9];\n      }, r.anchorPoint.get = function () {\n        return new i(this.anchorPointX, this.anchorPointY);\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n    $i.prototype.size = 20;\n    var Wi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new $i(this, t);\n      }, e;\n    }(Ri);\n    On("CollisionBoxArray", Wi);\n    var Qi = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorX: {\n          configurable: !0\n        },\n        anchorY: {\n          configurable: !0\n        },\n        glyphStartIndex: {\n          configurable: !0\n        },\n        numGlyphs: {\n          configurable: !0\n        },\n        vertexStartIndex: {\n          configurable: !0\n        },\n        lineStartIndex: {\n          configurable: !0\n        },\n        lineLength: {\n          configurable: !0\n        },\n        segment: {\n          configurable: !0\n        },\n        lowerSize: {\n          configurable: !0\n        },\n        upperSize: {\n          configurable: !0\n        },\n        lineOffsetX: {\n          configurable: !0\n        },\n        lineOffsetY: {\n          configurable: !0\n        },\n        writingMode: {\n          configurable: !0\n        },\n        placedOrientation: {\n          configurable: !0\n        },\n        hidden: {\n          configurable: !0\n        },\n        crossTileID: {\n          configurable: !0\n        },\n        associatedIconIndex: {\n          configurable: !0\n        }\n      };\n      return r.anchorX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.glyphStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 2];\n      }, r.numGlyphs.get = function () {\n        return this._structArray.uint16[this._pos2 + 3];\n      }, r.vertexStartIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 2];\n      }, r.lineStartIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 3];\n      }, r.lineLength.get = function () {\n        return this._structArray.uint32[this._pos4 + 4];\n      }, r.segment.get = function () {\n        return this._structArray.uint16[this._pos2 + 10];\n      }, r.lowerSize.get = function () {\n        return this._structArray.uint16[this._pos2 + 11];\n      }, r.upperSize.get = function () {\n        return this._structArray.uint16[this._pos2 + 12];\n      }, r.lineOffsetX.get = function () {\n        return this._structArray.float32[this._pos4 + 7];\n      }, r.lineOffsetY.get = function () {\n        return this._structArray.float32[this._pos4 + 8];\n      }, r.writingMode.get = function () {\n        return this._structArray.uint8[this._pos1 + 36];\n      }, r.placedOrientation.get = function () {\n        return this._structArray.uint8[this._pos1 + 37];\n      }, r.placedOrientation.set = function (t) {\n        this._structArray.uint8[this._pos1 + 37] = t;\n      }, r.hidden.get = function () {\n        return this._structArray.uint8[this._pos1 + 38];\n      }, r.hidden.set = function (t) {\n        this._structArray.uint8[this._pos1 + 38] = t;\n      }, r.crossTileID.get = function () {\n        return this._structArray.uint32[this._pos4 + 10];\n      }, r.crossTileID.set = function (t) {\n        this._structArray.uint32[this._pos4 + 10] = t;\n      }, r.associatedIconIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 22];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n    Qi.prototype.size = 48;\n    var ta = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new Qi(this, t);\n      }, e;\n    }(Ni);\n    On("PlacedSymbolArray", ta);\n    var ea = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        anchorX: {\n          configurable: !0\n        },\n        anchorY: {\n          configurable: !0\n        },\n        rightJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        centerJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        leftJustifiedTextSymbolIndex: {\n          configurable: !0\n        },\n        verticalPlacedTextSymbolIndex: {\n          configurable: !0\n        },\n        placedIconSymbolIndex: {\n          configurable: !0\n        },\n        verticalPlacedIconSymbolIndex: {\n          configurable: !0\n        },\n        key: {\n          configurable: !0\n        },\n        textBoxStartIndex: {\n          configurable: !0\n        },\n        textBoxEndIndex: {\n          configurable: !0\n        },\n        verticalTextBoxStartIndex: {\n          configurable: !0\n        },\n        verticalTextBoxEndIndex: {\n          configurable: !0\n        },\n        iconBoxStartIndex: {\n          configurable: !0\n        },\n        iconBoxEndIndex: {\n          configurable: !0\n        },\n        verticalIconBoxStartIndex: {\n          configurable: !0\n        },\n        verticalIconBoxEndIndex: {\n          configurable: !0\n        },\n        featureIndex: {\n          configurable: !0\n        },\n        numHorizontalGlyphVertices: {\n          configurable: !0\n        },\n        numVerticalGlyphVertices: {\n          configurable: !0\n        },\n        numIconVertices: {\n          configurable: !0\n        },\n        numVerticalIconVertices: {\n          configurable: !0\n        },\n        useRuntimeCollisionCircles: {\n          configurable: !0\n        },\n        crossTileID: {\n          configurable: !0\n        },\n        textBoxScale: {\n          configurable: !0\n        },\n        textOffset0: {\n          configurable: !0\n        },\n        textOffset1: {\n          configurable: !0\n        },\n        collisionCircleDiameter: {\n          configurable: !0\n        }\n      };\n      return r.anchorX.get = function () {\n        return this._structArray.int16[this._pos2 + 0];\n      }, r.anchorY.get = function () {\n        return this._structArray.int16[this._pos2 + 1];\n      }, r.rightJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 2];\n      }, r.centerJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 3];\n      }, r.leftJustifiedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 4];\n      }, r.verticalPlacedTextSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 5];\n      }, r.placedIconSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 6];\n      }, r.verticalPlacedIconSymbolIndex.get = function () {\n        return this._structArray.int16[this._pos2 + 7];\n      }, r.key.get = function () {\n        return this._structArray.uint16[this._pos2 + 8];\n      }, r.textBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 9];\n      }, r.textBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 10];\n      }, r.verticalTextBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 11];\n      }, r.verticalTextBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 12];\n      }, r.iconBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 13];\n      }, r.iconBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 14];\n      }, r.verticalIconBoxStartIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 15];\n      }, r.verticalIconBoxEndIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 16];\n      }, r.featureIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 17];\n      }, r.numHorizontalGlyphVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 18];\n      }, r.numVerticalGlyphVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 19];\n      }, r.numIconVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 20];\n      }, r.numVerticalIconVertices.get = function () {\n        return this._structArray.uint16[this._pos2 + 21];\n      }, r.useRuntimeCollisionCircles.get = function () {\n        return this._structArray.uint16[this._pos2 + 22];\n      }, r.crossTileID.get = function () {\n        return this._structArray.uint32[this._pos4 + 12];\n      }, r.crossTileID.set = function (t) {\n        this._structArray.uint32[this._pos4 + 12] = t;\n      }, r.textBoxScale.get = function () {\n        return this._structArray.float32[this._pos4 + 13];\n      }, r.textOffset0.get = function () {\n        return this._structArray.float32[this._pos4 + 14];\n      }, r.textOffset1.get = function () {\n        return this._structArray.float32[this._pos4 + 15];\n      }, r.collisionCircleDiameter.get = function () {\n        return this._structArray.float32[this._pos4 + 16];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n    ea.prototype.size = 68;\n    var ra = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new ea(this, t);\n      }, e;\n    }(Ki);\n    On("SymbolInstanceArray", ra);\n    var na = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getoffsetX = function (t) {\n        return this.float32[1 * t + 0];\n      }, e;\n    }(Gi);\n    On("GlyphOffsetArray", na);\n    var ia = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getx = function (t) {\n        return this.int16[3 * t + 0];\n      }, e.prototype.gety = function (t) {\n        return this.int16[3 * t + 1];\n      }, e.prototype.gettileUnitDistanceFromAnchor = function (t) {\n        return this.int16[3 * t + 2];\n      }, e;\n    }(Zi);\n    On("SymbolLineVertexArray", ia);\n    var aa = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n      var r = {\n        featureIndex: {\n          configurable: !0\n        },\n        sourceLayerIndex: {\n          configurable: !0\n        },\n        bucketIndex: {\n          configurable: !0\n        }\n      };\n      return r.featureIndex.get = function () {\n        return this._structArray.uint32[this._pos4 + 0];\n      }, r.sourceLayerIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 2];\n      }, r.bucketIndex.get = function () {\n        return this._structArray.uint16[this._pos2 + 3];\n      }, Object.defineProperties(e.prototype, r), e;\n    }(ki);\n    aa.prototype.size = 8;\n    var oa = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.get = function (t) {\n        return new aa(this, t);\n      }, e;\n    }(Xi);\n    On("FeatureIndexArray", oa);\n    var sa = zi([{\n        name: "a_pos",\n        components: 2,\n        type: "Int16"\n      }], 4).members,\n      ua = function (t) {\n        void 0 === t && (t = []), this.segments = t;\n      };\n    function la(t, e) {\n      return 256 * (t = p(Math.floor(t), 0, 255)) + p(Math.floor(e), 0, 255);\n    }\n    ua.prototype.prepareSegment = function (t, e, r, n) {\n      var i = this.segments[this.segments.length - 1];\n      return t > ua.MAX_VERTEX_ARRAY_LENGTH && A("Max vertices per segment is " + ua.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t), (!i || i.vertexLength + t > ua.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n        vertexOffset: e.length,\n        primitiveOffset: r.length,\n        vertexLength: 0,\n        primitiveLength: 0\n      }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n    }, ua.prototype.get = function () {\n      return this.segments;\n    }, ua.prototype.destroy = function () {\n      for (var t = 0, e = this.segments; t < e.length; t += 1) {\n        var r = e[t];\n        for (var n in r.vaos) r.vaos[n].destroy();\n      }\n    }, ua.simpleSegment = function (t, e, r, n) {\n      return new ua([{\n        vertexOffset: t,\n        primitiveOffset: e,\n        vertexLength: r,\n        primitiveLength: n,\n        vaos: {},\n        sortKey: 0\n      }]);\n    }, ua.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", ua);\n    var pa = zi([{\n        name: "a_pattern_from",\n        components: 4,\n        type: "Uint16"\n      }, {\n        name: "a_pattern_to",\n        components: 4,\n        type: "Uint16"\n      }, {\n        name: "a_pixel_ratio_from",\n        components: 1,\n        type: "Uint16"\n      }, {\n        name: "a_pixel_ratio_to",\n        components: 1,\n        type: "Uint16"\n      }]),\n      ca = e(function (t) {\n        t.exports = function (t, e) {\n          var r, n, i, a, o, s, u, l;\n          for (n = t.length - (r = 3 & t.length), i = e, o = 3432918353, s = 461845907, l = 0; l < n;) u = 255 & t.charCodeAt(l) | (255 & t.charCodeAt(++l)) << 8 | (255 & t.charCodeAt(++l)) << 16 | (255 & t.charCodeAt(++l)) << 24, ++l, i = 27492 + (65535 & (a = 5 * (65535 & (i = (i ^= u = (65535 & (u = (u = (65535 & u) * o + (((u >>> 16) * o & 65535) << 16) & 4294967295) << 15 | u >>> 17)) * s + (((u >>> 16) * s & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16);\n          switch (u = 0, r) {\n            case 3:\n              u ^= (255 & t.charCodeAt(l + 2)) << 16;\n            case 2:\n              u ^= (255 & t.charCodeAt(l + 1)) << 8;\n            case 1:\n              i ^= u = (65535 & (u = (u = (65535 & (u ^= 255 & t.charCodeAt(l))) * o + (((u >>> 16) * o & 65535) << 16) & 4294967295) << 15 | u >>> 17)) * s + (((u >>> 16) * s & 65535) << 16) & 4294967295;\n          }\n          return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n        };\n      }),\n      ha = e(function (t) {\n        t.exports = function (t, e) {\n          for (var r, n = t.length, i = e ^ n, a = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(a) | (255 & t.charCodeAt(++a)) << 8 | (255 & t.charCodeAt(++a)) << 16 | (255 & t.charCodeAt(++a)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++a;\n          switch (n) {\n            case 3:\n              i ^= (255 & t.charCodeAt(a + 2)) << 16;\n            case 2:\n              i ^= (255 & t.charCodeAt(a + 1)) << 8;\n            case 1:\n              i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(a))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n          }\n          return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n        };\n      }),\n      fa = ca,\n      ya = ha;\n    fa.murmur3 = ca, fa.murmur2 = ya;\n    var da = function () {\n      this.ids = [], this.positions = [], this.indexed = !1;\n    };\n    da.prototype.add = function (t, e, r, n) {\n      this.ids.push(va(t)), this.positions.push(e, r, n);\n    }, da.prototype.getPositions = function (t) {\n      for (var e = va(t), r = 0, n = this.ids.length - 1; r < n;) {\n        var i = r + n >> 1;\n        this.ids[i] >= e ? n = i : r = i + 1;\n      }\n      for (var a = []; this.ids[r] === e;) a.push({\n        index: this.positions[3 * r],\n        start: this.positions[3 * r + 1],\n        end: this.positions[3 * r + 2]\n      }), r++;\n      return a;\n    }, da.serialize = function (t, e) {\n      var r = new Float64Array(t.ids),\n        n = new Uint32Array(t.positions);\n      return function t(e, r, n, i) {\n        for (; n < i;) {\n          for (var a = e[n + i >> 1], o = n - 1, s = i + 1;;) {\n            do {\n              o++;\n            } while (e[o] < a);\n            do {\n              s--;\n            } while (e[s] > a);\n            if (o >= s) break;\n            ga(e, o, s), ga(r, 3 * o, 3 * s), ga(r, 3 * o + 1, 3 * s + 1), ga(r, 3 * o + 2, 3 * s + 2);\n          }\n          s - n < i - s ? (t(e, r, n, s), n = s + 1) : (t(e, r, s + 1, i), i = s);\n        }\n      }(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n        ids: r,\n        positions: n\n      };\n    }, da.deserialize = function (t) {\n      var e = new da();\n      return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n    };\n    var ma = Math.pow(2, 53) - 1;\n    function va(t) {\n      var e = +t;\n      return !isNaN(e) && e <= ma ? e : fa(String(t));\n    }\n    function ga(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    On("FeaturePositionMap", da);\n    var xa = function (t, e) {\n        this.gl = t.gl, this.location = e;\n      },\n      ba = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = 0;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t));\n        }, e;\n      }(xa),\n      wa = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = 0;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));\n        }, e;\n      }(xa),\n      _a = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = [0, 0];\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1]));\n        }, e;\n      }(xa),\n      Aa = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = [0, 0, 0];\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2]));\n        }, e;\n      }(xa),\n      Sa = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = [0, 0, 0, 0];\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));\n        }, e;\n      }(xa),\n      ka = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = ee.transparent;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));\n        }, e;\n      }(xa),\n      Ia = new Float32Array(16),\n      za = function (t) {\n        function e(e, r) {\n          t.call(this, e, r), this.current = Ia;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t);\n          for (var e = 1; e < 16; e++) if (t[e] !== this.current[e]) {\n            this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);\n            break;\n          }\n        }, e;\n      }(xa);\n    function Ca(t) {\n      return [la(255 * t.r, 255 * t.g), la(255 * t.b, 255 * t.a)];\n    }\n    var Ea = function (t, e, r) {\n      this.value = t, this.uniformNames = e.map(function (t) {\n        return "u_" + t;\n      }), this.type = r;\n    };\n    Ea.prototype.setUniform = function (t, e, r) {\n      t.set(r.constantOr(this.value));\n    }, Ea.prototype.getBinding = function (t, e, r) {\n      return "color" === this.type ? new ka(t, e) : new wa(t, e);\n    };\n    var Pa = function (t, e) {\n      this.uniformNames = e.map(function (t) {\n        return "u_" + t;\n      }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;\n    };\n    Pa.prototype.setConstantPatternPositions = function (t, e) {\n      this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr;\n    }, Pa.prototype.setUniform = function (t, e, r, n) {\n      var i = "u_pattern_to" === n ? this.patternTo : "u_pattern_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null;\n      i && t.set(i);\n    }, Pa.prototype.getBinding = function (t, e, r) {\n      return "u_pattern" === r.substr(0, 9) ? new Sa(t, e) : new wa(t, e);\n    };\n    var Ma = function (t, e, r, n) {\n      this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(function (t) {\n        return {\n          name: "a_" + t,\n          type: "Float32",\n          components: "color" === r ? 2 : 1,\n          offset: 0\n        };\n      }), this.paintVertexArray = new n();\n    };\n    Ma.prototype.populatePaintArray = function (t, e, r, n, i) {\n      var a = this.paintVertexArray.length,\n        o = this.expression.evaluate(new ui(0), e, {}, n, [], i);\n      this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);\n    }, Ma.prototype.updatePaintArray = function (t, e, r, n) {\n      var i = this.expression.evaluate({\n        zoom: 0\n      }, r, n);\n      this._setPaintValue(t, e, i);\n    }, Ma.prototype._setPaintValue = function (t, e, r) {\n      if ("color" === this.type) for (var n = Ca(r), i = t; i < e; i++) this.paintVertexArray.emplace(i, n[0], n[1]);else {\n        for (var a = t; a < e; a++) this.paintVertexArray.emplace(a, r);\n        this.maxValue = Math.max(this.maxValue, Math.abs(r));\n      }\n    }, Ma.prototype.upload = function (t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }, Ma.prototype.destroy = function () {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    };\n    var Ba = function (t, e, r, n, i, a) {\n      this.expression = t, this.uniformNames = e.map(function (t) {\n        return "u_" + t + "_t";\n      }), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(function (t) {\n        return {\n          name: "a_" + t,\n          type: "Float32",\n          components: "color" === r ? 4 : 2,\n          offset: 0\n        };\n      }), this.paintVertexArray = new a();\n    };\n    Ba.prototype.populatePaintArray = function (t, e, r, n, i) {\n      var a = this.expression.evaluate(new ui(this.zoom), e, {}, n, [], i),\n        o = this.expression.evaluate(new ui(this.zoom + 1), e, {}, n, [], i),\n        s = this.paintVertexArray.length;\n      this.paintVertexArray.resize(t), this._setPaintValue(s, t, a, o);\n    }, Ba.prototype.updatePaintArray = function (t, e, r, n) {\n      var i = this.expression.evaluate({\n          zoom: this.zoom\n        }, r, n),\n        a = this.expression.evaluate({\n          zoom: this.zoom + 1\n        }, r, n);\n      this._setPaintValue(t, e, i, a);\n    }, Ba.prototype._setPaintValue = function (t, e, r, n) {\n      if ("color" === this.type) for (var i = Ca(r), a = Ca(n), o = t; o < e; o++) this.paintVertexArray.emplace(o, i[0], i[1], a[0], a[1]);else {\n        for (var s = t; s < e; s++) this.paintVertexArray.emplace(s, r, n);\n        this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n      }\n    }, Ba.prototype.upload = function (t) {\n      this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n    }, Ba.prototype.destroy = function () {\n      this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n    }, Ba.prototype.setUniform = function (t, e) {\n      var r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,\n        n = p(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);\n      t.set(n);\n    }, Ba.prototype.getBinding = function (t, e, r) {\n      return new wa(t, e);\n    };\n    var Ta = function (t, e, r, n, i, a) {\n      this.expression = t, this.type = e, this.useIntegerZoom = r, this.zoom = n, this.layerId = a, this.zoomInPaintVertexArray = new i(), this.zoomOutPaintVertexArray = new i();\n    };\n    Ta.prototype.populatePaintArray = function (t, e, r) {\n      var n = this.zoomInPaintVertexArray.length;\n      this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n    }, Ta.prototype.updatePaintArray = function (t, e, r, n, i) {\n      this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], i);\n    }, Ta.prototype._setPaintValues = function (t, e, r, n) {\n      if (n && r) {\n        var i = n[r.min],\n          a = n[r.mid],\n          o = n[r.max];\n        if (i && a && o) for (var s = t; s < e; s++) this.zoomInPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], i.tl[0], i.tl[1], i.br[0], i.br[1], a.pixelRatio, i.pixelRatio), this.zoomOutPaintVertexArray.emplace(s, a.tl[0], a.tl[1], a.br[0], a.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], a.pixelRatio, o.pixelRatio);\n      }\n    }, Ta.prototype.upload = function (t) {\n      this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, pa.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, pa.members, this.expression.isStateDependent));\n    }, Ta.prototype.destroy = function () {\n      this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();\n    };\n    var Va = function (t, e, r) {\n      this.binders = {}, this._buffers = [];\n      var n = [];\n      for (var i in t.paint._values) if (r(i)) {\n        var a = t.paint.get(i);\n        if (a instanceof di && Vr(a.property.specification)) {\n          var o = Da(i, t.type),\n            s = a.value,\n            u = a.property.specification.type,\n            l = a.property.useIntegerZoom,\n            p = a.property.specification["property-type"],\n            c = "cross-faded" === p || "cross-faded-data-driven" === p;\n          if ("constant" === s.kind) this.binders[i] = c ? new Pa(s.value, o) : new Ea(s.value, o, u), n.push("/u_" + i);else if ("source" === s.kind || c) {\n            var h = La(i, u, "source");\n            this.binders[i] = c ? new Ta(s, u, l, e, h, t.id) : new Ma(s, o, u, h), n.push("/a_" + i);\n          } else {\n            var f = La(i, u, "composite");\n            this.binders[i] = new Ba(s, o, u, l, e, f), n.push("/z_" + i);\n          }\n        }\n      }\n      this.cacheKey = n.sort().join("");\n    };\n    Va.prototype.getMaxValue = function (t) {\n      var e = this.binders[t];\n      return e instanceof Ma || e instanceof Ba ? e.maxValue : 0;\n    }, Va.prototype.populatePaintArrays = function (t, e, r, n, i) {\n      for (var a in this.binders) {\n        var o = this.binders[a];\n        (o instanceof Ma || o instanceof Ba || o instanceof Ta) && o.populatePaintArray(t, e, r, n, i);\n      }\n    }, Va.prototype.setConstantPatternPositions = function (t, e) {\n      for (var r in this.binders) {\n        var n = this.binders[r];\n        n instanceof Pa && n.setConstantPatternPositions(t, e);\n      }\n    }, Va.prototype.updatePaintArrays = function (t, e, r, n, i) {\n      var a = !1;\n      for (var o in t) for (var s = 0, u = e.getPositions(o); s < u.length; s += 1) {\n        var l = u[s],\n          p = r.feature(l.index);\n        for (var c in this.binders) {\n          var h = this.binders[c];\n          if ((h instanceof Ma || h instanceof Ba || h instanceof Ta) && !0 === h.expression.isStateDependent) {\n            var f = n.paint.get(c);\n            h.expression = f.value, h.updatePaintArray(l.start, l.end, p, t[o], i), a = !0;\n          }\n        }\n      }\n      return a;\n    }, Va.prototype.defines = function () {\n      var t = [];\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        (r instanceof Ea || r instanceof Pa) && t.push.apply(t, r.uniformNames.map(function (t) {\n          return "#define HAS_UNIFORM_" + t;\n        }));\n      }\n      return t;\n    }, Va.prototype.getBinderAttributes = function () {\n      var t = [];\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        if (r instanceof Ma || r instanceof Ba) for (var n = 0; n < r.paintVertexAttributes.length; n++) t.push(r.paintVertexAttributes[n].name);else if (r instanceof Ta) for (var i = 0; i < pa.members.length; i++) t.push(pa.members[i].name);\n      }\n      return t;\n    }, Va.prototype.getBinderUniforms = function () {\n      var t = [];\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        if (r instanceof Ea || r instanceof Pa || r instanceof Ba) for (var n = 0, i = r.uniformNames; n < i.length; n += 1) t.push(i[n]);\n      }\n      return t;\n    }, Va.prototype.getPaintVertexBuffers = function () {\n      return this._buffers;\n    }, Va.prototype.getUniforms = function (t, e) {\n      var r = [];\n      for (var n in this.binders) {\n        var i = this.binders[n];\n        if (i instanceof Ea || i instanceof Pa || i instanceof Ba) for (var a = 0, o = i.uniformNames; a < o.length; a += 1) {\n          var s = o[a];\n          if (e[s]) {\n            var u = i.getBinding(t, e[s], s);\n            r.push({\n              name: s,\n              property: n,\n              binding: u\n            });\n          }\n        }\n      }\n      return r;\n    }, Va.prototype.setUniforms = function (t, e, r, n) {\n      for (var i = 0, a = e; i < a.length; i += 1) {\n        var o = a[i],\n          s = o.name,\n          u = o.property;\n        this.binders[u].setUniform(o.binding, n, r.get(u), s);\n      }\n    }, Va.prototype.updatePaintBuffers = function (t) {\n      for (var e in this._buffers = [], this.binders) {\n        var r = this.binders[e];\n        if (t && r instanceof Ta) {\n          var n = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;\n          n && this._buffers.push(n);\n        } else (r instanceof Ma || r instanceof Ba) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);\n      }\n    }, Va.prototype.upload = function (t) {\n      for (var e in this.binders) {\n        var r = this.binders[e];\n        (r instanceof Ma || r instanceof Ba || r instanceof Ta) && r.upload(t);\n      }\n      this.updatePaintBuffers();\n    }, Va.prototype.destroy = function () {\n      for (var t in this.binders) {\n        var e = this.binders[t];\n        (e instanceof Ma || e instanceof Ba || e instanceof Ta) && e.destroy();\n      }\n    };\n    var Fa = function (t, e, r) {\n      void 0 === r && (r = function () {\n        return !0;\n      }), this.programConfigurations = {};\n      for (var n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n];\n        this.programConfigurations[a.id] = new Va(a, e, r);\n      }\n      this.needsUpload = !1, this._featureMap = new da(), this._bufferOffset = 0;\n    };\n    function Da(t, e) {\n      return {\n        "text-opacity": ["opacity"],\n        "icon-opacity": ["opacity"],\n        "text-color": ["fill_color"],\n        "icon-color": ["fill_color"],\n        "text-halo-color": ["halo_color"],\n        "icon-halo-color": ["halo_color"],\n        "text-halo-blur": ["halo_blur"],\n        "icon-halo-blur": ["halo_blur"],\n        "text-halo-width": ["halo_width"],\n        "icon-halo-width": ["halo_width"],\n        "line-gap-width": ["gapwidth"],\n        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],\n        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],\n        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]\n      }[t] || [t.replace(e + "-", "").replace(/-/g, "_")];\n    }\n    function La(t, e, r) {\n      var n = {\n          color: {\n            source: Ti,\n            composite: Yi\n          },\n          number: {\n            source: Gi,\n            composite: Ti\n          }\n        },\n        i = function (t) {\n          return {\n            "line-pattern": {\n              source: Vi,\n              composite: Vi\n            },\n            "fill-pattern": {\n              source: Vi,\n              composite: Vi\n            },\n            "fill-extrusion-pattern": {\n              source: Vi,\n              composite: Vi\n            }\n          }[t];\n        }(t);\n      return i && i[r] || n[e][r];\n    }\n    Fa.prototype.populatePaintArrays = function (t, e, r, n, i, a) {\n      for (var o in this.programConfigurations) this.programConfigurations[o].populatePaintArrays(t, e, n, i, a);\n      void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n    }, Fa.prototype.updatePaintArrays = function (t, e, r, n) {\n      for (var i = 0, a = r; i < a.length; i += 1) {\n        var o = a[i];\n        this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, e, o, n) || this.needsUpload;\n      }\n    }, Fa.prototype.get = function (t) {\n      return this.programConfigurations[t];\n    }, Fa.prototype.upload = function (t) {\n      if (this.needsUpload) {\n        for (var e in this.programConfigurations) this.programConfigurations[e].upload(t);\n        this.needsUpload = !1;\n      }\n    }, Fa.prototype.destroy = function () {\n      for (var t in this.programConfigurations) this.programConfigurations[t].destroy();\n    }, On("ConstantBinder", Ea), On("CrossFadedConstantBinder", Pa), On("SourceExpressionBinder", Ma), On("CrossFadedCompositeBinder", Ta), On("CompositeExpressionBinder", Ba), On("ProgramConfiguration", Va, {\n      omit: ["_buffers"]\n    }), On("ProgramConfigurationSet", Fa);\n    var Ra = Math.pow(2, 14) - 1,\n      Oa = -Ra - 1;\n    function Ua(t) {\n      for (var e = 8192 / t.extent, r = t.loadGeometry(), n = 0; n < r.length; n++) for (var i = r[n], a = 0; a < i.length; a++) {\n        var o = i[a],\n          s = Math.round(o.x * e),\n          u = Math.round(o.y * e);\n        o.x = p(s, Oa, Ra), o.y = p(u, Oa, Ra), (s < o.x || s > o.x + 1 || u < o.y || u > o.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");\n      }\n      return r;\n    }\n    function ja(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? Ua(t) : []\n      };\n    }\n    function qa(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n    var Na = function (t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Ei(), this.indexArray = new qi(), this.segments = new ua(), this.programConfigurations = new Fa(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n    function Ka(t, e) {\n      for (var r = 0; r < t.length; r++) if (Qa(e, t[r])) return !0;\n      for (var n = 0; n < e.length; n++) if (Qa(t, e[n])) return !0;\n      return !!Ja(t, e);\n    }\n    function Ga(t, e, r) {\n      return !!Qa(t, e) || !!Ya(e, t, r);\n    }\n    function Za(t, e) {\n      if (1 === t.length) return Wa(e, t[0]);\n      for (var r = 0; r < e.length; r++) for (var n = e[r], i = 0; i < n.length; i++) if (Qa(t, n[i])) return !0;\n      for (var a = 0; a < t.length; a++) if (Wa(e, t[a])) return !0;\n      for (var o = 0; o < e.length; o++) if (Ja(t, e[o])) return !0;\n      return !1;\n    }\n    function Xa(t, e, r) {\n      if (t.length > 1) {\n        if (Ja(t, e)) return !0;\n        for (var n = 0; n < e.length; n++) if (Ya(e[n], t, r)) return !0;\n      }\n      for (var i = 0; i < t.length; i++) if (Ya(t[i], e, r)) return !0;\n      return !1;\n    }\n    function Ja(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n      for (var r = 0; r < t.length - 1; r++) for (var n = t[r], i = t[r + 1], a = 0; a < e.length - 1; a++) if (Ha(n, i, e[a], e[a + 1])) return !0;\n      return !1;\n    }\n    function Ha(t, e, r, n) {\n      return S(t, r, n) !== S(e, r, n) && S(t, e, r) !== S(t, e, n);\n    }\n    function Ya(t, e, r) {\n      var n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n      for (var i = 1; i < e.length; i++) if ($a(t, e[i - 1], e[i]) < n) return !0;\n      return !1;\n    }\n    function $a(t, e, r) {\n      var n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      var i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n    function Wa(t, e) {\n      for (var r, n, i, a = !1, o = 0; o < t.length; o++) for (var s = 0, u = (r = t[o]).length - 1; s < r.length; u = s++) (n = r[s]).y > e.y != (i = r[u]).y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (a = !a);\n      return a;\n    }\n    function Qa(t, e) {\n      for (var r = !1, n = 0, i = t.length - 1; n < t.length; i = n++) {\n        var a = t[n],\n          o = t[i];\n        a.y > e.y != o.y > e.y && e.x < (o.x - a.x) * (e.y - a.y) / (o.y - a.y) + a.x && (r = !r);\n      }\n      return r;\n    }\n    function to(t, e, r) {\n      var n = r[0],\n        i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      var a = S(t, e, r[0]);\n      return a !== S(t, e, r[1]) || a !== S(t, e, r[2]) || a !== S(t, e, r[3]);\n    }\n    function eo(t, e, r) {\n      var n = e.paint.get(t).value;\n      return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n    function ro(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n    function no(t, e, r, n, a) {\n      if (!e[0] && !e[1]) return t;\n      var o = i.convert(e)._mult(a);\n      "viewport" === r && o._rotate(-n);\n      for (var s = [], u = 0; u < t.length; u++) s.push(t[u].sub(o));\n      return s;\n    }\n    Na.prototype.populate = function (t, e, r) {\n      var n = this.layers[0],\n        i = [],\n        a = null,\n        o = !1;\n      "circle" === n.type && (o = !(a = n.layout.get("circle-sort-key")).isConstant());\n      for (var s = 0, u = t; s < u.length; s += 1) {\n        var l = u[s],\n          p = l.feature,\n          c = l.id,\n          h = l.index,\n          f = l.sourceLayerIndex,\n          y = this.layers[0]._featureFilter.needGeometry,\n          d = ja(p, y);\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), d, r)) {\n          var m = o ? a.evaluate(d, {}, r) : void 0,\n            v = {\n              id: c,\n              properties: p.properties,\n              type: p.type,\n              sourceLayerIndex: f,\n              index: h,\n              geometry: y ? d.geometry : Ua(p),\n              patterns: {},\n              sortKey: m\n            };\n          i.push(v);\n        }\n      }\n      o && i.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n      for (var g = 0, x = i; g < x.length; g += 1) {\n        var b = x[g],\n          w = b.geometry,\n          _ = b.index,\n          A = b.sourceLayerIndex,\n          S = t[_].feature;\n        this.addFeature(b, w, _, r), e.featureIndex.insert(S, w, _, A, this.index);\n      }\n    }, Na.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, Na.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, Na.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, Na.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, sa), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, Na.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, Na.prototype.addFeature = function (t, e, r, n) {\n      for (var i = 0, a = e; i < a.length; i += 1) for (var o = 0, s = a[i]; o < s.length; o += 1) {\n        var u = s[o],\n          l = u.x,\n          p = u.y;\n        if (!(l < 0 || l >= 8192 || p < 0 || p >= 8192)) {\n          var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n            h = c.vertexLength;\n          qa(this.layoutVertexArray, l, p, -1, -1), qa(this.layoutVertexArray, l, p, 1, -1), qa(this.layoutVertexArray, l, p, 1, 1), qa(this.layoutVertexArray, l, p, -1, 1), this.indexArray.emplaceBack(h, h + 1, h + 2), this.indexArray.emplaceBack(h, h + 3, h + 2), c.vertexLength += 4, c.primitiveLength += 2;\n        }\n      }\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n);\n    }, On("CircleBucket", Na, {\n      omit: ["layers"]\n    });\n    var io = new _i({\n        "circle-sort-key": new gi(Pt.layout_circle["circle-sort-key"])\n      }),\n      ao = {\n        paint: new _i({\n          "circle-radius": new gi(Pt.paint_circle["circle-radius"]),\n          "circle-color": new gi(Pt.paint_circle["circle-color"]),\n          "circle-blur": new gi(Pt.paint_circle["circle-blur"]),\n          "circle-opacity": new gi(Pt.paint_circle["circle-opacity"]),\n          "circle-translate": new vi(Pt.paint_circle["circle-translate"]),\n          "circle-translate-anchor": new vi(Pt.paint_circle["circle-translate-anchor"]),\n          "circle-pitch-scale": new vi(Pt.paint_circle["circle-pitch-scale"]),\n          "circle-pitch-alignment": new vi(Pt.paint_circle["circle-pitch-alignment"]),\n          "circle-stroke-width": new gi(Pt.paint_circle["circle-stroke-width"]),\n          "circle-stroke-color": new gi(Pt.paint_circle["circle-stroke-color"]),\n          "circle-stroke-opacity": new gi(Pt.paint_circle["circle-stroke-opacity"])\n        }),\n        layout: io\n      },\n      oo = "undefined" != typeof Float32Array ? Float32Array : Array;\n    function so(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    function uo(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        o = e[3],\n        s = e[4],\n        u = e[5],\n        l = e[6],\n        p = e[7],\n        c = e[8],\n        h = e[9],\n        f = e[10],\n        y = e[11],\n        d = e[12],\n        m = e[13],\n        v = e[14],\n        g = e[15],\n        x = r[0],\n        b = r[1],\n        w = r[2],\n        _ = r[3];\n      return t[0] = x * n + b * s + w * c + _ * d, t[1] = x * i + b * u + w * h + _ * m, t[2] = x * a + b * l + w * f + _ * v, t[3] = x * o + b * p + w * y + _ * g, t[4] = (x = r[4]) * n + (b = r[5]) * s + (w = r[6]) * c + (_ = r[7]) * d, t[5] = x * i + b * u + w * h + _ * m, t[6] = x * a + b * l + w * f + _ * v, t[7] = x * o + b * p + w * y + _ * g, t[8] = (x = r[8]) * n + (b = r[9]) * s + (w = r[10]) * c + (_ = r[11]) * d, t[9] = x * i + b * u + w * h + _ * m, t[10] = x * a + b * l + w * f + _ * v, t[11] = x * o + b * p + w * y + _ * g, t[12] = (x = r[12]) * n + (b = r[13]) * s + (w = r[14]) * c + (_ = r[15]) * d, t[13] = x * i + b * u + w * h + _ * m, t[14] = x * a + b * l + w * f + _ * v, t[15] = x * o + b * p + w * y + _ * g, t;\n    }\n    Math.hypot || (Math.hypot = function () {\n      for (var t = arguments, e = 0, r = arguments.length; r--;) e += t[r] * t[r];\n      return Math.sqrt(e);\n    });\n    var lo,\n      po = uo;\n    function co(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        o = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * a + r[12] * o, t[1] = r[1] * n + r[5] * i + r[9] * a + r[13] * o, t[2] = r[2] * n + r[6] * i + r[10] * a + r[14] * o, t[3] = r[3] * n + r[7] * i + r[11] * a + r[15] * o, t;\n    }\n    lo = new oo(3), oo != Float32Array && (lo[0] = 0, lo[1] = 0, lo[2] = 0), function () {\n      var t = new oo(4);\n      oo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0);\n    }();\n    var ho = (function () {\n      var t = new oo(2);\n      oo != Float32Array && (t[0] = 0, t[1] = 0);\n    }(), function (t) {\n      function e(e) {\n        t.call(this, e, ao);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n        return new Na(t);\n      }, e.prototype.queryRadius = function (t) {\n        var e = t;\n        return eo("circle-radius", this, e) + eo("circle-stroke-width", this, e) + ro(this.paint.get("circle-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, i, a, o, s) {\n        for (var u = no(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, o), l = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r), p = "map" === this.paint.get("circle-pitch-alignment"), c = p ? u : function (t, e) {\n            return t.map(function (t) {\n              return fo(t, e);\n            });\n          }(u, s), h = p ? l * o : l, f = 0, y = n; f < y.length; f += 1) for (var d = 0, m = y[f]; d < m.length; d += 1) {\n          var v = m[d],\n            g = p ? v : fo(v, s),\n            x = h,\n            b = co([], [v.x, v.y, 0, 1], s);\n          if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x *= b[3] / a.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x *= a.cameraToCenterDistance / b[3]), Ga(c, g, x)) return !0;\n        }\n        return !1;\n      }, e;\n    }(Ai));\n    function fo(t, e) {\n      var r = co([], [t.x, t.y, 0, 1], e);\n      return new i(r[0] / r[3], r[1] / r[3]);\n    }\n    var yo = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n    }(Na);\n    function mo(t, e, r, n) {\n      var i = e.width,\n        a = e.height;\n      if (n) {\n        if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);else if (n.length !== i * a * r) throw new RangeError("mismatched image size");\n      } else n = new Uint8Array(i * a * r);\n      return t.width = i, t.height = a, t.data = n, t;\n    }\n    function vo(t, e, r) {\n      var n = e.width,\n        i = e.height;\n      if (n !== t.width || i !== t.height) {\n        var a = mo({}, {\n          width: n,\n          height: i\n        }, r);\n        go(t, a, {\n          x: 0,\n          y: 0\n        }, {\n          x: 0,\n          y: 0\n        }, {\n          width: Math.min(t.width, n),\n          height: Math.min(t.height, i)\n        }, r), t.width = n, t.height = i, t.data = a.data;\n      }\n    }\n    function go(t, e, r, n, i, a) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");\n      for (var o = t.data, s = e.data, u = 0; u < i.height; u++) for (var l = ((r.y + u) * t.width + r.x) * a, p = ((n.y + u) * e.width + n.x) * a, c = 0; c < i.width * a; c++) s[p + c] = o[l + c];\n      return e;\n    }\n    On("HeatmapBucket", yo, {\n      omit: ["layers"]\n    });\n    var xo = function (t, e) {\n      mo(this, t, 1, e);\n    };\n    xo.prototype.resize = function (t) {\n      vo(this, t, 1);\n    }, xo.prototype.clone = function () {\n      return new xo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }, xo.copy = function (t, e, r, n, i) {\n      go(t, e, r, n, i, 1);\n    };\n    var bo = function (t, e) {\n      mo(this, t, 4, e);\n    };\n    bo.prototype.resize = function (t) {\n      vo(this, t, 4);\n    }, bo.prototype.replace = function (t, e) {\n      e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n    }, bo.prototype.clone = function () {\n      return new bo({\n        width: this.width,\n        height: this.height\n      }, new Uint8Array(this.data));\n    }, bo.copy = function (t, e, r, n, i) {\n      go(t, e, r, n, i, 4);\n    }, On("AlphaImage", xo), On("RGBAImage", bo);\n    var wo = {\n      paint: new _i({\n        "heatmap-radius": new gi(Pt.paint_heatmap["heatmap-radius"]),\n        "heatmap-weight": new gi(Pt.paint_heatmap["heatmap-weight"]),\n        "heatmap-intensity": new vi(Pt.paint_heatmap["heatmap-intensity"]),\n        "heatmap-color": new wi(Pt.paint_heatmap["heatmap-color"]),\n        "heatmap-opacity": new vi(Pt.paint_heatmap["heatmap-opacity"])\n      })\n    };\n    function _o(t) {\n      var e = {},\n        r = t.resolution || 256,\n        n = t.clips ? t.clips.length : 1,\n        i = t.image || new bo({\n          width: r,\n          height: n\n        }),\n        a = function (r, n, a) {\n          e[t.evaluationKey] = a;\n          var o = t.expression.evaluate(e);\n          i.data[r + n + 0] = Math.floor(255 * o.r / o.a), i.data[r + n + 1] = Math.floor(255 * o.g / o.a), i.data[r + n + 2] = Math.floor(255 * o.b / o.a), i.data[r + n + 3] = Math.floor(255 * o.a);\n        };\n      if (t.clips) for (var o = 0, s = 0; o < n; ++o, s += 4 * r) for (var u = 0, l = 0; u < r; u++, l += 4) {\n        var p = u / (r - 1),\n          c = t.clips[o];\n        a(s, l, c.start * (1 - p) + c.end * p);\n      } else for (var h = 0, f = 0; h < r; h++, f += 4) a(0, f, h / (r - 1));\n      return i;\n    }\n    var Ao = function (t) {\n        function e(e) {\n          t.call(this, e, wo), this._updateColorRamp();\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n          return new yo(t);\n        }, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {\n          "heatmap-color" === t && this._updateColorRamp();\n        }, e.prototype._updateColorRamp = function () {\n          this.colorRamp = _o({\n            expression: this._transitionablePaint._values["heatmap-color"].value.expression,\n            evaluationKey: "heatmapDensity",\n            image: this.colorRamp\n          }), this.colorRampTexture = null;\n        }, e.prototype.resize = function () {\n          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n        }, e.prototype.queryRadius = function () {\n          return 0;\n        }, e.prototype.queryIntersectsFeature = function () {\n          return !1;\n        }, e.prototype.hasOffscreenPass = function () {\n          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;\n        }, e;\n      }(Ai),\n      So = {\n        paint: new _i({\n          "hillshade-illumination-direction": new vi(Pt.paint_hillshade["hillshade-illumination-direction"]),\n          "hillshade-illumination-anchor": new vi(Pt.paint_hillshade["hillshade-illumination-anchor"]),\n          "hillshade-exaggeration": new vi(Pt.paint_hillshade["hillshade-exaggeration"]),\n          "hillshade-shadow-color": new vi(Pt.paint_hillshade["hillshade-shadow-color"]),\n          "hillshade-highlight-color": new vi(Pt.paint_hillshade["hillshade-highlight-color"]),\n          "hillshade-accent-color": new vi(Pt.paint_hillshade["hillshade-accent-color"])\n        })\n      },\n      ko = function (t) {\n        function e(e) {\n          t.call(this, e, So);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.hasOffscreenPass = function () {\n          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;\n        }, e;\n      }(Ai),\n      Io = zi([{\n        name: "a_pos",\n        components: 2,\n        type: "Int16"\n      }], 4).members,\n      zo = Eo,\n      Co = Eo;\n    function Eo(t, e, r) {\n      r = r || 2;\n      var n,\n        i,\n        a,\n        o,\n        s,\n        u,\n        l,\n        p = e && e.length,\n        c = p ? e[0] * r : t.length,\n        h = Po(t, 0, c, r, !0),\n        f = [];\n      if (!h || h.next === h.prev) return f;\n      if (p && (h = function (t, e, r, n) {\n        var i,\n          a,\n          o,\n          s = [];\n        for (i = 0, a = e.length; i < a; i++) (o = Po(t, e[i] * n, i < a - 1 ? e[i + 1] * n : t.length, n, !1)) === o.next && (o.steiner = !0), s.push(jo(o));\n        for (s.sort(Lo), i = 0; i < s.length; i++) Ro(s[i], r), r = Mo(r, r.next);\n        return r;\n      }(t, e, h, r)), t.length > 80 * r) {\n        n = a = t[0], i = o = t[1];\n        for (var y = r; y < c; y += r) (s = t[y]) < n && (n = s), (u = t[y + 1]) < i && (i = u), s > a && (a = s), u > o && (o = u);\n        l = 0 !== (l = Math.max(a - n, o - i)) ? 1 / l : 0;\n      }\n      return Bo(h, f, r, n, i, l), f;\n    }\n    function Po(t, e, r, n, i) {\n      var a, o;\n      if (i === ts(t, e, r, n) > 0) for (a = e; a < r; a += n) o = $o(a, t[a], t[a + 1], o);else for (a = r - n; a >= e; a -= n) o = $o(a, t[a], t[a + 1], o);\n      return o && Go(o, o.next) && (Wo(o), o = o.next), o;\n    }\n    function Mo(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n        n = t;\n      do {\n        if (r = !1, n.steiner || !Go(n, n.next) && 0 !== Ko(n.prev, n, n.next)) n = n.next;else {\n          if (Wo(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n      return e;\n    }\n    function Bo(t, e, r, n, i, a, o) {\n      if (t) {\n        !o && a && function (t, e, r, n) {\n          var i = t;\n          do {\n            null === i.z && (i.z = Uo(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n              r,\n              n,\n              i,\n              a,\n              o,\n              s,\n              u,\n              l = 1;\n            do {\n              for (r = t, t = null, a = null, o = 0; r;) {\n                for (o++, n = r, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++);\n                for (u = l; s > 0 || u > 0 && n;) 0 !== s && (0 === u || !n || r.z <= n.z) ? (i = r, r = r.nextZ, s--) : (i = n, n = n.nextZ, u--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;\n                r = n;\n              }\n              a.nextZ = null, l *= 2;\n            } while (o > 1);\n          }(i);\n        }(t, n, i, a);\n        for (var s, u, l = t; t.prev !== t.next;) if (s = t.prev, u = t.next, a ? Vo(t, n, i, a) : To(t)) e.push(s.i / r), e.push(t.i / r), e.push(u.i / r), Wo(t), t = u.next, l = u.next;else if ((t = u) === l) {\n          o ? 1 === o ? Bo(t = Fo(Mo(t), e, r), e, r, n, i, a, 2) : 2 === o && Do(t, e, r, n, i, a) : Bo(Mo(t), e, r, n, i, a, 1);\n          break;\n        }\n      }\n    }\n    function To(t) {\n      var e = t.prev,\n        r = t,\n        n = t.next;\n      if (Ko(e, r, n) >= 0) return !1;\n      for (var i = t.next.next; i !== t.prev;) {\n        if (qo(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && Ko(i.prev, i, i.next) >= 0) return !1;\n        i = i.next;\n      }\n      return !0;\n    }\n    function Vo(t, e, r, n) {\n      var i = t.prev,\n        a = t,\n        o = t.next;\n      if (Ko(i, a, o) >= 0) return !1;\n      for (var s = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, l = Uo(i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, e, r, n), p = Uo(s, u, e, r, n), c = t.prevZ, h = t.nextZ; c && c.z >= l && h && h.z <= p;) {\n        if (c !== t.prev && c !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, c.x, c.y) && Ko(c.prev, c, c.next) >= 0) return !1;\n        if (c = c.prevZ, h !== t.prev && h !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) && Ko(h.prev, h, h.next) >= 0) return !1;\n        h = h.nextZ;\n      }\n      for (; c && c.z >= l;) {\n        if (c !== t.prev && c !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, c.x, c.y) && Ko(c.prev, c, c.next) >= 0) return !1;\n        c = c.prevZ;\n      }\n      for (; h && h.z <= p;) {\n        if (h !== t.prev && h !== t.next && qo(i.x, i.y, a.x, a.y, o.x, o.y, h.x, h.y) && Ko(h.prev, h, h.next) >= 0) return !1;\n        h = h.nextZ;\n      }\n      return !0;\n    }\n    function Fo(t, e, r) {\n      var n = t;\n      do {\n        var i = n.prev,\n          a = n.next.next;\n        !Go(i, a) && Zo(i, n, n.next, a) && Ho(i, a) && Ho(a, i) && (e.push(i.i / r), e.push(n.i / r), e.push(a.i / r), Wo(n), Wo(n.next), n = t = a), n = n.next;\n      } while (n !== t);\n      return Mo(n);\n    }\n    function Do(t, e, r, n, i, a) {\n      var o = t;\n      do {\n        for (var s = o.next.next; s !== o.prev;) {\n          if (o.i !== s.i && No(o, s)) {\n            var u = Yo(o, s);\n            return o = Mo(o, o.next), u = Mo(u, u.next), Bo(o, e, r, n, i, a), void Bo(u, e, r, n, i, a);\n          }\n          s = s.next;\n        }\n        o = o.next;\n      } while (o !== t);\n    }\n    function Lo(t, e) {\n      return t.x - e.x;\n    }\n    function Ro(t, e) {\n      if (e = function (t, e) {\n        var r,\n          n = e,\n          i = t.x,\n          a = t.y,\n          o = -1 / 0;\n        do {\n          if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {\n            var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n            if (s <= i && s > o) {\n              if (o = s, s === i) {\n                if (a === n.y) return n;\n                if (a === n.next.y) return n.next;\n              }\n              r = n.x < n.next.x ? n : n.next;\n            }\n          }\n          n = n.next;\n        } while (n !== e);\n        if (!r) return null;\n        if (i === o) return r;\n        var u,\n          l = r,\n          p = r.x,\n          c = r.y,\n          h = 1 / 0;\n        n = r;\n        do {\n          i >= n.x && n.x >= p && i !== n.x && qo(a < c ? i : o, a, p, c, a < c ? o : i, a, n.x, n.y) && (u = Math.abs(a - n.y) / (i - n.x), Ho(n, t) && (u < h || u === h && (n.x > r.x || n.x === r.x && Oo(r, n))) && (r = n, h = u)), n = n.next;\n        } while (n !== l);\n        return r;\n      }(t, e)) {\n        var r = Yo(e, t);\n        Mo(e, e.next), Mo(r, r.next);\n      }\n    }\n    function Oo(t, e) {\n      return Ko(t.prev, t, e.prev) < 0 && Ko(e.next, t, t.next) < 0;\n    }\n    function Uo(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n    function jo(t) {\n      var e = t,\n        r = t;\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n      return r;\n    }\n    function qo(t, e, r, n, i, a, o, s) {\n      return (i - o) * (e - s) - (t - o) * (a - s) >= 0 && (t - o) * (n - s) - (r - o) * (e - s) >= 0 && (r - o) * (a - s) - (i - o) * (n - s) >= 0;\n    }\n    function No(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Zo(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n        return !1;\n      }(t, e) && (Ho(t, e) && Ho(e, t) && function (t, e) {\n        var r = t,\n          n = !1,\n          i = (t.x + e.x) / 2,\n          a = (t.y + e.y) / 2;\n        do {\n          r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n        return n;\n      }(t, e) && (Ko(t.prev, t, e.prev) || Ko(t, e.prev, e)) || Go(t, e) && Ko(t.prev, t, t.next) > 0 && Ko(e.prev, e, e.next) > 0);\n    }\n    function Ko(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n    function Go(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n    function Zo(t, e, r, n) {\n      var i = Jo(Ko(t, e, r)),\n        a = Jo(Ko(t, e, n)),\n        o = Jo(Ko(r, n, t)),\n        s = Jo(Ko(r, n, e));\n      return i !== a && o !== s || !(0 !== i || !Xo(t, r, e)) || !(0 !== a || !Xo(t, n, e)) || !(0 !== o || !Xo(r, t, n)) || !(0 !== s || !Xo(r, e, n));\n    }\n    function Xo(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n    function Jo(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n    function Ho(t, e) {\n      return Ko(t.prev, t, t.next) < 0 ? Ko(t, e, t.next) >= 0 && Ko(t, t.prev, e) >= 0 : Ko(t, e, t.prev) < 0 || Ko(t, t.next, e) < 0;\n    }\n    function Yo(t, e) {\n      var r = new Qo(t.i, t.x, t.y),\n        n = new Qo(e.i, e.x, e.y),\n        i = t.next,\n        a = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;\n    }\n    function $o(t, e, r, n) {\n      var i = new Qo(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n    function Wo(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n    function Qo(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n    function ts(t, e, r, n) {\n      for (var i = 0, a = e, o = r - n; a < r; a += n) i += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;\n      return i;\n    }\n    function es(t, e, r, n, i) {\n      !function t(e, r, n, i, a) {\n        for (; i > n;) {\n          if (i - n > 600) {\n            var o = i - n + 1,\n              s = r - n + 1,\n              u = Math.log(o),\n              l = .5 * Math.exp(2 * u / 3),\n              p = .5 * Math.sqrt(u * l * (o - l) / o) * (s - o / 2 < 0 ? -1 : 1);\n            t(e, r, Math.max(n, Math.floor(r - s * l / o + p)), Math.min(i, Math.floor(r + (o - s) * l / o + p)), a);\n          }\n          var c = e[r],\n            h = n,\n            f = i;\n          for (rs(e, n, r), a(e[i], c) > 0 && rs(e, n, i); h < f;) {\n            for (rs(e, h, f), h++, f--; a(e[h], c) < 0;) h++;\n            for (; a(e[f], c) > 0;) f--;\n          }\n          0 === a(e[n], c) ? rs(e, n, f) : rs(e, ++f, i), f <= r && (n = f + 1), r <= f && (i = f - 1);\n        }\n      }(t, e, r || 0, n || t.length - 1, i || ns);\n    }\n    function rs(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function ns(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function is(t, e) {\n      var r = t.length;\n      if (r <= 1) return [t];\n      for (var n, i, a = [], o = 0; o < r; o++) {\n        var s = k(t[o]);\n        0 !== s && (t[o].area = Math.abs(s), void 0 === i && (i = s < 0), i === s < 0 ? (n && a.push(n), n = [t[o]]) : n.push(t[o]));\n      }\n      if (n && a.push(n), e > 1) for (var u = 0; u < a.length; u++) a[u].length <= e || (es(a[u], e, 1, a[u].length - 1, as), a[u] = a[u].slice(0, e));\n      return a;\n    }\n    function as(t, e) {\n      return e.area - t.area;\n    }\n    function os(t, e, r) {\n      for (var n = r.patternDependencies, i = !1, a = 0, o = e; a < o.length; a += 1) {\n        var s = o[a].paint.get(t + "-pattern");\n        s.isConstant() || (i = !0);\n        var u = s.constantOr(null);\n        u && (i = !0, n[u.to] = !0, n[u.from] = !0);\n      }\n      return i;\n    }\n    function ss(t, e, r, n, i) {\n      for (var a = i.patternDependencies, o = 0, s = e; o < s.length; o += 1) {\n        var u = s[o],\n          l = u.paint.get(t + "-pattern").value;\n        if ("constant" !== l.kind) {\n          var p = l.evaluate({\n              zoom: n - 1\n            }, r, {}, i.availableImages),\n            c = l.evaluate({\n              zoom: n\n            }, r, {}, i.availableImages),\n            h = l.evaluate({\n              zoom: n + 1\n            }, r, {}, i.availableImages);\n          c = c && c.name ? c.name : c, h = h && h.name ? h.name : h, a[p = p && p.name ? p.name : p] = !0, a[c] = !0, a[h] = !0, r.patterns[u.id] = {\n            min: p,\n            mid: c,\n            max: h\n          };\n        }\n      }\n      return r;\n    }\n    Eo.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n        a = Math.abs(ts(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var o = 0, s = e.length; o < s; o++) a -= Math.abs(ts(t, e[o] * r, o < s - 1 ? e[o + 1] * r : t.length, r));\n      var u = 0;\n      for (o = 0; o < n.length; o += 3) {\n        var l = n[o] * r,\n          p = n[o + 1] * r,\n          c = n[o + 2] * r;\n        u += Math.abs((t[l] - t[c]) * (t[p + 1] - t[l + 1]) - (t[l] - t[p]) * (t[c + 1] - t[l + 1]));\n      }\n      return 0 === a && 0 === u ? 0 : Math.abs((u - a) / a);\n    }, Eo.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n          vertices: [],\n          holes: [],\n          dimensions: e\n        }, n = 0, i = 0; i < t.length; i++) {\n        for (var a = 0; a < t[i].length; a++) for (var o = 0; o < e; o++) r.vertices.push(t[i][a][o]);\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n      return r;\n    }, zo.default = Co;\n    var us = function (t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ei(), this.indexArray = new qi(), this.indexArray2 = new Ji(), this.programConfigurations = new Fa(t.layers, t.zoom), this.segments = new ua(), this.segments2 = new ua(), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n    us.prototype.populate = function (t, e, r) {\n      this.hasPattern = os("fill", this.layers, e);\n      for (var n = this.layers[0].layout.get("fill-sort-key"), i = !n.isConstant(), a = [], o = 0, s = t; o < s.length; o += 1) {\n        var u = s[o],\n          l = u.feature,\n          p = u.id,\n          c = u.index,\n          h = u.sourceLayerIndex,\n          f = this.layers[0]._featureFilter.needGeometry,\n          y = ja(l, f);\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), y, r)) {\n          var d = i ? n.evaluate(y, {}, r, e.availableImages) : void 0,\n            m = {\n              id: p,\n              properties: l.properties,\n              type: l.type,\n              sourceLayerIndex: h,\n              index: c,\n              geometry: f ? y.geometry : Ua(l),\n              patterns: {},\n              sortKey: d\n            };\n          a.push(m);\n        }\n      }\n      i && a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n      for (var v = 0, g = a; v < g.length; v += 1) {\n        var x = g[v],\n          b = x.geometry,\n          w = x.index,\n          _ = x.sourceLayerIndex;\n        if (this.hasPattern) {\n          var A = ss("fill", this.layers, x, this.zoom, e);\n          this.patternFeatures.push(A);\n        } else this.addFeature(x, b, w, r, {});\n        e.featureIndex.insert(t[w].feature, b, w, _, this.index);\n      }\n    }, us.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, us.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.patternFeatures; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, us.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, us.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, us.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Io), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, us.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n    }, us.prototype.addFeature = function (t, e, r, n, i) {\n      for (var a = 0, o = is(e, 500); a < o.length; a += 1) {\n        for (var s = o[a], u = 0, l = 0, p = s; l < p.length; l += 1) u += p[l].length;\n        for (var c = this.segments.prepareSegment(u, this.layoutVertexArray, this.indexArray), h = c.vertexLength, f = [], y = [], d = 0, m = s; d < m.length; d += 1) {\n          var v = m[d];\n          if (0 !== v.length) {\n            v !== s[0] && y.push(f.length / 2);\n            var g = this.segments2.prepareSegment(v.length, this.layoutVertexArray, this.indexArray2),\n              x = g.vertexLength;\n            this.layoutVertexArray.emplaceBack(v[0].x, v[0].y), this.indexArray2.emplaceBack(x + v.length - 1, x), f.push(v[0].x), f.push(v[0].y);\n            for (var b = 1; b < v.length; b++) this.layoutVertexArray.emplaceBack(v[b].x, v[b].y), this.indexArray2.emplaceBack(x + b - 1, x + b), f.push(v[b].x), f.push(v[b].y);\n            g.vertexLength += v.length, g.primitiveLength += v.length;\n          }\n        }\n        for (var w = zo(f, y), _ = 0; _ < w.length; _ += 3) this.indexArray.emplaceBack(h + w[_], h + w[_ + 1], h + w[_ + 2]);\n        c.vertexLength += u, c.primitiveLength += w.length / 3;\n      }\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, On("FillBucket", us, {\n      omit: ["layers", "patternFeatures"]\n    });\n    var ls = new _i({\n        "fill-sort-key": new gi(Pt.layout_fill["fill-sort-key"])\n      }),\n      ps = {\n        paint: new _i({\n          "fill-antialias": new vi(Pt.paint_fill["fill-antialias"]),\n          "fill-opacity": new gi(Pt.paint_fill["fill-opacity"]),\n          "fill-color": new gi(Pt.paint_fill["fill-color"]),\n          "fill-outline-color": new gi(Pt.paint_fill["fill-outline-color"]),\n          "fill-translate": new vi(Pt.paint_fill["fill-translate"]),\n          "fill-translate-anchor": new vi(Pt.paint_fill["fill-translate-anchor"]),\n          "fill-pattern": new xi(Pt.paint_fill["fill-pattern"])\n        }),\n        layout: ls\n      },\n      cs = function (t) {\n        function e(e) {\n          t.call(this, e, ps);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, r) {\n          t.prototype.recalculate.call(this, e, r);\n          var n = this.paint._values["fill-outline-color"];\n          "constant" === n.value.kind && void 0 === n.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);\n        }, e.prototype.createBucket = function (t) {\n          return new us(t);\n        }, e.prototype.queryRadius = function () {\n          return ro(this.paint.get("fill-translate"));\n        }, e.prototype.queryIntersectsFeature = function (t, e, r, n, i, a, o) {\n          return Za(no(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, o), n);\n        }, e.prototype.isTileClipped = function () {\n          return !0;\n        }, e;\n      }(Ai),\n      hs = zi([{\n        name: "a_pos",\n        components: 2,\n        type: "Int16"\n      }, {\n        name: "a_normal_ed",\n        components: 4,\n        type: "Int16"\n      }], 4).members,\n      fs = ys;\n    function ys(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(ds, this, e);\n    }\n    function ds(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n            i = e._values[t.readVarint()];\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n    function ms(t) {\n      for (var e, r, n = 0, i = 0, a = t.length, o = a - 1; i < a; o = i++) n += ((r = t[o]).x - (e = t[i]).x) * (e.y + r.y);\n      return n;\n    }\n    ys.types = ["Unknown", "Point", "LineString", "Polygon"], ys.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n      for (var e, r = t.readVarint() + t.pos, n = 1, a = 0, o = 0, s = 0, u = []; t.pos < r;) {\n        if (a <= 0) {\n          var l = t.readVarint();\n          n = 7 & l, a = l >> 3;\n        }\n        if (a--, 1 === n || 2 === n) o += t.readSVarint(), s += t.readSVarint(), 1 === n && (e && u.push(e), e = []), e.push(new i(o, s));else {\n          if (7 !== n) throw new Error("unknown command " + n);\n          e && e.push(e[0].clone());\n        }\n      }\n      return e && u.push(e), u;\n    }, ys.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, a = 0, o = 1 / 0, s = -1 / 0, u = 1 / 0, l = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var p = t.readVarint();\n          r = 7 & p, n = p >> 3;\n        }\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < o && (o = i), i > s && (s = i), (a += t.readSVarint()) < u && (u = a), a > l && (l = a);else if (7 !== r) throw new Error("unknown command " + r);\n      }\n      return [o, u, s, l];\n    }, ys.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n        i,\n        a = this.extent * Math.pow(2, r),\n        o = this.extent * t,\n        s = this.extent * e,\n        u = this.loadGeometry(),\n        l = ys.types[this.type];\n      function p(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + o) / a - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + s) / a) * Math.PI / 180)) - 90];\n        }\n      }\n      switch (this.type) {\n        case 1:\n          var c = [];\n          for (n = 0; n < u.length; n++) c[n] = u[n][0];\n          p(u = c);\n          break;\n        case 2:\n          for (n = 0; n < u.length; n++) p(u[n]);\n          break;\n        case 3:\n          for (u = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n            for (var r, n, i = [], a = 0; a < e; a++) {\n              var o = ms(t[a]);\n              0 !== o && (void 0 === n && (n = o < 0), n === o < 0 ? (r && i.push(r), r = [t[a]]) : r.push(t[a]));\n            }\n            return r && i.push(r), i;\n          }(u), n = 0; n < u.length; n++) for (i = 0; i < u[n].length; i++) p(u[n][i]);\n      }\n      1 === u.length ? u = u[0] : l = "Multi" + l;\n      var h = {\n        type: "Feature",\n        geometry: {\n          type: l,\n          coordinates: u\n        },\n        properties: this.properties\n      };\n      return "id" in this && (h.id = this.id), h;\n    };\n    var vs = gs;\n    function gs(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(xs, this, e), this.length = this._features.length;\n    }\n    function xs(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n        return e;\n      }(r));\n    }\n    function bs(t, e, r) {\n      if (3 === t) {\n        var n = new vs(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n    gs.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");\n      this._pbf.pos = this._features[t];\n      var e = this._pbf.readVarint() + this._pbf.pos;\n      return new fs(this._pbf, e, this.extent, this._keys, this._values);\n    };\n    var ws = {\n        VectorTile: function (t, e) {\n          this.layers = t.readFields(bs, {}, e);\n        },\n        VectorTileFeature: fs,\n        VectorTileLayer: vs\n      },\n      _s = ws.VectorTileFeature.types,\n      As = Math.pow(2, 13);\n    function Ss(t, e, r, n, i, a, o, s) {\n      t.emplaceBack(e, r, 2 * Math.floor(n * As) + o, i * As * 2, a * As * 2, Math.round(s));\n    }\n    var ks = function (t) {\n      this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new Mi(), this.indexArray = new qi(), this.programConfigurations = new Fa(t.layers, t.zoom), this.segments = new ua(), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      });\n    };\n    function Is(t, e) {\n      return t.x === e.x && (t.x < 0 || t.x > 8192) || t.y === e.y && (t.y < 0 || t.y > 8192);\n    }\n    ks.prototype.populate = function (t, e, r) {\n      this.features = [], this.hasPattern = os("fill-extrusion", this.layers, e);\n      for (var n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n],\n          o = a.feature,\n          s = a.id,\n          u = a.index,\n          l = a.sourceLayerIndex,\n          p = this.layers[0]._featureFilter.needGeometry,\n          c = ja(o, p);\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), c, r)) {\n          var h = {\n            id: s,\n            sourceLayerIndex: l,\n            index: u,\n            geometry: p ? c.geometry : Ua(o),\n            properties: o.properties,\n            type: o.type,\n            patterns: {}\n          };\n          this.hasPattern ? this.features.push(ss("fill-extrusion", this.layers, h, this.zoom, e)) : this.addFeature(h, h.geometry, u, r, {}), e.featureIndex.insert(o, h.geometry, u, l, this.index, !0);\n        }\n      }\n    }, ks.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.features; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, ks.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, ks.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, ks.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, ks.prototype.upload = function (t) {\n      this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, hs), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, ks.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, ks.prototype.addFeature = function (t, e, r, n, i) {\n      for (var a = 0, o = is(e, 500); a < o.length; a += 1) {\n        for (var s = o[a], u = 0, l = 0, p = s; l < p.length; l += 1) u += p[l].length;\n        for (var c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h = 0, f = s; h < f.length; h += 1) {\n          var y = f[h];\n          if (0 !== y.length && !((B = y).every(function (t) {\n            return t.x < 0;\n          }) || B.every(function (t) {\n            return t.x > 8192;\n          }) || B.every(function (t) {\n            return t.y < 0;\n          }) || B.every(function (t) {\n            return t.y > 8192;\n          }))) for (var d = 0, m = 0; m < y.length; m++) {\n            var v = y[m];\n            if (m >= 1) {\n              var g = y[m - 1];\n              if (!Is(v, g)) {\n                c.vertexLength + 4 > ua.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));\n                var x = v.sub(g)._perp()._unit(),\n                  b = g.dist(v);\n                d + b > 32768 && (d = 0), Ss(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 0, d), Ss(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 1, d), Ss(this.layoutVertexArray, g.x, g.y, x.x, x.y, 0, 0, d += b), Ss(this.layoutVertexArray, g.x, g.y, x.x, x.y, 0, 1, d);\n                var w = c.vertexLength;\n                this.indexArray.emplaceBack(w, w + 2, w + 1), this.indexArray.emplaceBack(w + 1, w + 2, w + 3), c.vertexLength += 4, c.primitiveLength += 2;\n              }\n            }\n          }\n        }\n        if (c.vertexLength + u > ua.MAX_VERTEX_ARRAY_LENGTH && (c = this.segments.prepareSegment(u, this.layoutVertexArray, this.indexArray)), "Polygon" === _s[t.type]) {\n          for (var _ = [], A = [], S = c.vertexLength, k = 0, I = s; k < I.length; k += 1) {\n            var z = I[k];\n            if (0 !== z.length) {\n              z !== s[0] && A.push(_.length / 2);\n              for (var C = 0; C < z.length; C++) {\n                var E = z[C];\n                Ss(this.layoutVertexArray, E.x, E.y, 0, 0, 1, 1, 0), _.push(E.x), _.push(E.y);\n              }\n            }\n          }\n          for (var P = zo(_, A), M = 0; M < P.length; M += 3) this.indexArray.emplaceBack(S + P[M], S + P[M + 2], S + P[M + 1]);\n          c.primitiveLength += P.length / 3, c.vertexLength += u;\n        }\n      }\n      var B;\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, On("FillExtrusionBucket", ks, {\n      omit: ["layers", "features"]\n    });\n    var zs = {\n        paint: new _i({\n          "fill-extrusion-opacity": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-opacity"]),\n          "fill-extrusion-color": new gi(Pt["paint_fill-extrusion"]["fill-extrusion-color"]),\n          "fill-extrusion-translate": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-translate"]),\n          "fill-extrusion-translate-anchor": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),\n          "fill-extrusion-pattern": new xi(Pt["paint_fill-extrusion"]["fill-extrusion-pattern"]),\n          "fill-extrusion-height": new gi(Pt["paint_fill-extrusion"]["fill-extrusion-height"]),\n          "fill-extrusion-base": new gi(Pt["paint_fill-extrusion"]["fill-extrusion-base"]),\n          "fill-extrusion-vertical-gradient": new vi(Pt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])\n        })\n      },\n      Cs = function (t) {\n        function e(e) {\n          t.call(this, e, zs);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.createBucket = function (t) {\n          return new ks(t);\n        }, e.prototype.queryRadius = function () {\n          return ro(this.paint.get("fill-extrusion-translate"));\n        }, e.prototype.is3D = function () {\n          return !0;\n        }, e.prototype.queryIntersectsFeature = function (t, e, r, n, a, o, s, u) {\n          var l = no(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, s),\n            p = this.paint.get("fill-extrusion-height").evaluate(e, r),\n            c = this.paint.get("fill-extrusion-base").evaluate(e, r),\n            h = function (t, e, r, n) {\n              for (var a = [], o = 0, s = t; o < s.length; o += 1) {\n                var u = s[o],\n                  l = [u.x, u.y, 0, 1];\n                co(l, l, e), a.push(new i(l[0] / l[3], l[1] / l[3]));\n              }\n              return a;\n            }(l, u),\n            f = function (t, e, r, n) {\n              for (var a = [], o = [], s = n[8] * e, u = n[9] * e, l = n[10] * e, p = n[11] * e, c = n[8] * r, h = n[9] * r, f = n[10] * r, y = n[11] * r, d = 0, m = t; d < m.length; d += 1) {\n                for (var v = [], g = [], x = 0, b = m[d]; x < b.length; x += 1) {\n                  var w = b[x],\n                    _ = w.x,\n                    A = w.y,\n                    S = n[0] * _ + n[4] * A + n[12],\n                    k = n[1] * _ + n[5] * A + n[13],\n                    I = n[2] * _ + n[6] * A + n[14],\n                    z = n[3] * _ + n[7] * A + n[15],\n                    C = I + l,\n                    E = z + p,\n                    P = S + c,\n                    M = k + h,\n                    B = I + f,\n                    T = z + y,\n                    V = new i((S + s) / E, (k + u) / E);\n                  V.z = C / E, v.push(V);\n                  var F = new i(P / T, M / T);\n                  F.z = B / T, g.push(F);\n                }\n                a.push(v), o.push(g);\n              }\n              return [a, o];\n            }(n, c, p, u);\n          return function (t, e, r) {\n            var n = 1 / 0;\n            Za(r, e) && (n = Ps(r, e[0]));\n            for (var i = 0; i < e.length; i++) for (var a = e[i], o = t[i], s = 0; s < a.length - 1; s++) {\n              var u = a[s],\n                l = [u, a[s + 1], o[s + 1], o[s], u];\n              Ka(r, l) && (n = Math.min(n, Ps(r, l)));\n            }\n            return n !== 1 / 0 && n;\n          }(f[0], f[1], h);\n        }, e;\n      }(Ai);\n    function Es(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n    function Ps(t, e) {\n      if (1 === t.length) {\n        for (var r, n = 0, i = e[n++]; !r || i.equals(r);) if (!(r = e[n++])) return 1 / 0;\n        for (; n < e.length; n++) {\n          var a = e[n],\n            o = t[0],\n            s = r.sub(i),\n            u = a.sub(i),\n            l = o.sub(i),\n            p = Es(s, s),\n            c = Es(s, u),\n            h = Es(u, u),\n            f = Es(l, s),\n            y = Es(l, u),\n            d = p * h - c * c,\n            m = (h * f - c * y) / d,\n            v = (p * y - c * f) / d,\n            g = i.z * (1 - m - v) + r.z * m + a.z * v;\n          if (isFinite(g)) return g;\n        }\n        return 1 / 0;\n      }\n      for (var x = 1 / 0, b = 0, w = e; b < w.length; b += 1) x = Math.min(x, w[b].z);\n      return x;\n    }\n    var Ms = zi([{\n        name: "a_pos_normal",\n        components: 2,\n        type: "Int16"\n      }, {\n        name: "a_data",\n        components: 4,\n        type: "Uint8"\n      }], 4).members,\n      Bs = zi([{\n        name: "a_uv_x",\n        components: 1,\n        type: "Float32"\n      }, {\n        name: "a_split_index",\n        components: 1,\n        type: "Float32"\n      }]).members,\n      Ts = ws.VectorTileFeature.types,\n      Vs = Math.cos(Math.PI / 180 * 37.5),\n      Fs = Math.pow(2, 14) / .5,\n      Ds = function (t) {\n        var e = this;\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n          return t.id;\n        }), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function (t) {\n          e.gradients[t.id] = {};\n        }), this.layoutVertexArray = new Bi(), this.layoutVertexArray2 = new Ti(), this.indexArray = new qi(), this.programConfigurations = new Fa(t.layers, t.zoom), this.segments = new ua(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function (t) {\n          return t.isStateDependent();\n        }).map(function (t) {\n          return t.id;\n        });\n      };\n    Ds.prototype.populate = function (t, e, r) {\n      this.hasPattern = os("line", this.layers, e);\n      for (var n = this.layers[0].layout.get("line-sort-key"), i = !n.isConstant(), a = [], o = 0, s = t; o < s.length; o += 1) {\n        var u = s[o],\n          l = u.feature,\n          p = u.id,\n          c = u.index,\n          h = u.sourceLayerIndex,\n          f = this.layers[0]._featureFilter.needGeometry,\n          y = ja(l, f);\n        if (this.layers[0]._featureFilter.filter(new ui(this.zoom), y, r)) {\n          var d = i ? n.evaluate(y, {}, r) : void 0,\n            m = {\n              id: p,\n              properties: l.properties,\n              type: l.type,\n              sourceLayerIndex: h,\n              index: c,\n              geometry: f ? y.geometry : Ua(l),\n              patterns: {},\n              sortKey: d\n            };\n          a.push(m);\n        }\n      }\n      i && a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n      for (var v = 0, g = a; v < g.length; v += 1) {\n        var x = g[v],\n          b = x.geometry,\n          w = x.index,\n          _ = x.sourceLayerIndex;\n        if (this.hasPattern) {\n          var A = ss("line", this.layers, x, this.zoom, e);\n          this.patternFeatures.push(A);\n        } else this.addFeature(x, b, w, r, {});\n        e.featureIndex.insert(t[w].feature, b, w, _, this.index);\n      }\n    }, Ds.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r);\n    }, Ds.prototype.addFeatures = function (t, e, r) {\n      for (var n = 0, i = this.patternFeatures; n < i.length; n += 1) {\n        var a = i[n];\n        this.addFeature(a, a.geometry, a.index, e, r);\n      }\n    }, Ds.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length;\n    }, Ds.prototype.uploadPending = function () {\n      return !this.uploaded || this.programConfigurations.needsUpload;\n    }, Ds.prototype.upload = function (t) {\n      this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Bs)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ms), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n    }, Ds.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n    }, Ds.prototype.lineFeatureClips = function (t) {\n      if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return {\n        start: +t.properties.mapbox_clip_start,\n        end: +t.properties.mapbox_clip_end\n      };\n    }, Ds.prototype.addFeature = function (t, e, r, n, i) {\n      var a = this.layers[0].layout,\n        o = a.get("line-join").evaluate(t, {}),\n        s = a.get("line-cap"),\n        u = a.get("line-miter-limit"),\n        l = a.get("line-round-limit");\n      this.lineClips = this.lineFeatureClips(t);\n      for (var p = 0, c = e; p < c.length; p += 1) this.addLine(c[p], t, o, s, u, l);\n      this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n);\n    }, Ds.prototype.addLine = function (t, e, r, n, i, a) {\n      if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {\n        this.lineClipsArray.push(this.lineClips);\n        for (var o = 0; o < t.length - 1; o++) this.totalDistance += t[o].dist(t[o + 1]);\n        this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n      }\n      for (var s = "Polygon" === Ts[e.type], u = t.length; u >= 2 && t[u - 1].equals(t[u - 2]);) u--;\n      for (var l = 0; l < u - 1 && t[l].equals(t[l + 1]);) l++;\n      if (!(u < (s ? 3 : 2))) {\n        "bevel" === r && (i = 1.05);\n        var p,\n          c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,\n          h = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray),\n          f = void 0,\n          y = void 0,\n          d = void 0,\n          m = void 0;\n        this.e1 = this.e2 = -1, s && (m = t[l].sub(p = t[u - 2])._unit()._perp());\n        for (var v = l; v < u; v++) if (!(y = v === u - 1 ? s ? t[l + 1] : void 0 : t[v + 1]) || !t[v].equals(y)) {\n          m && (d = m), p && (f = p), p = t[v], m = y ? y.sub(p)._unit()._perp() : d;\n          var g = (d = d || m).add(m);\n          0 === g.x && 0 === g.y || g._unit();\n          var x = d.x * m.x + d.y * m.y,\n            b = g.x * m.x + g.y * m.y,\n            w = 0 !== b ? 1 / b : 1 / 0,\n            _ = 2 * Math.sqrt(2 - 2 * b),\n            A = b < Vs && f && y,\n            S = d.x * m.y - d.y * m.x > 0;\n          if (A && v > l) {\n            var k = p.dist(f);\n            if (k > 2 * c) {\n              var I = p.sub(p.sub(f)._mult(c / k)._round());\n              this.updateDistance(f, I), this.addCurrentVertex(I, d, 0, 0, h), f = I;\n            }\n          }\n          var z = f && y,\n            C = z ? r : s ? "butt" : n;\n          if (z && "round" === C && (w < a ? C = "miter" : w <= 2 && (C = "fakeround")), "miter" === C && w > i && (C = "bevel"), "bevel" === C && (w > 2 && (C = "flipbevel"), w < i && (C = "miter")), f && this.updateDistance(f, p), "miter" === C) g._mult(w), this.addCurrentVertex(p, g, 0, 0, h);else if ("flipbevel" === C) {\n            if (w > 100) g = m.mult(-1);else {\n              var E = w * d.add(m).mag() / d.sub(m).mag();\n              g._perp()._mult(E * (S ? -1 : 1));\n            }\n            this.addCurrentVertex(p, g, 0, 0, h), this.addCurrentVertex(p, g.mult(-1), 0, 0, h);\n          } else if ("bevel" === C || "fakeround" === C) {\n            var P = -Math.sqrt(w * w - 1),\n              M = S ? P : 0,\n              B = S ? 0 : P;\n            if (f && this.addCurrentVertex(p, d, M, B, h), "fakeround" === C) for (var T = Math.round(180 * _ / Math.PI / 20), V = 1; V < T; V++) {\n              var F = V / T;\n              if (.5 !== F) {\n                var D = F - .5;\n                F += F * D * (F - 1) * ((1.0904 + x * (x * (3.55645 - 1.43519 * x) - 3.2452)) * D * D + (.848013 + x * (.215638 * x - 1.06021)));\n              }\n              var L = m.sub(d)._mult(F)._add(d)._unit()._mult(S ? -1 : 1);\n              this.addHalfVertex(p, L.x, L.y, !1, S, 0, h);\n            }\n            y && this.addCurrentVertex(p, m, -M, -B, h);\n          } else if ("butt" === C) this.addCurrentVertex(p, g, 0, 0, h);else if ("square" === C) {\n            var R = f ? 1 : -1;\n            this.addCurrentVertex(p, g, R, R, h);\n          } else "round" === C && (f && (this.addCurrentVertex(p, d, 0, 0, h), this.addCurrentVertex(p, d, 1, 1, h, !0)), y && (this.addCurrentVertex(p, m, -1, -1, h, !0), this.addCurrentVertex(p, m, 0, 0, h)));\n          if (A && v < u - 1) {\n            var O = p.dist(y);\n            if (O > 2 * c) {\n              var U = p.add(y.sub(p)._mult(c / O)._round());\n              this.updateDistance(p, U), this.addCurrentVertex(U, m, 0, 0, h), p = U;\n            }\n          }\n        }\n      }\n    }, Ds.prototype.addCurrentVertex = function (t, e, r, n, i, a) {\n      void 0 === a && (a = !1);\n      var o = e.y * n - e.x,\n        s = -e.y - e.x * n;\n      this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, a, !1, r, i), this.addHalfVertex(t, o, s, a, !0, -n, i), this.distance > Fs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t, e, r, n, i, a));\n    }, Ds.prototype.addHalfVertex = function (t, e, r, n, i, a, o) {\n      var s = .5 * (this.lineClips ? this.scaledDistance * (Fs - 1) : this.scaledDistance);\n      this.layoutVertexArray.emplaceBack((t.x << 1) + (n ? 1 : 0), (t.y << 1) + (i ? 1 : 0), Math.round(63 * e) + 128, Math.round(63 * r) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & s) << 2, s >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);\n      var u = o.vertexLength++;\n      this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), i ? this.e2 = u : this.e1 = u;\n    }, Ds.prototype.updateScaledDistance = function () {\n      this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;\n    }, Ds.prototype.updateDistance = function (t, e) {\n      this.distance += t.dist(e), this.updateScaledDistance();\n    }, On("LineBucket", Ds, {\n      omit: ["layers", "patternFeatures"]\n    });\n    var Ls = new _i({\n        "line-cap": new vi(Pt.layout_line["line-cap"]),\n        "line-join": new gi(Pt.layout_line["line-join"]),\n        "line-miter-limit": new vi(Pt.layout_line["line-miter-limit"]),\n        "line-round-limit": new vi(Pt.layout_line["line-round-limit"]),\n        "line-sort-key": new gi(Pt.layout_line["line-sort-key"])\n      }),\n      Rs = {\n        paint: new _i({\n          "line-opacity": new gi(Pt.paint_line["line-opacity"]),\n          "line-color": new gi(Pt.paint_line["line-color"]),\n          "line-translate": new vi(Pt.paint_line["line-translate"]),\n          "line-translate-anchor": new vi(Pt.paint_line["line-translate-anchor"]),\n          "line-width": new gi(Pt.paint_line["line-width"]),\n          "line-gap-width": new gi(Pt.paint_line["line-gap-width"]),\n          "line-offset": new gi(Pt.paint_line["line-offset"]),\n          "line-blur": new gi(Pt.paint_line["line-blur"]),\n          "line-dasharray": new bi(Pt.paint_line["line-dasharray"]),\n          "line-pattern": new xi(Pt.paint_line["line-pattern"]),\n          "line-gradient": new wi(Pt.paint_line["line-gradient"])\n        }),\n        layout: Ls\n      },\n      Os = new (function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.possiblyEvaluate = function (e, r) {\n          return r = new ui(Math.floor(r.zoom), {\n            now: r.now,\n            fadeDuration: r.fadeDuration,\n            zoomHistory: r.zoomHistory,\n            transition: r.transition\n          }), t.prototype.possiblyEvaluate.call(this, e, r);\n        }, e.prototype.evaluate = function (e, r, n, i) {\n          return r = h({}, r, {\n            zoom: Math.floor(r.zoom)\n          }), t.prototype.evaluate.call(this, e, r, n, i);\n        }, e;\n      }(gi))(Rs.paint.properties["line-width"].specification);\n    Os.useIntegerZoom = !0;\n    var Us = function (t) {\n      function e(e) {\n        t.call(this, e, Rs), this.gradientVersion = 0;\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._handleSpecialPaintPropertyUpdate = function (t) {\n        "line-gradient" === t && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ke, this.gradientVersion = (this.gradientVersion + 1) % s);\n      }, e.prototype.gradientExpression = function () {\n        return this._transitionablePaint._values["line-gradient"].value.expression;\n      }, e.prototype.recalculate = function (e, r) {\n        t.prototype.recalculate.call(this, e, r), this.paint._values["line-floorwidth"] = Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);\n      }, e.prototype.createBucket = function (t) {\n        return new Ds(t);\n      }, e.prototype.queryRadius = function (t) {\n        var e = t,\n          r = js(eo("line-width", this, e), eo("line-gap-width", this, e)),\n          n = eo("line-offset", this, e);\n        return r / 2 + Math.abs(n) + ro(this.paint.get("line-translate"));\n      }, e.prototype.queryIntersectsFeature = function (t, e, r, n, a, o, s) {\n        var u = no(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, s),\n          l = s / 2 * js(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)),\n          p = this.paint.get("line-offset").evaluate(e, r);\n        return p && (n = function (t, e) {\n          for (var r = [], n = new i(0, 0), a = 0; a < t.length; a++) {\n            for (var o = t[a], s = [], u = 0; u < o.length; u++) {\n              var l = o[u],\n                p = o[u + 1],\n                c = 0 === u ? n : l.sub(o[u - 1])._unit()._perp(),\n                h = u === o.length - 1 ? n : p.sub(l)._unit()._perp(),\n                f = c._add(h)._unit();\n              f._mult(1 / (f.x * h.x + f.y * h.y)), s.push(f._mult(e)._add(l));\n            }\n            r.push(s);\n          }\n          return r;\n        }(n, p * s)), function (t, e, r) {\n          for (var n = 0; n < e.length; n++) {\n            var i = e[n];\n            if (t.length >= 3) for (var a = 0; a < i.length; a++) if (Qa(t, i[a])) return !0;\n            if (Xa(t, i, r)) return !0;\n          }\n          return !1;\n        }(u, n, l);\n      }, e.prototype.isTileClipped = function () {\n        return !0;\n      }, e;\n    }(Ai);\n    function js(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n    var qs = zi([{\n        name: "a_pos_offset",\n        components: 4,\n        type: "Int16"\n      }, {\n        name: "a_data",\n        components: 4,\n        type: "Uint16"\n      }, {\n        name: "a_pixeloffset",\n        components: 4,\n        type: "Int16"\n      }], 4),\n      Ns = zi([{\n        name: "a_projected_pos",\n        components: 3,\n        type: "Float32"\n      }], 4),\n      Ks = (zi([{\n        name: "a_fade_opacity",\n        components: 1,\n        type: "Uint32"\n      }], 4), zi([{\n        name: "a_placed",\n        components: 2,\n        type: "Uint8"\n      }, {\n        name: "a_shift",\n        components: 2,\n        type: "Float32"\n      }])),\n      Gs = (zi([{\n        type: "Int16",\n        name: "anchorPointX"\n      }, {\n        type: "Int16",\n        name: "anchorPointY"\n      }, {\n        type: "Int16",\n        name: "x1"\n      }, {\n        type: "Int16",\n        name: "y1"\n      }, {\n        type: "Int16",\n        name: "x2"\n      }, {\n        type: "Int16",\n        name: "y2"\n      }, {\n        type: "Uint32",\n        name: "featureIndex"\n      }, {\n        type: "Uint16",\n        name: "sourceLayerIndex"\n      }, {\n        type: "Uint16",\n        name: "bucketIndex"\n      }]), zi([{\n        name: "a_pos",\n        components: 2,\n        type: "Int16"\n      }, {\n        name: "a_anchor_pos",\n        components: 2,\n        type: "Int16"\n      }, {\n        name: "a_extrude",\n        components: 2,\n        type: "Int16"\n      }], 4)),\n      Zs = zi([{\n        name: "a_pos",\n        components: 2,\n        type: "Float32"\n      }, {\n        name: "a_radius",\n        components: 1,\n        type: "Float32"\n      }, {\n        name: "a_flags",\n        components: 2,\n        type: "Int16"\n      }], 4);\n    function Xs(t, e, r) {\n      return t.sections.forEach(function (t) {\n        t.text = function (t, e, r) {\n          var n = e.layout.get("text-transform").evaluate(r, {});\n          return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), si.applyArabicShaping && (t = si.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n    zi([{\n      name: "triangle",\n      components: 3,\n      type: "Uint16"\n    }]), zi([{\n      type: "Int16",\n      name: "anchorX"\n    }, {\n      type: "Int16",\n      name: "anchorY"\n    }, {\n      type: "Uint16",\n      name: "glyphStartIndex"\n    }, {\n      type: "Uint16",\n      name: "numGlyphs"\n    }, {\n      type: "Uint32",\n      name: "vertexStartIndex"\n    }, {\n      type: "Uint32",\n      name: "lineStartIndex"\n    }, {\n      type: "Uint32",\n      name: "lineLength"\n    }, {\n      type: "Uint16",\n      name: "segment"\n    }, {\n      type: "Uint16",\n      name: "lowerSize"\n    }, {\n      type: "Uint16",\n      name: "upperSize"\n    }, {\n      type: "Float32",\n      name: "lineOffsetX"\n    }, {\n      type: "Float32",\n      name: "lineOffsetY"\n    }, {\n      type: "Uint8",\n      name: "writingMode"\n    }, {\n      type: "Uint8",\n      name: "placedOrientation"\n    }, {\n      type: "Uint8",\n      name: "hidden"\n    }, {\n      type: "Uint32",\n      name: "crossTileID"\n    }, {\n      type: "Int16",\n      name: "associatedIconIndex"\n    }]), zi([{\n      type: "Int16",\n      name: "anchorX"\n    }, {\n      type: "Int16",\n      name: "anchorY"\n    }, {\n      type: "Int16",\n      name: "rightJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "centerJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "leftJustifiedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "verticalPlacedTextSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "placedIconSymbolIndex"\n    }, {\n      type: "Int16",\n      name: "verticalPlacedIconSymbolIndex"\n    }, {\n      type: "Uint16",\n      name: "key"\n    }, {\n      type: "Uint16",\n      name: "textBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "textBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalTextBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalTextBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "iconBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "iconBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalIconBoxStartIndex"\n    }, {\n      type: "Uint16",\n      name: "verticalIconBoxEndIndex"\n    }, {\n      type: "Uint16",\n      name: "featureIndex"\n    }, {\n      type: "Uint16",\n      name: "numHorizontalGlyphVertices"\n    }, {\n      type: "Uint16",\n      name: "numVerticalGlyphVertices"\n    }, {\n      type: "Uint16",\n      name: "numIconVertices"\n    }, {\n      type: "Uint16",\n      name: "numVerticalIconVertices"\n    }, {\n      type: "Uint16",\n      name: "useRuntimeCollisionCircles"\n    }, {\n      type: "Uint32",\n      name: "crossTileID"\n    }, {\n      type: "Float32",\n      name: "textBoxScale"\n    }, {\n      type: "Float32",\n      components: 2,\n      name: "textOffset"\n    }, {\n      type: "Float32",\n      name: "collisionCircleDiameter"\n    }]), zi([{\n      type: "Float32",\n      name: "offsetX"\n    }]), zi([{\n      type: "Int16",\n      name: "x"\n    }, {\n      type: "Int16",\n      name: "y"\n    }, {\n      type: "Int16",\n      name: "tileUnitDistanceFromAnchor"\n    }]);\n    var Js = {\n        "!": "",\n        "#": "",\n        $: "",\n        "%": "",\n        "&": "",\n        "(": "",\n        ")": "",\n        "*": "",\n        "+": "",\n        ",": "",\n        "-": "",\n        ".": "",\n        "/": "",\n        ":": "",\n        ";": "",\n        "<": "",\n        "=": "",\n        ">": "",\n        "?": "",\n        "@": "",\n        "[": "",\n        "\\\\": "",\n        "]": "",\n        "^": "",\n        _: "",\n        "`": "",\n        "{": "",\n        "|": "",\n        "}": "",\n        "~": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": "",\n        "": ""\n      },\n      Hs = function (t, e, r, n, i) {\n        var a,\n          o,\n          s = 8 * i - n - 1,\n          u = (1 << s) - 1,\n          l = u >> 1,\n          p = -7,\n          c = r ? i - 1 : 0,\n          h = r ? -1 : 1,\n          f = t[e + c];\n        for (c += h, a = f & (1 << -p) - 1, f >>= -p, p += s; p > 0; a = 256 * a + t[e + c], c += h, p -= 8);\n        for (o = a & (1 << -p) - 1, a >>= -p, p += n; p > 0; o = 256 * o + t[e + c], c += h, p -= 8);\n        if (0 === a) a = 1 - l;else {\n          if (a === u) return o ? NaN : 1 / 0 * (f ? -1 : 1);\n          o += Math.pow(2, n), a -= l;\n        }\n        return (f ? -1 : 1) * o * Math.pow(2, a - n);\n      },\n      Ys = function (t, e, r, n, i, a) {\n        var o,\n          s,\n          u,\n          l = 8 * a - i - 1,\n          p = (1 << l) - 1,\n          c = p >> 1,\n          h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = n ? 0 : a - 1,\n          y = n ? 1 : -1,\n          d = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = p) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), (e += o + c >= 1 ? h / u : h * Math.pow(2, 1 - c)) * u >= 2 && (o++, u /= 2), o + c >= p ? (s = 0, o = p) : o + c >= 1 ? (s = (e * u - 1) * Math.pow(2, i), o += c) : (s = e * Math.pow(2, c - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + f] = 255 & s, f += y, s /= 256, i -= 8);\n        for (o = o << i | s, l += i; l > 0; t[r + f] = 255 & o, f += y, o /= 256, l -= 8);\n        t[r + f - y] |= 128 * d;\n      },\n      $s = Ws;\n    function Ws(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n    Ws.Varint = 0, Ws.Fixed64 = 1, Ws.Bytes = 2, Ws.Fixed32 = 5;\n    var Qs = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");\n    function tu(t) {\n      return t.type === Ws.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n    function eu(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n    function ru(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n    }\n    function nu(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n    }\n    function iu(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n    }\n    function au(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n    }\n    function ou(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n    }\n    function su(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n    }\n    function uu(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n    }\n    function lu(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n    }\n    function pu(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n    }\n    function cu(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n    }\n    function hu(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n    function fu(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n    function yu(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n    function du(t, e, r) {\n      1 === t && r.readMessage(mu, e);\n    }\n    function mu(t, e, r) {\n      if (3 === t) {\n        var n = r.readMessage(vu, {}),\n          i = n.width,\n          a = n.height,\n          o = n.left,\n          s = n.top,\n          u = n.advance;\n        e.push({\n          id: n.id,\n          bitmap: new xo({\n            width: i + 6,\n            height: a + 6\n          }, n.bitmap),\n          metrics: {\n            width: i,\n            height: a,\n            left: o,\n            top: s,\n            advance: u\n          }\n        });\n      }\n    }\n    function vu(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n    function gu(t) {\n      for (var e = 0, r = 0, n = 0, i = t; n < i.length; n += 1) {\n        var a = i[n];\n        e += a.w * a.h, r = Math.max(r, a.w);\n      }\n      t.sort(function (t, e) {\n        return e.h - t.h;\n      });\n      for (var o = [{\n          x: 0,\n          y: 0,\n          w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n          h: 1 / 0\n        }], s = 0, u = 0, l = 0, p = t; l < p.length; l += 1) for (var c = p[l], h = o.length - 1; h >= 0; h--) {\n        var f = o[h];\n        if (!(c.w > f.w || c.h > f.h)) {\n          if (c.x = f.x, c.y = f.y, u = Math.max(u, c.y + c.h), s = Math.max(s, c.x + c.w), c.w === f.w && c.h === f.h) {\n            var y = o.pop();\n            h < o.length && (o[h] = y);\n          } else c.h === f.h ? (f.x += c.w, f.w -= c.w) : c.w === f.w ? (f.y += c.h, f.h -= c.h) : (o.push({\n            x: f.x + c.w,\n            y: f.y,\n            w: f.w - c.w,\n            h: c.h\n          }), f.y += c.h, f.h -= c.h);\n          break;\n        }\n      }\n      return {\n        w: s,\n        h: u,\n        fill: e / (s * u) || 0\n      };\n    }\n    Ws.prototype = {\n      destroy: function () {\n        this.buf = null;\n      },\n      readFields: function (t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n            i = n >> 3,\n            a = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === a && this.skip(n);\n        }\n        return e;\n      },\n      readMessage: function (t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function () {\n        var t = hu(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readSFixed32: function () {\n        var t = yu(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function () {\n        var t = hu(this.buf, this.pos) + 4294967296 * hu(this.buf, this.pos + 4);\n        return this.pos += 8, t;\n      },\n      readSFixed64: function () {\n        var t = hu(this.buf, this.pos) + 4294967296 * yu(this.buf, this.pos + 4);\n        return this.pos += 8, t;\n      },\n      readFloat: function () {\n        var t = Hs(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function () {\n        var t = Hs(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function (t) {\n        var e,\n          r,\n          n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n            i,\n            a = r.buf;\n          if (n = (112 & (i = a[r.pos++])) >> 4, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 3, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 10, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 17, i < 128) return eu(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 24, i < 128) return eu(t, n, e);\n          if (n |= (1 & (i = a[r.pos++])) << 31, i < 128) return eu(t, n, e);\n          throw new Error("Expected varint not more than 10 bytes");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function () {\n        return this.readVarint(!0);\n      },\n      readSVarint: function () {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function () {\n        return Boolean(this.readVarint());\n      },\n      readString: function () {\n        var t = this.readVarint() + this.pos,\n          e = this.pos;\n        return this.pos = t, t - e >= 12 && Qs ? function (t, e, r) {\n          return Qs.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = "", i = e; i < r;) {\n            var a,\n              o,\n              s,\n              u = t[i],\n              l = null,\n              p = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;\n            if (i + p > r) break;\n            1 === p ? u < 128 && (l = u) : 2 === p ? 128 == (192 & (a = t[i + 1])) && (l = (31 & u) << 6 | 63 & a) <= 127 && (l = null) : 3 === p ? (o = t[i + 2], 128 == (192 & (a = t[i + 1])) && 128 == (192 & o) && ((l = (15 & u) << 12 | (63 & a) << 6 | 63 & o) <= 2047 || l >= 55296 && l <= 57343) && (l = null)) : 4 === p && (o = t[i + 2], s = t[i + 3], 128 == (192 & (a = t[i + 1])) && 128 == (192 & o) && 128 == (192 & s) && ((l = (15 & u) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) <= 65535 || l >= 1114112) && (l = null)), null === l ? (l = 65533, p = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += p;\n          }\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function () {\n        var t = this.readVarint() + this.pos,\n          e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function (t, e) {\n        if (this.type !== Ws.Bytes) return t.push(this.readVarint(e));\n        var r = tu(this);\n        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));\n        return t;\n      },\n      readPackedSVarint: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readSVarint());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSVarint());\n        return t;\n      },\n      readPackedBoolean: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readBoolean());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readBoolean());\n        return t;\n      },\n      readPackedFloat: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readFloat());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFloat());\n        return t;\n      },\n      readPackedDouble: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readDouble());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readDouble());\n        return t;\n      },\n      readPackedFixed32: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readFixed32());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFixed32());\n        return t;\n      },\n      readPackedSFixed32: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readSFixed32());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());\n        return t;\n      },\n      readPackedFixed64: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readFixed64());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFixed64());\n        return t;\n      },\n      readPackedSFixed64: function (t) {\n        if (this.type !== Ws.Bytes) return t.push(this.readSFixed64());\n        var e = tu(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());\n        return t;\n      },\n      skip: function (t) {\n        var e = 7 & t;\n        if (e === Ws.Varint) for (; this.buf[this.pos++] > 127;);else if (e === Ws.Bytes) this.pos = this.readVarint() + this.pos;else if (e === Ws.Fixed32) this.pos += 4;else {\n          if (e !== Ws.Fixed64) throw new Error("Unimplemented type: " + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function (t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function (t) {\n        for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function () {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function (t) {\n        this.realloc(4), fu(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function (t) {\n        this.realloc(4), fu(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function (t) {\n        this.realloc(8), fu(this.buf, -1 & t, this.pos), fu(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function (t) {\n        this.realloc(8), fu(this.buf, -1 & t, this.pos), fu(this.buf, Math.floor(t * (1 / 4294967296)), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function (t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn\'t fit into 10 bytes");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function (t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function (t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function (t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n        this.pos = function (t, e, r) {\n          for (var n, i, a = 0; a < e.length; a++) {\n            if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || a + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n          return r;\n        }(this.buf, t, this.pos);\n        var r = this.pos - e;\n        r >= 128 && ru(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function (t) {\n        this.realloc(4), Ys(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function (t) {\n        this.realloc(8), Ys(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function (t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n      },\n      writeRawMessage: function (t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && ru(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function (t, e, r) {\n        this.writeTag(t, Ws.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function (t, e) {\n        e.length && this.writeMessage(t, nu, e);\n      },\n      writePackedSVarint: function (t, e) {\n        e.length && this.writeMessage(t, iu, e);\n      },\n      writePackedBoolean: function (t, e) {\n        e.length && this.writeMessage(t, su, e);\n      },\n      writePackedFloat: function (t, e) {\n        e.length && this.writeMessage(t, au, e);\n      },\n      writePackedDouble: function (t, e) {\n        e.length && this.writeMessage(t, ou, e);\n      },\n      writePackedFixed32: function (t, e) {\n        e.length && this.writeMessage(t, uu, e);\n      },\n      writePackedSFixed32: function (t, e) {\n        e.length && this.writeMessage(t, lu, e);\n      },\n      writePackedFixed64: function (t, e) {\n        e.length && this.writeMessage(t, pu, e);\n      },\n      writePackedSFixed64: function (t, e) {\n        e.length && this.writeMessage(t, cu, e);\n      },\n      writeBytesField: function (t, e) {\n        this.writeTag(t, Ws.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function (t, e) {\n        this.writeTag(t, Ws.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function (t, e) {\n        this.writeTag(t, Ws.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function (t, e) {\n        this.writeTag(t, Ws.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function (t, e) {\n        this.writeTag(t, Ws.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function (t, e) {\n        this.writeTag(t, Ws.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function (t, e) {\n        this.writeTag(t, Ws.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function (t, e) {\n        this.writeTag(t, Ws.Bytes), this.writeString(e);\n      },\n      writeFloatField: function (t, e) {\n        this.writeTag(t, Ws.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function (t, e) {\n        this.writeTag(t, Ws.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function (t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n    var xu = function (t, e) {\n        var r = e.pixelRatio,\n          n = e.version,\n          i = e.stretchX,\n          a = e.stretchY,\n          o = e.content;\n        this.paddedRect = t, this.pixelRatio = r, this.stretchX = i, this.stretchY = a, this.content = o, this.version = n;\n      },\n      bu = {\n        tl: {\n          configurable: !0\n        },\n        br: {\n          configurable: !0\n        },\n        tlbr: {\n          configurable: !0\n        },\n        displaySize: {\n          configurable: !0\n        }\n      };\n    bu.tl.get = function () {\n      return [this.paddedRect.x + 1, this.paddedRect.y + 1];\n    }, bu.br.get = function () {\n      return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];\n    }, bu.tlbr.get = function () {\n      return this.tl.concat(this.br);\n    }, bu.displaySize.get = function () {\n      return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];\n    }, Object.defineProperties(xu.prototype, bu);\n    var wu = function (t, e) {\n      var r = {},\n        n = {};\n      this.haveRenderCallbacks = [];\n      var i = [];\n      this.addImages(t, r, i), this.addImages(e, n, i);\n      var a = gu(i),\n        o = new bo({\n          width: a.w || 1,\n          height: a.h || 1\n        });\n      for (var s in t) {\n        var u = t[s],\n          l = r[s].paddedRect;\n        bo.copy(u.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: l.x + 1,\n          y: l.y + 1\n        }, u.data);\n      }\n      for (var p in e) {\n        var c = e[p],\n          h = n[p].paddedRect,\n          f = h.x + 1,\n          y = h.y + 1,\n          d = c.data.width,\n          m = c.data.height;\n        bo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f,\n          y: y\n        }, c.data), bo.copy(c.data, o, {\n          x: 0,\n          y: m - 1\n        }, {\n          x: f,\n          y: y - 1\n        }, {\n          width: d,\n          height: 1\n        }), bo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f,\n          y: y + m\n        }, {\n          width: d,\n          height: 1\n        }), bo.copy(c.data, o, {\n          x: d - 1,\n          y: 0\n        }, {\n          x: f - 1,\n          y: y\n        }, {\n          width: 1,\n          height: m\n        }), bo.copy(c.data, o, {\n          x: 0,\n          y: 0\n        }, {\n          x: f + d,\n          y: y\n        }, {\n          width: 1,\n          height: m\n        });\n      }\n      this.image = o, this.iconPositions = r, this.patternPositions = n;\n    };\n    wu.prototype.addImages = function (t, e, r) {\n      for (var n in t) {\n        var i = t[n],\n          a = {\n            x: 0,\n            y: 0,\n            w: i.data.width + 2,\n            h: i.data.height + 2\n          };\n        r.push(a), e[n] = new xu(a, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n      }\n    }, wu.prototype.patchUpdatedImages = function (t, e) {\n      for (var r in t.dispatchRenderCallbacks(this.haveRenderCallbacks), t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n    }, wu.prototype.patchUpdatedImage = function (t, e, r) {\n      if (t && e && t.version !== e.version) {\n        t.version = e.version;\n        var n = t.tl;\n        r.update(e.data, void 0, {\n          x: n[0],\n          y: n[1]\n        });\n      }\n    }, On("ImagePosition", xu), On("ImageAtlas", wu);\n    var _u = {\n        horizontal: 1,\n        vertical: 2,\n        horizontalOnly: 3\n      },\n      Au = function () {\n        this.scale = 1, this.fontStack = "", this.imageName = null;\n      };\n    Au.forText = function (t, e) {\n      var r = new Au();\n      return r.scale = t || 1, r.fontStack = e, r;\n    }, Au.forImage = function (t) {\n      var e = new Au();\n      return e.imageName = t, e;\n    };\n    var Su = function () {\n      this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n    };\n    function ku(t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d) {\n      var m,\n        v = Su.fromFeature(t, i);\n      c === _u.vertical && v.verticalizePunctuation();\n      var g = si.processBidirectionalText,\n        x = si.processStyledBidirectionalText;\n      if (g && 1 === v.sections.length) {\n        m = [];\n        for (var b = 0, w = g(v.toString(), Bu(v, l, a, e, n, f, y)); b < w.length; b += 1) {\n          var _ = w[b],\n            A = new Su();\n          A.text = _, A.sections = v.sections;\n          for (var S = 0; S < _.length; S++) A.sectionIndex.push(0);\n          m.push(A);\n        }\n      } else if (x) {\n        m = [];\n        for (var k = 0, I = x(v.text, v.sectionIndex, Bu(v, l, a, e, n, f, y)); k < I.length; k += 1) {\n          var z = I[k],\n            C = new Su();\n          C.text = z[0], C.sectionIndex = z[1], C.sections = v.sections, m.push(C);\n        }\n      } else m = function (t, e) {\n        for (var r = [], n = t.text, i = 0, a = 0, o = e; a < o.length; a += 1) {\n          var s = o[a];\n          r.push(t.substring(i, s)), i = s;\n        }\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(v, Bu(v, l, a, e, n, f, y));\n      var E = [],\n        P = {\n          positionedLines: E,\n          text: v.toString(),\n          top: p[1],\n          bottom: p[1],\n          left: p[0],\n          right: p[0],\n          writingMode: c,\n          iconsInText: !1,\n          verticalizable: !1\n        };\n      return function (t, e, r, n, i, a, o, s, u, l, p, c) {\n        for (var h = 0, f = -17, y = 0, d = 0, m = "right" === s ? 1 : "left" === s ? 0 : .5, v = 0, g = 0, x = i; g < x.length; g += 1) {\n          var b = x[g];\n          b.trim();\n          var w = b.getMaxScale(),\n            _ = 24 * (w - 1),\n            A = {\n              positionedGlyphs: [],\n              lineOffset: 0\n            };\n          t.positionedLines[v] = A;\n          var S = A.positionedGlyphs,\n            k = 0;\n          if (b.length()) {\n            for (var I = 0; I < b.length(); I++) {\n              var z = b.getSection(I),\n                C = b.getSectionIndex(I),\n                E = b.getCharCode(I),\n                P = 0,\n                M = null,\n                B = null,\n                T = null,\n                V = 24,\n                F = !(u === _u.horizontal || !p && !Jn(E) || p && (Iu[E] || (K = E, Zn.Arabic(K) || Zn["Arabic Supplement"](K) || Zn["Arabic Extended-A"](K) || Zn["Arabic Presentation Forms-A"](K) || Zn["Arabic Presentation Forms-B"](K))));\n              if (z.imageName) {\n                var D = n[z.imageName];\n                if (!D) continue;\n                T = z.imageName, t.iconsInText = t.iconsInText || !0, B = D.paddedRect;\n                var L = D.displaySize;\n                z.scale = 24 * z.scale / c, P = _ + (24 - L[1] * z.scale), V = (M = {\n                  width: L[0],\n                  height: L[1],\n                  left: 1,\n                  top: -3,\n                  advance: F ? L[1] : L[0]\n                }).advance;\n                var R = F ? L[0] * z.scale - 24 * w : L[1] * z.scale - 24 * w;\n                R > 0 && R > k && (k = R);\n              } else {\n                var O = r[z.fontStack],\n                  U = O && O[E];\n                if (U && U.rect) B = U.rect, M = U.metrics;else {\n                  var j = e[z.fontStack],\n                    q = j && j[E];\n                  if (!q) continue;\n                  M = q.metrics;\n                }\n                P = 24 * (w - z.scale);\n              }\n              F ? (t.verticalizable = !0, S.push({\n                glyph: E,\n                imageName: T,\n                x: h,\n                y: f + P,\n                vertical: F,\n                scale: z.scale,\n                fontStack: z.fontStack,\n                sectionIndex: C,\n                metrics: M,\n                rect: B\n              }), h += V * z.scale + l) : (S.push({\n                glyph: E,\n                imageName: T,\n                x: h,\n                y: f + P,\n                vertical: F,\n                scale: z.scale,\n                fontStack: z.fontStack,\n                sectionIndex: C,\n                metrics: M,\n                rect: B\n              }), h += M.advance * z.scale + l);\n            }\n            0 !== S.length && (y = Math.max(h - l, y), Vu(S, 0, S.length - 1, m, k)), h = 0;\n            var N = a * w + k;\n            A.lineOffset = Math.max(k, _), f += N, d = Math.max(N, d), ++v;\n          } else f += a, ++v;\n        }\n        var K,\n          G = f - -17,\n          Z = Tu(o),\n          X = Z.horizontalAlign,\n          J = Z.verticalAlign;\n        (function (t, e, r, n, i, a, o, s, u) {\n          var l,\n            p = (e - r) * i;\n          l = a !== o ? -s * n - -17 : (-n * u + .5) * o;\n          for (var c = 0, h = t; c < h.length; c += 1) for (var f = 0, y = h[c].positionedGlyphs; f < y.length; f += 1) {\n            var d = y[f];\n            d.x += p, d.y += l;\n          }\n        })(t.positionedLines, m, X, J, y, d, a, G, i.length), t.top += -J * G, t.bottom = t.top + G, t.left += -X * y, t.right = t.left + y;\n      }(P, e, r, n, m, o, s, u, c, l, h, d), !function (t) {\n        for (var e = 0, r = t; e < r.length; e += 1) if (0 !== r[e].positionedGlyphs.length) return !1;\n        return !0;\n      }(E) && P;\n    }\n    Su.fromFeature = function (t, e) {\n      for (var r = new Su(), n = 0; n < t.sections.length; n++) {\n        var i = t.sections[n];\n        i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n      }\n      return r;\n    }, Su.prototype.length = function () {\n      return this.text.length;\n    }, Su.prototype.getSection = function (t) {\n      return this.sections[this.sectionIndex[t]];\n    }, Su.prototype.getSectionIndex = function (t) {\n      return this.sectionIndex[t];\n    }, Su.prototype.getCharCode = function (t) {\n      return this.text.charCodeAt(t);\n    }, Su.prototype.verticalizePunctuation = function () {\n      this.text = function (t) {\n        for (var e = "", r = 0; r < t.length; r++) {\n          var n = t.charCodeAt(r + 1) || null,\n            i = t.charCodeAt(r - 1) || null;\n          e += n && Hn(n) && !Js[t[r + 1]] || i && Hn(i) && !Js[t[r - 1]] || !Js[t[r]] ? t[r] : Js[t[r]];\n        }\n        return e;\n      }(this.text);\n    }, Su.prototype.trim = function () {\n      for (var t = 0, e = 0; e < this.text.length && Iu[this.text.charCodeAt(e)]; e++) t++;\n      for (var r = this.text.length, n = this.text.length - 1; n >= 0 && n >= t && Iu[this.text.charCodeAt(n)]; n--) r--;\n      this.text = this.text.substring(t, r), this.sectionIndex = this.sectionIndex.slice(t, r);\n    }, Su.prototype.substring = function (t, e) {\n      var r = new Su();\n      return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n    }, Su.prototype.toString = function () {\n      return this.text;\n    }, Su.prototype.getMaxScale = function () {\n      var t = this;\n      return this.sectionIndex.reduce(function (e, r) {\n        return Math.max(e, t.sections[r].scale);\n      }, 0);\n    }, Su.prototype.addTextSection = function (t, e) {\n      this.text += t.text, this.sections.push(Au.forText(t.scale, t.fontStack || e));\n      for (var r = this.sections.length - 1, n = 0; n < t.text.length; ++n) this.sectionIndex.push(r);\n    }, Su.prototype.addImageSection = function (t) {\n      var e = t.image ? t.image.name : "";\n      if (0 !== e.length) {\n        var r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCharCode(r), this.sections.push(Au.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");\n      } else A("Can\'t add FormattedSection with an empty image.");\n    }, Su.prototype.getNextImageSectionCharCode = function () {\n      return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n    };\n    var Iu = {\n        9: !0,\n        10: !0,\n        11: !0,\n        12: !0,\n        13: !0,\n        32: !0\n      },\n      zu = {};\n    function Cu(t, e, r, n, i, a) {\n      if (e.imageName) {\n        var o = n[e.imageName];\n        return o ? o.displaySize[0] * e.scale * 24 / a + i : 0;\n      }\n      var s = r[e.fontStack],\n        u = s && s[t];\n      return u ? u.metrics.advance * e.scale + i : 0;\n    }\n    function Eu(t, e, r, n) {\n      var i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n    function Pu(t, e, r) {\n      var n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n    function Mu(t, e, r, n, i, a) {\n      for (var o = null, s = Eu(e, r, i, a), u = 0, l = n; u < l.length; u += 1) {\n        var p = l[u],\n          c = Eu(e - p.x, r, i, a) + p.badness;\n        c <= s && (o = p, s = c);\n      }\n      return {\n        index: t,\n        x: e,\n        priorBreak: o,\n        badness: s\n      };\n    }\n    function Bu(t, e, r, n, i, a, o) {\n      if ("point" !== a) return [];\n      if (!t) return [];\n      for (var s, u = [], l = function (t, e, r, n, i, a) {\n          for (var o = 0, s = 0; s < t.length(); s++) {\n            var u = t.getSection(s);\n            o += Cu(t.getCharCode(s), u, n, i, e, a);\n          }\n          return o / Math.max(1, Math.ceil(o / r));\n        }(t, e, r, n, i, o), p = t.text.indexOf("") >= 0, c = 0, h = 0; h < t.length(); h++) {\n        var f = t.getSection(h),\n          y = t.getCharCode(h);\n        if (Iu[y] || (c += Cu(y, f, n, i, e, o)), h < t.length() - 1) {\n          var d = !((s = y) < 11904 || !(Zn["Bopomofo Extended"](s) || Zn.Bopomofo(s) || Zn["CJK Compatibility Forms"](s) || Zn["CJK Compatibility Ideographs"](s) || Zn["CJK Compatibility"](s) || Zn["CJK Radicals Supplement"](s) || Zn["CJK Strokes"](s) || Zn["CJK Symbols and Punctuation"](s) || Zn["CJK Unified Ideographs Extension A"](s) || Zn["CJK Unified Ideographs"](s) || Zn["Enclosed CJK Letters and Months"](s) || Zn["Halfwidth and Fullwidth Forms"](s) || Zn.Hiragana(s) || Zn["Ideographic Description Characters"](s) || Zn["Kangxi Radicals"](s) || Zn["Katakana Phonetic Extensions"](s) || Zn.Katakana(s) || Zn["Vertical Forms"](s) || Zn["Yi Radicals"](s) || Zn["Yi Syllables"](s)));\n          (zu[y] || d || f.imageName) && u.push(Mu(h + 1, c, l, u, Pu(y, t.getCharCode(h + 1), d && p), !1));\n        }\n      }\n      return function t(e) {\n        return e ? t(e.priorBreak).concat(e.index) : [];\n      }(Mu(t.length(), c, l, u, 0, !0));\n    }\n    function Tu(t) {\n      var e = .5,\n        r = .5;\n      switch (t) {\n        case "right":\n        case "top-right":\n        case "bottom-right":\n          e = 1;\n          break;\n        case "left":\n        case "top-left":\n        case "bottom-left":\n          e = 0;\n      }\n      switch (t) {\n        case "bottom":\n        case "bottom-right":\n        case "bottom-left":\n          r = 1;\n          break;\n        case "top":\n        case "top-right":\n        case "top-left":\n          r = 0;\n      }\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n    function Vu(t, e, r, n, i) {\n      if (n || i) for (var a = t[r], o = (t[r].x + a.metrics.advance * a.scale) * n, s = e; s <= r; s++) t[s].x -= o, t[s].y += i;\n    }\n    function Fu(t, e, r, n, i, a) {\n      var o,\n        s = t.image;\n      if (s.content) {\n        var u = s.content,\n          l = s.pixelRatio || 1;\n        o = [u[0] / l, u[1] / l, s.displaySize[0] - u[2] / l, s.displaySize[1] - u[3] / l];\n      }\n      var p,\n        c,\n        h,\n        f,\n        y = e.left * a,\n        d = e.right * a;\n      "width" === r || "both" === r ? (f = i[0] + y - n[3], c = i[0] + d + n[1]) : c = (f = i[0] + (y + d - s.displaySize[0]) / 2) + s.displaySize[0];\n      var m = e.top * a,\n        v = e.bottom * a;\n      return "height" === r || "both" === r ? (p = i[1] + m - n[0], h = i[1] + v + n[2]) : h = (p = i[1] + (m + v - s.displaySize[1]) / 2) + s.displaySize[1], {\n        image: s,\n        top: p,\n        right: c,\n        bottom: h,\n        left: f,\n        collisionPadding: o\n      };\n    }\n    zu[10] = !0, zu[32] = !0, zu[38] = !0, zu[40] = !0, zu[41] = !0, zu[43] = !0, zu[45] = !0, zu[47] = !0, zu[173] = !0, zu[183] = !0, zu[8203] = !0, zu[8208] = !0, zu[8211] = !0, zu[8231] = !0;\n    var Du = function (t) {\n      function e(e, r, n, i) {\n        t.call(this, e, r), this.angle = n, void 0 !== i && (this.segment = i);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.clone = function () {\n        return new e(this.x, this.y, this.angle, this.segment);\n      }, e;\n    }(i);\n    function Lu(t, e) {\n      var r = e.expression;\n      if ("constant" === r.kind) return {\n        kind: "constant",\n        layoutSize: r.evaluate(new ui(t + 1))\n      };\n      if ("source" === r.kind) return {\n        kind: "source"\n      };\n      for (var n = r.zoomStops, i = r.interpolationType, a = 0; a < n.length && n[a] <= t;) a++;\n      for (var o = a = Math.max(0, a - 1); o < n.length && n[o] < t + 1;) o++;\n      o = Math.min(n.length - 1, o);\n      var s = n[a],\n        u = n[o];\n      return "composite" === r.kind ? {\n        kind: "composite",\n        minZoom: s,\n        maxZoom: u,\n        interpolationType: i\n      } : {\n        kind: "camera",\n        minZoom: s,\n        maxZoom: u,\n        minSize: r.evaluate(new ui(s)),\n        maxSize: r.evaluate(new ui(u)),\n        interpolationType: i\n      };\n    }\n    function Ru(t, e, r) {\n      var n = e.uSize,\n        i = r.lowerSize;\n      return "source" === t.kind ? i / 128 : "composite" === t.kind ? Ge(i / 128, r.upperSize / 128, e.uSizeT) : n;\n    }\n    function Ou(t, e) {\n      var r = 0,\n        n = 0;\n      if ("constant" === t.kind) n = t.layoutSize;else if ("source" !== t.kind) {\n        var i = t.interpolationType,\n          a = i ? p(or.interpolationFactor(i, e, t.minZoom, t.maxZoom), 0, 1) : 0;\n        "camera" === t.kind ? n = Ge(t.minSize, t.maxSize, a) : r = a;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n    On("Anchor", Du);\n    var Uu = Object.freeze({\n      __proto__: null,\n      getSizeData: Lu,\n      evaluateSizeForFeature: Ru,\n      evaluateSizeForZoom: Ou,\n      SIZE_PACK_FACTOR: 128\n    });\n    function ju(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      for (var a = e, o = e.segment + 1, s = 0; s > -r / 2;) {\n        if (--o < 0) return !1;\n        s -= t[o].dist(a), a = t[o];\n      }\n      s += t[o].dist(t[o + 1]), o++;\n      for (var u = [], l = 0; s < r / 2;) {\n        var p = t[o],\n          c = t[o + 1];\n        if (!c) return !1;\n        var h = t[o - 1].angleTo(p) - p.angleTo(c);\n        for (h = Math.abs((h + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u.push({\n          distance: s,\n          angleDelta: h\n        }), l += h; s - u[0].distance > n;) l -= u.shift().angleDelta;\n        if (l > i) return !1;\n        o++, s += p.dist(c);\n      }\n      return !0;\n    }\n    function qu(t) {\n      for (var e = 0, r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n      return e;\n    }\n    function Nu(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n    function Ku(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n    function Gu(t, e, r, n, i, a) {\n      for (var o = Nu(r, i, a), s = Ku(r, n) * a, u = 0, l = qu(t) / 2, p = 0; p < t.length - 1; p++) {\n        var c = t[p],\n          h = t[p + 1],\n          f = c.dist(h);\n        if (u + f > l) {\n          var y = (l - u) / f,\n            d = Ge(c.x, h.x, y),\n            m = Ge(c.y, h.y, y),\n            v = new Du(d, m, h.angleTo(c), p);\n          return v._round(), !o || ju(t, v, s, o, e) ? v : void 0;\n        }\n        u += f;\n      }\n    }\n    function Zu(t, e, r, n, i, a, o, s, u) {\n      var l = Nu(n, a, o),\n        p = Ku(n, i),\n        c = p * o,\n        h = 0 === t[0].x || t[0].x === u || 0 === t[0].y || t[0].y === u;\n      return e - c < e / 4 && (e = c + e / 4), function t(e, r, n, i, a, o, s, u, l) {\n        for (var p = o / 2, c = qu(e), h = 0, f = r - n, y = [], d = 0; d < e.length - 1; d++) {\n          for (var m = e[d], v = e[d + 1], g = m.dist(v), x = v.angleTo(m); f + n < h + g;) {\n            var b = ((f += n) - h) / g,\n              w = Ge(m.x, v.x, b),\n              _ = Ge(m.y, v.y, b);\n            if (w >= 0 && w < l && _ >= 0 && _ < l && f - p >= 0 && f + p <= c) {\n              var A = new Du(w, _, x, d);\n              A._round(), i && !ju(e, A, o, i, a) || y.push(A);\n            }\n          }\n          h += g;\n        }\n        return u || y.length || s || (y = t(e, h / 2, n, i, a, o, s, !0, l)), y;\n      }(t, h ? e / 2 * s % e : (p / 2 + 2 * a) * o * s % e, e, l, r, c, h, !1, u);\n    }\n    function Xu(t, e, r, n, a) {\n      for (var o = [], s = 0; s < t.length; s++) for (var u = t[s], l = void 0, p = 0; p < u.length - 1; p++) {\n        var c = u[p],\n          h = u[p + 1];\n        c.x < e && h.x < e || (c.x < e ? c = new i(e, c.y + (e - c.x) / (h.x - c.x) * (h.y - c.y))._round() : h.x < e && (h = new i(e, c.y + (e - c.x) / (h.x - c.x) * (h.y - c.y))._round()), c.y < r && h.y < r || (c.y < r ? c = new i(c.x + (r - c.y) / (h.y - c.y) * (h.x - c.x), r)._round() : h.y < r && (h = new i(c.x + (r - c.y) / (h.y - c.y) * (h.x - c.x), r)._round()), c.x >= n && h.x >= n || (c.x >= n ? c = new i(n, c.y + (n - c.x) / (h.x - c.x) * (h.y - c.y))._round() : h.x >= n && (h = new i(n, c.y + (n - c.x) / (h.x - c.x) * (h.y - c.y))._round()), c.y >= a && h.y >= a || (c.y >= a ? c = new i(c.x + (a - c.y) / (h.y - c.y) * (h.x - c.x), a)._round() : h.y >= a && (h = new i(c.x + (a - c.y) / (h.y - c.y) * (h.x - c.x), a)._round()), l && c.equals(l[l.length - 1]) || o.push(l = [c]), l.push(h)))));\n      }\n      return o;\n    }\n    function Ju(t, e, r, n) {\n      var a = [],\n        o = t.image,\n        s = o.pixelRatio,\n        u = o.paddedRect.w - 2,\n        l = o.paddedRect.h - 2,\n        p = t.right - t.left,\n        c = t.bottom - t.top,\n        h = o.stretchX || [[0, u]],\n        f = o.stretchY || [[0, l]],\n        y = function (t, e) {\n          return t + e[1] - e[0];\n        },\n        d = h.reduce(y, 0),\n        m = f.reduce(y, 0),\n        v = u - d,\n        g = l - m,\n        x = 0,\n        b = d,\n        w = 0,\n        _ = m,\n        A = 0,\n        S = v,\n        k = 0,\n        I = g;\n      if (o.content && n) {\n        var z = o.content;\n        x = Hu(h, 0, z[0]), w = Hu(f, 0, z[1]), b = Hu(h, z[0], z[2]), _ = Hu(f, z[1], z[3]), A = z[0] - x, k = z[1] - w, S = z[2] - z[0] - b, I = z[3] - z[1] - _;\n      }\n      var C = function (n, a, u, l) {\n        var h = $u(n.stretch - x, b, p, t.left),\n          f = Wu(n.fixed - A, S, n.stretch, d),\n          y = $u(a.stretch - w, _, c, t.top),\n          v = Wu(a.fixed - k, I, a.stretch, m),\n          g = $u(u.stretch - x, b, p, t.left),\n          z = Wu(u.fixed - A, S, u.stretch, d),\n          C = $u(l.stretch - w, _, c, t.top),\n          E = Wu(l.fixed - k, I, l.stretch, m),\n          P = new i(h, y),\n          M = new i(g, y),\n          B = new i(g, C),\n          T = new i(h, C),\n          V = new i(f / s, v / s),\n          F = new i(z / s, E / s),\n          D = e * Math.PI / 180;\n        if (D) {\n          var L = Math.sin(D),\n            R = Math.cos(D),\n            O = [R, -L, L, R];\n          P._matMult(O), M._matMult(O), T._matMult(O), B._matMult(O);\n        }\n        var U = n.stretch + n.fixed,\n          j = a.stretch + a.fixed;\n        return {\n          tl: P,\n          tr: M,\n          bl: T,\n          br: B,\n          tex: {\n            x: o.paddedRect.x + 1 + U,\n            y: o.paddedRect.y + 1 + j,\n            w: u.stretch + u.fixed - U,\n            h: l.stretch + l.fixed - j\n          },\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: V,\n          pixelOffsetBR: F,\n          minFontScaleX: S / s / p,\n          minFontScaleY: I / s / c,\n          isSDF: r\n        };\n      };\n      if (n && (o.stretchX || o.stretchY)) for (var E = Yu(h, v, d), P = Yu(f, g, m), M = 0; M < E.length - 1; M++) for (var B = E[M], T = E[M + 1], V = 0; V < P.length - 1; V++) a.push(C(B, P[V], T, P[V + 1]));else a.push(C({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: u + 1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }));\n      return a;\n    }\n    function Hu(t, e, r) {\n      for (var n = 0, i = 0, a = t; i < a.length; i += 1) {\n        var o = a[i];\n        n += Math.max(e, Math.min(r, o[1])) - Math.max(e, Math.min(r, o[0]));\n      }\n      return n;\n    }\n    function Yu(t, e, r) {\n      for (var n = [{\n          fixed: -1,\n          stretch: 0\n        }], i = 0, a = t; i < a.length; i += 1) {\n        var o = a[i],\n          s = o[0],\n          u = o[1],\n          l = n[n.length - 1];\n        n.push({\n          fixed: s - l.stretch,\n          stretch: l.stretch\n        }), n.push({\n          fixed: s - l.stretch,\n          stretch: l.stretch + (u - s)\n        });\n      }\n      return n.push({\n        fixed: e + 1,\n        stretch: r\n      }), n;\n    }\n    function $u(t, e, r, n) {\n      return t / e * r + n;\n    }\n    function Wu(t, e, r, n) {\n      return t - e * r / n;\n    }\n    var Qu = function (t, e, r, n, a, o, s, u, l, p) {\n        if (this.boxStartIndex = t.length, l) {\n          var c = o.top,\n            h = o.bottom,\n            f = o.collisionPadding;\n          f && (c -= f[1], h += f[3]);\n          var y = h - c;\n          y > 0 && (y = Math.max(10, y), this.circleDiameter = y);\n        } else {\n          var d = o.top * s - u,\n            m = o.bottom * s + u,\n            v = o.left * s - u,\n            g = o.right * s + u,\n            x = o.collisionPadding;\n          if (x && (v -= x[0] * s, d -= x[1] * s, g += x[2] * s, m += x[3] * s), p) {\n            var b = new i(v, d),\n              w = new i(g, d),\n              _ = new i(v, m),\n              A = new i(g, m),\n              S = p * Math.PI / 180;\n            b._rotate(S), w._rotate(S), _._rotate(S), A._rotate(S), v = Math.min(b.x, w.x, _.x, A.x), g = Math.max(b.x, w.x, _.x, A.x), d = Math.min(b.y, w.y, _.y, A.y), m = Math.max(b.y, w.y, _.y, A.y);\n          }\n          t.emplaceBack(e.x, e.y, v, d, g, m, r, n, a);\n        }\n        this.boxEndIndex = t.length;\n      },\n      tl = function (t, e) {\n        if (void 0 === t && (t = []), void 0 === e && (e = el), this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (var r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);\n      };\n    function el(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function rl(t, e, r) {\n      void 0 === e && (e = 1), void 0 === r && (r = !1);\n      for (var n = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, u = t[0], l = 0; l < u.length; l++) {\n        var p = u[l];\n        (!l || p.x < n) && (n = p.x), (!l || p.y < a) && (a = p.y), (!l || p.x > o) && (o = p.x), (!l || p.y > s) && (s = p.y);\n      }\n      var c = Math.min(o - n, s - a),\n        h = c / 2,\n        f = new tl([], nl);\n      if (0 === c) return new i(n, a);\n      for (var y = n; y < o; y += c) for (var d = a; d < s; d += c) f.push(new il(y + h, d + h, h, t));\n      for (var m = function (t) {\n          for (var e = 0, r = 0, n = 0, i = t[0], a = 0, o = i.length, s = o - 1; a < o; s = a++) {\n            var u = i[a],\n              l = i[s],\n              p = u.x * l.y - l.x * u.y;\n            r += (u.x + l.x) * p, n += (u.y + l.y) * p, e += 3 * p;\n          }\n          return new il(r / e, n / e, 0, t);\n        }(t), v = f.length; f.length;) {\n        var g = f.pop();\n        (g.d > m.d || !m.d) && (m = g, r && console.log("found best %d after %d probes", Math.round(1e4 * g.d) / 1e4, v)), g.max - m.d <= e || (f.push(new il(g.p.x - (h = g.h / 2), g.p.y - h, h, t)), f.push(new il(g.p.x + h, g.p.y - h, h, t)), f.push(new il(g.p.x - h, g.p.y + h, h, t)), f.push(new il(g.p.x + h, g.p.y + h, h, t)), v += 4);\n      }\n      return r && (console.log("num probes: " + v), console.log("best distance: " + m.d)), m.p;\n    }\n    function nl(t, e) {\n      return e.max - t.max;\n    }\n    function il(t, e, r, n) {\n      this.p = new i(t, e), this.h = r, this.d = function (t, e) {\n        for (var r = !1, n = 1 / 0, i = 0; i < e.length; i++) for (var a = e[i], o = 0, s = a.length, u = s - 1; o < s; u = o++) {\n          var l = a[o],\n            p = a[u];\n          l.y > t.y != p.y > t.y && t.x < (p.x - l.x) * (t.y - l.y) / (p.y - l.y) + l.x && (r = !r), n = Math.min(n, $a(t, l, p));\n        }\n        return (r ? 1 : -1) * Math.sqrt(n);\n      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n    }\n    tl.prototype.push = function (t) {\n      this.data.push(t), this.length++, this._up(this.length - 1);\n    }, tl.prototype.pop = function () {\n      if (0 !== this.length) {\n        var t = this.data[0],\n          e = this.data.pop();\n        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n    }, tl.prototype.peek = function () {\n      return this.data[0];\n    }, tl.prototype._up = function (t) {\n      for (var e = this.data, r = this.compare, n = e[t]; t > 0;) {\n        var i = t - 1 >> 1,\n          a = e[i];\n        if (r(n, a) >= 0) break;\n        e[t] = a, t = i;\n      }\n      e[t] = n;\n    }, tl.prototype._down = function (t) {\n      for (var e = this.data, r = this.compare, n = this.length >> 1, i = e[t]; t < n;) {\n        var a = 1 + (t << 1),\n          o = e[a],\n          s = a + 1;\n        if (s < this.length && r(e[s], o) < 0 && (a = s, o = e[s]), r(o, i) >= 0) break;\n        e[t] = o, t = a;\n      }\n      e[t] = i;\n    };\n    var al = Number.POSITIVE_INFINITY;\n    function ol(t, e) {\n      return e[1] !== al ? function (t, e, r) {\n        var n = 0,\n          i = 0;\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case "top-right":\n          case "top-left":\n          case "top":\n            i = r - 7;\n            break;\n          case "bottom-right":\n          case "bottom-left":\n          case "bottom":\n            i = 7 - r;\n        }\n        switch (t) {\n          case "top-right":\n          case "bottom-right":\n          case "right":\n            n = -e;\n            break;\n          case "top-left":\n          case "bottom-left":\n          case "left":\n            n = e;\n        }\n        return [n, i];\n      }(t, e[0], e[1]) : function (t, e) {\n        var r = 0,\n          n = 0;\n        e < 0 && (e = 0);\n        var i = e / Math.sqrt(2);\n        switch (t) {\n          case "top-right":\n          case "top-left":\n            n = i - 7;\n            break;\n          case "bottom-right":\n          case "bottom-left":\n            n = 7 - i;\n            break;\n          case "bottom":\n            n = 7 - e;\n            break;\n          case "top":\n            n = e - 7;\n        }\n        switch (t) {\n          case "top-right":\n          case "bottom-right":\n            r = -i;\n            break;\n          case "top-left":\n          case "bottom-left":\n            r = i;\n            break;\n          case "left":\n            r = e;\n            break;\n          case "right":\n            r = -e;\n        }\n        return [r, n];\n      }(t, e[0]);\n    }\n    function sl(t) {\n      switch (t) {\n        case "right":\n        case "top-right":\n        case "bottom-right":\n          return "right";\n        case "left":\n        case "top-left":\n        case "bottom-left":\n          return "left";\n      }\n      return "center";\n    }\n    function ul(t, e, r, n, a, o, s, u, l, p, c, h, f, y, d) {\n      var m = function (t, e, r, n, a, o, s, u) {\n          for (var l = n.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180, p = [], c = 0, h = e.positionedLines; c < h.length; c += 1) for (var f = h[c], y = 0, d = f.positionedGlyphs; y < d.length; y += 1) {\n            var m = d[y];\n            if (m.rect) {\n              var v = m.rect || {},\n                g = 4,\n                x = !0,\n                b = 1,\n                w = 0,\n                _ = (a || u) && m.vertical,\n                A = m.metrics.advance * m.scale / 2;\n              if (u && e.verticalizable && (w = f.lineOffset / 2 - (m.imageName ? -(24 - m.metrics.width * m.scale) / 2 : 24 * (m.scale - 1))), m.imageName) {\n                var S = s[m.imageName];\n                x = S.sdf, g = 1 / (b = S.pixelRatio);\n              }\n              var k = a ? [m.x + A, m.y] : [0, 0],\n                I = a ? [0, 0] : [m.x + A + r[0], m.y + r[1] - w],\n                z = [0, 0];\n              _ && (z = I, I = [0, 0]);\n              var C = (m.metrics.left - g) * m.scale - A + I[0],\n                E = (-m.metrics.top - g) * m.scale + I[1],\n                P = C + v.w * m.scale / b,\n                M = E + v.h * m.scale / b,\n                B = new i(C, E),\n                T = new i(P, E),\n                V = new i(C, M),\n                F = new i(P, M);\n              if (_) {\n                var D = new i(-A, A - -17),\n                  L = -Math.PI / 2,\n                  R = 12 - A,\n                  O = new i(22 - R, -(m.imageName ? R : 0)),\n                  U = new (Function.prototype.bind.apply(i, [null].concat(z)))();\n                B._rotateAround(L, D)._add(O)._add(U), T._rotateAround(L, D)._add(O)._add(U), V._rotateAround(L, D)._add(O)._add(U), F._rotateAround(L, D)._add(O)._add(U);\n              }\n              if (l) {\n                var j = Math.sin(l),\n                  q = Math.cos(l),\n                  N = [q, -j, j, q];\n                B._matMult(N), T._matMult(N), V._matMult(N), F._matMult(N);\n              }\n              var K = new i(0, 0),\n                G = new i(0, 0);\n              p.push({\n                tl: B,\n                tr: T,\n                bl: V,\n                br: F,\n                tex: v,\n                writingMode: e.writingMode,\n                glyphOffset: k,\n                sectionIndex: m.sectionIndex,\n                isSDF: x,\n                pixelOffsetTL: K,\n                pixelOffsetBR: G,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n          return p;\n        }(0, r, u, a, o, s, n, t.allowVerticalPlacement),\n        v = t.textSizeData,\n        g = null;\n      "source" === v.kind ? (g = [128 * a.layout.get("text-size").evaluate(s, {})])[0] > 32640 && A(t.layerIds[0] + \': Value for "text-size" is >= 255. Reduce your "text-size".\') : "composite" === v.kind && ((g = [128 * y.compositeTextSizes[0].evaluate(s, {}, d), 128 * y.compositeTextSizes[1].evaluate(s, {}, d)])[0] > 32640 || g[1] > 32640) && A(t.layerIds[0] + \': Value for "text-size" is >= 255. Reduce your "text-size".\'), t.addSymbols(t.text, m, g, u, o, s, p, e, l.lineStartIndex, l.lineLength, f, d);\n      for (var x = 0, b = c; x < b.length; x += 1) h[b[x]] = t.text.placedSymbolArray.length - 1;\n      return 4 * m.length;\n    }\n    function ll(t) {\n      for (var e in t) return t[e];\n      return null;\n    }\n    function pl(t, e, r, n) {\n      var i = t.compareText;\n      if (e in i) {\n        for (var a = i[e], o = a.length - 1; o >= 0; o--) if (n.dist(a[o]) < r) return !0;\n      } else i[e] = [];\n      return i[e].push(n), !1;\n    }\n    var cl = ws.VectorTileFeature.types,\n      hl = [{\n        name: "a_fade_opacity",\n        components: 1,\n        type: "Uint8",\n        offset: 0\n      }];\n    function fl(t, e, r, n, i, a, o, s, u, l, p, c, h) {\n      var f = s ? Math.min(32640, Math.round(s[0])) : 0,\n        y = s ? Math.min(32640, Math.round(s[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), a, o, (f << 1) + (u ? 1 : 0), y, 16 * l, 16 * p, 256 * c, 256 * h);\n    }\n    function yl(t, e, r) {\n      t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);\n    }\n    function dl(t) {\n      for (var e = 0, r = t.sections; e < r.length; e += 1) if (Wn(r[e].text)) return !0;\n      return !1;\n    }\n    var ml = function (t) {\n      this.layoutVertexArray = new Fi(), this.indexArray = new qi(), this.programConfigurations = t, this.segments = new ua(), this.dynamicLayoutVertexArray = new Di(), this.opacityVertexArray = new Li(), this.placedSymbolArray = new ta();\n    };\n    ml.prototype.isEmpty = function () {\n      return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n    }, ml.prototype.upload = function (t, e, r, n) {\n      this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, qs.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Ns.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, hl, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n    }, ml.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());\n    }, On("SymbolBuffers", ml);\n    var vl = function (t, e, r) {\n      this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new ua(), this.collisionVertexArray = new ji();\n    };\n    vl.prototype.upload = function (t) {\n      this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Ks.members, !0);\n    }, vl.prototype.destroy = function () {\n      this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());\n    }, On("CollisionBuffers", vl);\n    var gl = function (t) {\n      this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(function (t) {\n        return t.id;\n      }), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = so([]), this.placementViewportMatrix = so([]);\n      var e = this.layers[0]._unevaluatedLayout._values;\n      this.textSizeData = Lu(this.zoom, e["text-size"]), this.iconSizeData = Lu(this.zoom, e["icon-size"]);\n      var r = this.layers[0].layout,\n        n = r.get("symbol-sort-key"),\n        i = r.get("symbol-z-order");\n      this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && !n.isConstant(), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, "point" === r.get("symbol-placement") && (this.writingModes = r.get("text-writing-mode").map(function (t) {\n        return _u[t];\n      })), this.stateDependentLayerIds = this.layers.filter(function (t) {\n        return t.isStateDependent();\n      }).map(function (t) {\n        return t.id;\n      }), this.sourceID = t.sourceID;\n    };\n    gl.prototype.createArrays = function () {\n      this.text = new ml(new Fa(this.layers, this.zoom, function (t) {\n        return /^text/.test(t);\n      })), this.icon = new ml(new Fa(this.layers, this.zoom, function (t) {\n        return /^icon/.test(t);\n      })), this.glyphOffsetArray = new na(), this.lineVertexArray = new ia(), this.symbolInstances = new ra();\n    }, gl.prototype.calculateGlyphDependencies = function (t, e, r, n, i) {\n      for (var a = 0; a < t.length; a++) if (e[t.charCodeAt(a)] = !0, (r || n) && i) {\n        var o = Js[t.charAt(a)];\n        o && (e[o.charCodeAt(0)] = !0);\n      }\n    }, gl.prototype.populate = function (t, e, r) {\n      var n = this.layers[0],\n        i = n.layout,\n        a = i.get("text-font"),\n        o = i.get("text-field"),\n        s = i.get("icon-image"),\n        u = ("constant" !== o.value.kind || o.value.value instanceof ie && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0),\n        l = "constant" !== s.value.kind || !!s.value.value || Object.keys(s.parameters).length > 0,\n        p = i.get("symbol-sort-key");\n      if (this.features = [], u || l) {\n        for (var c = e.iconDependencies, h = e.glyphDependencies, f = e.availableImages, y = new ui(this.zoom), d = 0, m = t; d < m.length; d += 1) {\n          var v = m[d],\n            g = v.feature,\n            x = v.id,\n            b = v.index,\n            w = v.sourceLayerIndex,\n            _ = n._featureFilter.needGeometry,\n            A = ja(g, _);\n          if (n._featureFilter.filter(y, A, r)) {\n            _ || (A.geometry = Ua(g));\n            var S = void 0;\n            if (u) {\n              var k = n.getValueAndResolveTokens("text-field", A, r, f),\n                I = ie.factory(k);\n              dl(I) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === ai() || this.hasRTLText && si.isParsed()) && (S = Xs(I, n, A));\n            }\n            var z = void 0;\n            if (l) {\n              var C = n.getValueAndResolveTokens("icon-image", A, r, f);\n              z = C instanceof ae ? C : ae.fromString(C);\n            }\n            if (S || z) {\n              var E = this.sortFeaturesByKey ? p.evaluate(A, {}, r) : void 0;\n              if (this.features.push({\n                id: x,\n                text: S,\n                icon: z,\n                index: b,\n                sourceLayerIndex: w,\n                geometry: A.geometry,\n                properties: g.properties,\n                type: cl[g.type],\n                sortKey: E\n              }), z && (c[z.name] = !0), S) {\n                var P = a.evaluate(A, {}, r).join(","),\n                  M = "map" === i.get("text-rotation-alignment") && "point" !== i.get("symbol-placement");\n                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(_u.vertical) >= 0;\n                for (var B = 0, T = S.sections; B < T.length; B += 1) {\n                  var V = T[B];\n                  if (V.image) c[V.image.name] = !0;else {\n                    var F = Xn(S.toString()),\n                      D = V.fontStack || P,\n                      L = h[D] = h[D] || {};\n                    this.calculateGlyphDependencies(V.text, L, M, this.allowVerticalPlacement, F);\n                  }\n                }\n              }\n            }\n          }\n        }\n        "line" === i.get("symbol-placement") && (this.features = function (t) {\n          var e = {},\n            r = {},\n            n = [],\n            i = 0;\n          function a(e) {\n            n.push(t[e]), i++;\n          }\n          function o(t, e, i) {\n            var a = r[t];\n            return delete r[t], r[e] = a, n[a].geometry[0].pop(), n[a].geometry[0] = n[a].geometry[0].concat(i[0]), a;\n          }\n          function s(t, r, i) {\n            var a = e[r];\n            return delete e[r], e[t] = a, n[a].geometry[0].shift(), n[a].geometry[0] = i[0].concat(n[a].geometry[0]), a;\n          }\n          function u(t, e, r) {\n            var n = r ? e[0][e[0].length - 1] : e[0][0];\n            return t + ":" + n.x + ":" + n.y;\n          }\n          for (var l = 0; l < t.length; l++) {\n            var p = t[l],\n              c = p.geometry,\n              h = p.text ? p.text.toString() : null;\n            if (h) {\n              var f = u(h, c),\n                y = u(h, c, !0);\n              if (f in r && y in e && r[f] !== e[y]) {\n                var d = s(f, y, c),\n                  m = o(f, y, n[d].geometry);\n                delete e[f], delete r[y], r[u(h, n[m].geometry, !0)] = m, n[d].geometry = null;\n              } else f in r ? o(f, y, c) : y in e ? s(f, y, c) : (a(l), e[f] = i - 1, r[y] = i - 1);\n            } else a(l);\n          }\n          return n.filter(function (t) {\n            return t.geometry;\n          });\n        }(this.features)), this.sortFeaturesByKey && this.features.sort(function (t, e) {\n          return t.sortKey - e.sortKey;\n        });\n      }\n    }, gl.prototype.update = function (t, e, r) {\n      this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r));\n    }, gl.prototype.isEmpty = function () {\n      return 0 === this.symbolInstances.length && !this.hasRTLText;\n    }, gl.prototype.uploadPending = function () {\n      return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n    }, gl.prototype.upload = function (t) {\n      !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n    }, gl.prototype.destroyDebugData = function () {\n      this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n    }, gl.prototype.destroy = function () {\n      this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n    }, gl.prototype.addToLineVertexArray = function (t, e) {\n      var r = this.lineVertexArray.length;\n      if (void 0 !== t.segment) {\n        for (var n = t.dist(e[t.segment + 1]), i = t.dist(e[t.segment]), a = {}, o = t.segment + 1; o < e.length; o++) a[o] = {\n          x: e[o].x,\n          y: e[o].y,\n          tileUnitDistanceFromAnchor: n\n        }, o < e.length - 1 && (n += e[o + 1].dist(e[o]));\n        for (var s = t.segment || 0; s >= 0; s--) a[s] = {\n          x: e[s].x,\n          y: e[s].y,\n          tileUnitDistanceFromAnchor: i\n        }, s > 0 && (i += e[s - 1].dist(e[s]));\n        for (var u = 0; u < e.length; u++) {\n          var l = a[u];\n          this.lineVertexArray.emplaceBack(l.x, l.y, l.tileUnitDistanceFromAnchor);\n        }\n      }\n      return {\n        lineStartIndex: r,\n        lineLength: this.lineVertexArray.length - r\n      };\n    }, gl.prototype.addSymbols = function (t, e, r, n, i, a, o, s, u, l, p, c) {\n      for (var h = t.indexArray, f = t.layoutVertexArray, y = t.segments.prepareSegment(4 * e.length, f, h, this.canOverlap ? a.sortKey : void 0), d = this.glyphOffsetArray.length, m = y.vertexLength, v = this.allowVerticalPlacement && o === _u.vertical ? Math.PI / 2 : 0, g = a.text && a.text.sections, x = 0; x < e.length; x++) {\n        var b = e[x],\n          w = b.tl,\n          _ = b.tr,\n          A = b.bl,\n          S = b.br,\n          k = b.tex,\n          I = b.pixelOffsetTL,\n          z = b.pixelOffsetBR,\n          C = b.minFontScaleX,\n          E = b.minFontScaleY,\n          P = b.glyphOffset,\n          M = b.isSDF,\n          B = b.sectionIndex,\n          T = y.vertexLength,\n          V = P[1];\n        fl(f, s.x, s.y, w.x, V + w.y, k.x, k.y, r, M, I.x, I.y, C, E), fl(f, s.x, s.y, _.x, V + _.y, k.x + k.w, k.y, r, M, z.x, I.y, C, E), fl(f, s.x, s.y, A.x, V + A.y, k.x, k.y + k.h, r, M, I.x, z.y, C, E), fl(f, s.x, s.y, S.x, V + S.y, k.x + k.w, k.y + k.h, r, M, z.x, z.y, C, E), yl(t.dynamicLayoutVertexArray, s, v), h.emplaceBack(T, T + 1, T + 2), h.emplaceBack(T + 1, T + 2, T + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), x !== e.length - 1 && B === e[x + 1].sectionIndex || t.programConfigurations.populatePaintArrays(f.length, a, a.index, {}, c, g && g[B]);\n      }\n      t.placedSymbolArray.emplaceBack(s.x, s.y, d, this.glyphOffsetArray.length - d, m, u, l, s.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], o, 0, !1, 0, p);\n    }, gl.prototype._addCollisionDebugVertex = function (t, e, r, n, i, a) {\n      return e.emplaceBack(0, 0), t.emplaceBack(r.x, r.y, n, i, Math.round(a.x), Math.round(a.y));\n    }, gl.prototype.addCollisionDebugVertices = function (t, e, r, n, a, o, s) {\n      var u = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray),\n        l = u.vertexLength,\n        p = a.layoutVertexArray,\n        c = a.collisionVertexArray,\n        h = s.anchorX,\n        f = s.anchorY;\n      this._addCollisionDebugVertex(p, c, o, h, f, new i(t, e)), this._addCollisionDebugVertex(p, c, o, h, f, new i(r, e)), this._addCollisionDebugVertex(p, c, o, h, f, new i(r, n)), this._addCollisionDebugVertex(p, c, o, h, f, new i(t, n)), u.vertexLength += 4;\n      var y = a.indexArray;\n      y.emplaceBack(l, l + 1), y.emplaceBack(l + 1, l + 2), y.emplaceBack(l + 2, l + 3), y.emplaceBack(l + 3, l), u.primitiveLength += 4;\n    }, gl.prototype.addDebugCollisionBoxes = function (t, e, r, n) {\n      for (var i = t; i < e; i++) {\n        var a = this.collisionBoxArray.get(i);\n        this.addCollisionDebugVertices(a.x1, a.y1, a.x2, a.y2, n ? this.textCollisionBox : this.iconCollisionBox, a.anchorPoint, r);\n      }\n    }, gl.prototype.generateCollisionDebugBuffers = function () {\n      this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new vl(Oi, Gs.members, Ji), this.iconCollisionBox = new vl(Oi, Gs.members, Ji);\n      for (var t = 0; t < this.symbolInstances.length; t++) {\n        var e = this.symbolInstances.get(t);\n        this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1);\n      }\n    }, gl.prototype._deserializeCollisionBoxesForSymbol = function (t, e, r, n, i, a, o, s, u) {\n      for (var l = {}, p = e; p < r; p++) {\n        var c = t.get(p);\n        l.textBox = {\n          x1: c.x1,\n          y1: c.y1,\n          x2: c.x2,\n          y2: c.y2,\n          anchorPointX: c.anchorPointX,\n          anchorPointY: c.anchorPointY\n        }, l.textFeatureIndex = c.featureIndex;\n        break;\n      }\n      for (var h = n; h < i; h++) {\n        var f = t.get(h);\n        l.verticalTextBox = {\n          x1: f.x1,\n          y1: f.y1,\n          x2: f.x2,\n          y2: f.y2,\n          anchorPointX: f.anchorPointX,\n          anchorPointY: f.anchorPointY\n        }, l.verticalTextFeatureIndex = f.featureIndex;\n        break;\n      }\n      for (var y = a; y < o; y++) {\n        var d = t.get(y);\n        l.iconBox = {\n          x1: d.x1,\n          y1: d.y1,\n          x2: d.x2,\n          y2: d.y2,\n          anchorPointX: d.anchorPointX,\n          anchorPointY: d.anchorPointY\n        }, l.iconFeatureIndex = d.featureIndex;\n        break;\n      }\n      for (var m = s; m < u; m++) {\n        var v = t.get(m);\n        l.verticalIconBox = {\n          x1: v.x1,\n          y1: v.y1,\n          x2: v.x2,\n          y2: v.y2,\n          anchorPointX: v.anchorPointX,\n          anchorPointY: v.anchorPointY\n        }, l.verticalIconFeatureIndex = v.featureIndex;\n        break;\n      }\n      return l;\n    }, gl.prototype.deserializeCollisionBoxes = function (t) {\n      this.collisionArrays = [];\n      for (var e = 0; e < this.symbolInstances.length; e++) {\n        var r = this.symbolInstances.get(e);\n        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n      }\n    }, gl.prototype.hasTextData = function () {\n      return this.text.segments.get().length > 0;\n    }, gl.prototype.hasIconData = function () {\n      return this.icon.segments.get().length > 0;\n    }, gl.prototype.hasDebugData = function () {\n      return this.textCollisionBox && this.iconCollisionBox;\n    }, gl.prototype.hasTextCollisionBoxData = function () {\n      return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n    }, gl.prototype.hasIconCollisionBoxData = function () {\n      return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n    }, gl.prototype.addIndicesForPlacedSymbol = function (t, e) {\n      for (var r = t.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs, i = r.vertexStartIndex; i < n; i += 4) t.indexArray.emplaceBack(i, i + 1, i + 2), t.indexArray.emplaceBack(i + 1, i + 2, i + 3);\n    }, gl.prototype.getSortedSymbolIndexes = function (t) {\n      if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n      for (var e = Math.sin(t), r = Math.cos(t), n = [], i = [], a = [], o = 0; o < this.symbolInstances.length; ++o) {\n        a.push(o);\n        var s = this.symbolInstances.get(o);\n        n.push(0 | Math.round(e * s.anchorX + r * s.anchorY)), i.push(s.featureIndex);\n      }\n      return a.sort(function (t, e) {\n        return n[t] - n[e] || i[e] - i[t];\n      }), a;\n    }, gl.prototype.addToSortKeyRanges = function (t, e) {\n      var r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n      r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n        sortKey: e,\n        symbolInstanceStart: t,\n        symbolInstanceEnd: t + 1\n      });\n    }, gl.prototype.sortFeatures = function (t) {\n      var e = this;\n      if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n        for (var r = 0, n = this.symbolInstanceIndexes; r < n.length; r += 1) {\n          var i = this.symbolInstances.get(n[r]);\n          this.featureSortOrder.push(i.featureIndex), [i.rightJustifiedTextSymbolIndex, i.centerJustifiedTextSymbolIndex, i.leftJustifiedTextSymbolIndex].forEach(function (t, r, n) {\n            t >= 0 && n.indexOf(t) === r && e.addIndicesForPlacedSymbol(e.text, t);\n          }), i.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i.verticalPlacedTextSymbolIndex), i.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.placedIconSymbolIndex), i.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i.verticalPlacedIconSymbolIndex);\n        }\n        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n      }\n    }, On("SymbolBucket", gl, {\n      omit: ["layers", "collisionBoxArray", "features", "compareText"]\n    }), gl.MAX_GLYPHS = 65535, gl.addDynamicAttributes = yl;\n    var xl = new _i({\n        "symbol-placement": new vi(Pt.layout_symbol["symbol-placement"]),\n        "symbol-spacing": new vi(Pt.layout_symbol["symbol-spacing"]),\n        "symbol-avoid-edges": new vi(Pt.layout_symbol["symbol-avoid-edges"]),\n        "symbol-sort-key": new gi(Pt.layout_symbol["symbol-sort-key"]),\n        "symbol-z-order": new vi(Pt.layout_symbol["symbol-z-order"]),\n        "icon-allow-overlap": new vi(Pt.layout_symbol["icon-allow-overlap"]),\n        "icon-ignore-placement": new vi(Pt.layout_symbol["icon-ignore-placement"]),\n        "icon-optional": new vi(Pt.layout_symbol["icon-optional"]),\n        "icon-rotation-alignment": new vi(Pt.layout_symbol["icon-rotation-alignment"]),\n        "icon-size": new gi(Pt.layout_symbol["icon-size"]),\n        "icon-text-fit": new vi(Pt.layout_symbol["icon-text-fit"]),\n        "icon-text-fit-padding": new vi(Pt.layout_symbol["icon-text-fit-padding"]),\n        "icon-image": new gi(Pt.layout_symbol["icon-image"]),\n        "icon-rotate": new gi(Pt.layout_symbol["icon-rotate"]),\n        "icon-padding": new vi(Pt.layout_symbol["icon-padding"]),\n        "icon-keep-upright": new vi(Pt.layout_symbol["icon-keep-upright"]),\n        "icon-offset": new gi(Pt.layout_symbol["icon-offset"]),\n        "icon-anchor": new gi(Pt.layout_symbol["icon-anchor"]),\n        "icon-pitch-alignment": new vi(Pt.layout_symbol["icon-pitch-alignment"]),\n        "text-pitch-alignment": new vi(Pt.layout_symbol["text-pitch-alignment"]),\n        "text-rotation-alignment": new vi(Pt.layout_symbol["text-rotation-alignment"]),\n        "text-field": new gi(Pt.layout_symbol["text-field"]),\n        "text-font": new gi(Pt.layout_symbol["text-font"]),\n        "text-size": new gi(Pt.layout_symbol["text-size"]),\n        "text-max-width": new gi(Pt.layout_symbol["text-max-width"]),\n        "text-line-height": new vi(Pt.layout_symbol["text-line-height"]),\n        "text-letter-spacing": new gi(Pt.layout_symbol["text-letter-spacing"]),\n        "text-justify": new gi(Pt.layout_symbol["text-justify"]),\n        "text-radial-offset": new gi(Pt.layout_symbol["text-radial-offset"]),\n        "text-variable-anchor": new vi(Pt.layout_symbol["text-variable-anchor"]),\n        "text-anchor": new gi(Pt.layout_symbol["text-anchor"]),\n        "text-max-angle": new vi(Pt.layout_symbol["text-max-angle"]),\n        "text-writing-mode": new vi(Pt.layout_symbol["text-writing-mode"]),\n        "text-rotate": new gi(Pt.layout_symbol["text-rotate"]),\n        "text-padding": new vi(Pt.layout_symbol["text-padding"]),\n        "text-keep-upright": new vi(Pt.layout_symbol["text-keep-upright"]),\n        "text-transform": new gi(Pt.layout_symbol["text-transform"]),\n        "text-offset": new gi(Pt.layout_symbol["text-offset"]),\n        "text-allow-overlap": new vi(Pt.layout_symbol["text-allow-overlap"]),\n        "text-ignore-placement": new vi(Pt.layout_symbol["text-ignore-placement"]),\n        "text-optional": new vi(Pt.layout_symbol["text-optional"])\n      }),\n      bl = {\n        paint: new _i({\n          "icon-opacity": new gi(Pt.paint_symbol["icon-opacity"]),\n          "icon-color": new gi(Pt.paint_symbol["icon-color"]),\n          "icon-halo-color": new gi(Pt.paint_symbol["icon-halo-color"]),\n          "icon-halo-width": new gi(Pt.paint_symbol["icon-halo-width"]),\n          "icon-halo-blur": new gi(Pt.paint_symbol["icon-halo-blur"]),\n          "icon-translate": new vi(Pt.paint_symbol["icon-translate"]),\n          "icon-translate-anchor": new vi(Pt.paint_symbol["icon-translate-anchor"]),\n          "text-opacity": new gi(Pt.paint_symbol["text-opacity"]),\n          "text-color": new gi(Pt.paint_symbol["text-color"], {\n            runtimeType: qt,\n            getOverride: function (t) {\n              return t.textColor;\n            },\n            hasOverride: function (t) {\n              return !!t.textColor;\n            }\n          }),\n          "text-halo-color": new gi(Pt.paint_symbol["text-halo-color"]),\n          "text-halo-width": new gi(Pt.paint_symbol["text-halo-width"]),\n          "text-halo-blur": new gi(Pt.paint_symbol["text-halo-blur"]),\n          "text-translate": new vi(Pt.paint_symbol["text-translate"]),\n          "text-translate-anchor": new vi(Pt.paint_symbol["text-translate-anchor"])\n        }),\n        layout: xl\n      },\n      wl = function (t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : Rt, this.defaultValue = t;\n      };\n    wl.prototype.evaluate = function (t) {\n      if (t.formattedSection) {\n        var e = this.defaultValue.property.overrides;\n        if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n      }\n      return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n    }, wl.prototype.eachChild = function (t) {\n      this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n    }, wl.prototype.outputDefined = function () {\n      return !1;\n    }, wl.prototype.serialize = function () {\n      return null;\n    }, On("FormatSectionOverride", wl, {\n      omit: ["defaultValue"]\n    });\n    var _l = function (t) {\n        function e(e) {\n          t.call(this, e, bl);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.recalculate = function (e, r) {\n          if (t.prototype.recalculate.call(this, e, r), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {\n            var n = this.layout.get("text-writing-mode");\n            if (n) {\n              for (var i = [], a = 0, o = n; a < o.length; a += 1) {\n                var s = o[a];\n                i.indexOf(s) < 0 && i.push(s);\n              }\n              this.layout._values["text-writing-mode"] = i;\n            } else this.layout._values["text-writing-mode"] = ["horizontal"];\n          }\n          this._setPaintOverrides();\n        }, e.prototype.getValueAndResolveTokens = function (t, e, r, n) {\n          var i = this.layout.get(t).evaluate(e, {}, r, n),\n            a = this._unevaluatedLayout._values[t];\n          return a.isDataDriven() || Zr(a.value) || !i ? i : function (t, e) {\n            return e.replace(/{([^{}]+)}/g, function (e, r) {\n              return r in t ? String(t[r]) : "";\n            });\n          }(e.properties, i);\n        }, e.prototype.createBucket = function (t) {\n          return new gl(t);\n        }, e.prototype.queryRadius = function () {\n          return 0;\n        }, e.prototype.queryIntersectsFeature = function () {\n          return !1;\n        }, e.prototype._setPaintOverrides = function () {\n          for (var t = 0, r = bl.paint.overridableProperties; t < r.length; t += 1) {\n            var n = r[t];\n            if (e.hasPaintOverride(this.layout, n)) {\n              var i,\n                a = this.paint.get(n),\n                o = new wl(a),\n                s = new Gr(o, a.property.specification);\n              i = "constant" === a.value.kind || "source" === a.value.kind ? new Jr("source", s) : new Hr("composite", s, a.value.zoomStops, a.value._interpolationType), this.paint._values[n] = new di(a.property, i, a.parameters);\n            }\n          }\n        }, e.prototype._handleOverridablePaintPropertyUpdate = function (t, r, n) {\n          return !(!this.layout || r.isDataDriven() || n.isDataDriven()) && e.hasPaintOverride(this.layout, t);\n        }, e.hasPaintOverride = function (t, e) {\n          var r = t.get("text-field"),\n            n = bl.paint.properties[e],\n            i = !1,\n            a = function (t) {\n              for (var e = 0, r = t; e < r.length; e += 1) if (n.overrides && n.overrides.hasOverride(r[e])) return void (i = !0);\n            };\n          if ("constant" === r.value.kind && r.value.value instanceof ie) a(r.value.value.sections);else if ("source" === r.value.kind) {\n            var o = function (t) {\n                i || (t instanceof pe && ue(t.value) === Zt ? a(t.value.sections) : t instanceof ye ? a(t.sections) : t.eachChild(o));\n              },\n              s = r.value;\n            s._styleExpression && o(s._styleExpression.expression);\n          }\n          return i;\n        }, e;\n      }(Ai),\n      Al = {\n        paint: new _i({\n          "background-color": new vi(Pt.paint_background["background-color"]),\n          "background-pattern": new bi(Pt.paint_background["background-pattern"]),\n          "background-opacity": new vi(Pt.paint_background["background-opacity"])\n        })\n      },\n      Sl = function (t) {\n        function e(e) {\n          t.call(this, e, Al);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n      }(Ai),\n      kl = {\n        paint: new _i({\n          "raster-opacity": new vi(Pt.paint_raster["raster-opacity"]),\n          "raster-hue-rotate": new vi(Pt.paint_raster["raster-hue-rotate"]),\n          "raster-brightness-min": new vi(Pt.paint_raster["raster-brightness-min"]),\n          "raster-brightness-max": new vi(Pt.paint_raster["raster-brightness-max"]),\n          "raster-saturation": new vi(Pt.paint_raster["raster-saturation"]),\n          "raster-contrast": new vi(Pt.paint_raster["raster-contrast"]),\n          "raster-resampling": new vi(Pt.paint_raster["raster-resampling"]),\n          "raster-fade-duration": new vi(Pt.paint_raster["raster-fade-duration"])\n        })\n      },\n      Il = function (t) {\n        function e(e) {\n          t.call(this, e, kl);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n      }(Ai),\n      zl = function (t) {\n        function e(e) {\n          t.call(this, e, {}), this.implementation = e;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.is3D = function () {\n          return "3d" === this.implementation.renderingMode;\n        }, e.prototype.hasOffscreenPass = function () {\n          return void 0 !== this.implementation.prerender;\n        }, e.prototype.recalculate = function () {}, e.prototype.updateTransitions = function () {}, e.prototype.hasTransition = function () {}, e.prototype.serialize = function () {}, e.prototype.onAdd = function (t) {\n          this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n        }, e.prototype.onRemove = function (t) {\n          this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n        }, e;\n      }(Ai),\n      Cl = {\n        circle: ho,\n        heatmap: Ao,\n        hillshade: ko,\n        fill: cs,\n        "fill-extrusion": Cs,\n        line: Us,\n        symbol: _l,\n        background: Sl,\n        raster: Il\n      },\n      El = o.HTMLImageElement,\n      Pl = o.HTMLCanvasElement,\n      Ml = o.HTMLVideoElement,\n      Bl = o.ImageData,\n      Tl = o.ImageBitmap,\n      Vl = function (t, e, r, n) {\n        this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);\n      };\n    Vl.prototype.update = function (t, e, r) {\n      var n = t.width,\n        i = t.height,\n        a = !(this.size && this.size[0] === n && this.size[1] === i || r),\n        o = this.context,\n        s = o.gl;\n      if (this.useMipmap = Boolean(e && e.useMipmap), s.bindTexture(s.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!e || !1 !== e.premultiply)), a) this.size = [n, i], t instanceof El || t instanceof Pl || t instanceof Ml || t instanceof Bl || Tl && t instanceof Tl ? s.texImage2D(s.TEXTURE_2D, 0, this.format, this.format, s.UNSIGNED_BYTE, t) : s.texImage2D(s.TEXTURE_2D, 0, this.format, n, i, 0, this.format, s.UNSIGNED_BYTE, t.data);else {\n        var u = r || {\n            x: 0,\n            y: 0\n          },\n          l = u.x,\n          p = u.y;\n        t instanceof El || t instanceof Pl || t instanceof Ml || t instanceof Bl || Tl && t instanceof Tl ? s.texSubImage2D(s.TEXTURE_2D, 0, l, p, s.RGBA, s.UNSIGNED_BYTE, t) : s.texSubImage2D(s.TEXTURE_2D, 0, l, p, n, i, s.RGBA, s.UNSIGNED_BYTE, t.data);\n      }\n      this.useMipmap && this.isSizePowerOfTwo() && s.generateMipmap(s.TEXTURE_2D);\n    }, Vl.prototype.bind = function (t, e, r) {\n      var n = this.context.gl;\n      n.bindTexture(n.TEXTURE_2D, this.texture), r !== n.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r = n.LINEAR), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, r || t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);\n    }, Vl.prototype.isSizePowerOfTwo = function () {\n      return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;\n    }, Vl.prototype.destroy = function () {\n      this.context.gl.deleteTexture(this.texture), this.texture = null;\n    };\n    var Fl = function (t) {\n      var e = this;\n      this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function () {\n        e._triggered = !1, e._callback();\n      });\n    };\n    Fl.prototype.trigger = function () {\n      var t = this;\n      this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(function () {\n        t._triggered = !1, t._callback();\n      }, 0));\n    }, Fl.prototype.remove = function () {\n      delete this._channel, this._callback = function () {};\n    };\n    var Dl = function (t, e, r) {\n      this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, v(["receive", "process"], this), this.invoker = new Fl(this.process), this.target.addEventListener("message", this.receive, !1), this.globalScope = I() ? t : o;\n    };\n    function Ll(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n    Dl.prototype.send = function (t, e, r, n, i) {\n      var a = this;\n      void 0 === i && (i = !1);\n      var o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n      r && (this.callbacks[o] = r);\n      var s = E(this.globalScope) ? void 0 : [];\n      return this.target.postMessage({\n        id: o,\n        type: t,\n        hasCallback: !!r,\n        targetMapId: n,\n        mustQueue: i,\n        sourceMapId: this.mapId,\n        data: Nn(e, s)\n      }, s), {\n        cancel: function () {\n          r && delete a.callbacks[o], a.target.postMessage({\n            id: o,\n            type: "<cancel>",\n            targetMapId: n,\n            sourceMapId: a.mapId\n          });\n        }\n      };\n    }, Dl.prototype.receive = function (t) {\n      var e = t.data,\n        r = e.id;\n      if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {\n        delete this.tasks[r];\n        var n = this.cancelCallbacks[r];\n        delete this.cancelCallbacks[r], n && n();\n      } else I() || e.mustQueue ? (this.tasks[r] = e, this.taskQueue.push(r), this.invoker.trigger()) : this.processTask(r, e);\n    }, Dl.prototype.process = function () {\n      if (this.taskQueue.length) {\n        var t = this.taskQueue.shift(),\n          e = this.tasks[t];\n        delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), e && this.processTask(t, e);\n      }\n    }, Dl.prototype.processTask = function (t, e) {\n      var r = this;\n      if ("<response>" === e.type) {\n        var n = this.callbacks[t];\n        delete this.callbacks[t], n && (e.error ? n(Kn(e.error)) : n(null, Kn(e.data)));\n      } else {\n        var i = !1,\n          a = E(this.globalScope) ? void 0 : [],\n          o = e.hasCallback ? function (e, n) {\n            i = !0, delete r.cancelCallbacks[t], r.target.postMessage({\n              id: t,\n              type: "<response>",\n              sourceMapId: r.mapId,\n              error: e ? Nn(e) : null,\n              data: Nn(n, a)\n            }, a);\n          } : function (t) {\n            i = !0;\n          },\n          s = null,\n          u = Kn(e.data);\n        if (this.parent[e.type]) s = this.parent[e.type](e.sourceMapId, u, o);else if (this.parent.getWorkerSource) {\n          var l = e.type.split(".");\n          s = this.parent.getWorkerSource(e.sourceMapId, l[0], u.source)[l[1]](u, o);\n        } else o(new Error("Could not find function " + e.type));\n        !i && s && s.cancel && (this.cancelCallbacks[t] = s.cancel);\n      }\n    }, Dl.prototype.remove = function () {\n      this.invoker.remove(), this.target.removeEventListener("message", this.receive, !1);\n    };\n    var Rl = function (t, e) {\n      t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n    };\n    Rl.prototype.setNorthEast = function (t) {\n      return this._ne = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n    }, Rl.prototype.setSouthWest = function (t) {\n      return this._sw = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n    }, Rl.prototype.extend = function (t) {\n      var e,\n        r,\n        n = this._sw,\n        i = this._ne;\n      if (t instanceof Ol) e = t, r = t;else {\n        if (!(t instanceof Rl)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Rl.convert(t)) : this.extend(Ol.convert(t)) : this;\n        if (r = t._ne, !(e = t._sw) || !r) return this;\n      }\n      return n || i ? (n.lng = Math.min(e.lng, n.lng), n.lat = Math.min(e.lat, n.lat), i.lng = Math.max(r.lng, i.lng), i.lat = Math.max(r.lat, i.lat)) : (this._sw = new Ol(e.lng, e.lat), this._ne = new Ol(r.lng, r.lat)), this;\n    }, Rl.prototype.getCenter = function () {\n      return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }, Rl.prototype.getSouthWest = function () {\n      return this._sw;\n    }, Rl.prototype.getNorthEast = function () {\n      return this._ne;\n    }, Rl.prototype.getNorthWest = function () {\n      return new Ol(this.getWest(), this.getNorth());\n    }, Rl.prototype.getSouthEast = function () {\n      return new Ol(this.getEast(), this.getSouth());\n    }, Rl.prototype.getWest = function () {\n      return this._sw.lng;\n    }, Rl.prototype.getSouth = function () {\n      return this._sw.lat;\n    }, Rl.prototype.getEast = function () {\n      return this._ne.lng;\n    }, Rl.prototype.getNorth = function () {\n      return this._ne.lat;\n    }, Rl.prototype.toArray = function () {\n      return [this._sw.toArray(), this._ne.toArray()];\n    }, Rl.prototype.toString = function () {\n      return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";\n    }, Rl.prototype.isEmpty = function () {\n      return !(this._sw && this._ne);\n    }, Rl.prototype.contains = function (t) {\n      var e = Ol.convert(t),\n        r = e.lng,\n        n = e.lat,\n        i = this._sw.lng <= r && r <= this._ne.lng;\n      return this._sw.lng > this._ne.lng && (i = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= n && n <= this._ne.lat && i;\n    }, Rl.convert = function (t) {\n      return !t || t instanceof Rl ? t : new Rl(t);\n    };\n    var Ol = function (t, e) {\n      if (isNaN(t) || isNaN(e)) throw new Error("Invalid LngLat object: (" + t + ", " + e + ")");\n      if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");\n    };\n    Ol.prototype.wrap = function () {\n      return new Ol(c(this.lng, -180, 180), this.lat);\n    }, Ol.prototype.toArray = function () {\n      return [this.lng, this.lat];\n    }, Ol.prototype.toString = function () {\n      return "LngLat(" + this.lng + ", " + this.lat + ")";\n    }, Ol.prototype.distanceTo = function (t) {\n      var e = Math.PI / 180,\n        r = this.lat * e,\n        n = t.lat * e,\n        i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n      return 6371008.8 * Math.acos(Math.min(i, 1));\n    }, Ol.prototype.toBounds = function (t) {\n      void 0 === t && (t = 0);\n      var e = 360 * t / 40075017,\n        r = e / Math.cos(Math.PI / 180 * this.lat);\n      return new Rl(new Ol(this.lng - r, this.lat - e), new Ol(this.lng + r, this.lat + e));\n    }, Ol.convert = function (t) {\n      if (t instanceof Ol) return t;\n      if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ol(Number(t[0]), Number(t[1]));\n      if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Ol(Number("lng" in t ? t.lng : t.lon), Number(t.lat));\n      throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");\n    };\n    var Ul = 2 * Math.PI * 6371008.8;\n    function jl(t) {\n      return Ul * Math.cos(t * Math.PI / 180);\n    }\n    function ql(t) {\n      return (180 + t) / 360;\n    }\n    function Nl(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n    function Kl(t, e) {\n      return t / jl(e);\n    }\n    function Gl(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    var Zl = function (t, e, r) {\n      void 0 === r && (r = 0), this.x = +t, this.y = +e, this.z = +r;\n    };\n    Zl.fromLngLat = function (t, e) {\n      void 0 === e && (e = 0);\n      var r = Ol.convert(t);\n      return new Zl(ql(r.lng), Nl(r.lat), Kl(e, r.lat));\n    }, Zl.prototype.toLngLat = function () {\n      return new Ol(360 * this.x - 180, Gl(this.y));\n    }, Zl.prototype.toAltitude = function () {\n      return this.z * jl(Gl(this.y));\n    }, Zl.prototype.meterInMercatorCoordinateUnits = function () {\n      return 1 / Ul * (t = Gl(this.y), 1 / Math.cos(t * Math.PI / 180));\n      var t;\n    };\n    var Xl = function (t, e, r) {\n      this.z = t, this.x = e, this.y = r, this.key = Yl(0, t, t, e, r);\n    };\n    Xl.prototype.equals = function (t) {\n      return this.z === t.z && this.x === t.x && this.y === t.y;\n    }, Xl.prototype.url = function (t, e) {\n      var r,\n        n,\n        i,\n        a,\n        o,\n        s = (n = this.y, i = this.z, a = Ll(256 * (r = this.x), 256 * (n = Math.pow(2, i) - n - 1), i), o = Ll(256 * (r + 1), 256 * (n + 1), i), a[0] + "," + a[1] + "," + o[0] + "," + o[1]),\n        u = function (t, e, r) {\n          for (var n, i = "", a = t; a > 0; a--) i += (e & (n = 1 << a - 1) ? 1 : 0) + (r & n ? 2 : 0);\n          return i;\n        }(this.z, this.x, this.y);\n      return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u).replace("{bbox-epsg-3857}", s);\n    }, Xl.prototype.getTilePoint = function (t) {\n      var e = Math.pow(2, this.z);\n      return new i(8192 * (t.x * e - this.x), 8192 * (t.y * e - this.y));\n    }, Xl.prototype.toString = function () {\n      return this.z + "/" + this.x + "/" + this.y;\n    };\n    var Jl = function (t, e) {\n        this.wrap = t, this.canonical = e, this.key = Yl(t, e.z, e.z, e.x, e.y);\n      },\n      Hl = function (t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new Xl(r, +n, +i), this.key = Yl(e, t, r, n, i);\n      };\n    function Yl(t, e, r, n, i) {\n      (t *= 2) < 0 && (t = -1 * t - 1);\n      var a = 1 << r;\n      return (a * a * t + a * i + n).toString(36) + r.toString(36) + e.toString(36);\n    }\n    Hl.prototype.equals = function (t) {\n      return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n    }, Hl.prototype.scaledTo = function (t) {\n      var e = this.canonical.z - t;\n      return t > this.canonical.z ? new Hl(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Hl(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n    }, Hl.prototype.calculateScaledKey = function (t, e) {\n      var r = this.canonical.z - t;\n      return t > this.canonical.z ? Yl(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : Yl(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n    }, Hl.prototype.isChildOf = function (t) {\n      if (t.wrap !== this.wrap) return !1;\n      var e = this.canonical.z - t.canonical.z;\n      return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n    }, Hl.prototype.children = function (t) {\n      if (this.overscaledZ >= t) return [new Hl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n      var e = this.canonical.z + 1,\n        r = 2 * this.canonical.x,\n        n = 2 * this.canonical.y;\n      return [new Hl(e, this.wrap, e, r, n), new Hl(e, this.wrap, e, r + 1, n), new Hl(e, this.wrap, e, r, n + 1), new Hl(e, this.wrap, e, r + 1, n + 1)];\n    }, Hl.prototype.isLessThan = function (t) {\n      return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n    }, Hl.prototype.wrapped = function () {\n      return new Hl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }, Hl.prototype.unwrapTo = function (t) {\n      return new Hl(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n    }, Hl.prototype.overscaleFactor = function () {\n      return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }, Hl.prototype.toUnwrapped = function () {\n      return new Jl(this.wrap, this.canonical);\n    }, Hl.prototype.toString = function () {\n      return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;\n    }, Hl.prototype.getTilePoint = function (t) {\n      return this.canonical.getTilePoint(new Zl(t.x - this.wrap, t.y));\n    }, On("CanonicalTileID", Xl), On("OverscaledTileID", Hl, {\n      omit: ["posMatrix"]\n    });\n    var $l = function (t, e, r) {\n      if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square");\n      if (r && "mapbox" !== r && "terrarium" !== r) return A(\'"\' + r + \'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".\');\n      this.stride = e.height;\n      var n = this.dim = e.height - 2;\n      this.data = new Uint32Array(e.data.buffer), this.encoding = r || "mapbox";\n      for (var i = 0; i < n; i++) this.data[this._idx(-1, i)] = this.data[this._idx(0, i)], this.data[this._idx(n, i)] = this.data[this._idx(n - 1, i)], this.data[this._idx(i, -1)] = this.data[this._idx(i, 0)], this.data[this._idx(i, n)] = this.data[this._idx(i, n - 1)];\n      this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n, -1)] = this.data[this._idx(n - 1, 0)], this.data[this._idx(-1, n)] = this.data[this._idx(0, n - 1)], this.data[this._idx(n, n)] = this.data[this._idx(n - 1, n - 1)];\n    };\n    $l.prototype.get = function (t, e) {\n      var r = new Uint8Array(this.data.buffer),\n        n = 4 * this._idx(t, e);\n      return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r[n], r[n + 1], r[n + 2]);\n    }, $l.prototype.getUnpackVector = function () {\n      return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, .1, 1e4];\n    }, $l.prototype._idx = function (t, e) {\n      if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");\n      return (e + 1) * this.stride + (t + 1);\n    }, $l.prototype._unpackMapbox = function (t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }, $l.prototype._unpackTerrarium = function (t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }, $l.prototype.getPixels = function () {\n      return new bo({\n        width: this.stride,\n        height: this.stride\n      }, new Uint8Array(this.data.buffer));\n    }, $l.prototype.backfillBorder = function (t, e, r) {\n      if (this.dim !== t.dim) throw new Error("dem dimension mismatch");\n      var n = e * this.dim,\n        i = e * this.dim + this.dim,\n        a = r * this.dim,\n        o = r * this.dim + this.dim;\n      switch (e) {\n        case -1:\n          n = i - 1;\n          break;\n        case 1:\n          i = n + 1;\n      }\n      switch (r) {\n        case -1:\n          a = o - 1;\n          break;\n        case 1:\n          o = a + 1;\n      }\n      for (var s = -e * this.dim, u = -r * this.dim, l = a; l < o; l++) for (var p = n; p < i; p++) this.data[this._idx(p, l)] = t.data[this._idx(p + s, l + u)];\n    }, On("DEMData", $l);\n    var Wl = function (t) {\n      this._stringToNumber = {}, this._numberToString = [];\n      for (var e = 0; e < t.length; e++) {\n        var r = t[e];\n        this._stringToNumber[r] = e, this._numberToString[e] = r;\n      }\n    };\n    Wl.prototype.encode = function (t) {\n      return this._stringToNumber[t];\n    }, Wl.prototype.decode = function (t) {\n      return this._numberToString[t];\n    };\n    var Ql = function (t, e, r, n, i) {\n        this.type = "Feature", this._vectorTileFeature = t, t._z = e, t._x = r, t._y = n, this.properties = t.properties, this.id = i;\n      },\n      tp = {\n        geometry: {\n          configurable: !0\n        }\n      };\n    tp.geometry.get = function () {\n      return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;\n    }, tp.geometry.set = function (t) {\n      this._geometry = t;\n    }, Ql.prototype.toJSON = function () {\n      var t = {\n        geometry: this.geometry\n      };\n      for (var e in this) "_geometry" !== e && "_vectorTileFeature" !== e && (t[e] = this[e]);\n      return t;\n    }, Object.defineProperties(Ql.prototype, tp);\n    var ep = function () {\n      this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n    };\n    ep.prototype.updateState = function (t, e, r) {\n      var n = String(e);\n      if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, h(this.stateChanges[t][n], r), null === this.deletedStates[t]) for (var i in this.deletedStates[t] = {}, this.state[t]) i !== n && (this.deletedStates[t][i] = null);else if (this.deletedStates[t] && null === this.deletedStates[t][n]) for (var a in this.deletedStates[t][n] = {}, this.state[t][n]) r[a] || (this.deletedStates[t][n][a] = null);else for (var o in r) this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][o] && delete this.deletedStates[t][n][o];\n    }, ep.prototype.removeFeatureState = function (t, e, r) {\n      if (null !== this.deletedStates[t]) {\n        var n = String(e);\n        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {\n          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) this.deletedStates[t][n][r] = null;else this.deletedStates[t][n] = null;\n        } else this.deletedStates[t] = null;\n      }\n    }, ep.prototype.getState = function (t, e) {\n      var r = String(e),\n        n = h({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);\n      if (null === this.deletedStates[t]) return {};\n      if (this.deletedStates[t]) {\n        var i = this.deletedStates[t][e];\n        if (null === i) return {};\n        for (var a in i) delete n[a];\n      }\n      return n;\n    }, ep.prototype.initializeTileState = function (t, e) {\n      t.setFeatureState(this.state, e);\n    }, ep.prototype.coalesceChanges = function (t, e) {\n      var r = {};\n      for (var n in this.stateChanges) {\n        this.state[n] = this.state[n] || {};\n        var i = {};\n        for (var a in this.stateChanges[n]) this.state[n][a] || (this.state[n][a] = {}), h(this.state[n][a], this.stateChanges[n][a]), i[a] = this.state[n][a];\n        r[n] = i;\n      }\n      for (var o in this.deletedStates) {\n        this.state[o] = this.state[o] || {};\n        var s = {};\n        if (null === this.deletedStates[o]) for (var u in this.state[o]) s[u] = {}, this.state[o][u] = {};else for (var l in this.deletedStates[o]) {\n          if (null === this.deletedStates[o][l]) this.state[o][l] = {};else for (var p = 0, c = Object.keys(this.deletedStates[o][l]); p < c.length; p += 1) delete this.state[o][l][c[p]];\n          s[l] = this.state[o][l];\n        }\n        r[o] = r[o] || {}, h(r[o], s);\n      }\n      if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (var f in t) t[f].setFeatureState(r, e);\n    };\n    var rp = function (t, e) {\n      this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Vn(8192, 16, 0), this.grid3D = new Vn(8192, 16, 0), this.featureIndexArray = new oa(), this.promoteId = e;\n    };\n    function np(t, e, r, n, i) {\n      return x(t, function (t, a) {\n        var o = e instanceof mi ? e.get(a) : null;\n        return o && o.evaluate ? o.evaluate(r, n, i) : o;\n      });\n    }\n    function ip(t) {\n      for (var e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0, o = t; a < o.length; a += 1) {\n        var s = o[a];\n        e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n      }\n      return {\n        minX: e,\n        minY: r,\n        maxX: n,\n        maxY: i\n      };\n    }\n    function ap(t, e) {\n      return e - t;\n    }\n    rp.prototype.insert = function (t, e, r, n, i, a) {\n      var o = this.featureIndexArray.length;\n      this.featureIndexArray.emplaceBack(r, n, i);\n      for (var s = a ? this.grid3D : this.grid, u = 0; u < e.length; u++) {\n        for (var l = e[u], p = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c = 0; c < l.length; c++) {\n          var h = l[c];\n          p[0] = Math.min(p[0], h.x), p[1] = Math.min(p[1], h.y), p[2] = Math.max(p[2], h.x), p[3] = Math.max(p[3], h.y);\n        }\n        p[0] < 8192 && p[1] < 8192 && p[2] >= 0 && p[3] >= 0 && s.insert(o, p[0], p[1], p[2], p[3]);\n      }\n    }, rp.prototype.loadVTLayers = function () {\n      return this.vtLayers || (this.vtLayers = new ws.VectorTile(new $s(this.rawTileData)).layers, this.sourceLayerCoder = new Wl(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;\n    }, rp.prototype.query = function (t, e, r, n) {\n      var a = this;\n      this.loadVTLayers();\n      for (var o = t.params || {}, s = 8192 / t.tileSize / t.scale, u = sn(o.filter), l = t.queryGeometry, p = t.queryPadding * s, c = ip(l), h = this.grid.query(c.minX - p, c.minY - p, c.maxX + p, c.maxY + p), f = ip(t.cameraQueryGeometry), y = this.grid3D.query(f.minX - p, f.minY - p, f.maxX + p, f.maxY + p, function (e, r, n, a) {\n          return function (t, e, r, n, a) {\n            for (var o = 0, s = t; o < s.length; o += 1) {\n              var u = s[o];\n              if (e <= u.x && r <= u.y && n >= u.x && a >= u.y) return !0;\n            }\n            var l = [new i(e, r), new i(e, a), new i(n, a), new i(n, r)];\n            if (t.length > 2) for (var p = 0, c = l; p < c.length; p += 1) if (Qa(t, c[p])) return !0;\n            for (var h = 0; h < t.length - 1; h++) if (to(t[h], t[h + 1], l)) return !0;\n            return !1;\n          }(t.cameraQueryGeometry, e - p, r - p, n + p, a + p);\n        }), d = 0, m = y; d < m.length; d += 1) h.push(m[d]);\n      h.sort(ap);\n      for (var v, g = {}, x = function (i) {\n          var p = h[i];\n          if (p !== v) {\n            v = p;\n            var c = a.featureIndexArray.get(p),\n              f = null;\n            a.loadMatchingFeature(g, c.bucketIndex, c.sourceLayerIndex, c.featureIndex, u, o.layers, o.availableImages, e, r, n, function (e, r, n) {\n              return f || (f = Ua(e)), r.queryIntersectsFeature(l, e, n, f, a.z, t.transform, s, t.pixelPosMatrix);\n            });\n          }\n        }, b = 0; b < h.length; b++) x(b);\n      return g;\n    }, rp.prototype.loadMatchingFeature = function (t, e, r, n, i, a, o, s, u, l, p) {\n      var c = this.bucketLayerIDs[e];\n      if (!a || function (t, e) {\n        for (var r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n        return !1;\n      }(a, c)) {\n        var f = this.sourceLayerCoder.decode(r),\n          y = this.vtLayers[f].feature(n);\n        if (i.needGeometry) {\n          var d = ja(y, !0);\n          if (!i.filter(new ui(this.tileID.overscaledZ), d, this.tileID.canonical)) return;\n        } else if (!i.filter(new ui(this.tileID.overscaledZ), y)) return;\n        for (var m = this.getId(y, f), v = 0; v < c.length; v++) {\n          var g = c[v];\n          if (!(a && a.indexOf(g) < 0)) {\n            var x = s[g];\n            if (x) {\n              var b = {};\n              void 0 !== m && l && (b = l.getState(x.sourceLayer || "_geojsonTileLayer", m));\n              var w = h({}, u[g]);\n              w.paint = np(w.paint, x.paint, y, b, o), w.layout = np(w.layout, x.layout, y, b, o);\n              var _ = !p || p(y, x, b);\n              if (_) {\n                var A = new Ql(y, this.z, this.x, this.y, m);\n                A.layer = w;\n                var S = t[g];\n                void 0 === S && (S = t[g] = []), S.push({\n                  featureIndex: n,\n                  feature: A,\n                  intersectionZ: _\n                });\n              }\n            }\n          }\n        }\n      }\n    }, rp.prototype.lookupSymbolFeatures = function (t, e, r, n, i, a, o, s) {\n      var u = {};\n      this.loadVTLayers();\n      for (var l = sn(i), p = 0, c = t; p < c.length; p += 1) this.loadMatchingFeature(u, r, n, c[p], l, a, o, s, e);\n      return u;\n    }, rp.prototype.hasLayer = function (t) {\n      for (var e = 0, r = this.bucketLayerIDs; e < r.length; e += 1) for (var n = 0, i = r[e]; n < i.length; n += 1) if (t === i[n]) return !0;\n      return !1;\n    }, rp.prototype.getId = function (t, e) {\n      var r = t.id;\n      return this.promoteId && "boolean" == typeof (r = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]]) && (r = Number(r)), r;\n    }, On("FeatureIndex", rp, {\n      omit: ["rawTileData", "sourceLayerCoder"]\n    });\n    var op = function (t, e) {\n      this.tileID = t, this.uid = y(), this.uses = 0, this.tileSize = e, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";\n    };\n    op.prototype.registerFadeDuration = function (t) {\n      var e = t + this.timeAdded;\n      e < R.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);\n    }, op.prototype.wasRequested = function () {\n      return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;\n    }, op.prototype.loadVectorData = function (t, e, r) {\n      if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {\n        for (var n in t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {\n          var r = {};\n          if (!e) return r;\n          for (var n = function () {\n              var t = a[i],\n                n = t.layerIds.map(function (t) {\n                  return e.getLayer(t);\n                }).filter(Boolean);\n              if (0 !== n.length) {\n                t.layers = n, t.stateDependentLayerIds && (t.stateDependentLayers = t.stateDependentLayerIds.map(function (t) {\n                  return n.filter(function (e) {\n                    return e.id === t;\n                  })[0];\n                }));\n                for (var o = 0, s = n; o < s.length; o += 1) r[s[o].id] = t;\n              }\n            }, i = 0, a = t; i < a.length; i += 1) n();\n          return r;\n        }(t.buckets, e.style), this.hasSymbolBuckets = !1, this.buckets) {\n          var i = this.buckets[n];\n          if (i instanceof gl) {\n            if (this.hasSymbolBuckets = !0, !r) break;\n            i.justReloaded = !0;\n          }\n        }\n        if (this.hasRTLText = !1, this.hasSymbolBuckets) for (var a in this.buckets) {\n          var o = this.buckets[a];\n          if (o instanceof gl && o.hasRTLText) {\n            this.hasRTLText = !0, si.isLoading() || si.isLoaded() || "deferred" !== ai() || oi();\n            break;\n          }\n        }\n        for (var s in this.queryPadding = 0, this.buckets) {\n          var u = this.buckets[s];\n          this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(s).queryRadius(u));\n        }\n        t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);\n      } else this.collisionBoxArray = new Wi();\n    }, op.prototype.unloadVectorData = function () {\n      for (var t in this.buckets) this.buckets[t].destroy();\n      this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";\n    }, op.prototype.getBucket = function (t) {\n      return this.buckets[t.id];\n    }, op.prototype.upload = function (t) {\n      for (var e in this.buckets) {\n        var r = this.buckets[e];\n        r.uploadPending() && r.upload(t);\n      }\n      var n = t.gl;\n      this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Vl(t, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Vl(t, this.glyphAtlasImage, n.ALPHA), this.glyphAtlasImage = null);\n    }, op.prototype.prepare = function (t) {\n      this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);\n    }, op.prototype.queryRenderedFeatures = function (t, e, r, n, i, a, o, s, u, l) {\n      return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({\n        queryGeometry: n,\n        cameraQueryGeometry: i,\n        scale: a,\n        tileSize: this.tileSize,\n        pixelPosMatrix: l,\n        transform: s,\n        params: o,\n        queryPadding: this.queryPadding * u\n      }, t, e, r) : {};\n    }, op.prototype.querySourceFeatures = function (t, e) {\n      var r = this.latestFeatureIndex;\n      if (r && r.rawTileData) {\n        var n = r.loadVTLayers(),\n          i = e ? e.sourceLayer : "",\n          a = n._geojsonTileLayer || n[i];\n        if (a) for (var o = sn(e && e.filter), s = this.tileID.canonical, u = s.z, l = s.x, p = s.y, c = {\n            z: u,\n            x: l,\n            y: p\n          }, h = 0; h < a.length; h++) {\n          var f = a.feature(h);\n          if (o.needGeometry) {\n            var y = ja(f, !0);\n            if (!o.filter(new ui(this.tileID.overscaledZ), y, this.tileID.canonical)) continue;\n          } else if (!o.filter(new ui(this.tileID.overscaledZ), f)) continue;\n          var d = r.getId(f, i),\n            m = new Ql(f, u, l, p, d);\n          m.tile = c, t.push(m);\n        }\n      }\n    }, op.prototype.hasData = function () {\n      return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;\n    }, op.prototype.patternsLoaded = function () {\n      return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n    }, op.prototype.setExpiryData = function (t) {\n      var e = this.expirationTime;\n      if (t.cacheControl) {\n        var r = z(t.cacheControl);\n        r["max-age"] && (this.expirationTime = Date.now() + 1e3 * r["max-age"]);\n      } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n      if (this.expirationTime) {\n        var n = Date.now(),\n          i = !1;\n        if (this.expirationTime > n) i = !1;else if (e) {\n          if (this.expirationTime < e) i = !0;else {\n            var a = this.expirationTime - e;\n            a ? this.expirationTime = n + Math.max(a, 3e4) : i = !0;\n          }\n        } else i = !0;\n        i ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;\n      }\n    }, op.prototype.getExpiryTimeout = function () {\n      if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n    }, op.prototype.setFeatureState = function (t, e) {\n      if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t).length) {\n        var r = this.latestFeatureIndex.loadVTLayers();\n        for (var n in this.buckets) if (e.style.hasLayer(n)) {\n          var i = this.buckets[n],\n            a = i.layers[0].sourceLayer || "_geojsonTileLayer",\n            o = r[a],\n            s = t[a];\n          if (o && s && 0 !== Object.keys(s).length) {\n            i.update(s, o, this.imageAtlas && this.imageAtlas.patternPositions || {});\n            var u = e && e.style && e.style.getLayer(n);\n            u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(i)));\n          }\n        }\n      }\n    }, op.prototype.holdingForFade = function () {\n      return void 0 !== this.symbolFadeHoldUntil;\n    }, op.prototype.symbolFadeFinished = function () {\n      return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < R.now();\n    }, op.prototype.clearFadeHold = function () {\n      this.symbolFadeHoldUntil = void 0;\n    }, op.prototype.setHoldDuration = function (t) {\n      this.symbolFadeHoldUntil = R.now() + t;\n    }, op.prototype.setDependencies = function (t, e) {\n      for (var r = {}, n = 0, i = e; n < i.length; n += 1) r[i[n]] = !0;\n      this.dependencies[t] = r;\n    }, op.prototype.hasDependency = function (t, e) {\n      for (var r = 0, n = t; r < n.length; r += 1) {\n        var i = this.dependencies[n[r]];\n        if (i) for (var a = 0, o = e; a < o.length; a += 1) if (i[o[a]]) return !0;\n      }\n      return !1;\n    };\n    var sp = o.performance,\n      up = function (t) {\n        this._marks = {\n          start: [t.url, "start"].join("#"),\n          end: [t.url, "end"].join("#"),\n          measure: t.url.toString()\n        }, sp.mark(this._marks.start);\n      };\n    up.prototype.finish = function () {\n      sp.mark(this._marks.end);\n      var t = sp.getEntriesByName(this._marks.measure);\n      return 0 === t.length && (sp.measure(this._marks.measure, this._marks.start, this._marks.end), t = sp.getEntriesByName(this._marks.measure), sp.clearMarks(this._marks.start), sp.clearMarks(this._marks.end), sp.clearMeasures(this._marks.measure)), t;\n    }, t.Actor = Dl, t.AlphaImage = xo, t.CanonicalTileID = Xl, t.CollisionBoxArray = Wi, t.Color = ee, t.DEMData = $l, t.DataConstantProperty = vi, t.DictionaryCoder = Wl, t.EXTENT = 8192, t.ErrorEvent = Ct, t.EvaluationParameters = ui, t.Event = zt, t.Evented = Et, t.FeatureIndex = rp, t.FillBucket = us, t.FillExtrusionBucket = ks, t.ImageAtlas = wu, t.ImagePosition = xu, t.LineBucket = Ds, t.LngLat = Ol, t.LngLatBounds = Rl, t.MercatorCoordinate = Zl, t.ONE_EM = 24, t.OverscaledTileID = Hl, t.Point = i, t.Point$1 = i, t.Properties = _i, t.Protobuf = $s, t.RGBAImage = bo, t.RequestManager = G, t.RequestPerformance = up, t.ResourceType = yt, t.SegmentVector = ua, t.SourceFeatureState = ep, t.StructArrayLayout1ui2 = Hi, t.StructArrayLayout2f1f2i16 = Ui, t.StructArrayLayout2i4 = Ei, t.StructArrayLayout3ui6 = qi, t.StructArrayLayout4i8 = Pi, t.SymbolBucket = gl, t.Texture = Vl, t.Tile = op, t.Transitionable = ci, t.Uniform1f = wa, t.Uniform1i = ba, t.Uniform2f = _a, t.Uniform3f = Aa, t.Uniform4f = Sa, t.UniformColor = ka, t.UniformMatrix4f = za, t.UnwrappedTileID = Jl, t.ValidationError = Mt, t.WritingMode = _u, t.ZoomHistory = Gn, t.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }, t.addDynamicAttributes = yl, t.asyncAll = function (t, e, r) {\n      if (!t.length) return r(null, []);\n      var n = t.length,\n        i = new Array(t.length),\n        a = null;\n      t.forEach(function (t, o) {\n        e(t, function (t, e) {\n          t && (a = t), i[o] = e, 0 == --n && r(a, i);\n        });\n      });\n    }, t.bezier = u, t.bindAll = v, t.browser = R, t.cacheEntryPossiblyAdded = function (t) {\n      ++ht > ut && (t.getActor().send("enforceCacheSizeLimit", st), ht = 0);\n    }, t.clamp = p, t.clearTileCache = function (t) {\n      var e = o.caches.delete("mapbox-tiles");\n      t && e.catch(t).then(function () {\n        return t();\n      });\n    }, t.clipLine = Xu, t.clone = function (t) {\n      var e = new oo(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.clone$1 = w, t.clone$2 = function (t) {\n      var e = new oo(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }, t.collisionCircleLayout = Zs, t.config = O, t.create = function () {\n      var t = new oo(16);\n      return oo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, t.create$1 = function () {\n      var t = new oo(9);\n      return oo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }, t.create$2 = function () {\n      var t = new oo(4);\n      return oo != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n    }, t.createCommonjsModule = e, t.createExpression = Xr, t.createLayout = zi, t.createStyleLayer = function (t) {\n      return "custom" === t.type ? new zl(t) : new Cl[t.type](t);\n    }, t.cross = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        o = r[0],\n        s = r[1],\n        u = r[2];\n      return t[0] = i * u - a * s, t[1] = a * o - n * u, t[2] = n * s - i * o, t;\n    }, t.deepEqual = function t(e, r) {\n      if (Array.isArray(e)) {\n        if (!Array.isArray(r) || e.length !== r.length) return !1;\n        for (var n = 0; n < e.length; n++) if (!t(e[n], r[n])) return !1;\n        return !0;\n      }\n      if ("object" == typeof e && null !== e && null !== r) {\n        if ("object" != typeof r) return !1;\n        if (Object.keys(e).length !== Object.keys(r).length) return !1;\n        for (var i in e) if (!t(e[i], r[i])) return !1;\n        return !0;\n      }\n      return e === r;\n    }, t.dot = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }, t.dot$1 = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];\n    }, t.ease = l, t.emitValidationErrors = Tn, t.endsWith = g, t.enforceCacheSizeLimit = function (t) {\n      lt(), tt && tt.then(function (e) {\n        e.keys().then(function (r) {\n          for (var n = 0; n < r.length - t; n++) e.delete(r[n]);\n        });\n      });\n    }, t.evaluateSizeForFeature = Ru, t.evaluateSizeForZoom = Ou, t.evaluateVariableOffset = ol, t.evented = ii, t.extend = h, t.featureFilter = sn, t.filterObject = b, t.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, t.getAnchorAlignment = Tu, t.getAnchorJustification = sl, t.getArrayBuffer = wt, t.getImage = St, t.getJSON = function (t, e) {\n      return bt(h(t, {\n        type: "json"\n      }), e);\n    }, t.getRTLTextPluginStatus = ai, t.getReferrer = mt, t.getVideo = function (t, e) {\n      var r,\n        n,\n        i = o.document.createElement("video");\n      i.muted = !0, i.onloadstart = function () {\n        e(null, i);\n      };\n      for (var a = 0; a < t.length; a++) {\n        var s = o.document.createElement("source");\n        r = t[a], n = void 0, (n = o.document.createElement("a")).href = r, (n.protocol !== o.document.location.protocol || n.host !== o.document.location.host) && (i.crossOrigin = "Anonymous"), s.src = t[a], i.appendChild(s);\n      }\n      return {\n        cancel: function () {}\n      };\n    }, t.identity = so, t.invert = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        o = e[4],\n        s = e[5],\n        u = e[6],\n        l = e[7],\n        p = e[8],\n        c = e[9],\n        h = e[10],\n        f = e[11],\n        y = e[12],\n        d = e[13],\n        m = e[14],\n        v = e[15],\n        g = r * s - n * o,\n        x = r * u - i * o,\n        b = r * l - a * o,\n        w = n * u - i * s,\n        _ = n * l - a * s,\n        A = i * l - a * u,\n        S = p * d - c * y,\n        k = p * m - h * y,\n        I = p * v - f * y,\n        z = c * m - h * d,\n        C = c * v - f * d,\n        E = h * v - f * m,\n        P = g * E - x * C + b * z + w * I - _ * k + A * S;\n      return P ? (t[0] = (s * E - u * C + l * z) * (P = 1 / P), t[1] = (i * C - n * E - a * z) * P, t[2] = (d * A - m * _ + v * w) * P, t[3] = (h * _ - c * A - f * w) * P, t[4] = (u * I - o * E - l * k) * P, t[5] = (r * E - i * I + a * k) * P, t[6] = (m * b - y * A - v * x) * P, t[7] = (p * A - h * b + f * x) * P, t[8] = (o * C - s * I + l * S) * P, t[9] = (n * I - r * C - a * S) * P, t[10] = (y * _ - d * b + v * g) * P, t[11] = (c * b - p * _ - f * g) * P, t[12] = (s * k - o * z - u * S) * P, t[13] = (r * z - n * k + i * S) * P, t[14] = (d * x - y * w - m * g) * P, t[15] = (p * w - c * x + h * g) * P, t) : null;\n    }, t.isChar = Zn, t.isMapboxURL = Z, t.keysDifference = function (t, e) {\n      var r = [];\n      for (var n in t) n in e || r.push(n);\n      return r;\n    }, t.makeRequest = bt, t.mapObject = x, t.mercatorXfromLng = ql, t.mercatorYfromLat = Nl, t.mercatorZfromAltitude = Kl, t.mul = po, t.multiply = uo, t.mvt = ws, t.nextPowerOfTwo = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }, t.normalize = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = r * r + n * n + i * i;\n      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;\n    }, t.number = Ge, t.offscreenCanvasSupported = ft, t.ortho = function (t, e, r, n, i, a, o) {\n      var s = 1 / (e - r),\n        u = 1 / (n - i),\n        l = 1 / (a - o);\n      return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + r) * s, t[13] = (i + n) * u, t[14] = (o + a) * l, t[15] = 1, t;\n    }, t.parseGlyphPBF = function (t) {\n      return new $s(t).readFields(du, []);\n    }, t.pbf = $s, t.performSymbolLayout = function (t, e, r, n, i, a, o) {\n      t.createArrays(), t.tilePixelRatio = 8192 / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      var s = t.layers[0].layout,\n        u = t.layers[0]._unevaluatedLayout._values,\n        l = {};\n      if ("composite" === t.textSizeData.kind) {\n        var p = t.textSizeData,\n          c = p.maxZoom;\n        l.compositeTextSizes = [u["text-size"].possiblyEvaluate(new ui(p.minZoom), o), u["text-size"].possiblyEvaluate(new ui(c), o)];\n      }\n      if ("composite" === t.iconSizeData.kind) {\n        var h = t.iconSizeData,\n          f = h.maxZoom;\n        l.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new ui(h.minZoom), o), u["icon-size"].possiblyEvaluate(new ui(f), o)];\n      }\n      l.layoutTextSize = u["text-size"].possiblyEvaluate(new ui(t.zoom + 1), o), l.layoutIconSize = u["icon-size"].possiblyEvaluate(new ui(t.zoom + 1), o), l.textMaxSize = u["text-size"].possiblyEvaluate(new ui(18));\n      for (var y = 24 * s.get("text-line-height"), d = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement"), m = s.get("text-keep-upright"), v = s.get("text-size"), g = function () {\n          var a = b[x],\n            u = s.get("text-font").evaluate(a, {}, o).join(","),\n            p = v.evaluate(a, {}, o),\n            c = l.layoutTextSize.evaluate(a, {}, o),\n            h = l.layoutIconSize.evaluate(a, {}, o),\n            f = {\n              horizontal: {},\n              vertical: void 0\n            },\n            g = a.text,\n            w = [0, 0];\n          if (g) {\n            var _ = g.toString(),\n              S = 24 * s.get("text-letter-spacing").evaluate(a, {}, o),\n              k = function (t) {\n                for (var e = 0, r = t; e < r.length; e += 1) if (n = r[e].charCodeAt(0), Zn.Arabic(n) || Zn["Arabic Supplement"](n) || Zn["Arabic Extended-A"](n) || Zn["Arabic Presentation Forms-A"](n) || Zn["Arabic Presentation Forms-B"](n)) return !1;\n                var n;\n                return !0;\n              }(_) ? S : 0,\n              I = s.get("text-anchor").evaluate(a, {}, o),\n              z = s.get("text-variable-anchor");\n            if (!z) {\n              var C = s.get("text-radial-offset").evaluate(a, {}, o);\n              w = C ? ol(I, [24 * C, al]) : s.get("text-offset").evaluate(a, {}, o).map(function (t) {\n                return 24 * t;\n              });\n            }\n            var E = d ? "center" : s.get("text-justify").evaluate(a, {}, o),\n              P = s.get("symbol-placement"),\n              M = "point" === P ? 24 * s.get("text-max-width").evaluate(a, {}, o) : 0,\n              B = function () {\n                t.allowVerticalPlacement && Xn(_) && (f.vertical = ku(g, e, r, i, u, M, y, I, "left", k, w, _u.vertical, !0, P, c, p));\n              };\n            if (!d && z) {\n              for (var T = "auto" === E ? z.map(function (t) {\n                  return sl(t);\n                }) : [E], V = !1, F = 0; F < T.length; F++) {\n                var D = T[F];\n                if (!f.horizontal[D]) if (V) f.horizontal[D] = f.horizontal[0];else {\n                  var L = ku(g, e, r, i, u, M, y, "center", D, k, w, _u.horizontal, !1, P, c, p);\n                  L && (f.horizontal[D] = L, V = 1 === L.positionedLines.length);\n                }\n              }\n              B();\n            } else {\n              "auto" === E && (E = sl(I));\n              var R = ku(g, e, r, i, u, M, y, I, E, k, w, _u.horizontal, !1, P, c, p);\n              R && (f.horizontal[E] = R), B(), Xn(_) && d && m && (f.vertical = ku(g, e, r, i, u, M, y, I, E, k, w, _u.vertical, !1, P, c, p));\n            }\n          }\n          var O = void 0,\n            U = !1;\n          if (a.icon && a.icon.name) {\n            var j = n[a.icon.name];\n            j && (O = function (t, e, r) {\n              var n = Tu(r),\n                i = e[0] - t.displaySize[0] * n.horizontalAlign,\n                a = e[1] - t.displaySize[1] * n.verticalAlign;\n              return {\n                image: t,\n                top: a,\n                bottom: a + t.displaySize[1],\n                left: i,\n                right: i + t.displaySize[0]\n              };\n            }(i[a.icon.name], s.get("icon-offset").evaluate(a, {}, o), s.get("icon-anchor").evaluate(a, {}, o)), U = j.sdf, void 0 === t.sdfIcons ? t.sdfIcons = j.sdf : t.sdfIcons !== j.sdf && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j.pixelRatio !== t.pixelRatio || 0 !== s.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));\n          }\n          var q = ll(f.horizontal) || f.vertical;\n          t.iconsInText = !!q && q.iconsInText, (q || O) && function (t, e, r, n, i, a, o, s, u, l, p) {\n            var c = a.textMaxSize.evaluate(e, {});\n            void 0 === c && (c = o);\n            var h,\n              f = t.layers[0].layout,\n              y = f.get("icon-offset").evaluate(e, {}, p),\n              d = ll(r.horizontal),\n              m = o / 24,\n              v = t.tilePixelRatio * m,\n              g = t.tilePixelRatio * c / 24,\n              x = t.tilePixelRatio * s,\n              b = t.tilePixelRatio * f.get("symbol-spacing"),\n              w = f.get("text-padding") * t.tilePixelRatio,\n              _ = f.get("icon-padding") * t.tilePixelRatio,\n              S = f.get("text-max-angle") / 180 * Math.PI,\n              k = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"),\n              I = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"),\n              z = f.get("symbol-placement"),\n              C = b / 2,\n              E = f.get("icon-text-fit");\n            n && "none" !== E && (t.allowVerticalPlacement && r.vertical && (h = Fu(n, r.vertical, E, f.get("icon-text-fit-padding"), y, m)), d && (n = Fu(n, d, E, f.get("icon-text-fit-padding"), y, m)));\n            var P = function (s, c) {\n              c.x < 0 || c.x >= 8192 || c.y < 0 || c.y >= 8192 || function (t, e, r, n, i, a, o, s, u, l, p, c, h, f, y, d, m, v, g, x, b, w, _, S, k) {\n                var I,\n                  z,\n                  C,\n                  E,\n                  P,\n                  M = t.addToLineVertexArray(e, r),\n                  B = 0,\n                  T = 0,\n                  V = 0,\n                  F = 0,\n                  D = -1,\n                  L = -1,\n                  R = {},\n                  O = fa(""),\n                  U = 0,\n                  j = 0;\n                if (void 0 === s._unevaluatedLayout.getValue("text-radial-offset") ? (U = (I = s.layout.get("text-offset").evaluate(b, {}, S).map(function (t) {\n                  return 24 * t;\n                }))[0], j = I[1]) : (U = 24 * s.layout.get("text-radial-offset").evaluate(b, {}, S), j = al), t.allowVerticalPlacement && n.vertical) {\n                  var q = s.layout.get("text-rotate").evaluate(b, {}, S) + 90;\n                  E = new Qu(u, e, l, p, c, n.vertical, h, f, y, q), o && (P = new Qu(u, e, l, p, c, o, m, v, y, q));\n                }\n                if (i) {\n                  var N = s.layout.get("icon-rotate").evaluate(b, {}),\n                    K = "none" !== s.layout.get("icon-text-fit"),\n                    G = Ju(i, N, _, K),\n                    Z = o ? Ju(o, N, _, K) : void 0;\n                  C = new Qu(u, e, l, p, c, i, m, v, !1, N), B = 4 * G.length;\n                  var X = t.iconSizeData,\n                    J = null;\n                  "source" === X.kind ? (J = [128 * s.layout.get("icon-size").evaluate(b, {})])[0] > 32640 && A(t.layerIds[0] + \': Value for "icon-size" is >= 255. Reduce your "icon-size".\') : "composite" === X.kind && ((J = [128 * w.compositeIconSizes[0].evaluate(b, {}, S), 128 * w.compositeIconSizes[1].evaluate(b, {}, S)])[0] > 32640 || J[1] > 32640) && A(t.layerIds[0] + \': Value for "icon-size" is >= 255. Reduce your "icon-size".\'), t.addSymbols(t.icon, G, J, x, g, b, !1, e, M.lineStartIndex, M.lineLength, -1, S), D = t.icon.placedSymbolArray.length - 1, Z && (T = 4 * Z.length, t.addSymbols(t.icon, Z, J, x, g, b, _u.vertical, e, M.lineStartIndex, M.lineLength, -1, S), L = t.icon.placedSymbolArray.length - 1);\n                }\n                for (var H in n.horizontal) {\n                  var Y = n.horizontal[H];\n                  if (!z) {\n                    O = fa(Y.text);\n                    var $ = s.layout.get("text-rotate").evaluate(b, {}, S);\n                    z = new Qu(u, e, l, p, c, Y, h, f, y, $);\n                  }\n                  var W = 1 === Y.positionedLines.length;\n                  if (V += ul(t, e, Y, a, s, y, b, d, M, n.vertical ? _u.horizontal : _u.horizontalOnly, W ? Object.keys(n.horizontal) : [H], R, D, w, S), W) break;\n                }\n                n.vertical && (F += ul(t, e, n.vertical, a, s, y, b, d, M, _u.vertical, ["vertical"], R, L, w, S));\n                var Q = z ? z.boxStartIndex : t.collisionBoxArray.length,\n                  tt = z ? z.boxEndIndex : t.collisionBoxArray.length,\n                  et = E ? E.boxStartIndex : t.collisionBoxArray.length,\n                  rt = E ? E.boxEndIndex : t.collisionBoxArray.length,\n                  nt = C ? C.boxStartIndex : t.collisionBoxArray.length,\n                  it = C ? C.boxEndIndex : t.collisionBoxArray.length,\n                  at = P ? P.boxStartIndex : t.collisionBoxArray.length,\n                  ot = P ? P.boxEndIndex : t.collisionBoxArray.length,\n                  st = -1,\n                  ut = function (t, e) {\n                    return t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e;\n                  };\n                st = ut(z, st), st = ut(E, st), st = ut(C, st);\n                var lt = (st = ut(P, st)) > -1 ? 1 : 0;\n                lt && (st *= k / 24), t.glyphOffsetArray.length >= gl.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, R.right >= 0 ? R.right : -1, R.center >= 0 ? R.center : -1, R.left >= 0 ? R.left : -1, R.vertical || -1, D, L, O, Q, tt, et, rt, nt, it, at, ot, l, V, F, B, T, lt, 0, h, U, j, st);\n              }(t, c, s, r, n, i, h, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, v, w, k, u, x, _, I, y, e, a, l, p, o);\n            };\n            if ("line" === z) for (var M = 0, B = Xu(e.geometry, 0, 0, 8192, 8192); M < B.length; M += 1) for (var T = B[M], V = 0, F = Zu(T, b, S, r.vertical || d, n, 24, g, t.overscaling, 8192); V < F.length; V += 1) {\n              var D = F[V];\n              d && pl(t, d.text, C, D) || P(T, D);\n            } else if ("line-center" === z) for (var L = 0, R = e.geometry; L < R.length; L += 1) {\n              var O = R[L];\n              if (O.length > 1) {\n                var U = Gu(O, S, r.vertical || d, n, 24, g);\n                U && P(O, U);\n              }\n            } else if ("Polygon" === e.type) for (var j = 0, q = is(e.geometry, 0); j < q.length; j += 1) {\n              var N = q[j],\n                K = rl(N, 16);\n              P(N[0], new Du(K.x, K.y, 0));\n            } else if ("LineString" === e.type) for (var G = 0, Z = e.geometry; G < Z.length; G += 1) {\n              var X = Z[G];\n              P(X, new Du(X[0].x, X[0].y, 0));\n            } else if ("Point" === e.type) for (var J = 0, H = e.geometry; J < H.length; J += 1) for (var Y = 0, $ = H[J]; Y < $.length; Y += 1) {\n              var W = $[Y];\n              P([W], new Du(W.x, W.y, 0));\n            }\n          }(t, a, f, O, n, l, c, h, w, U, o);\n        }, x = 0, b = t.features; x < b.length; x += 1) g();\n      a && t.generateCollisionDebugBuffers();\n    }, t.perspective = function (t, e, r, n, i) {\n      var a,\n        o = 1 / Math.tan(e / 2);\n      return t[0] = o / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (a = 1 / (n - i)), t[14] = 2 * i * n * a) : (t[10] = -1, t[14] = -2 * n), t;\n    }, t.pick = function (t, e) {\n      for (var r = {}, n = 0; n < e.length; n++) {\n        var i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n      return r;\n    }, t.plugin = si, t.polygonIntersectsPolygon = Ka, t.postMapLoadEvent = ot, t.postTurnstileEvent = it, t.potpack = gu, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = On, t.registerForPluginStateChange = function (t) {\n      return t({\n        pluginStatus: ti,\n        pluginURL: ei\n      }), ii.on("pluginStateChange", t), t;\n    }, t.renderColorRamp = _o, t.rotate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        o = e[3],\n        s = Math.sin(r),\n        u = Math.cos(r);\n      return t[0] = n * u + a * s, t[1] = i * u + o * s, t[2] = n * -s + a * u, t[3] = i * -s + o * u, t;\n    }, t.rotateX = function (t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        a = e[4],\n        o = e[5],\n        s = e[6],\n        u = e[7],\n        l = e[8],\n        p = e[9],\n        c = e[10],\n        h = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + l * n, t[5] = o * i + p * n, t[6] = s * i + c * n, t[7] = u * i + h * n, t[8] = l * i - a * n, t[9] = p * i - o * n, t[10] = c * i - s * n, t[11] = h * i - u * n, t;\n    }, t.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        a = e[0],\n        o = e[1],\n        s = e[2],\n        u = e[3],\n        l = e[4],\n        p = e[5],\n        c = e[6],\n        h = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + l * n, t[1] = o * i + p * n, t[2] = s * i + c * n, t[3] = u * i + h * n, t[4] = l * i - a * n, t[5] = p * i - o * n, t[6] = c * i - s * n, t[7] = h * i - u * n, t;\n    }, t.scale = function (t, e, r) {\n      var n = r[0],\n        i = r[1],\n        a = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }, t.scale$1 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, t.scale$2 = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }, t.setCacheLimits = function (t, e) {\n      st = t, ut = e;\n    }, t.setRTLTextPlugin = function (t, e, r) {\n      if (void 0 === r && (r = !1), "deferred" === ti || "loading" === ti || "loaded" === ti) throw new Error("setRTLTextPlugin cannot be called multiple times.");\n      ei = R.resolveURL(t), ti = "deferred", Qn = e, ni(), r || oi();\n    }, t.sphericalToCartesian = function (t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2];\n      return r += 90, r *= Math.PI / 180, n *= Math.PI / 180, {\n        x: e * Math.cos(r) * Math.sin(n),\n        y: e * Math.sin(r) * Math.sin(n),\n        z: e * Math.cos(n)\n      };\n    }, t.sqrLen = function (t) {\n      var e = t[0],\n        r = t[1];\n      return e * e + r * r;\n    }, t.styleSpec = Pt, t.sub = function (t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }, t.symbolSize = Uu, t.transformMat3 = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2];\n      return t[0] = n * r[0] + i * r[3] + a * r[6], t[1] = n * r[1] + i * r[4] + a * r[7], t[2] = n * r[2] + i * r[5] + a * r[8], t;\n    }, t.transformMat4 = co, t.translate = function (t, e, r) {\n      var n,\n        i,\n        a,\n        o,\n        s,\n        u,\n        l,\n        p,\n        c,\n        h,\n        f,\n        y,\n        d = r[0],\n        m = r[1],\n        v = r[2];\n      return e === t ? (t[12] = e[0] * d + e[4] * m + e[8] * v + e[12], t[13] = e[1] * d + e[5] * m + e[9] * v + e[13], t[14] = e[2] * d + e[6] * m + e[10] * v + e[14], t[15] = e[3] * d + e[7] * m + e[11] * v + e[15]) : (i = e[1], a = e[2], o = e[3], s = e[4], u = e[5], l = e[6], p = e[7], c = e[8], h = e[9], f = e[10], y = e[11], t[0] = n = e[0], t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = u, t[6] = l, t[7] = p, t[8] = c, t[9] = h, t[10] = f, t[11] = y, t[12] = n * d + s * m + c * v + e[12], t[13] = i * d + u * m + h * v + e[13], t[14] = a * d + l * m + f * v + e[14], t[15] = o * d + p * m + y * v + e[15]), t;\n    }, t.triggerPluginCompletionEvent = ri, t.uniqueId = y, t.validateCustomStyleLayer = function (t) {\n      var e = [],\n        r = t.id;\n      return void 0 === r && e.push({\n        message: "layers." + r + \': missing required property "id"\'\n      }), void 0 === t.render && e.push({\n        message: "layers." + r + \': missing required method "render"\'\n      }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({\n        message: "layers." + r + \': property "renderingMode" must be either "2d" or "3d"\'\n      }), e;\n    }, t.validateLight = Pn, t.validateStyle = En, t.values = function (t) {\n      var e = [];\n      for (var r in t) e.push(t[r]);\n      return e;\n    }, t.vectorTile = ws, t.version = "1.15.3", t.warnOnce = A, t.webpSupported = U, t.window = o, t.wrap = c;\n  });\n  define(["./shared"], function (e) {\n    "use strict";\n\n    function t(e) {\n      var r = typeof e;\n      if ("number" === r || "boolean" === r || "string" === r || null == e) return JSON.stringify(e);\n      if (Array.isArray(e)) {\n        for (var i = "[", o = 0, n = e; o < n.length; o += 1) i += t(n[o]) + ",";\n        return i + "]";\n      }\n      for (var s = Object.keys(e).sort(), a = "{", l = 0; l < s.length; l++) a += JSON.stringify(s[l]) + ":" + t(e[s[l]]) + ",";\n      return a + "}";\n    }\n    function r(r) {\n      for (var i = "", o = 0, n = e.refProperties; o < n.length; o += 1) i += "/" + t(r[n[o]]);\n      return i;\n    }\n    var i = function (e) {\n      this.keyCache = {}, e && this.replace(e);\n    };\n    i.prototype.replace = function (e) {\n      this._layerConfigs = {}, this._layers = {}, this.update(e, []);\n    }, i.prototype.update = function (t, i) {\n      for (var o = this, n = 0, s = t; n < s.length; n += 1) {\n        var a = s[n];\n        this._layerConfigs[a.id] = a;\n        var l = this._layers[a.id] = e.createStyleLayer(a);\n        l._featureFilter = e.featureFilter(l.filter), this.keyCache[a.id] && delete this.keyCache[a.id];\n      }\n      for (var u = 0, h = i; u < h.length; u += 1) {\n        var c = h[u];\n        delete this.keyCache[c], delete this._layerConfigs[c], delete this._layers[c];\n      }\n      this.familiesBySource = {};\n      for (var p = 0, f = function (e, t) {\n          for (var i = {}, o = 0; o < e.length; o++) {\n            var n = t && t[e[o].id] || r(e[o]);\n            t && (t[e[o].id] = n);\n            var s = i[n];\n            s || (s = i[n] = []), s.push(e[o]);\n          }\n          var a = [];\n          for (var l in i) a.push(i[l]);\n          return a;\n        }(e.values(this._layerConfigs), this.keyCache); p < f.length; p += 1) {\n        var d = f[p].map(function (e) {\n            return o._layers[e.id];\n          }),\n          g = d[0];\n        if ("none" !== g.visibility) {\n          var v = g.source || "",\n            m = this.familiesBySource[v];\n          m || (m = this.familiesBySource[v] = {});\n          var y = g.sourceLayer || "_geojsonTileLayer",\n            x = m[y];\n          x || (x = m[y] = []), x.push(d);\n        }\n      }\n    };\n    var o = function (t) {\n      var r = {},\n        i = [];\n      for (var o in t) {\n        var n = t[o],\n          s = r[o] = {};\n        for (var a in n) {\n          var l = n[+a];\n          if (l && 0 !== l.bitmap.width && 0 !== l.bitmap.height) {\n            var u = {\n              x: 0,\n              y: 0,\n              w: l.bitmap.width + 2,\n              h: l.bitmap.height + 2\n            };\n            i.push(u), s[a] = {\n              rect: u,\n              metrics: l.metrics\n            };\n          }\n        }\n      }\n      var h = e.potpack(i),\n        c = new e.AlphaImage({\n          width: h.w || 1,\n          height: h.h || 1\n        });\n      for (var p in t) {\n        var f = t[p];\n        for (var d in f) {\n          var g = f[+d];\n          if (g && 0 !== g.bitmap.width && 0 !== g.bitmap.height) {\n            var v = r[p][d].rect;\n            e.AlphaImage.copy(g.bitmap, c, {\n              x: 0,\n              y: 0\n            }, {\n              x: v.x + 1,\n              y: v.y + 1\n            }, g.bitmap);\n          }\n        }\n      }\n      this.image = c, this.positions = r;\n    };\n    e.register("GlyphAtlas", o);\n    var n = function (t) {\n      this.tileID = new e.OverscaledTileID(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId;\n    };\n    function s(t, r, i) {\n      for (var o = new e.EvaluationParameters(r), n = 0, s = t; n < s.length; n += 1) s[n].recalculate(o, i);\n    }\n    function a(t, r) {\n      var i = e.getArrayBuffer(t.request, function (t, i, o, n) {\n        t ? r(t) : i && r(null, {\n          vectorTile: new e.vectorTile.VectorTile(new e.pbf(i)),\n          rawData: i,\n          cacheControl: o,\n          expires: n\n        });\n      });\n      return function () {\n        i.cancel(), r();\n      };\n    }\n    n.prototype.parse = function (t, r, i, n, a) {\n      var l = this;\n      this.status = "parsing", this.data = t, this.collisionBoxArray = new e.CollisionBoxArray();\n      var u = new e.DictionaryCoder(Object.keys(t.layers).sort()),\n        h = new e.FeatureIndex(this.tileID, this.promoteId);\n      h.bucketLayerIDs = [];\n      var c,\n        p,\n        f,\n        d,\n        g = {},\n        v = {\n          featureIndex: h,\n          iconDependencies: {},\n          patternDependencies: {},\n          glyphDependencies: {},\n          availableImages: i\n        },\n        m = r.familiesBySource[this.source];\n      for (var y in m) {\n        var x = t.layers[y];\n        if (x) {\n          1 === x.version && e.warnOnce(\'Vector tile source "\' + this.source + \'" layer "\' + y + \'" does not use vector tile spec v2 and therefore may have some rendering errors.\');\n          for (var w = u.encode(y), S = [], I = 0; I < x.length; I++) {\n            var M = x.feature(I),\n              b = h.getId(M, y);\n            S.push({\n              feature: M,\n              id: b,\n              index: I,\n              sourceLayerIndex: w\n            });\n          }\n          for (var _ = 0, k = m[y]; _ < k.length; _ += 1) {\n            var P = k[_],\n              T = P[0];\n            T.minzoom && this.zoom < Math.floor(T.minzoom) || T.maxzoom && this.zoom >= T.maxzoom || "none" !== T.visibility && (s(P, this.zoom, i), (g[T.id] = T.createBucket({\n              index: h.bucketLayerIDs.length,\n              layers: P,\n              zoom: this.zoom,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: w,\n              sourceID: this.source\n            })).populate(S, v, this.tileID.canonical), h.bucketLayerIDs.push(P.map(function (e) {\n              return e.id;\n            })));\n          }\n        }\n      }\n      var C = e.mapObject(v.glyphDependencies, function (e) {\n        return Object.keys(e).map(Number);\n      });\n      Object.keys(C).length ? n.send("getGlyphs", {\n        uid: this.uid,\n        stacks: C\n      }, function (e, t) {\n        c || (c = e, p = t, z.call(l));\n      }) : p = {};\n      var D = Object.keys(v.iconDependencies);\n      D.length ? n.send("getImages", {\n        icons: D,\n        source: this.source,\n        tileID: this.tileID,\n        type: "icons"\n      }, function (e, t) {\n        c || (c = e, f = t, z.call(l));\n      }) : f = {};\n      var L = Object.keys(v.patternDependencies);\n      function z() {\n        if (c) return a(c);\n        if (p && f && d) {\n          var t = new o(p),\n            r = new e.ImageAtlas(f, d);\n          for (var n in g) {\n            var l = g[n];\n            l instanceof e.SymbolBucket ? (s(l.layers, this.zoom, i), e.performSymbolLayout(l, p, t.positions, f, r.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l.hasPattern && (l instanceof e.LineBucket || l instanceof e.FillBucket || l instanceof e.FillExtrusionBucket) && (s(l.layers, this.zoom, i), l.addFeatures(v, this.tileID.canonical, r.patternPositions));\n          }\n          this.status = "done", a(null, {\n            buckets: e.values(g).filter(function (e) {\n              return !e.isEmpty();\n            }),\n            featureIndex: h,\n            collisionBoxArray: this.collisionBoxArray,\n            glyphAtlasImage: t.image,\n            imageAtlas: r,\n            glyphMap: this.returnDependencies ? p : null,\n            iconMap: this.returnDependencies ? f : null,\n            glyphPositions: this.returnDependencies ? t.positions : null\n          });\n        }\n      }\n      L.length ? n.send("getImages", {\n        icons: L,\n        source: this.source,\n        tileID: this.tileID,\n        type: "patterns"\n      }, function (e, t) {\n        c || (c = e, d = t, z.call(l));\n      }) : d = {}, z.call(this);\n    };\n    var l = function (e, t, r, i) {\n      this.actor = e, this.layerIndex = t, this.availableImages = r, this.loadVectorData = i || a, this.loading = {}, this.loaded = {};\n    };\n    l.prototype.loadTile = function (t, r) {\n      var i = this,\n        o = t.uid;\n      this.loading || (this.loading = {});\n      var s = !!(t && t.request && t.request.collectResourceTiming) && new e.RequestPerformance(t.request),\n        a = this.loading[o] = new n(t);\n      a.abort = this.loadVectorData(t, function (t, n) {\n        if (delete i.loading[o], t || !n) return a.status = "done", i.loaded[o] = a, r(t);\n        var l = n.rawData,\n          u = {};\n        n.expires && (u.expires = n.expires), n.cacheControl && (u.cacheControl = n.cacheControl);\n        var h = {};\n        if (s) {\n          var c = s.finish();\n          c && (h.resourceTiming = JSON.parse(JSON.stringify(c)));\n        }\n        a.vectorTile = n.vectorTile, a.parse(n.vectorTile, i.layerIndex, i.availableImages, i.actor, function (t, i) {\n          if (t || !i) return r(t);\n          r(null, e.extend({\n            rawTileData: l.slice(0)\n          }, i, u, h));\n        }), i.loaded = i.loaded || {}, i.loaded[o] = a;\n      });\n    }, l.prototype.reloadTile = function (e, t) {\n      var r = this,\n        i = this.loaded,\n        o = e.uid,\n        n = this;\n      if (i && i[o]) {\n        var s = i[o];\n        s.showCollisionBoxes = e.showCollisionBoxes;\n        var a = function (e, i) {\n          var o = s.reloadCallback;\n          o && (delete s.reloadCallback, s.parse(s.vectorTile, n.layerIndex, r.availableImages, n.actor, o)), t(e, i);\n        };\n        "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());\n      }\n    }, l.prototype.abortTile = function (e, t) {\n      var r = this.loading,\n        i = e.uid;\n      r && r[i] && r[i].abort && (r[i].abort(), delete r[i]), t();\n    }, l.prototype.removeTile = function (e, t) {\n      var r = this.loaded,\n        i = e.uid;\n      r && r[i] && delete r[i], t();\n    };\n    var u = e.window.ImageBitmap,\n      h = function () {\n        this.loaded = {};\n      };\n    function c(e, t) {\n      if (0 !== e.length) {\n        p(e[0], t);\n        for (var r = 1; r < e.length; r++) p(e[r], !t);\n      }\n    }\n    function p(e, t) {\n      for (var r = 0, i = 0, o = e.length, n = o - 1; i < o; n = i++) r += (e[i][0] - e[n][0]) * (e[n][1] + e[i][1]);\n      r >= 0 != !!t && e.reverse();\n    }\n    h.prototype.loadTile = function (t, r) {\n      var i = t.uid,\n        o = t.encoding,\n        n = t.rawImageData,\n        s = u && n instanceof u ? this.getImageData(n) : n,\n        a = new e.DEMData(i, s, o);\n      this.loaded = this.loaded || {}, this.loaded[i] = a, r(null, a);\n    }, h.prototype.getImageData = function (t) {\n      this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width, t.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t.width, this.offscreenCanvas.height = t.height, this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);\n      var r = this.offscreenCanvasContext.getImageData(-1, -1, t.width + 2, t.height + 2);\n      return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({\n        width: r.width,\n        height: r.height\n      }, r.data);\n    }, h.prototype.removeTile = function (e) {\n      var t = this.loaded,\n        r = e.uid;\n      t && t[r] && delete t[r];\n    };\n    var f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON,\n      d = function (t) {\n        this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n      };\n    d.prototype.loadGeometry = function () {\n      if (1 === this._feature.type) {\n        for (var t = [], r = 0, i = this._feature.geometry; r < i.length; r += 1) {\n          var o = i[r];\n          t.push([new e.Point$1(o[0], o[1])]);\n        }\n        return t;\n      }\n      for (var n = [], s = 0, a = this._feature.geometry; s < a.length; s += 1) {\n        for (var l = [], u = 0, h = a[s]; u < h.length; u += 1) {\n          var c = h[u];\n          l.push(new e.Point$1(c[0], c[1]));\n        }\n        n.push(l);\n      }\n      return n;\n    }, d.prototype.toGeoJSON = function (e, t, r) {\n      return f.call(this, e, t, r);\n    };\n    var g = function (t) {\n      this.layers = {\n        _geojsonTileLayer: this\n      }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t;\n    };\n    g.prototype.feature = function (e) {\n      return new d(this._features[e]);\n    };\n    var v = e.vectorTile.VectorTileFeature,\n      m = y;\n    function y(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n    function x(e, t) {\n      this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n    y.prototype.feature = function (e) {\n      return new x(this.features[e], this.options.extent);\n    }, x.prototype.loadGeometry = function () {\n      var t = this.rawGeometry;\n      this.geometry = [];\n      for (var r = 0; r < t.length; r++) {\n        for (var i = t[r], o = [], n = 0; n < i.length; n++) o.push(new e.Point$1(i[n][0], i[n][1]));\n        this.geometry.push(o);\n      }\n      return this.geometry;\n    }, x.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, i = 1 / 0, o = -1 / 0, n = 0; n < e.length; n++) for (var s = e[n], a = 0; a < s.length; a++) {\n        var l = s[a];\n        t = Math.min(t, l.x), r = Math.max(r, l.x), i = Math.min(i, l.y), o = Math.max(o, l.y);\n      }\n      return [t, i, r, o];\n    }, x.prototype.toGeoJSON = v.prototype.toGeoJSON;\n    var w = I,\n      S = m;\n    function I(t) {\n      var r = new e.pbf();\n      return function (e, t) {\n        for (var r in e.layers) t.writeMessage(3, M, e.layers[r]);\n      }(t, r), r.finish();\n    }\n    function M(e, t) {\n      var r;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);\n      var i = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n      for (r = 0; r < e.length; r++) i.feature = e.feature(r), t.writeMessage(2, b, i);\n      var o = i.keys;\n      for (r = 0; r < o.length; r++) t.writeStringField(3, o[r]);\n      var n = i.values;\n      for (r = 0; r < n.length; r++) t.writeMessage(4, C, n[r]);\n    }\n    function b(e, t) {\n      var r = e.feature;\n      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, _, e), t.writeVarintField(3, r.type), t.writeMessage(4, T, r);\n    }\n    function _(e, t) {\n      var r = e.feature,\n        i = e.keys,\n        o = e.values,\n        n = e.keycache,\n        s = e.valuecache;\n      for (var a in r.properties) {\n        var l = n[a];\n        void 0 === l && (i.push(a), n[a] = l = i.length - 1), t.writeVarint(l);\n        var u = r.properties[a],\n          h = typeof u;\n        "string" !== h && "boolean" !== h && "number" !== h && (u = JSON.stringify(u));\n        var c = h + ":" + u,\n          p = s[c];\n        void 0 === p && (o.push(u), s[c] = p = o.length - 1), t.writeVarint(p);\n      }\n    }\n    function k(e, t) {\n      return (t << 3) + (7 & e);\n    }\n    function P(e) {\n      return e << 1 ^ e >> 31;\n    }\n    function T(e, t) {\n      for (var r = e.loadGeometry(), i = e.type, o = 0, n = 0, s = r.length, a = 0; a < s; a++) {\n        var l = r[a],\n          u = 1;\n        1 === i && (u = l.length), t.writeVarint(k(1, u));\n        for (var h = 3 === i ? l.length - 1 : l.length, c = 0; c < h; c++) {\n          1 === c && 1 !== i && t.writeVarint(k(2, h - 1));\n          var p = l[c].x - o,\n            f = l[c].y - n;\n          t.writeVarint(P(p)), t.writeVarint(P(f)), o += p, n += f;\n        }\n        3 === i && t.writeVarint(k(7, 1));\n      }\n    }\n    function C(e, t) {\n      var r = typeof e;\n      "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n    function D(e, t, r, i) {\n      L(e, r, i), L(t, 2 * r, 2 * i), L(t, 2 * r + 1, 2 * i + 1);\n    }\n    function L(e, t, r) {\n      var i = e[t];\n      e[t] = e[r], e[r] = i;\n    }\n    function z(e, t, r, i) {\n      var o = e - r,\n        n = t - i;\n      return o * o + n * n;\n    }\n    w.fromVectorTileJs = I, w.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var r = {};\n      for (var i in e) r[i] = new m(e[i].features, t), r[i].name = i, r[i].version = t.version, r[i].extent = t.extent;\n      return I({\n        layers: r\n      });\n    }, w.GeoJSONWrapper = S;\n    var O = function (e) {\n        return e[0];\n      },\n      E = function (e) {\n        return e[1];\n      },\n      F = function (e, t, r, i, o) {\n        void 0 === t && (t = O), void 0 === r && (r = E), void 0 === i && (i = 64), void 0 === o && (o = Float64Array), this.nodeSize = i, this.points = e;\n        for (var n = e.length < 65536 ? Uint16Array : Uint32Array, s = this.ids = new n(e.length), a = this.coords = new o(2 * e.length), l = 0; l < e.length; l++) s[l] = l, a[2 * l] = t(e[l]), a[2 * l + 1] = r(e[l]);\n        !function e(t, r, i, o, n, s) {\n          if (!(n - o <= i)) {\n            var a = o + n >> 1;\n            !function e(t, r, i, o, n, s) {\n              for (; n > o;) {\n                if (n - o > 600) {\n                  var a = n - o + 1,\n                    l = i - o + 1,\n                    u = Math.log(a),\n                    h = .5 * Math.exp(2 * u / 3),\n                    c = .5 * Math.sqrt(u * h * (a - h) / a) * (l - a / 2 < 0 ? -1 : 1);\n                  e(t, r, i, Math.max(o, Math.floor(i - l * h / a + c)), Math.min(n, Math.floor(i + (a - l) * h / a + c)), s);\n                }\n                var p = r[2 * i + s],\n                  f = o,\n                  d = n;\n                for (D(t, r, o, i), r[2 * n + s] > p && D(t, r, o, n); f < d;) {\n                  for (D(t, r, f, d), f++, d--; r[2 * f + s] < p;) f++;\n                  for (; r[2 * d + s] > p;) d--;\n                }\n                r[2 * o + s] === p ? D(t, r, o, d) : D(t, r, ++d, n), d <= i && (o = d + 1), i <= d && (n = d - 1);\n              }\n            }(t, r, a, o, n, s % 2), e(t, r, i, o, a - 1, s + 1), e(t, r, i, a + 1, n, s + 1);\n          }\n        }(s, a, i, 0, s.length - 1, 0);\n      };\n    F.prototype.range = function (e, t, r, i) {\n      return function (e, t, r, i, o, n, s) {\n        for (var a, l, u = [0, e.length - 1, 0], h = []; u.length;) {\n          var c = u.pop(),\n            p = u.pop(),\n            f = u.pop();\n          if (p - f <= s) for (var d = f; d <= p; d++) l = t[2 * d + 1], (a = t[2 * d]) >= r && a <= o && l >= i && l <= n && h.push(e[d]);else {\n            var g = Math.floor((f + p) / 2);\n            l = t[2 * g + 1], (a = t[2 * g]) >= r && a <= o && l >= i && l <= n && h.push(e[g]);\n            var v = (c + 1) % 2;\n            (0 === c ? r <= a : i <= l) && (u.push(f), u.push(g - 1), u.push(v)), (0 === c ? o >= a : n >= l) && (u.push(g + 1), u.push(p), u.push(v));\n          }\n        }\n        return h;\n      }(this.ids, this.coords, e, t, r, i, this.nodeSize);\n    }, F.prototype.within = function (e, t, r) {\n      return function (e, t, r, i, o, n) {\n        for (var s = [0, e.length - 1, 0], a = [], l = o * o; s.length;) {\n          var u = s.pop(),\n            h = s.pop(),\n            c = s.pop();\n          if (h - c <= n) for (var p = c; p <= h; p++) z(t[2 * p], t[2 * p + 1], r, i) <= l && a.push(e[p]);else {\n            var f = Math.floor((c + h) / 2),\n              d = t[2 * f],\n              g = t[2 * f + 1];\n            z(d, g, r, i) <= l && a.push(e[f]);\n            var v = (u + 1) % 2;\n            (0 === u ? r - o <= d : i - o <= g) && (s.push(c), s.push(f - 1), s.push(v)), (0 === u ? r + o >= d : i + o >= g) && (s.push(f + 1), s.push(h), s.push(v));\n          }\n        }\n        return a;\n      }(this.ids, this.coords, e, t, r, this.nodeSize);\n    };\n    var N = {\n        minZoom: 0,\n        maxZoom: 16,\n        minPoints: 2,\n        radius: 40,\n        extent: 512,\n        nodeSize: 64,\n        log: !1,\n        generateId: !1,\n        reduce: null,\n        map: function (e) {\n          return e;\n        }\n      },\n      J = function (e) {\n        this.options = V(Object.create(N), e), this.trees = new Array(this.options.maxZoom + 1);\n      };\n    function Z(e, t, r, i, o) {\n      return {\n        x: e,\n        y: t,\n        zoom: 1 / 0,\n        id: r,\n        parentId: -1,\n        numPoints: i,\n        properties: o\n      };\n    }\n    function A(e, t) {\n      var r = e.geometry.coordinates,\n        i = r[1];\n      return {\n        x: Y(r[0]),\n        y: j(i),\n        zoom: 1 / 0,\n        index: t,\n        parentId: -1\n      };\n    }\n    function B(e) {\n      return {\n        type: "Feature",\n        id: e.id,\n        properties: G(e),\n        geometry: {\n          type: "Point",\n          coordinates: [(i = e.x, 360 * (i - .5)), (t = e.y, r = (180 - 360 * t) * Math.PI / 180, 360 * Math.atan(Math.exp(r)) / Math.PI - 90)]\n        }\n      };\n      var t, r, i;\n    }\n    function G(e) {\n      var t = e.numPoints,\n        r = t >= 1e4 ? Math.round(t / 1e3) + "k" : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;\n      return V(V({}, e.properties), {\n        cluster: !0,\n        cluster_id: e.id,\n        point_count: t,\n        point_count_abbreviated: r\n      });\n    }\n    function Y(e) {\n      return e / 360 + .5;\n    }\n    function j(e) {\n      var t = Math.sin(e * Math.PI / 180),\n        r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n    function V(e, t) {\n      for (var r in t) e[r] = t[r];\n      return e;\n    }\n    function X(e) {\n      return e.x;\n    }\n    function W(e) {\n      return e.y;\n    }\n    function R(e, t, r, i, o, n) {\n      var s = o - r,\n        a = n - i;\n      if (0 !== s || 0 !== a) {\n        var l = ((e - r) * s + (t - i) * a) / (s * s + a * a);\n        l > 1 ? (r = o, i = n) : l > 0 && (r += s * l, i += a * l);\n      }\n      return (s = e - r) * s + (a = t - i) * a;\n    }\n    function q(e, t, r, i) {\n      var o = {\n        id: void 0 === e ? null : e,\n        type: t,\n        geometry: r,\n        tags: i,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      return function (e) {\n        var t = e.geometry,\n          r = e.type;\n        if ("Point" === r || "MultiPoint" === r || "LineString" === r) U(e, t);else if ("Polygon" === r || "MultiLineString" === r) for (var i = 0; i < t.length; i++) U(e, t[i]);else if ("MultiPolygon" === r) for (i = 0; i < t.length; i++) for (var o = 0; o < t[i].length; o++) U(e, t[i][o]);\n      }(o), o;\n    }\n    function U(e, t) {\n      for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);\n    }\n    function $(e, t, r, i) {\n      if (t.geometry) {\n        var o = t.geometry.coordinates,\n          n = t.geometry.type,\n          s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),\n          a = [],\n          l = t.id;\n        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = i || 0), "Point" === n) H(o, a);else if ("MultiPoint" === n) for (var u = 0; u < o.length; u++) H(o[u], a);else if ("LineString" === n) K(o, a, s, !1);else if ("MultiLineString" === n) {\n          if (r.lineMetrics) {\n            for (u = 0; u < o.length; u++) K(o[u], a = [], s, !1), e.push(q(l, "LineString", a, t.properties));\n            return;\n          }\n          Q(o, a, s, !1);\n        } else if ("Polygon" === n) Q(o, a, s, !0);else {\n          if ("MultiPolygon" !== n) {\n            if ("GeometryCollection" === n) {\n              for (u = 0; u < t.geometry.geometries.length; u++) $(e, {\n                id: l,\n                geometry: t.geometry.geometries[u],\n                properties: t.properties\n              }, r, i);\n              return;\n            }\n            throw new Error("Input data is not a valid GeoJSON object.");\n          }\n          for (u = 0; u < o.length; u++) {\n            var h = [];\n            Q(o[u], h, s, !0), a.push(h);\n          }\n        }\n        e.push(q(l, n, a, t.properties));\n      }\n    }\n    function H(e, t) {\n      t.push(ee(e[0])), t.push(te(e[1])), t.push(0);\n    }\n    function K(e, t, r, i) {\n      for (var o, n, s = 0, a = 0; a < e.length; a++) {\n        var l = ee(e[a][0]),\n          u = te(e[a][1]);\n        t.push(l), t.push(u), t.push(0), a > 0 && (s += i ? (o * u - l * n) / 2 : Math.sqrt(Math.pow(l - o, 2) + Math.pow(u - n, 2))), o = l, n = u;\n      }\n      var h = t.length - 3;\n      t[2] = 1, function e(t, r, i, o) {\n        for (var n, s = o, a = i - r >> 1, l = i - r, u = t[r], h = t[r + 1], c = t[i], p = t[i + 1], f = r + 3; f < i; f += 3) {\n          var d = R(t[f], t[f + 1], u, h, c, p);\n          if (d > s) n = f, s = d;else if (d === s) {\n            var g = Math.abs(f - a);\n            g < l && (n = f, l = g);\n          }\n        }\n        s > o && (n - r > 3 && e(t, r, n, o), t[n + 2] = s, i - n > 3 && e(t, n, i, o));\n      }(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;\n    }\n    function Q(e, t, r, i) {\n      for (var o = 0; o < e.length; o++) {\n        var n = [];\n        K(e[o], n, r, i), t.push(n);\n      }\n    }\n    function ee(e) {\n      return e / 360 + .5;\n    }\n    function te(e) {\n      var t = Math.sin(e * Math.PI / 180),\n        r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n    function re(e, t, r, i, o, n, s, a) {\n      if (i /= t, n >= (r /= t) && s < i) return e;\n      if (s < r || n >= i) return null;\n      for (var l = [], u = 0; u < e.length; u++) {\n        var h = e[u],\n          c = h.geometry,\n          p = h.type,\n          f = 0 === o ? h.minX : h.minY,\n          d = 0 === o ? h.maxX : h.maxY;\n        if (f >= r && d < i) l.push(h);else if (!(d < r || f >= i)) {\n          var g = [];\n          if ("Point" === p || "MultiPoint" === p) ie(c, g, r, i, o);else if ("LineString" === p) oe(c, g, r, i, o, !1, a.lineMetrics);else if ("MultiLineString" === p) se(c, g, r, i, o, !1);else if ("Polygon" === p) se(c, g, r, i, o, !0);else if ("MultiPolygon" === p) for (var v = 0; v < c.length; v++) {\n            var m = [];\n            se(c[v], m, r, i, o, !0), m.length && g.push(m);\n          }\n          if (g.length) {\n            if (a.lineMetrics && "LineString" === p) {\n              for (v = 0; v < g.length; v++) l.push(q(h.id, p, g[v], h.tags));\n              continue;\n            }\n            "LineString" !== p && "MultiLineString" !== p || (1 === g.length ? (p = "LineString", g = g[0]) : p = "MultiLineString"), "Point" !== p && "MultiPoint" !== p || (p = 3 === g.length ? "Point" : "MultiPoint"), l.push(q(h.id, p, g, h.tags));\n          }\n        }\n      }\n      return l.length ? l : null;\n    }\n    function ie(e, t, r, i, o) {\n      for (var n = 0; n < e.length; n += 3) {\n        var s = e[n + o];\n        s >= r && s <= i && (t.push(e[n]), t.push(e[n + 1]), t.push(e[n + 2]));\n      }\n    }\n    function oe(e, t, r, i, o, n, s) {\n      for (var a, l, u = ne(e), h = 0 === o ? le : ue, c = e.start, p = 0; p < e.length - 3; p += 3) {\n        var f = e[p],\n          d = e[p + 1],\n          g = e[p + 2],\n          v = e[p + 3],\n          m = e[p + 4],\n          y = 0 === o ? f : d,\n          x = 0 === o ? v : m,\n          w = !1;\n        s && (a = Math.sqrt(Math.pow(f - v, 2) + Math.pow(d - m, 2))), y < r ? x > r && (l = h(u, f, d, v, m, r), s && (u.start = c + a * l)) : y > i ? x < i && (l = h(u, f, d, v, m, i), s && (u.start = c + a * l)) : ae(u, f, d, g), x < r && y >= r && (l = h(u, f, d, v, m, r), w = !0), x > i && y <= i && (l = h(u, f, d, v, m, i), w = !0), !n && w && (s && (u.end = c + a * l), t.push(u), u = ne(e)), s && (c += a);\n      }\n      var S = e.length - 3;\n      f = e[S], d = e[S + 1], g = e[S + 2], (y = 0 === o ? f : d) >= r && y <= i && ae(u, f, d, g), S = u.length - 3, n && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && ae(u, u[0], u[1], u[2]), u.length && t.push(u);\n    }\n    function ne(e) {\n      var t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n    function se(e, t, r, i, o, n) {\n      for (var s = 0; s < e.length; s++) oe(e[s], t, r, i, o, n, !1);\n    }\n    function ae(e, t, r, i) {\n      e.push(t), e.push(r), e.push(i);\n    }\n    function le(e, t, r, i, o, n) {\n      var s = (n - t) / (i - t);\n      return e.push(n), e.push(r + (o - r) * s), e.push(1), s;\n    }\n    function ue(e, t, r, i, o, n) {\n      var s = (n - r) / (o - r);\n      return e.push(t + (i - t) * s), e.push(n), e.push(1), s;\n    }\n    function he(e, t) {\n      for (var r = [], i = 0; i < e.length; i++) {\n        var o,\n          n = e[i],\n          s = n.type;\n        if ("Point" === s || "MultiPoint" === s || "LineString" === s) o = ce(n.geometry, t);else if ("MultiLineString" === s || "Polygon" === s) {\n          o = [];\n          for (var a = 0; a < n.geometry.length; a++) o.push(ce(n.geometry[a], t));\n        } else if ("MultiPolygon" === s) for (o = [], a = 0; a < n.geometry.length; a++) {\n          for (var l = [], u = 0; u < n.geometry[a].length; u++) l.push(ce(n.geometry[a][u], t));\n          o.push(l);\n        }\n        r.push(q(n.id, s, o, n.tags));\n      }\n      return r;\n    }\n    function ce(e, t) {\n      var r = [];\n      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);\n      for (var i = 0; i < e.length; i += 3) r.push(e[i] + t, e[i + 1], e[i + 2]);\n      return r;\n    }\n    function pe(e, t) {\n      if (e.transformed) return e;\n      var r,\n        i,\n        o,\n        n = 1 << e.z,\n        s = e.x,\n        a = e.y;\n      for (r = 0; r < e.features.length; r++) {\n        var l = e.features[r],\n          u = l.geometry,\n          h = l.type;\n        if (l.geometry = [], 1 === h) for (i = 0; i < u.length; i += 2) l.geometry.push(fe(u[i], u[i + 1], t, n, s, a));else for (i = 0; i < u.length; i++) {\n          var c = [];\n          for (o = 0; o < u[i].length; o += 2) c.push(fe(u[i][o], u[i][o + 1], t, n, s, a));\n          l.geometry.push(c);\n        }\n      }\n      return e.transformed = !0, e;\n    }\n    function fe(e, t, r, i, o, n) {\n      return [Math.round(r * (e * i - o)), Math.round(r * (t * i - n))];\n    }\n    function de(e, t, r, i, o) {\n      for (var n = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent), s = {\n          features: [],\n          numPoints: 0,\n          numSimplified: 0,\n          numFeatures: 0,\n          source: null,\n          x: r,\n          y: i,\n          z: t,\n          transformed: !1,\n          minX: 2,\n          minY: 1,\n          maxX: -1,\n          maxY: 0\n        }, a = 0; a < e.length; a++) {\n        s.numFeatures++, ge(s, e[a], n, o);\n        var l = e[a].minX,\n          u = e[a].minY,\n          h = e[a].maxX,\n          c = e[a].maxY;\n        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);\n      }\n      return s;\n    }\n    function ge(e, t, r, i) {\n      var o = t.geometry,\n        n = t.type,\n        s = [];\n      if ("Point" === n || "MultiPoint" === n) for (var a = 0; a < o.length; a += 3) s.push(o[a]), s.push(o[a + 1]), e.numPoints++, e.numSimplified++;else if ("LineString" === n) ve(s, o, e, r, !1, !1);else if ("MultiLineString" === n || "Polygon" === n) for (a = 0; a < o.length; a++) ve(s, o[a], e, r, "Polygon" === n, 0 === a);else if ("MultiPolygon" === n) for (var l = 0; l < o.length; l++) {\n        var u = o[l];\n        for (a = 0; a < u.length; a++) ve(s, u[a], e, r, !0, 0 === a);\n      }\n      if (s.length) {\n        var h = t.tags || null;\n        if ("LineString" === n && i.lineMetrics) {\n          for (var c in h = {}, t.tags) h[c] = t.tags[c];\n          h.mapbox_clip_start = o.start / o.size, h.mapbox_clip_end = o.end / o.size;\n        }\n        var p = {\n          geometry: s,\n          type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,\n          tags: h\n        };\n        null !== t.id && (p.id = t.id), e.features.push(p);\n      }\n    }\n    function ve(e, t, r, i, o, n) {\n      var s = i * i;\n      if (i > 0 && t.size < (o ? s : i)) r.numPoints += t.length / 3;else {\n        for (var a = [], l = 0; l < t.length; l += 3) (0 === i || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;\n        o && function (e, t) {\n          for (var r = 0, i = 0, o = e.length, n = o - 2; i < o; n = i, i += 2) r += (e[i] - e[n]) * (e[i + 1] + e[n + 1]);\n          if (r > 0 === t) for (i = 0, o = e.length; i < o / 2; i += 2) {\n            var s = e[i],\n              a = e[i + 1];\n            e[i] = e[o - 2 - i], e[i + 1] = e[o - 1 - i], e[o - 2 - i] = s, e[o - 1 - i] = a;\n          }\n        }(a, n), e.push(a);\n      }\n    }\n    function me(e, t) {\n      var r = (t = this.options = function (e, t) {\n        for (var r in t) e[r] = t[r];\n        return e;\n      }(Object.create(this.options), t)).debug;\n      if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");\n      if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");\n      var i = function (e, t) {\n        var r = [];\n        if ("FeatureCollection" === e.type) for (var i = 0; i < e.features.length; i++) $(r, e.features[i], t, i);else $(r, "Feature" === e.type ? e : {\n          geometry: e\n        }, t);\n        return r;\n      }(e, t);\n      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i = function (e, t) {\n        var r = t.buffer / t.extent,\n          i = e,\n          o = re(e, 1, -1 - r, r, 0, -1, 2, t),\n          n = re(e, 1, 1 - r, 2 + r, 0, -1, 2, t);\n        return (o || n) && (i = re(e, 1, -r, 1 + r, 0, -1, 2, t) || [], o && (i = he(o, 1).concat(i)), n && (i = i.concat(he(n, -1)))), i;\n      }(i, t)).length && this.splitTile(i, 0, 0, 0), r && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));\n    }\n    function ye(e, t, r) {\n      return 32 * ((1 << e) * r + t) + e;\n    }\n    function xe(e, t) {\n      var r = e.tileID.canonical;\n      if (!this._geoJSONIndex) return t(null, null);\n      var i = this._geoJSONIndex.getTile(r.z, r.x, r.y);\n      if (!i) return t(null, null);\n      var o = new g(i.features),\n        n = w(o);\n      0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t(null, {\n        vectorTile: o,\n        rawData: n.buffer\n      });\n    }\n    J.prototype.load = function (e) {\n      var t = this.options,\n        r = t.log,\n        i = t.minZoom,\n        o = t.maxZoom,\n        n = t.nodeSize;\n      r && console.time("total time");\n      var s = "prepare " + e.length + " points";\n      r && console.time(s), this.points = e;\n      for (var a = [], l = 0; l < e.length; l++) e[l].geometry && a.push(A(e[l], l));\n      this.trees[o + 1] = new F(a, X, W, n, Float32Array), r && console.timeEnd(s);\n      for (var u = o; u >= i; u--) {\n        var h = +Date.now();\n        a = this._cluster(a, u), this.trees[u] = new F(a, X, W, n, Float32Array), r && console.log("z%d: %d clusters in %dms", u, a.length, +Date.now() - h);\n      }\n      return r && console.timeEnd("total time"), this;\n    }, J.prototype.getClusters = function (e, t) {\n      var r = ((e[0] + 180) % 360 + 360) % 360 - 180,\n        i = Math.max(-90, Math.min(90, e[1])),\n        o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180,\n        n = Math.max(-90, Math.min(90, e[3]));\n      if (e[2] - e[0] >= 360) r = -180, o = 180;else if (r > o) {\n        var s = this.getClusters([r, i, 180, n], t),\n          a = this.getClusters([-180, i, o, n], t);\n        return s.concat(a);\n      }\n      for (var l = this.trees[this._limitZoom(t)], u = [], h = 0, c = l.range(Y(r), j(n), Y(o), j(i)); h < c.length; h += 1) {\n        var p = l.points[c[h]];\n        u.push(p.numPoints ? B(p) : this.points[p.index]);\n      }\n      return u;\n    }, J.prototype.getChildren = function (e) {\n      var t = this._getOriginId(e),\n        r = this._getOriginZoom(e),\n        i = "No cluster with the specified id.",\n        o = this.trees[r];\n      if (!o) throw new Error(i);\n      var n = o.points[t];\n      if (!n) throw new Error(i);\n      for (var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = [], l = 0, u = o.within(n.x, n.y, s); l < u.length; l += 1) {\n        var h = o.points[u[l]];\n        h.parentId === e && a.push(h.numPoints ? B(h) : this.points[h.index]);\n      }\n      if (0 === a.length) throw new Error(i);\n      return a;\n    }, J.prototype.getLeaves = function (e, t, r) {\n      var i = [];\n      return this._appendLeaves(i, e, t = t || 10, r = r || 0, 0), i;\n    }, J.prototype.getTile = function (e, t, r) {\n      var i = this.trees[this._limitZoom(e)],\n        o = Math.pow(2, e),\n        n = this.options,\n        s = n.radius / n.extent,\n        a = (r - s) / o,\n        l = (r + 1 + s) / o,\n        u = {\n          features: []\n        };\n      return this._addTileFeatures(i.range((t - s) / o, a, (t + 1 + s) / o, l), i.points, t, r, o, u), 0 === t && this._addTileFeatures(i.range(1 - s / o, a, 1, l), i.points, o, r, o, u), t === o - 1 && this._addTileFeatures(i.range(0, a, s / o, l), i.points, -1, r, o, u), u.features.length ? u : null;\n    }, J.prototype.getClusterExpansionZoom = function (e) {\n      for (var t = this._getOriginZoom(e) - 1; t <= this.options.maxZoom;) {\n        var r = this.getChildren(e);\n        if (t++, 1 !== r.length) break;\n        e = r[0].properties.cluster_id;\n      }\n      return t;\n    }, J.prototype._appendLeaves = function (e, t, r, i, o) {\n      for (var n = 0, s = this.getChildren(t); n < s.length; n += 1) {\n        var a = s[n],\n          l = a.properties;\n        if (l && l.cluster ? o + l.point_count <= i ? o += l.point_count : o = this._appendLeaves(e, l.cluster_id, r, i, o) : o < i ? o++ : e.push(a), e.length === r) break;\n      }\n      return o;\n    }, J.prototype._addTileFeatures = function (e, t, r, i, o, n) {\n      for (var s = 0, a = e; s < a.length; s += 1) {\n        var l = t[a[s]],\n          u = l.numPoints,\n          h = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (l.x * o - r)), Math.round(this.options.extent * (l.y * o - i))]],\n            tags: u ? G(l) : this.points[l.index].properties\n          },\n          c = void 0;\n        u ? c = l.id : this.options.generateId ? c = l.index : this.points[l.index].id && (c = this.points[l.index].id), void 0 !== c && (h.id = c), n.features.push(h);\n      }\n    }, J.prototype._limitZoom = function (e) {\n      return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1));\n    }, J.prototype._cluster = function (e, t) {\n      for (var r = [], i = this.options, o = i.reduce, n = i.minPoints, s = i.radius / (i.extent * Math.pow(2, t)), a = 0; a < e.length; a++) {\n        var l = e[a];\n        if (!(l.zoom <= t)) {\n          l.zoom = t;\n          for (var u = this.trees[t + 1], h = u.within(l.x, l.y, s), c = l.numPoints || 1, p = c, f = 0, d = h; f < d.length; f += 1) {\n            var g = u.points[d[f]];\n            g.zoom > t && (p += g.numPoints || 1);\n          }\n          if (p >= n) {\n            for (var v = l.x * c, m = l.y * c, y = o && c > 1 ? this._map(l, !0) : null, x = (a << 5) + (t + 1) + this.points.length, w = 0, S = h; w < S.length; w += 1) {\n              var I = u.points[S[w]];\n              if (!(I.zoom <= t)) {\n                I.zoom = t;\n                var M = I.numPoints || 1;\n                v += I.x * M, m += I.y * M, I.parentId = x, o && (y || (y = this._map(l, !0)), o(y, this._map(I)));\n              }\n            }\n            l.parentId = x, r.push(Z(v / p, m / p, x, p, y));\n          } else if (r.push(l), p > 1) for (var b = 0, _ = h; b < _.length; b += 1) {\n            var k = u.points[_[b]];\n            k.zoom <= t || (k.zoom = t, r.push(k));\n          }\n        }\n      }\n      return r;\n    }, J.prototype._getOriginId = function (e) {\n      return e - this.points.length >> 5;\n    }, J.prototype._getOriginZoom = function (e) {\n      return (e - this.points.length) % 32;\n    }, J.prototype._map = function (e, t) {\n      if (e.numPoints) return t ? V({}, e.properties) : e.properties;\n      var r = this.points[e.index].properties,\n        i = this.options.map(r);\n      return t && i === r ? V({}, i) : i;\n    }, me.prototype.options = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    }, me.prototype.splitTile = function (e, t, r, i, o, n, s) {\n      for (var a = [e, t, r, i], l = this.options, u = l.debug; a.length;) {\n        i = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();\n        var h = 1 << t,\n          c = ye(t, r, i),\n          p = this.tiles[c];\n        if (!p && (u > 1 && console.time("creation"), p = this.tiles[c] = de(e, t, r, i, l), this.tileCoords.push({\n          z: t,\n          x: r,\n          y: i\n        }), u)) {\n          u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd("creation"));\n          var f = "z" + t;\n          this.stats[f] = (this.stats[f] || 0) + 1, this.total++;\n        }\n        if (p.source = e, o) {\n          if (t === l.maxZoom || t === o) continue;\n          var d = 1 << o - t;\n          if (r !== Math.floor(n / d) || i !== Math.floor(s / d)) continue;\n        } else if (t === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;\n        if (p.source = null, 0 !== e.length) {\n          u > 1 && console.time("clipping");\n          var g,\n            v,\n            m,\n            y,\n            x,\n            w,\n            S = .5 * l.buffer / l.extent,\n            I = .5 - S,\n            M = .5 + S,\n            b = 1 + S;\n          g = v = m = y = null, x = re(e, h, r - S, r + M, 0, p.minX, p.maxX, l), w = re(e, h, r + I, r + b, 0, p.minX, p.maxX, l), e = null, x && (g = re(x, h, i - S, i + M, 1, p.minY, p.maxY, l), v = re(x, h, i + I, i + b, 1, p.minY, p.maxY, l), x = null), w && (m = re(w, h, i - S, i + M, 1, p.minY, p.maxY, l), y = re(w, h, i + I, i + b, 1, p.minY, p.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(g || [], t + 1, 2 * r, 2 * i), a.push(v || [], t + 1, 2 * r, 2 * i + 1), a.push(m || [], t + 1, 2 * r + 1, 2 * i), a.push(y || [], t + 1, 2 * r + 1, 2 * i + 1);\n        }\n      }\n    }, me.prototype.getTile = function (e, t, r) {\n      var i = this.options,\n        o = i.extent,\n        n = i.debug;\n      if (e < 0 || e > 24) return null;\n      var s = 1 << e,\n        a = ye(e, t = (t % s + s) % s, r);\n      if (this.tiles[a]) return pe(this.tiles[a], o);\n      n > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);\n      for (var l, u = e, h = t, c = r; !l && u > 0;) u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[ye(u, h, c)];\n      return l && l.source ? (n > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), n > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e, t, r), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? pe(this.tiles[a], o) : null) : null;\n    };\n    var we = function (t) {\n        function r(e, r, i, o) {\n          t.call(this, e, r, i, xe), o && (this.loadGeoJSON = o);\n        }\n        return t && (r.__proto__ = t), (r.prototype = Object.create(t && t.prototype)).constructor = r, r.prototype.loadData = function (e, t) {\n          this._pendingCallback && this._pendingCallback(null, {\n            abandoned: !0\n          }), this._pendingCallback = t, this._pendingLoadDataParams = e, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());\n        }, r.prototype._loadData = function () {\n          var t = this;\n          if (this._pendingCallback && this._pendingLoadDataParams) {\n            var r = this._pendingCallback,\n              i = this._pendingLoadDataParams;\n            delete this._pendingCallback, delete this._pendingLoadDataParams;\n            var o = !!(i && i.request && i.request.collectResourceTiming) && new e.RequestPerformance(i.request);\n            this.loadGeoJSON(i, function (n, s) {\n              if (n || !s) return r(n);\n              if ("object" != typeof s) return r(new Error("Input data given to \'" + i.source + "\' is not a valid GeoJSON object."));\n              !function e(t, r) {\n                var i,\n                  o = t && t.type;\n                if ("FeatureCollection" === o) for (i = 0; i < t.features.length; i++) e(t.features[i], r);else if ("GeometryCollection" === o) for (i = 0; i < t.geometries.length; i++) e(t.geometries[i], r);else if ("Feature" === o) e(t.geometry, r);else if ("Polygon" === o) c(t.coordinates, r);else if ("MultiPolygon" === o) for (i = 0; i < t.coordinates.length; i++) c(t.coordinates[i], r);\n                return t;\n              }(s, !0);\n              try {\n                if (i.filter) {\n                  var a = e.createExpression(i.filter, {\n                    type: "boolean",\n                    "property-type": "data-driven",\n                    overridable: !1,\n                    transition: !1\n                  });\n                  if ("error" === a.result) throw new Error(a.value.map(function (e) {\n                    return e.key + ": " + e.message;\n                  }).join(", "));\n                  var l = s.features.filter(function (e) {\n                    return a.value.evaluate({\n                      zoom: 0\n                    }, e);\n                  });\n                  s = {\n                    type: "FeatureCollection",\n                    features: l\n                  };\n                }\n                t._geoJSONIndex = i.cluster ? new J(function (t) {\n                  var r = t.superclusterOptions,\n                    i = t.clusterProperties;\n                  if (!i || !r) return r;\n                  for (var o = {}, n = {}, s = {\n                      accumulated: null,\n                      zoom: 0\n                    }, a = {\n                      properties: null\n                    }, l = Object.keys(i), u = 0, h = l; u < h.length; u += 1) {\n                    var c = h[u],\n                      p = i[c],\n                      f = p[0],\n                      d = e.createExpression(p[1]),\n                      g = e.createExpression("string" == typeof f ? [f, ["accumulated"], ["get", c]] : f);\n                    o[c] = d.value, n[c] = g.value;\n                  }\n                  return r.map = function (e) {\n                    a.properties = e;\n                    for (var t = {}, r = 0, i = l; r < i.length; r += 1) {\n                      var n = i[r];\n                      t[n] = o[n].evaluate(s, a);\n                    }\n                    return t;\n                  }, r.reduce = function (e, t) {\n                    a.properties = t;\n                    for (var r = 0, i = l; r < i.length; r += 1) {\n                      var o = i[r];\n                      s.accumulated = e[o], e[o] = n[o].evaluate(s, a);\n                    }\n                  }, r;\n                }(i)).load(s.features) : function (e, t) {\n                  return new me(e, t);\n                }(s, i.geojsonVtOptions);\n              } catch (n) {\n                return r(n);\n              }\n              t.loaded = {};\n              var u = {};\n              if (o) {\n                var h = o.finish();\n                h && (u.resourceTiming = {}, u.resourceTiming[i.source] = JSON.parse(JSON.stringify(h)));\n              }\n              r(null, u);\n            });\n          }\n        }, r.prototype.coalesce = function () {\n          "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());\n        }, r.prototype.reloadTile = function (e, r) {\n          var i = this.loaded;\n          return i && i[e.uid] ? t.prototype.reloadTile.call(this, e, r) : this.loadTile(e, r);\n        }, r.prototype.loadGeoJSON = function (t, r) {\n          if (t.request) e.getJSON(t.request, r);else {\n            if ("string" != typeof t.data) return r(new Error("Input data given to \'" + t.source + "\' is not a valid GeoJSON object."));\n            try {\n              return r(null, JSON.parse(t.data));\n            } catch (e) {\n              return r(new Error("Input data given to \'" + t.source + "\' is not a valid GeoJSON object."));\n            }\n          }\n        }, r.prototype.removeSource = function (e, t) {\n          this._pendingCallback && this._pendingCallback(null, {\n            abandoned: !0\n          }), t();\n        }, r.prototype.getClusterExpansionZoom = function (e, t) {\n          try {\n            t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n          } catch (e) {\n            t(e);\n          }\n        }, r.prototype.getClusterChildren = function (e, t) {\n          try {\n            t(null, this._geoJSONIndex.getChildren(e.clusterId));\n          } catch (e) {\n            t(e);\n          }\n        }, r.prototype.getClusterLeaves = function (e, t) {\n          try {\n            t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n          } catch (e) {\n            t(e);\n          }\n        }, r;\n      }(l),\n      Se = function (t) {\n        var r = this;\n        this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = {\n          vector: l,\n          geojson: we\n        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function (e, t) {\n          if (r.workerSourceTypes[e]) throw new Error(\'Worker source with name "\' + e + \'" already registered.\');\n          r.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = function (t) {\n          if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");\n          e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;\n        };\n      };\n    return Se.prototype.setReferrer = function (e, t) {\n      this.referrer = t;\n    }, Se.prototype.setImages = function (e, t, r) {\n      for (var i in this.availableImages[e] = t, this.workerSources[e]) {\n        var o = this.workerSources[e][i];\n        for (var n in o) o[n].availableImages = t;\n      }\n      r();\n    }, Se.prototype.setLayers = function (e, t, r) {\n      this.getLayerIndex(e).replace(t), r();\n    }, Se.prototype.updateLayers = function (e, t, r) {\n      this.getLayerIndex(e).update(t.layers, t.removedIds), r();\n    }, Se.prototype.loadTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).loadTile(t, r);\n    }, Se.prototype.loadDEMTile = function (e, t, r) {\n      this.getDEMWorkerSource(e, t.source).loadTile(t, r);\n    }, Se.prototype.reloadTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).reloadTile(t, r);\n    }, Se.prototype.abortTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).abortTile(t, r);\n    }, Se.prototype.removeTile = function (e, t, r) {\n      this.getWorkerSource(e, t.type, t.source).removeTile(t, r);\n    }, Se.prototype.removeDEMTile = function (e, t) {\n      this.getDEMWorkerSource(e, t.source).removeTile(t);\n    }, Se.prototype.removeSource = function (e, t, r) {\n      if (this.workerSources[e] && this.workerSources[e][t.type] && this.workerSources[e][t.type][t.source]) {\n        var i = this.workerSources[e][t.type][t.source];\n        delete this.workerSources[e][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, r) : r();\n      }\n    }, Se.prototype.loadWorkerSource = function (e, t, r) {\n      try {\n        this.self.importScripts(t.url), r();\n      } catch (e) {\n        r(e.toString());\n      }\n    }, Se.prototype.syncRTLPluginState = function (t, r, i) {\n      try {\n        e.plugin.setState(r);\n        var o = e.plugin.getPluginURL();\n        if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o) {\n          this.self.importScripts(o);\n          var n = e.plugin.isParsed();\n          i(n ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o), n);\n        }\n      } catch (e) {\n        i(e.toString());\n      }\n    }, Se.prototype.getAvailableImages = function (e) {\n      var t = this.availableImages[e];\n      return t || (t = []), t;\n    }, Se.prototype.getLayerIndex = function (e) {\n      var t = this.layerIndexes[e];\n      return t || (t = this.layerIndexes[e] = new i()), t;\n    }, Se.prototype.getWorkerSource = function (e, t, r) {\n      var i = this;\n      return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), this.workerSources[e][t][r] || (this.workerSources[e][t][r] = new this.workerSourceTypes[t]({\n        send: function (t, r, o) {\n          i.actor.send(t, r, o, e);\n        }\n      }, this.getLayerIndex(e), this.getAvailableImages(e))), this.workerSources[e][t][r];\n    }, Se.prototype.getDEMWorkerSource = function (e, t) {\n      return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new h()), this.demWorkerSources[e][t];\n    }, Se.prototype.enforceCacheSizeLimit = function (t, r) {\n      e.enforceCacheSizeLimit(r);\n    }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;\n  });\n  define(["./shared"], function (t) {\n    "use strict";\n\n    var e = t.createCommonjsModule(function (t) {\n        function e(t) {\n          return !i(t);\n        }\n        function i(t) {\n          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {\n            if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;\n            var t,\n              e,\n              i = new Blob([""], {\n                type: "text/javascript"\n              }),\n              o = URL.createObjectURL(i);\n            try {\n              e = new Worker(o), t = !0;\n            } catch (e) {\n              t = !1;\n            }\n            return e && e.terminate(), URL.revokeObjectURL(o), t;\n          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {\n            var t = document.createElement("canvas");\n            t.width = t.height = 1;\n            var e = t.getContext("2d");\n            if (!e) return !1;\n            var i = e.getImageData(0, 0, 1, 1);\n            return i && i.width === t.width;\n          }() ? (void 0 === o[i = t && t.failIfMajorPerformanceCaveat] && (o[i] = function (t) {\n            var i = function (t) {\n              var i = document.createElement("canvas"),\n                o = Object.create(e.webGLContextAttributes);\n              return o.failIfMajorPerformanceCaveat = t, i.probablySupportsContext ? i.probablySupportsContext("webgl", o) || i.probablySupportsContext("experimental-webgl", o) : i.supportsContext ? i.supportsContext("webgl", o) || i.supportsContext("experimental-webgl", o) : i.getContext("webgl", o) || i.getContext("experimental-webgl", o);\n            }(t);\n            if (!i) return !1;\n            var o = i.createShader(i.VERTEX_SHADER);\n            return !(!o || i.isContextLost()) && (i.shaderSource(o, "void main() {}"), i.compileShader(o), !0 === i.getShaderParameter(o, i.COMPILE_STATUS));\n          }(i)), o[i] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";\n          var i;\n        }\n        t.exports ? t.exports = e : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e, window.mapboxgl.notSupportedReason = i);\n        var o = {};\n        e.webGLContextAttributes = {\n          antialias: !1,\n          alpha: !0,\n          stencil: !0,\n          depth: !0\n        };\n      }),\n      i = {\n        create: function (e, i, o) {\n          var r = t.window.document.createElement(e);\n          return void 0 !== i && (r.className = i), o && o.appendChild(r), r;\n        },\n        createNS: function (e, i) {\n          return t.window.document.createElementNS(e, i);\n        }\n      },\n      o = t.window.document && t.window.document.documentElement.style;\n    function r(t) {\n      if (!o) return t[0];\n      for (var e = 0; e < t.length; e++) if (t[e] in o) return t[e];\n      return t[0];\n    }\n    var a,\n      n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);\n    i.disableDrag = function () {\n      o && n && (a = o[n], o[n] = "none");\n    }, i.enableDrag = function () {\n      o && n && (o[n] = a);\n    };\n    var s = r(["transform", "WebkitTransform"]);\n    i.setTransform = function (t, e) {\n      t.style[s] = e;\n    };\n    var l = !1;\n    try {\n      var c = Object.defineProperty({}, "passive", {\n        get: function () {\n          l = !0;\n        }\n      });\n      t.window.addEventListener("test", c, c), t.window.removeEventListener("test", c, c);\n    } catch (t) {\n      l = !1;\n    }\n    i.addEventListener = function (t, e, i, o) {\n      void 0 === o && (o = {}), t.addEventListener(e, i, "passive" in o && l ? o : o.capture);\n    }, i.removeEventListener = function (t, e, i, o) {\n      void 0 === o && (o = {}), t.removeEventListener(e, i, "passive" in o && l ? o : o.capture);\n    };\n    var u = function (e) {\n      e.preventDefault(), e.stopPropagation(), t.window.removeEventListener("click", u, !0);\n    };\n    function h(t) {\n      var e = t.userImage;\n      return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)), !0);\n    }\n    i.suppressClick = function () {\n      t.window.addEventListener("click", u, !0), t.window.setTimeout(function () {\n        t.window.removeEventListener("click", u, !0);\n      }, 0);\n    }, i.mousePos = function (e, i) {\n      var o = e.getBoundingClientRect();\n      return new t.Point(i.clientX - o.left - e.clientLeft, i.clientY - o.top - e.clientTop);\n    }, i.touchPos = function (e, i) {\n      for (var o = e.getBoundingClientRect(), r = [], a = 0; a < i.length; a++) r.push(new t.Point(i[a].clientX - o.left - e.clientLeft, i[a].clientY - o.top - e.clientTop));\n      return r;\n    }, i.mouseButton = function (e) {\n      return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button;\n    }, i.remove = function (t) {\n      t.parentNode && t.parentNode.removeChild(t);\n    };\n    var p = function (e) {\n        function i() {\n          e.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({\n            width: 1,\n            height: 1\n          }), this.dirty = !0;\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.isLoaded = function () {\n          return this.loaded;\n        }, i.prototype.setLoaded = function (t) {\n          if (this.loaded !== t && (this.loaded = t, t)) {\n            for (var e = 0, i = this.requestors; e < i.length; e += 1) {\n              var o = i[e];\n              this._notify(o.ids, o.callback);\n            }\n            this.requestors = [];\n          }\n        }, i.prototype.getImage = function (t) {\n          return this.images[t];\n        }, i.prototype.addImage = function (t, e) {\n          this._validate(t, e) && (this.images[t] = e);\n        }, i.prototype._validate = function (e, i) {\n          var o = !0;\n          return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "stretchX" value\'))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "stretchY" value\'))), o = !1), this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(\'Image "\' + e + \'" has invalid "content" value\'))), o = !1), o;\n        }, i.prototype._validateStretch = function (t, e) {\n          if (!t) return !0;\n          for (var i = 0, o = 0, r = t; o < r.length; o += 1) {\n            var a = r[o];\n            if (a[0] < i || a[1] < a[0] || e < a[1]) return !1;\n            i = a[1];\n          }\n          return !0;\n        }, i.prototype._validateContent = function (t, e) {\n          return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]));\n        }, i.prototype.updateImage = function (t, e) {\n          e.version = this.images[t].version + 1, this.images[t] = e, this.updatedImages[t] = !0;\n        }, i.prototype.removeImage = function (t) {\n          var e = this.images[t];\n          delete this.images[t], delete this.patterns[t], e.userImage && e.userImage.onRemove && e.userImage.onRemove();\n        }, i.prototype.listImages = function () {\n          return Object.keys(this.images);\n        }, i.prototype.getImages = function (t, e) {\n          var i = !0;\n          if (!this.isLoaded()) for (var o = 0, r = t; o < r.length; o += 1) this.images[r[o]] || (i = !1);\n          this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({\n            ids: t,\n            callback: e\n          });\n        }, i.prototype._notify = function (e, i) {\n          for (var o = {}, r = 0, a = e; r < a.length; r += 1) {\n            var n = a[r];\n            this.images[n] || this.fire(new t.Event("styleimagemissing", {\n              id: n\n            }));\n            var s = this.images[n];\n            s ? o[n] = {\n              data: s.data.clone(),\n              pixelRatio: s.pixelRatio,\n              sdf: s.sdf,\n              version: s.version,\n              stretchX: s.stretchX,\n              stretchY: s.stretchY,\n              content: s.content,\n              hasRenderCallback: Boolean(s.userImage && s.userImage.render)\n            } : t.warnOnce(\'Image "\' + n + \'" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.\');\n          }\n          i(null, o);\n        }, i.prototype.getPixelSize = function () {\n          var t = this.atlasImage;\n          return {\n            width: t.width,\n            height: t.height\n          };\n        }, i.prototype.getPattern = function (e) {\n          var i = this.patterns[e],\n            o = this.getImage(e);\n          if (!o) return null;\n          if (i && i.position.version === o.version) return i.position;\n          if (i) i.position.version = o.version;else {\n            var r = {\n                w: o.data.width + 2,\n                h: o.data.height + 2,\n                x: 0,\n                y: 0\n              },\n              a = new t.ImagePosition(r, o);\n            this.patterns[e] = {\n              bin: r,\n              position: a\n            };\n          }\n          return this._updatePatternAtlas(), this.patterns[e].position;\n        }, i.prototype.bind = function (e) {\n          var i = e.gl;\n          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new t.Texture(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n        }, i.prototype._updatePatternAtlas = function () {\n          var e = [];\n          for (var i in this.patterns) e.push(this.patterns[i].bin);\n          var o = t.potpack(e),\n            r = o.w,\n            a = o.h,\n            n = this.atlasImage;\n          for (var s in n.resize({\n            width: r || 1,\n            height: a || 1\n          }), this.patterns) {\n            var l = this.patterns[s].bin,\n              c = l.x + 1,\n              u = l.y + 1,\n              h = this.images[s].data,\n              p = h.width,\n              d = h.height;\n            t.RGBAImage.copy(h, n, {\n              x: 0,\n              y: 0\n            }, {\n              x: c,\n              y: u\n            }, {\n              width: p,\n              height: d\n            }), t.RGBAImage.copy(h, n, {\n              x: 0,\n              y: d - 1\n            }, {\n              x: c,\n              y: u - 1\n            }, {\n              width: p,\n              height: 1\n            }), t.RGBAImage.copy(h, n, {\n              x: 0,\n              y: 0\n            }, {\n              x: c,\n              y: u + d\n            }, {\n              width: p,\n              height: 1\n            }), t.RGBAImage.copy(h, n, {\n              x: p - 1,\n              y: 0\n            }, {\n              x: c - 1,\n              y: u\n            }, {\n              width: 1,\n              height: d\n            }), t.RGBAImage.copy(h, n, {\n              x: 0,\n              y: 0\n            }, {\n              x: c + p,\n              y: u\n            }, {\n              width: 1,\n              height: d\n            });\n          }\n          this.dirty = !0;\n        }, i.prototype.beginFrame = function () {\n          this.callbackDispatchedThisFrame = {};\n        }, i.prototype.dispatchRenderCallbacks = function (t) {\n          for (var e = 0, i = t; e < i.length; e += 1) {\n            var o = i[e];\n            if (!this.callbackDispatchedThisFrame[o]) {\n              this.callbackDispatchedThisFrame[o] = !0;\n              var r = this.images[o];\n              h(r) && this.updateImage(o, r);\n            }\n          }\n        }, i;\n      }(t.Evented),\n      d = m,\n      _ = m,\n      f = 1e20;\n    function m(t, e, i, o, r, a) {\n      this.fontSize = t || 24, this.buffer = void 0 === e ? 3 : e, this.cutoff = o || .25, this.fontFamily = r || "sans-serif", this.fontWeight = a || "normal", this.radius = i || 8;\n      var n = this.size = this.fontSize + 2 * this.buffer;\n      this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.d = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Int16Array(n), this.middle = Math.round(n / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));\n    }\n    function g(t, e, i, o, r, a, n) {\n      for (var s = 0; s < e; s++) {\n        for (var l = 0; l < i; l++) o[l] = t[l * e + s];\n        for (v(o, r, a, n, i), l = 0; l < i; l++) t[l * e + s] = r[l];\n      }\n      for (l = 0; l < i; l++) {\n        for (s = 0; s < e; s++) o[s] = t[l * e + s];\n        for (v(o, r, a, n, e), s = 0; s < e; s++) t[l * e + s] = Math.sqrt(r[s]);\n      }\n    }\n    function v(t, e, i, o, r) {\n      i[0] = 0, o[0] = -f, o[1] = +f;\n      for (var a = 1, n = 0; a < r; a++) {\n        for (var s = (t[a] + a * a - (t[i[n]] + i[n] * i[n])) / (2 * a - 2 * i[n]); s <= o[n];) n--, s = (t[a] + a * a - (t[i[n]] + i[n] * i[n])) / (2 * a - 2 * i[n]);\n        i[++n] = a, o[n] = s, o[n + 1] = +f;\n      }\n      for (a = 0, n = 0; a < r; a++) {\n        for (; o[n + 1] < a;) n++;\n        e[a] = (a - i[n]) * (a - i[n]) + t[i[n]];\n      }\n    }\n    m.prototype.draw = function (t) {\n      this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t, this.buffer, this.middle);\n      for (var e = this.ctx.getImageData(0, 0, this.size, this.size), i = new Uint8ClampedArray(this.size * this.size), o = 0; o < this.size * this.size; o++) {\n        var r = e.data[4 * o + 3] / 255;\n        this.gridOuter[o] = 1 === r ? 0 : 0 === r ? f : Math.pow(Math.max(0, .5 - r), 2), this.gridInner[o] = 1 === r ? f : 0 === r ? 0 : Math.pow(Math.max(0, r - .5), 2);\n      }\n      for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), o = 0; o < this.size * this.size; o++) i[o] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[o] - this.gridInner[o]) / this.radius + this.cutoff))));\n      return i;\n    }, d.default = _;\n    var y = function (t, e) {\n      this.requestManager = t, this.localIdeographFontFamily = e, this.entries = {};\n    };\n    y.prototype.setURL = function (t) {\n      this.url = t;\n    }, y.prototype.getGlyphs = function (e, i) {\n      var o = this,\n        r = [];\n      for (var a in e) for (var n = 0, s = e[a]; n < s.length; n += 1) r.push({\n        stack: a,\n        id: s[n]\n      });\n      t.asyncAll(r, function (t, e) {\n        var i = t.stack,\n          r = t.id,\n          a = o.entries[i];\n        a || (a = o.entries[i] = {\n          glyphs: {},\n          requests: {},\n          ranges: {}\n        });\n        var n = a.glyphs[r];\n        if (void 0 === n) {\n          if (n = o._tinySDF(a, i, r)) return a.glyphs[r] = n, void e(null, {\n            stack: i,\n            id: r,\n            glyph: n\n          });\n          var s = Math.floor(r / 256);\n          if (256 * s > 65535) e(new Error("glyphs > 65535 not supported"));else if (a.ranges[s]) e(null, {\n            stack: i,\n            id: r,\n            glyph: n\n          });else {\n            var l = a.requests[s];\n            l || (l = a.requests[s] = [], y.loadGlyphRange(i, s, o.url, o.requestManager, function (t, e) {\n              if (e) {\n                for (var i in e) o._doesCharSupportLocalGlyph(+i) || (a.glyphs[+i] = e[+i]);\n                a.ranges[s] = !0;\n              }\n              for (var r = 0, n = l; r < n.length; r += 1) (0, n[r])(t, e);\n              delete a.requests[s];\n            })), l.push(function (t, o) {\n              t ? e(t) : o && e(null, {\n                stack: i,\n                id: r,\n                glyph: o[r] || null\n              });\n            });\n          }\n        } else e(null, {\n          stack: i,\n          id: r,\n          glyph: n\n        });\n      }, function (t, e) {\n        if (t) i(t);else if (e) {\n          for (var o = {}, r = 0, a = e; r < a.length; r += 1) {\n            var n = a[r],\n              s = n.stack,\n              l = n.id,\n              c = n.glyph;\n            (o[s] || (o[s] = {}))[l] = c && {\n              id: c.id,\n              bitmap: c.bitmap.clone(),\n              metrics: c.metrics\n            };\n          }\n          i(null, o);\n        }\n      });\n    }, y.prototype._doesCharSupportLocalGlyph = function (e) {\n      return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e) || t.isChar["Hangul Syllables"](e) || t.isChar.Hiragana(e) || t.isChar.Katakana(e));\n    }, y.prototype._tinySDF = function (e, i, o) {\n      var r = this.localIdeographFontFamily;\n      if (r && this._doesCharSupportLocalGlyph(o)) {\n        var a = e.tinySDF;\n        if (!a) {\n          var n = "400";\n          /bold/i.test(i) ? n = "900" : /medium/i.test(i) ? n = "500" : /light/i.test(i) && (n = "200"), a = e.tinySDF = new y.TinySDF(24, 3, 8, .25, r, n);\n        }\n        return {\n          id: o,\n          bitmap: new t.AlphaImage({\n            width: 30,\n            height: 30\n          }, a.draw(String.fromCharCode(o))),\n          metrics: {\n            width: 24,\n            height: 24,\n            left: 0,\n            top: -8,\n            advance: 24\n          }\n        };\n      }\n    }, y.loadGlyphRange = function (e, i, o, r, a) {\n      var n = 256 * i,\n        s = n + 255,\n        l = r.transformRequest(r.normalizeGlyphsURL(o).replace("{fontstack}", e).replace("{range}", n + "-" + s), t.ResourceType.Glyphs);\n      t.getArrayBuffer(l, function (e, i) {\n        if (e) a(e);else if (i) {\n          for (var o = {}, r = 0, n = t.parseGlyphPBF(i); r < n.length; r += 1) {\n            var s = n[r];\n            o[s.id] = s;\n          }\n          a(null, o);\n        }\n      });\n    }, y.TinySDF = d;\n    var x = function () {\n      this.specification = t.styleSpec.light.position;\n    };\n    x.prototype.possiblyEvaluate = function (e, i) {\n      return t.sphericalToCartesian(e.expression.evaluate(i));\n    }, x.prototype.interpolate = function (e, i, o) {\n      return {\n        x: t.number(e.x, i.x, o),\n        y: t.number(e.y, i.y, o),\n        z: t.number(e.z, i.z, o)\n      };\n    };\n    var b = new t.Properties({\n        anchor: new t.DataConstantProperty(t.styleSpec.light.anchor),\n        position: new x(),\n        color: new t.DataConstantProperty(t.styleSpec.light.color),\n        intensity: new t.DataConstantProperty(t.styleSpec.light.intensity)\n      }),\n      w = function (e) {\n        function i(i) {\n          e.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i), this._transitioning = this._transitionable.untransitioned();\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getLight = function () {\n          return this._transitionable.serialize();\n        }, i.prototype.setLight = function (e, i) {\n          if (void 0 === i && (i = {}), !this._validate(t.validateLight, e, i)) for (var o in e) {\n            var r = e[o];\n            t.endsWith(o, "-transition") ? this._transitionable.setTransition(o.slice(0, -"-transition".length), r) : this._transitionable.setValue(o, r);\n          }\n        }, i.prototype.updateTransitions = function (t) {\n          this._transitioning = this._transitionable.transitioned(t, this._transitioning);\n        }, i.prototype.hasTransition = function () {\n          return this._transitioning.hasTransition();\n        }, i.prototype.recalculate = function (t) {\n          this.properties = this._transitioning.possiblyEvaluate(t);\n        }, i.prototype._validate = function (e, i, o) {\n          return (!o || !1 !== o.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({\n            value: i,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            },\n            styleSpec: t.styleSpec\n          })));\n        }, i;\n      }(t.Evented),\n      T = function (t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};\n      };\n    T.prototype.getDash = function (t, e) {\n      var i = t.join(",") + String(e);\n      return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(t, e)), this.dashEntry[i];\n    }, T.prototype.getDashRanges = function (t, e, i) {\n      var o = [],\n        r = t.length % 2 == 1 ? -t[t.length - 1] * i : 0,\n        a = t[0] * i,\n        n = !0;\n      o.push({\n        left: r,\n        right: a,\n        isDash: n,\n        zeroLength: 0 === t[0]\n      });\n      for (var s = t[0], l = 1; l < t.length; l++) {\n        var c = t[l];\n        o.push({\n          left: r = s * i,\n          right: a = (s += c) * i,\n          isDash: n = !n,\n          zeroLength: 0 === c\n        });\n      }\n      return o;\n    }, T.prototype.addRoundDash = function (t, e, i) {\n      for (var o = e / 2, r = -i; r <= i; r++) for (var a = this.width * (this.nextRow + i + r), n = 0, s = t[n], l = 0; l < this.width; l++) {\n        l / s.right > 1 && (s = t[++n]);\n        var c = Math.abs(l - s.left),\n          u = Math.abs(l - s.right),\n          h = Math.min(c, u),\n          p = void 0,\n          d = r / i * (o + 1);\n        if (s.isDash) {\n          var _ = o - Math.abs(d);\n          p = Math.sqrt(h * h + _ * _);\n        } else p = o - Math.sqrt(h * h + d * d);\n        this.data[a + l] = Math.max(0, Math.min(255, p + 128));\n      }\n    }, T.prototype.addRegularDash = function (t) {\n      for (var e = t.length - 1; e >= 0; --e) {\n        var i = t[e],\n          o = t[e + 1];\n        i.zeroLength ? t.splice(e, 1) : o && o.isDash === i.isDash && (o.left = i.left, t.splice(e, 1));\n      }\n      var r = t[0],\n        a = t[t.length - 1];\n      r.isDash === a.isDash && (r.left = a.left - this.width, a.right = r.right + this.width);\n      for (var n = this.width * this.nextRow, s = 0, l = t[s], c = 0; c < this.width; c++) {\n        c / l.right > 1 && (l = t[++s]);\n        var u = Math.abs(c - l.left),\n          h = Math.abs(c - l.right),\n          p = Math.min(u, h);\n        this.data[n + c] = Math.max(0, Math.min(255, (l.isDash ? p : -p) + 128));\n      }\n    }, T.prototype.addDash = function (e, i) {\n      var o = i ? 7 : 0,\n        r = 2 * o + 1;\n      if (this.nextRow + r > this.height) return t.warnOnce("LineAtlas out of space"), null;\n      for (var a = 0, n = 0; n < e.length; n++) a += e[n];\n      if (0 !== a) {\n        var s = this.width / a,\n          l = this.getDashRanges(e, this.width, s);\n        i ? this.addRoundDash(l, s, o) : this.addRegularDash(l);\n      }\n      var c = {\n        y: (this.nextRow + o + .5) / this.height,\n        height: 2 * o / this.height,\n        width: a\n      };\n      return this.nextRow += r, this.dirty = !0, c;\n    }, T.prototype.bind = function (t) {\n      var e = t.gl;\n      this.texture ? (e.bindTexture(e.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, this.width, this.height, e.ALPHA, e.UNSIGNED_BYTE, this.data))) : (this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.width, this.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.data));\n    };\n    var E = function e(i, o) {\n      this.workerPool = i, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();\n      for (var r = this.workerPool.acquire(this.id), a = 0; a < r.length; a++) {\n        var n = new e.Actor(r[a], o, this.id);\n        n.name = "Worker " + a, this.actors.push(n);\n      }\n    };\n    function I(e, i, o) {\n      var r = function (r, a) {\n        if (r) return o(r);\n        if (a) {\n          var n = t.pick(t.extend(a, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);\n          a.vector_layers && (n.vectorLayers = a.vector_layers, n.vectorLayerIds = n.vectorLayers.map(function (t) {\n            return t.id;\n          })), n.tiles = i.canonicalizeTileset(n, e.url), o(null, n);\n        }\n      };\n      return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url), t.ResourceType.Source), r) : t.browser.frame(function () {\n        return r(null, e);\n      });\n    }\n    E.prototype.broadcast = function (e, i, o) {\n      t.asyncAll(this.actors, function (t, o) {\n        t.send(e, i, o);\n      }, o = o || function () {});\n    }, E.prototype.getActor = function () {\n      return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n    }, E.prototype.remove = function () {\n      this.actors.forEach(function (t) {\n        t.remove();\n      }), this.actors = [], this.workerPool.release(this.id);\n    }, E.Actor = t.Actor;\n    var P = function (e, i, o) {\n      this.bounds = t.LngLatBounds.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = o || 24;\n    };\n    P.prototype.validateBounds = function (t) {\n      return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];\n    }, P.prototype.contains = function (e) {\n      var i = Math.pow(2, e.z),\n        o = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i),\n        r = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i),\n        a = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i),\n        n = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i);\n      return e.x >= o && e.x < a && e.y >= r && e.y < n;\n    };\n    var S = function (e) {\n        function i(i, o, r, a) {\n          if (e.call(this), this.id = i, this.dispatcher = r, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.extend(this, t.pick(o, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({\n            type: "vector"\n          }, o), this._collectResourceTiming = o.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");\n          this.setEventedParent(a);\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n          var e = this;\n          this._loaded = !1, this.fire(new t.Event("dataloading", {\n            dataType: "source"\n          })), this._tileJSONRequest = I(this._options, this.map._requestManager, function (i, o) {\n            e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (t.extend(e, o), o.bounds && (e.tileBounds = new P(o.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(o.tiles, e.map._requestManager._customAccessToken), t.postMapLoadEvent(o.tiles, e.map._getMapId(), e.map._requestManager._skuToken, e.map._requestManager._customAccessToken), e.fire(new t.Event("data", {\n              dataType: "source",\n              sourceDataType: "metadata"\n            })), e.fire(new t.Event("data", {\n              dataType: "source",\n              sourceDataType: "content"\n            })));\n          });\n        }, i.prototype.loaded = function () {\n          return this._loaded;\n        }, i.prototype.hasTile = function (t) {\n          return !this.tileBounds || this.tileBounds.contains(t.canonical);\n        }, i.prototype.onAdd = function (t) {\n          this.map = t, this.load();\n        }, i.prototype.setSourceProperty = function (t) {\n          this._tileJSONRequest && this._tileJSONRequest.cancel(), t(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();\n        }, i.prototype.setTiles = function (t) {\n          var e = this;\n          return this.setSourceProperty(function () {\n            e._options.tiles = t;\n          }), this;\n        }, i.prototype.setUrl = function (t) {\n          var e = this;\n          return this.setSourceProperty(function () {\n            e.url = t, e._options.url = t;\n          }), this;\n        }, i.prototype.onRemove = function () {\n          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n        }, i.prototype.serialize = function () {\n          return t.extend({}, this._options);\n        }, i.prototype.loadTile = function (e, i) {\n          var o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme)),\n            r = {\n              request: this.map._requestManager.transformRequest(o, t.ResourceType.Tile),\n              uid: e.uid,\n              tileID: e.tileID,\n              zoom: e.tileID.overscaledZ,\n              tileSize: this.tileSize * e.tileID.overscaleFactor(),\n              type: this.type,\n              source: this.id,\n              pixelRatio: t.browser.devicePixelRatio,\n              showCollisionBoxes: this.map.showCollisionBoxes,\n              promoteId: this.promoteId\n            };\n          function a(o, r) {\n            return delete e.request, e.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && e.setExpiryData(r), e.loadVectorData(r, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (e.reloadCallback && (this.loadTile(e, e.reloadCallback), e.reloadCallback = null)));\n          }\n          r.request.collectResourceTiming = this._collectResourceTiming, e.actor && "expired" !== e.state ? "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", r, a.bind(this)) : (e.actor = this.dispatcher.getActor(), e.request = e.actor.send("loadTile", r, a.bind(this)));\n        }, i.prototype.abortTile = function (t) {\n          t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", {\n            uid: t.uid,\n            type: this.type,\n            source: this.id\n          }, void 0);\n        }, i.prototype.unloadTile = function (t) {\n          t.unloadVectorData(), t.actor && t.actor.send("removeTile", {\n            uid: t.uid,\n            type: this.type,\n            source: this.id\n          }, void 0);\n        }, i.prototype.hasTransition = function () {\n          return !1;\n        }, i;\n      }(t.Evented),\n      C = function (e) {\n        function i(i, o, r, a) {\n          e.call(this), this.id = i, this.dispatcher = r, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.extend({\n            type: "raster"\n          }, o), t.extend(this, t.pick(o, ["url", "scheme", "tileSize"]));\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n          var e = this;\n          this._loaded = !1, this.fire(new t.Event("dataloading", {\n            dataType: "source"\n          })), this._tileJSONRequest = I(this._options, this.map._requestManager, function (i, o) {\n            e._tileJSONRequest = null, e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (t.extend(e, o), o.bounds && (e.tileBounds = new P(o.bounds, e.minzoom, e.maxzoom)), t.postTurnstileEvent(o.tiles), t.postMapLoadEvent(o.tiles, e.map._getMapId(), e.map._requestManager._skuToken), e.fire(new t.Event("data", {\n              dataType: "source",\n              sourceDataType: "metadata"\n            })), e.fire(new t.Event("data", {\n              dataType: "source",\n              sourceDataType: "content"\n            })));\n          });\n        }, i.prototype.loaded = function () {\n          return this._loaded;\n        }, i.prototype.onAdd = function (t) {\n          this.map = t, this.load();\n        }, i.prototype.onRemove = function () {\n          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n        }, i.prototype.serialize = function () {\n          return t.extend({}, this._options);\n        }, i.prototype.hasTile = function (t) {\n          return !this.tileBounds || this.tileBounds.contains(t.canonical);\n        }, i.prototype.loadTile = function (e, i) {\n          var o = this,\n            r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);\n          e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), function (r, a) {\n            if (delete e.request, e.aborted) e.state = "unloaded", i(null);else if (r) e.state = "errored", i(r);else if (a) {\n              o.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n              var n = o.map.painter.context,\n                s = n.gl;\n              e.texture = o.map.painter.getTileTexture(a.width), e.texture ? e.texture.update(a, {\n                useMipmap: !0\n              }) : (e.texture = new t.Texture(n, a, s.RGBA, {\n                useMipmap: !0\n              }), e.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST), n.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, n.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n.extTextureFilterAnisotropicMax)), e.state = "loaded", t.cacheEntryPossiblyAdded(o.dispatcher), i(null);\n            }\n          });\n        }, i.prototype.abortTile = function (t, e) {\n          t.request && (t.request.cancel(), delete t.request), e();\n        }, i.prototype.unloadTile = function (t, e) {\n          t.texture && this.map.painter.saveTileTexture(t.texture), e();\n        }, i.prototype.hasTransition = function () {\n          return !1;\n        }, i;\n      }(t.Evented),\n      z = function (e) {\n        function i(i, o, r, a) {\n          e.call(this, i, o, r, a), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({\n            type: "raster-dem"\n          }, o), this.encoding = o.encoding || "mapbox";\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.serialize = function () {\n          return {\n            type: "raster-dem",\n            url: this.url,\n            tileSize: this.tileSize,\n            tiles: this.tiles,\n            bounds: this.bounds,\n            encoding: this.encoding\n          };\n        }, i.prototype.loadTile = function (e, i) {\n          var o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);\n          function r(t, o) {\n            t && (e.state = "errored", i(t)), o && (e.dem = o, e.needsHillshadePrepare = !0, e.state = "loaded", i(null));\n          }\n          e.request = t.getImage(this.map._requestManager.transformRequest(o, t.ResourceType.Tile), function (o, a) {\n            if (delete e.request, e.aborted) e.state = "unloaded", i(null);else if (o) e.state = "errored", i(o);else if (a) {\n              this.map._refreshExpiredTiles && e.setExpiryData(a), delete a.cacheControl, delete a.expires;\n              var n = t.window.ImageBitmap && a instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a : t.browser.getImageData(a, 1),\n                s = {\n                  uid: e.uid,\n                  coord: e.tileID,\n                  source: this.id,\n                  rawImageData: n,\n                  encoding: this.encoding\n                };\n              e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(), e.actor.send("loadDEMTile", s, r.bind(this)));\n            }\n          }.bind(this)), e.neighboringTiles = this._getNeighboringTiles(e.tileID);\n        }, i.prototype._getNeighboringTiles = function (e) {\n          var i = e.canonical,\n            o = Math.pow(2, i.z),\n            r = (i.x - 1 + o) % o,\n            a = 0 === i.x ? e.wrap - 1 : e.wrap,\n            n = (i.x + 1 + o) % o,\n            s = i.x + 1 === o ? e.wrap + 1 : e.wrap,\n            l = {};\n          return l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y).key] = {\n            backfilled: !1\n          }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y).key] = {\n            backfilled: !1\n          }, i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y - 1).key] = {\n            backfilled: !1\n          }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = {\n            backfilled: !1\n          }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y - 1).key] = {\n            backfilled: !1\n          }), i.y + 1 < o && (l[new t.OverscaledTileID(e.overscaledZ, a, i.z, r, i.y + 1).key] = {\n            backfilled: !1\n          }, l[new t.OverscaledTileID(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = {\n            backfilled: !1\n          }, l[new t.OverscaledTileID(e.overscaledZ, s, i.z, n, i.y + 1).key] = {\n            backfilled: !1\n          }), l;\n        }, i.prototype.unloadTile = function (t) {\n          t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && t.actor.send("removeDEMTile", {\n            uid: t.uid,\n            source: this.id\n          });\n        }, i;\n      }(C),\n      D = function (e) {\n        function i(i, o, r, a) {\n          e.call(this), this.id = i, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._loaded = !1, this.actor = r.getActor(), this.setEventedParent(a), this._data = o.data, this._options = t.extend({}, o), this._collectResourceTiming = o.collectResourceTiming, this._resourceTiming = [], void 0 !== o.maxzoom && (this.maxzoom = o.maxzoom), o.type && (this.type = o.type), o.attribution && (this.attribution = o.attribution), this.promoteId = o.promoteId;\n          var n = t.EXTENT / this.tileSize;\n          this.workerOptions = t.extend({\n            source: this.id,\n            cluster: o.cluster || !1,\n            geojsonVtOptions: {\n              buffer: (void 0 !== o.buffer ? o.buffer : 128) * n,\n              tolerance: (void 0 !== o.tolerance ? o.tolerance : .375) * n,\n              extent: t.EXTENT,\n              maxZoom: this.maxzoom,\n              lineMetrics: o.lineMetrics || !1,\n              generateId: o.generateId || !1\n            },\n            superclusterOptions: {\n              maxZoom: void 0 !== o.clusterMaxZoom ? Math.min(o.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1,\n              minPoints: Math.max(2, o.clusterMinPoints || 2),\n              extent: t.EXTENT,\n              radius: (o.clusterRadius || 50) * n,\n              log: !1,\n              generateId: o.generateId || !1\n            },\n            clusterProperties: o.clusterProperties,\n            filter: o.filter\n          }, o.workerOptions);\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n          var e = this;\n          this.fire(new t.Event("dataloading", {\n            dataType: "source"\n          })), this._updateWorkerData(function (i) {\n            if (i) e.fire(new t.ErrorEvent(i));else {\n              var o = {\n                dataType: "source",\n                sourceDataType: "metadata"\n              };\n              e._collectResourceTiming && e._resourceTiming && e._resourceTiming.length > 0 && (o.resourceTiming = e._resourceTiming, e._resourceTiming = []), e.fire(new t.Event("data", o));\n            }\n          });\n        }, i.prototype.onAdd = function (t) {\n          this.map = t, this.load();\n        }, i.prototype.setData = function (e) {\n          var i = this;\n          return this._data = e, this.fire(new t.Event("dataloading", {\n            dataType: "source"\n          })), this._updateWorkerData(function (e) {\n            if (e) i.fire(new t.ErrorEvent(e));else {\n              var o = {\n                dataType: "source",\n                sourceDataType: "content"\n              };\n              i._collectResourceTiming && i._resourceTiming && i._resourceTiming.length > 0 && (o.resourceTiming = i._resourceTiming, i._resourceTiming = []), i.fire(new t.Event("data", o));\n            }\n          }), this;\n        }, i.prototype.getClusterExpansionZoom = function (t, e) {\n          return this.actor.send("geojson.getClusterExpansionZoom", {\n            clusterId: t,\n            source: this.id\n          }, e), this;\n        }, i.prototype.getClusterChildren = function (t, e) {\n          return this.actor.send("geojson.getClusterChildren", {\n            clusterId: t,\n            source: this.id\n          }, e), this;\n        }, i.prototype.getClusterLeaves = function (t, e, i, o) {\n          return this.actor.send("geojson.getClusterLeaves", {\n            source: this.id,\n            clusterId: t,\n            limit: e,\n            offset: i\n          }, o), this;\n        }, i.prototype._updateWorkerData = function (e) {\n          var i = this;\n          this._loaded = !1;\n          var o = t.extend({}, this.workerOptions),\n            r = this._data;\n          "string" == typeof r ? (o.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r), t.ResourceType.Source), o.request.collectResourceTiming = this._collectResourceTiming) : o.data = JSON.stringify(r), this.actor.send(this.type + ".loadData", o, function (t, r) {\n            i._removed || r && r.abandoned || (i._loaded = !0, r && r.resourceTiming && r.resourceTiming[i.id] && (i._resourceTiming = r.resourceTiming[i.id].slice(0)), i.actor.send(i.type + ".coalesce", {\n              source: o.source\n            }, null), e(t));\n          });\n        }, i.prototype.loaded = function () {\n          return this._loaded;\n        }, i.prototype.loadTile = function (e, i) {\n          var o = this,\n            r = e.actor ? "reloadTile" : "loadTile";\n          e.actor = this.actor, e.request = this.actor.send(r, {\n            type: this.type,\n            uid: e.uid,\n            tileID: e.tileID,\n            zoom: e.tileID.overscaledZ,\n            maxZoom: this.maxzoom,\n            tileSize: this.tileSize,\n            source: this.id,\n            pixelRatio: t.browser.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId\n          }, function (t, a) {\n            return delete e.request, e.unloadVectorData(), e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(a, o.map.painter, "reloadTile" === r), i(null));\n          });\n        }, i.prototype.abortTile = function (t) {\n          t.request && (t.request.cancel(), delete t.request), t.aborted = !0;\n        }, i.prototype.unloadTile = function (t) {\n          t.unloadVectorData(), this.actor.send("removeTile", {\n            uid: t.uid,\n            type: this.type,\n            source: this.id\n          });\n        }, i.prototype.onRemove = function () {\n          this._removed = !0, this.actor.send("removeSource", {\n            type: this.type,\n            source: this.id\n          });\n        }, i.prototype.serialize = function () {\n          return t.extend({}, this._options, {\n            type: this.type,\n            data: this._data\n          });\n        }, i.prototype.hasTransition = function () {\n          return !1;\n        }, i;\n      }(t.Evented),\n      A = t.createLayout([{\n        name: "a_pos",\n        type: "Int16",\n        components: 2\n      }, {\n        name: "a_texture_pos",\n        type: "Int16",\n        components: 2\n      }]),\n      M = function (e) {\n        function i(t, i, o, r) {\n          e.call(this), this.id = t, this.dispatcher = o, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(r), this.options = i;\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function (e, i) {\n          var o = this;\n          this._loaded = !1, this.fire(new t.Event("dataloading", {\n            dataType: "source"\n          })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function (r, a) {\n            o._loaded = !0, r ? o.fire(new t.ErrorEvent(r)) : a && (o.image = a, e && (o.coordinates = e), i && i(), o._finishLoading());\n          });\n        }, i.prototype.loaded = function () {\n          return this._loaded;\n        }, i.prototype.updateImage = function (t) {\n          var e = this;\n          return this.image && t.url ? (this.options.url = t.url, this.load(t.coordinates, function () {\n            e.texture = null;\n          }), this) : this;\n        }, i.prototype._finishLoading = function () {\n          this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "metadata"\n          })));\n        }, i.prototype.onAdd = function (t) {\n          this.map = t, this.load();\n        }, i.prototype.setCoordinates = function (e) {\n          var i = this;\n          this.coordinates = e;\n          var o = e.map(t.MercatorCoordinate.fromLngLat);\n          this.tileID = function (e) {\n            for (var i = 1 / 0, o = 1 / 0, r = -1 / 0, a = -1 / 0, n = 0, s = e; n < s.length; n += 1) {\n              var l = s[n];\n              i = Math.min(i, l.x), o = Math.min(o, l.y), r = Math.max(r, l.x), a = Math.max(a, l.y);\n            }\n            var c = Math.max(r - i, a - o),\n              u = Math.max(0, Math.floor(-Math.log(c) / Math.LN2)),\n              h = Math.pow(2, u);\n            return new t.CanonicalTileID(u, Math.floor((i + r) / 2 * h), Math.floor((o + a) / 2 * h));\n          }(o), this.minzoom = this.maxzoom = this.tileID.z;\n          var r = o.map(function (t) {\n            return i.tileID.getTilePoint(t)._round();\n          });\n          return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r[0].x, r[0].y, 0, 0), this._boundsArray.emplaceBack(r[1].x, r[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r[3].x, r[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r[2].x, r[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", {\n            dataType: "source",\n            sourceDataType: "content"\n          })), this;\n        }, i.prototype.prepare = function () {\n          if (0 !== Object.keys(this.tiles).length && this.image) {\n            var e = this.map.painter.context,\n              i = e.gl;\n            for (var o in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) {\n              var r = this.tiles[o];\n              "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture);\n            }\n          }\n        }, i.prototype.loadTile = function (t, e) {\n          this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = "errored", e(null));\n        }, i.prototype.serialize = function () {\n          return {\n            type: "image",\n            url: this.options.url,\n            coordinates: this.coordinates\n          };\n        }, i.prototype.hasTransition = function () {\n          return !1;\n        }, i;\n      }(t.Evented),\n      L = function (e) {\n        function i(t, i, o, r) {\n          e.call(this, t, i, o, r), this.roundZoom = !0, this.type = "video", this.options = i;\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n          var e = this;\n          this._loaded = !1;\n          var i = this.options;\n          this.urls = [];\n          for (var o = 0, r = i.urls; o < r.length; o += 1) this.urls.push(this.map._requestManager.transformRequest(r[o], t.ResourceType.Source).url);\n          t.getVideo(this.urls, function (i, o) {\n            e._loaded = !0, i ? e.fire(new t.ErrorEvent(i)) : o && (e.video = o, e.video.loop = !0, e.video.addEventListener("playing", function () {\n              e.map.triggerRepaint();\n            }), e.map && e.video.play(), e._finishLoading());\n          });\n        }, i.prototype.pause = function () {\n          this.video && this.video.pause();\n        }, i.prototype.play = function () {\n          this.video && this.video.play();\n        }, i.prototype.seek = function (e) {\n          if (this.video) {\n            var i = this.video.seekable;\n            e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i.start(0) + " and " + i.end(0) + "-second mark."))) : this.video.currentTime = e;\n          }\n        }, i.prototype.getVideo = function () {\n          return this.video;\n        }, i.prototype.onAdd = function (t) {\n          this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n        }, i.prototype.prepare = function () {\n          if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {\n            var e = this.map.painter.context,\n              i = e.gl;\n            for (var o in this.boundsBuffer || (this.boundsBuffer = e.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this.tiles) {\n              var r = this.tiles[o];\n              "loaded" !== r.state && (r.state = "loaded", r.texture = this.texture);\n            }\n          }\n        }, i.prototype.serialize = function () {\n          return {\n            type: "video",\n            urls: this.urls,\n            coordinates: this.coordinates\n          };\n        }, i.prototype.hasTransition = function () {\n          return this.video && !this.video.paused;\n        }, i;\n      }(M),\n      R = function (e) {\n        function i(i, o, r, a) {\n          e.call(this, i, o, r, a), o.coordinates ? Array.isArray(o.coordinates) && 4 === o.coordinates.length && !o.coordinates.some(function (t) {\n            return !Array.isArray(t) || 2 !== t.length || t.some(function (t) {\n              return "number" != typeof t;\n            });\n          }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'"coordinates" property must be an array of 4 longitude/latitude array pairs\'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'missing required property "coordinates"\'))), o.animate && "boolean" != typeof o.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'optional "animate" property must be a boolean value\'))), o.canvas ? "string" == typeof o.canvas || o.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance\'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i, null, \'missing required property "canvas"\'))), this.options = o, this.animate = void 0 === o.animate || o.animate;\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.load = function () {\n          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {\n            this._playing = !0, this.map.triggerRepaint();\n          }, this.pause = function () {\n            this._playing && (this.prepare(), this._playing = !1);\n          }, this._finishLoading());\n        }, i.prototype.getCanvas = function () {\n          return this.canvas;\n        }, i.prototype.onAdd = function (t) {\n          this.map = t, this.load(), this.canvas && this.animate && this.play();\n        }, i.prototype.onRemove = function () {\n          this.pause();\n        }, i.prototype.prepare = function () {\n          var e = !1;\n          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {\n            var i = this.map.painter.context,\n              o = i.gl;\n            for (var r in this.boundsBuffer || (this.boundsBuffer = i.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e || this._playing) && this.texture.update(this.canvas, {\n              premultiply: !0\n            }) : this.texture = new t.Texture(i, this.canvas, o.RGBA, {\n              premultiply: !0\n            }), this.tiles) {\n              var a = this.tiles[r];\n              "loaded" !== a.state && (a.state = "loaded", a.texture = this.texture);\n            }\n          }\n        }, i.prototype.serialize = function () {\n          return {\n            type: "canvas",\n            coordinates: this.coordinates\n          };\n        }, i.prototype.hasTransition = function () {\n          return this._playing;\n        }, i.prototype._hasInvalidDimensions = function () {\n          for (var t = 0, e = [this.canvas.width, this.canvas.height]; t < e.length; t += 1) {\n            var i = e[t];\n            if (isNaN(i) || i <= 0) return !0;\n          }\n          return !1;\n        }, i;\n      }(M),\n      k = {\n        vector: S,\n        raster: C,\n        "raster-dem": z,\n        geojson: D,\n        video: L,\n        image: M,\n        canvas: R\n      };\n    function B(e, i) {\n      var o = t.identity([]);\n      return t.translate(o, o, [1, 1, 0]), t.scale(o, o, [.5 * e.width, .5 * e.height, 1]), t.multiply(o, o, e.calculatePosMatrix(i.toUnwrapped()));\n    }\n    function O(t, e, i, o, r, a) {\n      var n = function (t, e, i) {\n          if (t) for (var o = 0, r = t; o < r.length; o += 1) {\n            var a = e[r[o]];\n            if (a && a.source === i && "fill-extrusion" === a.type) return !0;\n          } else for (var n in e) {\n            var s = e[n];\n            if (s.source === i && "fill-extrusion" === s.type) return !0;\n          }\n          return !1;\n        }(r && r.layers, e, t.id),\n        s = a.maxPitchScaleFactor(),\n        l = t.tilesIn(o, s, n);\n      l.sort(F);\n      for (var c = [], u = 0, h = l; u < h.length; u += 1) {\n        var p = h[u];\n        c.push({\n          wrappedTileID: p.tileID.wrapped().key,\n          queryResults: p.tile.queryRenderedFeatures(e, i, t._state, p.queryGeometry, p.cameraQueryGeometry, p.scale, r, a, s, B(t.transform, p.tileID))\n        });\n      }\n      var d = function (t) {\n        for (var e = {}, i = {}, o = 0, r = t; o < r.length; o += 1) {\n          var a = r[o],\n            n = a.queryResults,\n            s = a.wrappedTileID,\n            l = i[s] = i[s] || {};\n          for (var c in n) for (var u = n[c], h = l[c] = l[c] || {}, p = e[c] = e[c] || [], d = 0, _ = u; d < _.length; d += 1) {\n            var f = _[d];\n            h[f.featureIndex] || (h[f.featureIndex] = !0, p.push(f));\n          }\n        }\n        return e;\n      }(c);\n      for (var _ in d) d[_].forEach(function (e) {\n        var i = e.feature,\n          o = t.getFeatureState(i.layer["source-layer"], i.id);\n        i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = o;\n      });\n      return d;\n    }\n    function F(t, e) {\n      var i = t.tileID,\n        o = e.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n    var U = function (t, e) {\n      this.max = t, this.onRemove = e, this.reset();\n    };\n    U.prototype.reset = function () {\n      for (var t in this.data) for (var e = 0, i = this.data[t]; e < i.length; e += 1) {\n        var o = i[e];\n        o.timeout && clearTimeout(o.timeout), this.onRemove(o.value);\n      }\n      return this.data = {}, this.order = [], this;\n    }, U.prototype.add = function (t, e, i) {\n      var o = this,\n        r = t.wrapped().key;\n      void 0 === this.data[r] && (this.data[r] = []);\n      var a = {\n        value: e,\n        timeout: void 0\n      };\n      if (void 0 !== i && (a.timeout = setTimeout(function () {\n        o.remove(t, a);\n      }, i)), this.data[r].push(a), this.order.push(r), this.order.length > this.max) {\n        var n = this._getAndRemoveByKey(this.order[0]);\n        n && this.onRemove(n);\n      }\n      return this;\n    }, U.prototype.has = function (t) {\n      return t.wrapped().key in this.data;\n    }, U.prototype.getAndRemove = function (t) {\n      return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;\n    }, U.prototype._getAndRemoveByKey = function (t) {\n      var e = this.data[t].shift();\n      return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;\n    }, U.prototype.getByKey = function (t) {\n      var e = this.data[t];\n      return e ? e[0].value : null;\n    }, U.prototype.get = function (t) {\n      return this.has(t) ? this.data[t.wrapped().key][0].value : null;\n    }, U.prototype.remove = function (t, e) {\n      if (!this.has(t)) return this;\n      var i = t.wrapped().key,\n        o = void 0 === e ? 0 : this.data[i].indexOf(e),\n        r = this.data[i][o];\n      return this.data[i].splice(o, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(r.value), this.order.splice(this.order.indexOf(i), 1), this;\n    }, U.prototype.setMaxSize = function (t) {\n      for (this.max = t; this.order.length > this.max;) {\n        var e = this._getAndRemoveByKey(this.order[0]);\n        e && this.onRemove(e);\n      }\n      return this;\n    }, U.prototype.filter = function (t) {\n      var e = [];\n      for (var i in this.data) for (var o = 0, r = this.data[i]; o < r.length; o += 1) {\n        var a = r[o];\n        t(a.value) || e.push(a);\n      }\n      for (var n = 0, s = e; n < s.length; n += 1) {\n        var l = s[n];\n        this.remove(l.value.tileID, l);\n      }\n    };\n    var N = function (t, e, i) {\n      this.context = t;\n      var o = t.gl;\n      this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n    };\n    N.prototype.bind = function () {\n      this.context.bindElementBuffer.set(this.buffer);\n    }, N.prototype.updateData = function (t) {\n      var e = this.context.gl;\n      this.context.unbindVAO(), this.bind(), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);\n    }, N.prototype.destroy = function () {\n      this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n    };\n    var Z = {\n        Int8: "BYTE",\n        Uint8: "UNSIGNED_BYTE",\n        Int16: "SHORT",\n        Uint16: "UNSIGNED_SHORT",\n        Int32: "INT",\n        Uint32: "UNSIGNED_INT",\n        Float32: "FLOAT"\n      },\n      q = function (t, e, i, o) {\n        this.length = e.length, this.attributes = i, this.itemSize = e.bytesPerElement, this.dynamicDraw = o, this.context = t;\n        var r = t.gl;\n        this.buffer = r.createBuffer(), t.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete e.arrayBuffer;\n      };\n    q.prototype.bind = function () {\n      this.context.bindVertexBuffer.set(this.buffer);\n    }, q.prototype.updateData = function (t) {\n      var e = this.context.gl;\n      this.bind(), e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);\n    }, q.prototype.enableAttributes = function (t, e) {\n      for (var i = 0; i < this.attributes.length; i++) {\n        var o = e.attributes[this.attributes[i].name];\n        void 0 !== o && t.enableVertexAttribArray(o);\n      }\n    }, q.prototype.setVertexAttribPointers = function (t, e, i) {\n      for (var o = 0; o < this.attributes.length; o++) {\n        var r = this.attributes[o],\n          a = e.attributes[r.name];\n        void 0 !== a && t.vertexAttribPointer(a, r.components, t[Z[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));\n      }\n    }, q.prototype.destroy = function () {\n      this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n    };\n    var j = function (t) {\n      this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n    };\n    j.prototype.get = function () {\n      return this.current;\n    }, j.prototype.set = function (t) {}, j.prototype.getDefault = function () {\n      return this.default;\n    }, j.prototype.setDefault = function () {\n      this.set(this.default);\n    };\n    var V = function (e) {\n        function i() {\n          e.apply(this, arguments);\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () {\n          return t.Color.transparent;\n        }, i.prototype.set = function (t) {\n          var e = this.current;\n          (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n        }, i;\n      }(j),\n      G = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return 1;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      W = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return 0;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      X = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return [!0, !0, !0, !0];\n        }, e.prototype.set = function (t) {\n          var e = this.current;\n          (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      H = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !0;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      K = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return 255;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      Y = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return {\n            func: this.gl.ALWAYS,\n            ref: 0,\n            mask: 255\n          };\n        }, e.prototype.set = function (t) {\n          var e = this.current;\n          (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      J = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          var t = this.gl;\n          return [t.KEEP, t.KEEP, t.KEEP];\n        }, e.prototype.set = function (t) {\n          var e = this.current;\n          (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      Q = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !1;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      $ = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return [0, 1];\n        }, e.prototype.set = function (t) {\n          var e = this.current;\n          (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      tt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !1;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      et = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return this.gl.LESS;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      it = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !1;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            t ? e.enable(e.BLEND) : e.disable(e.BLEND), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      ot = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          var t = this.gl;\n          return [t.ONE, t.ZERO];\n        }, e.prototype.set = function (t) {\n          var e = this.current;\n          (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      rt = function (e) {\n        function i() {\n          e.apply(this, arguments);\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getDefault = function () {\n          return t.Color.transparent;\n        }, i.prototype.set = function (t) {\n          var e = this.current;\n          (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);\n        }, i;\n      }(j),\n      at = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return this.gl.FUNC_ADD;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      nt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !1;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      st = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return this.gl.BACK;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      lt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return this.gl.CCW;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      ct = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      ut = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return this.gl.TEXTURE0;\n        }, e.prototype.set = function (t) {\n          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      ht = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          var t = this.gl;\n          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];\n        }, e.prototype.set = function (t) {\n          var e = this.current;\n          (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      pt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.bindFramebuffer(e.FRAMEBUFFER, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      dt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.bindRenderbuffer(e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      _t = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.bindTexture(e.TEXTURE_2D, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      ft = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.bindBuffer(e.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      mt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          var e = this.gl;\n          e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;\n        }, e;\n      }(j),\n      gt = function (t) {\n        function e(e) {\n          t.call(this, e), this.vao = e.extVertexArrayObject;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e.prototype.set = function (t) {\n          this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t), this.current = t, this.dirty = !1);\n        }, e;\n      }(j),\n      vt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return 4;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.pixelStorei(e.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      yt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !1;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      xt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return !1;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            var e = this.gl;\n            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(j),\n      bt = function (t) {\n        function e(e, i) {\n          t.call(this, e), this.context = e, this.parent = i;\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.getDefault = function () {\n          return null;\n        }, e;\n      }(j),\n      wt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.setDirty = function () {\n          this.dirty = !0;\n        }, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            this.context.bindFramebuffer.set(this.parent);\n            var e = this.gl;\n            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(bt),\n      Tt = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.set = function (t) {\n          if (t !== this.current || this.dirty) {\n            this.context.bindFramebuffer.set(this.parent);\n            var e = this.gl;\n            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t), this.current = t, this.dirty = !1;\n          }\n        }, e;\n      }(bt),\n      Et = function (t, e, i, o) {\n        this.context = t, this.width = e, this.height = i;\n        var r = this.framebuffer = t.gl.createFramebuffer();\n        this.colorAttachment = new wt(t, r), o && (this.depthAttachment = new Tt(t, r));\n      };\n    Et.prototype.destroy = function () {\n      var t = this.context.gl,\n        e = this.colorAttachment.get();\n      if (e && t.deleteTexture(e), this.depthAttachment) {\n        var i = this.depthAttachment.get();\n        i && t.deleteRenderbuffer(i);\n      }\n      t.deleteFramebuffer(this.framebuffer);\n    };\n    var It = function (t, e, i) {\n      this.func = t, this.mask = e, this.range = i;\n    };\n    It.ReadOnly = !1, It.ReadWrite = !0, It.disabled = new It(519, It.ReadOnly, [0, 1]);\n    var Pt = function (t, e, i, o, r, a) {\n      this.test = t, this.ref = e, this.mask = i, this.fail = o, this.depthFail = r, this.pass = a;\n    };\n    Pt.disabled = new Pt({\n      func: 519,\n      mask: 0\n    }, 0, 0, 7680, 7680, 7680);\n    var St = function (t, e, i) {\n      this.blendFunction = t, this.blendColor = e, this.mask = i;\n    };\n    St.disabled = new St(St.Replace = [1, 0], t.Color.transparent, [!1, !1, !1, !1]), St.unblended = new St(St.Replace, t.Color.transparent, [!0, !0, !0, !0]), St.alphaBlended = new St([1, 771], t.Color.transparent, [!0, !0, !0, !0]);\n    var Ct = function (t, e, i) {\n      this.enable = t, this.mode = e, this.frontFace = i;\n    };\n    Ct.disabled = new Ct(!1, 1029, 2305), Ct.backCCW = new Ct(!0, 1029, 2305);\n    var zt = function (t) {\n      this.gl = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);\n    };\n    zt.prototype.setDefault = function () {\n      this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n    }, zt.prototype.setDirty = function () {\n      this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n    }, zt.prototype.createIndexBuffer = function (t, e) {\n      return new N(this, t, e);\n    }, zt.prototype.createVertexBuffer = function (t, e, i) {\n      return new q(this, t, e, i);\n    }, zt.prototype.createRenderbuffer = function (t, e, i) {\n      var o = this.gl,\n        r = o.createRenderbuffer();\n      return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, t, e, i), this.bindRenderbuffer.set(null), r;\n    }, zt.prototype.createFramebuffer = function (t, e, i) {\n      return new Et(this, t, e, i);\n    }, zt.prototype.clear = function (t) {\n      var e = t.color,\n        i = t.depth,\n        o = this.gl,\n        r = 0;\n      e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== i && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), o.clear(r);\n    }, zt.prototype.setCullFace = function (t) {\n      !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));\n    }, zt.prototype.setDepthMode = function (t) {\n      t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);\n    }, zt.prototype.setStencilMode = function (t) {\n      t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({\n        func: t.test.func,\n        ref: t.ref,\n        mask: t.test.mask\n      })) : this.stencilTest.set(!1);\n    }, zt.prototype.setColorMode = function (e) {\n      t.deepEqual(e.blendFunction, St.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);\n    }, zt.prototype.unbindVAO = function () {\n      this.extVertexArrayObject && this.bindVertexArrayOES.set(null);\n    };\n    var Dt = function (e) {\n      function i(i, o, r) {\n        var a = this;\n        e.call(this), this.id = i, this.dispatcher = r, this.on("data", function (t) {\n          "source" === t.dataType && "metadata" === t.sourceDataType && (a._sourceLoaded = !0), a._sourceLoaded && !a._paused && "source" === t.dataType && "content" === t.sourceDataType && (a.reload(), a.transform && a.update(a.transform));\n        }), this.on("error", function () {\n          a._sourceErrored = !0;\n        }), this._source = function (e, i, o, r) {\n          var a = new k[i.type](e, i, o, r);\n          if (a.id !== e) throw new Error("Expected Source id to be " + e + " instead of " + a.id);\n          return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a), a;\n        }(i, o, r, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();\n      }\n      return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.onAdd = function (t) {\n        this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t);\n      }, i.prototype.onRemove = function (t) {\n        this._source && this._source.onRemove && this._source.onRemove(t);\n      }, i.prototype.loaded = function () {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n        for (var t in this._tiles) {\n          var e = this._tiles[t];\n          if ("loaded" !== e.state && "errored" !== e.state) return !1;\n        }\n        return !0;\n      }, i.prototype.getSource = function () {\n        return this._source;\n      }, i.prototype.pause = function () {\n        this._paused = !0;\n      }, i.prototype.resume = function () {\n        if (this._paused) {\n          var t = this._shouldReloadOnResume;\n          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);\n        }\n      }, i.prototype._loadTile = function (t, e) {\n        return this._source.loadTile(t, e);\n      }, i.prototype._unloadTile = function (t) {\n        if (this._source.unloadTile) return this._source.unloadTile(t, function () {});\n      }, i.prototype._abortTile = function (t) {\n        if (this._source.abortTile) return this._source.abortTile(t, function () {});\n      }, i.prototype.serialize = function () {\n        return this._source.serialize();\n      }, i.prototype.prepare = function (t) {\n        for (var e in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {\n          var i = this._tiles[e];\n          i.upload(t), i.prepare(this.map.style.imageManager);\n        }\n      }, i.prototype.getIds = function () {\n        return t.values(this._tiles).map(function (t) {\n          return t.tileID;\n        }).sort(At).map(function (t) {\n          return t.key;\n        });\n      }, i.prototype.getRenderableIds = function (e) {\n        var i = this,\n          o = [];\n        for (var r in this._tiles) this._isIdRenderable(r, e) && o.push(this._tiles[r]);\n        return e ? o.sort(function (e, o) {\n          var r = e.tileID,\n            a = o.tileID,\n            n = new t.Point(r.canonical.x, r.canonical.y)._rotate(i.transform.angle),\n            s = new t.Point(a.canonical.x, a.canonical.y)._rotate(i.transform.angle);\n          return r.overscaledZ - a.overscaledZ || s.y - n.y || s.x - n.x;\n        }).map(function (t) {\n          return t.tileID.key;\n        }) : o.map(function (t) {\n          return t.tileID;\n        }).sort(At).map(function (t) {\n          return t.key;\n        });\n      }, i.prototype.hasRenderableParent = function (t) {\n        var e = this.findLoadedParent(t, 0);\n        return !!e && this._isIdRenderable(e.tileID.key);\n      }, i.prototype._isIdRenderable = function (t, e) {\n        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());\n      }, i.prototype.reload = function () {\n        if (this._paused) this._shouldReloadOnResume = !0;else for (var t in this._cache.reset(), this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading");\n      }, i.prototype._reloadTile = function (t, e) {\n        var i = this._tiles[t];\n        i && ("loading" !== i.state && (i.state = e), this._loadTile(i, this._tileLoaded.bind(this, i, t, e)));\n      }, i.prototype._tileLoaded = function (e, i, o, r) {\n        if (r) return e.state = "errored", void (404 !== r.status ? this._source.fire(new t.ErrorEvent(r, {\n          tile: e\n        })) : this.update(this.transform));\n        e.timeAdded = t.browser.now(), "expired" === o && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", {\n          dataType: "source",\n          tile: e,\n          coord: e.tileID\n        }));\n      }, i.prototype._backfillDEM = function (t) {\n        for (var e = this.getRenderableIds(), i = 0; i < e.length; i++) {\n          var o = e[i];\n          if (t.neighboringTiles && t.neighboringTiles[o]) {\n            var r = this.getTileByID(o);\n            a(t, r), a(r, t);\n          }\n        }\n        function a(t, e) {\n          t.needsHillshadePrepare = !0;\n          var i = e.tileID.canonical.x - t.tileID.canonical.x,\n            o = e.tileID.canonical.y - t.tileID.canonical.y,\n            r = Math.pow(2, t.tileID.canonical.z),\n            a = e.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + r) ? i += r : 1 === Math.abs(i - r) && (i -= r)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, o), t.neighboringTiles && t.neighboringTiles[a] && (t.neighboringTiles[a].backfilled = !0)));\n        }\n      }, i.prototype.getTile = function (t) {\n        return this.getTileByID(t.key);\n      }, i.prototype.getTileByID = function (t) {\n        return this._tiles[t];\n      }, i.prototype._retainLoadedChildren = function (t, e, i, o) {\n        for (var r in this._tiles) {\n          var a = this._tiles[r];\n          if (!(o[r] || !a.hasData() || a.tileID.overscaledZ <= e || a.tileID.overscaledZ > i)) {\n            for (var n = a.tileID; a && a.tileID.overscaledZ > e + 1;) {\n              var s = a.tileID.scaledTo(a.tileID.overscaledZ - 1);\n              (a = this._tiles[s.key]) && a.hasData() && (n = s);\n            }\n            for (var l = n; l.overscaledZ > e;) if (t[(l = l.scaledTo(l.overscaledZ - 1)).key]) {\n              o[n.key] = n;\n              break;\n            }\n          }\n        }\n      }, i.prototype.findLoadedParent = function (t, e) {\n        if (t.key in this._loadedParentTiles) {\n          var i = this._loadedParentTiles[t.key];\n          return i && i.tileID.overscaledZ >= e ? i : null;\n        }\n        for (var o = t.overscaledZ - 1; o >= e; o--) {\n          var r = t.scaledTo(o),\n            a = this._getLoadedTile(r);\n          if (a) return a;\n        }\n      }, i.prototype._getLoadedTile = function (t) {\n        var e = this._tiles[t.key];\n        return e && e.hasData() ? e : this._cache.getByKey(t.wrapped().key);\n      }, i.prototype.updateCacheSize = function (t) {\n        var e = Math.ceil(t.width / this._source.tileSize) + 1,\n          i = Math.ceil(t.height / this._source.tileSize) + 1,\n          o = Math.floor(e * i * 5),\n          r = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;\n        this._cache.setMaxSize(r);\n      }, i.prototype.handleWrapJump = function (t) {\n        var e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);\n        if (this._prevLng = t, e) {\n          var i = {};\n          for (var o in this._tiles) {\n            var r = this._tiles[o];\n            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e), i[r.tileID.key] = r;\n          }\n          for (var a in this._tiles = i, this._timers) clearTimeout(this._timers[a]), delete this._timers[a];\n          for (var n in this._tiles) this._setTileReloadTimer(n, this._tiles[n]);\n        }\n      }, i.prototype.update = function (e) {\n        var o = this;\n        if (this.transform = e, this._sourceLoaded && !this._paused) {\n          var r;\n          this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(function (e) {\n            return new t.OverscaledTileID(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y);\n          }) : (r = e.coveringTiles({\n            tileSize: this._source.tileSize,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom,\n            reparseOverscaled: this._source.reparseOverscaled\n          }), this._source.hasTile && (r = r.filter(function (t) {\n            return o._source.hasTile(t);\n          }))) : r = [];\n          var a = e.coveringZoomLevel(this._source),\n            n = Math.max(a - i.maxOverzooming, this._source.minzoom),\n            s = Math.max(a + i.maxUnderzooming, this._source.minzoom),\n            l = this._updateRetainedTiles(r, a);\n          if (Mt(this._source.type)) {\n            for (var c = {}, u = {}, h = 0, p = Object.keys(l); h < p.length; h += 1) {\n              var d = p[h],\n                _ = l[d],\n                f = this._tiles[d];\n              if (f && !(f.fadeEndTime && f.fadeEndTime <= t.browser.now())) {\n                var m = this.findLoadedParent(_, n);\n                m && (this._addTile(m.tileID), c[m.tileID.key] = m.tileID), u[d] = _;\n              }\n            }\n            for (var g in this._retainLoadedChildren(u, a, s, l), c) l[g] || (this._coveredTiles[g] = !0, l[g] = c[g]);\n          }\n          for (var v in l) this._tiles[v].clearFadeHold();\n          for (var y = 0, x = t.keysDifference(this._tiles, l); y < x.length; y += 1) {\n            var b = x[y],\n              w = this._tiles[b];\n            w.hasSymbolBuckets && !w.holdingForFade() ? w.setHoldDuration(this.map._fadeDuration) : w.hasSymbolBuckets && !w.symbolFadeFinished() || this._removeTile(b);\n          }\n          this._updateLoadedParentTileCache();\n        }\n      }, i.prototype.releaseSymbolFadeTiles = function () {\n        for (var t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t);\n      }, i.prototype._updateRetainedTiles = function (t, e) {\n        for (var o = {}, r = {}, a = Math.max(e - i.maxOverzooming, this._source.minzoom), n = Math.max(e + i.maxUnderzooming, this._source.minzoom), s = {}, l = 0, c = t; l < c.length; l += 1) {\n          var u = c[l],\n            h = this._addTile(u);\n          o[u.key] = u, h.hasData() || e < this._source.maxzoom && (s[u.key] = u);\n        }\n        this._retainLoadedChildren(s, e, n, o);\n        for (var p = 0, d = t; p < d.length; p += 1) {\n          var _ = d[p],\n            f = this._tiles[_.key];\n          if (!f.hasData()) {\n            if (e + 1 > this._source.maxzoom) {\n              var m = _.children(this._source.maxzoom)[0],\n                g = this.getTile(m);\n              if (g && g.hasData()) {\n                o[m.key] = m;\n                continue;\n              }\n            } else {\n              var v = _.children(this._source.maxzoom);\n              if (o[v[0].key] && o[v[1].key] && o[v[2].key] && o[v[3].key]) continue;\n            }\n            for (var y = f.wasRequested(), x = _.overscaledZ - 1; x >= a; --x) {\n              var b = _.scaledTo(x);\n              if (r[b.key]) break;\n              if (r[b.key] = !0, !(f = this.getTile(b)) && y && (f = this._addTile(b)), f && (o[b.key] = b, y = f.wasRequested(), f.hasData())) break;\n            }\n          }\n        }\n        return o;\n      }, i.prototype._updateLoadedParentTileCache = function () {\n        for (var t in this._loadedParentTiles = {}, this._tiles) {\n          for (var e = [], i = void 0, o = this._tiles[t].tileID; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n            e.push(o.key);\n            var r = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(r)) break;\n            o = r;\n          }\n          for (var a = 0, n = e; a < n.length; a += 1) this._loadedParentTiles[n[a]] = i;\n        }\n      }, i.prototype._addTile = function (e) {\n        var i = this._tiles[e.key];\n        if (i) return i;\n        (i = this._cache.getAndRemove(e)) && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i)));\n        var o = Boolean(i);\n        return o || (i = new t.Tile(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, this._tileLoaded.bind(this, i, e.key, i.state))), i ? (i.uses++, this._tiles[e.key] = i, o || this._source.fire(new t.Event("dataloading", {\n          tile: i,\n          coord: i.tileID,\n          dataType: "source"\n        })), i) : null;\n      }, i.prototype._setTileReloadTimer = function (t, e) {\n        var i = this;\n        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);\n        var o = e.getExpiryTimeout();\n        o && (this._timers[t] = setTimeout(function () {\n          i._reloadTile(t, "expired"), delete i._timers[t];\n        }, o));\n      }, i.prototype._removeTile = function (t) {\n        var e = this._tiles[t];\n        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));\n      }, i.prototype.clearTiles = function () {\n        for (var t in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(t);\n        this._cache.reset();\n      }, i.prototype.tilesIn = function (e, i, o) {\n        var r = this,\n          a = [],\n          n = this.transform;\n        if (!n) return a;\n        for (var s = o ? n.getCameraQueryGeometry(e) : e, l = e.map(function (t) {\n            return n.pointCoordinate(t);\n          }), c = s.map(function (t) {\n            return n.pointCoordinate(t);\n          }), u = this.getIds(), h = 1 / 0, p = 1 / 0, d = -1 / 0, _ = -1 / 0, f = 0, m = c; f < m.length; f += 1) {\n          var g = m[f];\n          h = Math.min(h, g.x), p = Math.min(p, g.y), d = Math.max(d, g.x), _ = Math.max(_, g.y);\n        }\n        for (var v = function (e) {\n            var o = r._tiles[u[e]];\n            if (!o.holdingForFade()) {\n              var s = o.tileID,\n                f = Math.pow(2, n.zoom - o.tileID.overscaledZ),\n                m = i * o.queryPadding * t.EXTENT / o.tileSize / f,\n                g = [s.getTilePoint(new t.MercatorCoordinate(h, p)), s.getTilePoint(new t.MercatorCoordinate(d, _))];\n              if (g[0].x - m < t.EXTENT && g[0].y - m < t.EXTENT && g[1].x + m >= 0 && g[1].y + m >= 0) {\n                var v = l.map(function (t) {\n                    return s.getTilePoint(t);\n                  }),\n                  y = c.map(function (t) {\n                    return s.getTilePoint(t);\n                  });\n                a.push({\n                  tile: o,\n                  tileID: s,\n                  queryGeometry: v,\n                  cameraQueryGeometry: y,\n                  scale: f\n                });\n              }\n            }\n          }, y = 0; y < u.length; y++) v(y);\n        return a;\n      }, i.prototype.getVisibleCoordinates = function (t) {\n        for (var e = this, i = this.getRenderableIds(t).map(function (t) {\n            return e._tiles[t].tileID;\n          }), o = 0, r = i; o < r.length; o += 1) {\n          var a = r[o];\n          a.posMatrix = this.transform.calculatePosMatrix(a.toUnwrapped());\n        }\n        return i;\n      }, i.prototype.hasTransition = function () {\n        if (this._source.hasTransition()) return !0;\n        if (Mt(this._source.type)) for (var e in this._tiles) {\n          var i = this._tiles[e];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= t.browser.now()) return !0;\n        }\n        return !1;\n      }, i.prototype.setFeatureState = function (t, e, i) {\n        this._state.updateState(t = t || "_geojsonTileLayer", e, i);\n      }, i.prototype.removeFeatureState = function (t, e, i) {\n        this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, i);\n      }, i.prototype.getFeatureState = function (t, e) {\n        return this._state.getState(t = t || "_geojsonTileLayer", e);\n      }, i.prototype.setDependencies = function (t, e, i) {\n        var o = this._tiles[t];\n        o && o.setDependencies(e, i);\n      }, i.prototype.reloadTilesForDependencies = function (t, e) {\n        for (var i in this._tiles) this._tiles[i].hasDependency(t, e) && this._reloadTile(i, "reloading");\n        this._cache.filter(function (i) {\n          return !i.hasDependency(t, e);\n        });\n      }, i;\n    }(t.Evented);\n    function At(t, e) {\n      var i = Math.abs(2 * t.wrap) - +(t.wrap < 0),\n        o = Math.abs(2 * e.wrap) - +(e.wrap < 0);\n      return t.overscaledZ - e.overscaledZ || o - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;\n    }\n    function Mt(t) {\n      return "raster" === t || "image" === t || "video" === t;\n    }\n    function Lt() {\n      return new t.window.Worker(Kr.workerUrl);\n    }\n    Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;\n    var Rt = "mapboxgl_preloaded_worker_pool",\n      kt = function () {\n        this.active = {};\n      };\n    kt.prototype.acquire = function (t) {\n      if (!this.workers) for (this.workers = []; this.workers.length < kt.workerCount;) this.workers.push(new Lt());\n      return this.active[t] = !0, this.workers.slice();\n    }, kt.prototype.release = function (t) {\n      delete this.active[t], 0 === this.numActive() && (this.workers.forEach(function (t) {\n        t.terminate();\n      }), this.workers = null);\n    }, kt.prototype.isPreloaded = function () {\n      return !!this.active[Rt];\n    }, kt.prototype.numActive = function () {\n      return Object.keys(this.active).length;\n    };\n    var Bt,\n      Ot = Math.floor(t.browser.hardwareConcurrency / 2);\n    function Ft() {\n      return Bt || (Bt = new kt()), Bt;\n    }\n    function Ut(e, i) {\n      var o = {};\n      for (var r in e) "ref" !== r && (o[r] = e[r]);\n      return t.refProperties.forEach(function (t) {\n        t in i && (o[t] = i[t]);\n      }), o;\n    }\n    function Nt(t) {\n      t = t.slice();\n      for (var e = Object.create(null), i = 0; i < t.length; i++) e[t[i].id] = t[i];\n      for (var o = 0; o < t.length; o++) "ref" in t[o] && (t[o] = Ut(t[o], e[t[o].ref]));\n      return t;\n    }\n    kt.workerCount = Math.max(Math.min(Ot, 6), 1);\n    var Zt = {\n      setStyle: "setStyle",\n      addLayer: "addLayer",\n      removeLayer: "removeLayer",\n      setPaintProperty: "setPaintProperty",\n      setLayoutProperty: "setLayoutProperty",\n      setFilter: "setFilter",\n      addSource: "addSource",\n      removeSource: "removeSource",\n      setGeoJSONSourceData: "setGeoJSONSourceData",\n      setLayerZoomRange: "setLayerZoomRange",\n      setLayerProperty: "setLayerProperty",\n      setCenter: "setCenter",\n      setZoom: "setZoom",\n      setBearing: "setBearing",\n      setPitch: "setPitch",\n      setSprite: "setSprite",\n      setGlyphs: "setGlyphs",\n      setTransition: "setTransition",\n      setLight: "setLight"\n    };\n    function qt(t, e, i) {\n      i.push({\n        command: Zt.addSource,\n        args: [t, e[t]]\n      });\n    }\n    function jt(t, e, i) {\n      e.push({\n        command: Zt.removeSource,\n        args: [t]\n      }), i[t] = !0;\n    }\n    function Vt(t, e, i, o) {\n      jt(t, i, o), qt(t, e, i);\n    }\n    function Gt(e, i, o) {\n      var r;\n      for (r in e[o]) if (e[o].hasOwnProperty(r) && "data" !== r && !t.deepEqual(e[o][r], i[o][r])) return !1;\n      for (r in i[o]) if (i[o].hasOwnProperty(r) && "data" !== r && !t.deepEqual(e[o][r], i[o][r])) return !1;\n      return !0;\n    }\n    function Wt(e, i, o, r, a, n) {\n      var s;\n      for (s in i = i || {}, e = e || {}) e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || o.push({\n        command: n,\n        args: [r, s, i[s], a]\n      }));\n      for (s in i) i.hasOwnProperty(s) && !e.hasOwnProperty(s) && (t.deepEqual(e[s], i[s]) || o.push({\n        command: n,\n        args: [r, s, i[s], a]\n      }));\n    }\n    function Xt(t) {\n      return t.id;\n    }\n    function Ht(t, e) {\n      return t[e.id] = e, t;\n    }\n    var Kt = function (t, e) {\n      this.reset(t, e);\n    };\n    Kt.prototype.reset = function (t, e) {\n      this.points = t || [], this._distances = [0];\n      for (var i = 1; i < this.points.length; i++) this._distances[i] = this._distances[i - 1] + this.points[i].dist(this.points[i - 1]);\n      this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n    }, Kt.prototype.lerp = function (e) {\n      if (1 === this.points.length) return this.points[0];\n      e = t.clamp(e, 0, 1);\n      for (var i = 1, o = this._distances[i], r = e * this.paddedLength + this.padding; o < r && i < this._distances.length;) o = this._distances[++i];\n      var a = i - 1,\n        n = this._distances[a],\n        s = o - n,\n        l = s > 0 ? (r - n) / s : 0;\n      return this.points[a].mult(1 - l).add(this.points[i].mult(l));\n    };\n    var Yt = function (t, e, i) {\n      var o = this.boxCells = [],\n        r = this.circleCells = [];\n      this.xCellCount = Math.ceil(t / i), this.yCellCount = Math.ceil(e / i);\n      for (var a = 0; a < this.xCellCount * this.yCellCount; a++) o.push([]), r.push([]);\n      this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = e, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / e, this.boxUid = 0, this.circleUid = 0;\n    };\n    function Jt(e, i, o, r, a) {\n      var n = t.create();\n      return i ? (t.scale(n, n, [1 / a, 1 / a, 1]), o || t.rotateZ(n, n, r.angle)) : t.multiply(n, r.labelPlaneMatrix, e), n;\n    }\n    function Qt(e, i, o, r, a) {\n      if (i) {\n        var n = t.clone(e);\n        return t.scale(n, n, [a, a, 1]), o || t.rotateZ(n, n, -r.angle), n;\n      }\n      return r.glCoordMatrix;\n    }\n    function $t(e, i) {\n      var o = [e.x, e.y, 0, 1];\n      ue(o, o, i);\n      var r = o[3];\n      return {\n        point: new t.Point(o[0] / r, o[1] / r),\n        signedDistanceFromCamera: r\n      };\n    }\n    function te(t, e) {\n      return .5 + t / e * .5;\n    }\n    function ee(t, e) {\n      var i = t[0] / t[3],\n        o = t[1] / t[3];\n      return i >= -e[0] && i <= e[0] && o >= -e[1] && o <= e[1];\n    }\n    function ie(e, i, o, r, a, n, s, l) {\n      var c = r ? e.textSizeData : e.iconSizeData,\n        u = t.evaluateSizeForZoom(c, o.transform.zoom),\n        h = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n        p = r ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;\n      p.clear();\n      for (var d = e.lineVertexArray, _ = r ? e.text.placedSymbolArray : e.icon.placedSymbolArray, f = o.transform.width / o.transform.height, m = !1, g = 0; g < _.length; g++) {\n        var v = _.get(g);\n        if (v.hidden || v.writingMode === t.WritingMode.vertical && !m) ce(v.numGlyphs, p);else {\n          m = !1;\n          var y = [v.anchorX, v.anchorY, 0, 1];\n          if (t.transformMat4(y, y, i), ee(y, h)) {\n            var x = te(o.transform.cameraToCenterDistance, y[3]),\n              b = t.evaluateSizeForFeature(c, u, v),\n              w = s ? b / x : b * x,\n              T = new t.Point(v.anchorX, v.anchorY),\n              E = $t(T, a).point,\n              I = {},\n              P = ae(v, w, !1, l, i, a, n, e.glyphOffsetArray, d, p, E, T, I, f);\n            m = P.useVertical, (P.notEnoughRoom || m || P.needsFlipping && ae(v, w, !0, l, i, a, n, e.glyphOffsetArray, d, p, E, T, I, f).notEnoughRoom) && ce(v.numGlyphs, p);\n          } else ce(v.numGlyphs, p);\n        }\n      }\n      r ? e.text.dynamicLayoutVertexBuffer.updateData(p) : e.icon.dynamicLayoutVertexBuffer.updateData(p);\n    }\n    function oe(t, e, i, o, r, a, n, s, l, c, u) {\n      var h = s.glyphStartIndex + s.numGlyphs,\n        p = s.lineStartIndex,\n        d = s.lineStartIndex + s.lineLength,\n        _ = e.getoffsetX(s.glyphStartIndex),\n        f = e.getoffsetX(h - 1),\n        m = se(t * _, i, o, r, a, n, s.segment, p, d, l, c, u);\n      if (!m) return null;\n      var g = se(t * f, i, o, r, a, n, s.segment, p, d, l, c, u);\n      return g ? {\n        first: m,\n        last: g\n      } : null;\n    }\n    function re(e, i, o, r) {\n      return e === t.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * r ? {\n        useVertical: !0\n      } : (e === t.WritingMode.vertical ? i.y < o.y : i.x > o.x) ? {\n        needsFlipping: !0\n      } : null;\n    }\n    function ae(e, i, o, r, a, n, s, l, c, u, h, p, d, _) {\n      var f,\n        m = i / 24,\n        g = e.lineOffsetX * m,\n        v = e.lineOffsetY * m;\n      if (e.numGlyphs > 1) {\n        var y = e.glyphStartIndex + e.numGlyphs,\n          x = e.lineStartIndex,\n          b = e.lineStartIndex + e.lineLength,\n          w = oe(m, l, g, v, o, h, p, e, c, n, d);\n        if (!w) return {\n          notEnoughRoom: !0\n        };\n        var T = $t(w.first.point, s).point,\n          E = $t(w.last.point, s).point;\n        if (r && !o) {\n          var I = re(e.writingMode, T, E, _);\n          if (I) return I;\n        }\n        f = [w.first];\n        for (var P = e.glyphStartIndex + 1; P < y - 1; P++) f.push(se(m * l.getoffsetX(P), g, v, o, h, p, e.segment, x, b, c, n, d));\n        f.push(w.last);\n      } else {\n        if (r && !o) {\n          var S = $t(p, a).point,\n            C = e.lineStartIndex + e.segment + 1,\n            z = new t.Point(c.getx(C), c.gety(C)),\n            D = $t(z, a),\n            A = D.signedDistanceFromCamera > 0 ? D.point : ne(p, z, S, 1, a),\n            M = re(e.writingMode, S, A, _);\n          if (M) return M;\n        }\n        var L = se(m * l.getoffsetX(e.glyphStartIndex), g, v, o, h, p, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, c, n, d);\n        if (!L) return {\n          notEnoughRoom: !0\n        };\n        f = [L];\n      }\n      for (var R = 0, k = f; R < k.length; R += 1) {\n        var B = k[R];\n        t.addDynamicAttributes(u, B.point, B.angle);\n      }\n      return {};\n    }\n    function ne(t, e, i, o, r) {\n      var a = $t(t.add(t.sub(e)._unit()), r).point,\n        n = i.sub(a);\n      return i.add(n._mult(o / n.mag()));\n    }\n    function se(e, i, o, r, a, n, s, l, c, u, h, p) {\n      var d = r ? e - i : e + i,\n        _ = d > 0 ? 1 : -1,\n        f = 0;\n      r && (_ *= -1, f = Math.PI), _ < 0 && (f += Math.PI);\n      for (var m = _ > 0 ? l + s : l + s + 1, g = a, v = a, y = 0, x = 0, b = Math.abs(d), w = []; y + x <= b;) {\n        if ((m += _) < l || m >= c) return null;\n        if (v = g, w.push(g), void 0 === (g = p[m])) {\n          var T = new t.Point(u.getx(m), u.gety(m)),\n            E = $t(T, h);\n          if (E.signedDistanceFromCamera > 0) g = p[m] = E.point;else {\n            var I = m - _;\n            g = ne(0 === y ? n : new t.Point(u.getx(I), u.gety(I)), T, v, b - y + 1, h);\n          }\n        }\n        y += x, x = v.dist(g);\n      }\n      var P = (b - y) / x,\n        S = g.sub(v),\n        C = S.mult(P)._add(v);\n      C._add(S._unit()._perp()._mult(o * _));\n      var z = f + Math.atan2(g.y - v.y, g.x - v.x);\n      return w.push(C), {\n        point: C,\n        angle: z,\n        path: w\n      };\n    }\n    Yt.prototype.keysLength = function () {\n      return this.boxKeys.length + this.circleKeys.length;\n    }, Yt.prototype.insert = function (t, e, i, o, r) {\n      this._forEachCell(e, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(e), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);\n    }, Yt.prototype.insertCircle = function (t, e, i, o) {\n      this._forEachCell(e - o, i - o, e + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(e), this.circles.push(i), this.circles.push(o);\n    }, Yt.prototype._insertBoxCell = function (t, e, i, o, r, a) {\n      this.boxCells[r].push(a);\n    }, Yt.prototype._insertCircleCell = function (t, e, i, o, r, a) {\n      this.circleCells[r].push(a);\n    }, Yt.prototype._query = function (t, e, i, o, r, a) {\n      if (i < 0 || t > this.width || o < 0 || e > this.height) return !r && [];\n      var n = [];\n      if (t <= 0 && e <= 0 && this.width <= i && this.height <= o) {\n        if (r) return !0;\n        for (var s = 0; s < this.boxKeys.length; s++) n.push({\n          key: this.boxKeys[s],\n          x1: this.bboxes[4 * s],\n          y1: this.bboxes[4 * s + 1],\n          x2: this.bboxes[4 * s + 2],\n          y2: this.bboxes[4 * s + 3]\n        });\n        for (var l = 0; l < this.circleKeys.length; l++) {\n          var c = this.circles[3 * l],\n            u = this.circles[3 * l + 1],\n            h = this.circles[3 * l + 2];\n          n.push({\n            key: this.circleKeys[l],\n            x1: c - h,\n            y1: u - h,\n            x2: c + h,\n            y2: u + h\n          });\n        }\n        return a ? n.filter(a) : n;\n      }\n      return this._forEachCell(t, e, i, o, this._queryCell, n, {\n        hitTest: r,\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      }, a), r ? n.length > 0 : n;\n    }, Yt.prototype._queryCircle = function (t, e, i, o, r) {\n      var a = t - i,\n        n = t + i,\n        s = e - i,\n        l = e + i;\n      if (n < 0 || a > this.width || l < 0 || s > this.height) return !o && [];\n      var c = [];\n      return this._forEachCell(a, s, n, l, this._queryCellCircle, c, {\n        hitTest: o,\n        circle: {\n          x: t,\n          y: e,\n          radius: i\n        },\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      }, r), o ? c.length > 0 : c;\n    }, Yt.prototype.query = function (t, e, i, o, r) {\n      return this._query(t, e, i, o, !1, r);\n    }, Yt.prototype.hitTest = function (t, e, i, o, r) {\n      return this._query(t, e, i, o, !0, r);\n    }, Yt.prototype.hitTestCircle = function (t, e, i, o) {\n      return this._queryCircle(t, e, i, !0, o);\n    }, Yt.prototype._queryCell = function (t, e, i, o, r, a, n, s) {\n      var l = n.seenUids,\n        c = this.boxCells[r];\n      if (null !== c) for (var u = this.bboxes, h = 0, p = c; h < p.length; h += 1) {\n        var d = p[h];\n        if (!l.box[d]) {\n          l.box[d] = !0;\n          var _ = 4 * d;\n          if (t <= u[_ + 2] && e <= u[_ + 3] && i >= u[_ + 0] && o >= u[_ + 1] && (!s || s(this.boxKeys[d]))) {\n            if (n.hitTest) return a.push(!0), !0;\n            a.push({\n              key: this.boxKeys[d],\n              x1: u[_],\n              y1: u[_ + 1],\n              x2: u[_ + 2],\n              y2: u[_ + 3]\n            });\n          }\n        }\n      }\n      var f = this.circleCells[r];\n      if (null !== f) for (var m = this.circles, g = 0, v = f; g < v.length; g += 1) {\n        var y = v[g];\n        if (!l.circle[y]) {\n          l.circle[y] = !0;\n          var x = 3 * y;\n          if (this._circleAndRectCollide(m[x], m[x + 1], m[x + 2], t, e, i, o) && (!s || s(this.circleKeys[y]))) {\n            if (n.hitTest) return a.push(!0), !0;\n            var b = m[x],\n              w = m[x + 1],\n              T = m[x + 2];\n            a.push({\n              key: this.circleKeys[y],\n              x1: b - T,\n              y1: w - T,\n              x2: b + T,\n              y2: w + T\n            });\n          }\n        }\n      }\n    }, Yt.prototype._queryCellCircle = function (t, e, i, o, r, a, n, s) {\n      var l = n.circle,\n        c = n.seenUids,\n        u = this.boxCells[r];\n      if (null !== u) for (var h = this.bboxes, p = 0, d = u; p < d.length; p += 1) {\n        var _ = d[p];\n        if (!c.box[_]) {\n          c.box[_] = !0;\n          var f = 4 * _;\n          if (this._circleAndRectCollide(l.x, l.y, l.radius, h[f + 0], h[f + 1], h[f + 2], h[f + 3]) && (!s || s(this.boxKeys[_]))) return a.push(!0), !0;\n        }\n      }\n      var m = this.circleCells[r];\n      if (null !== m) for (var g = this.circles, v = 0, y = m; v < y.length; v += 1) {\n        var x = y[v];\n        if (!c.circle[x]) {\n          c.circle[x] = !0;\n          var b = 3 * x;\n          if (this._circlesCollide(g[b], g[b + 1], g[b + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[x]))) return a.push(!0), !0;\n        }\n      }\n    }, Yt.prototype._forEachCell = function (t, e, i, o, r, a, n, s) {\n      for (var l = this._convertToXCellCoord(t), c = this._convertToYCellCoord(e), u = this._convertToXCellCoord(i), h = this._convertToYCellCoord(o), p = l; p <= u; p++) for (var d = c; d <= h; d++) if (r.call(this, t, e, i, o, this.xCellCount * d + p, a, n, s)) return;\n    }, Yt.prototype._convertToXCellCoord = function (t) {\n      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));\n    }, Yt.prototype._convertToYCellCoord = function (t) {\n      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));\n    }, Yt.prototype._circlesCollide = function (t, e, i, o, r, a) {\n      var n = o - t,\n        s = r - e,\n        l = i + a;\n      return l * l > n * n + s * s;\n    }, Yt.prototype._circleAndRectCollide = function (t, e, i, o, r, a, n) {\n      var s = (a - o) / 2,\n        l = Math.abs(t - (o + s));\n      if (l > s + i) return !1;\n      var c = (n - r) / 2,\n        u = Math.abs(e - (r + c));\n      if (u > c + i) return !1;\n      if (l <= s || u <= c) return !0;\n      var h = l - s,\n        p = u - c;\n      return h * h + p * p <= i * i;\n    };\n    var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);\n    function ce(t, e) {\n      for (var i = 0; i < t; i++) {\n        var o = e.length;\n        e.resize(o + 4), e.float32.set(le, 3 * o);\n      }\n    }\n    function ue(t, e, i) {\n      var o = e[0],\n        r = e[1];\n      return t[0] = i[0] * o + i[4] * r + i[12], t[1] = i[1] * o + i[5] * r + i[13], t[3] = i[3] * o + i[7] * r + i[15], t;\n    }\n    var he = function (t, e, i) {\n      void 0 === e && (e = new Yt(t.width + 200, t.height + 200, 25)), void 0 === i && (i = new Yt(t.width + 200, t.height + 200, 25)), this.transform = t, this.grid = e, this.ignoredGrid = i, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + 100, this.screenBottomBoundary = t.height + 100, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200;\n    };\n    function pe(e, i, o) {\n      return i * (t.EXTENT / (e.tileSize * Math.pow(2, o - e.tileID.overscaledZ)));\n    }\n    he.prototype.placeCollisionBox = function (t, e, i, o, r) {\n      var a = this.projectAndGetPerspectiveRatio(o, t.anchorPointX, t.anchorPointY),\n        n = i * a.perspectiveRatio,\n        s = t.x1 * n + a.point.x,\n        l = t.y1 * n + a.point.y,\n        c = t.x2 * n + a.point.x,\n        u = t.y2 * n + a.point.y;\n      return !this.isInsideGrid(s, l, c, u) || !e && this.grid.hitTest(s, l, c, u, r) ? {\n        box: [],\n        offscreen: !1\n      } : {\n        box: [s, l, c, u],\n        offscreen: this.isOffscreen(s, l, c, u)\n      };\n    }, he.prototype.placeCollisionCircles = function (e, i, o, r, a, n, s, l, c, u, h, p, d) {\n      var _ = [],\n        f = new t.Point(i.anchorX, i.anchorY),\n        m = $t(f, n),\n        g = te(this.transform.cameraToCenterDistance, m.signedDistanceFromCamera),\n        v = (u ? a / g : a * g) / t.ONE_EM,\n        y = $t(f, s).point,\n        x = oe(v, r, i.lineOffsetX * v, i.lineOffsetY * v, !1, y, f, i, o, s, {}),\n        b = !1,\n        w = !1,\n        T = !0;\n      if (x) {\n        for (var E = .5 * p * g + d, I = new t.Point(-100, -100), P = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), S = new Kt(), C = x.first, z = x.last, D = [], A = C.path.length - 1; A >= 1; A--) D.push(C.path[A]);\n        for (var M = 1; M < z.path.length; M++) D.push(z.path[M]);\n        var L = 2.5 * E;\n        if (l) {\n          var R = D.map(function (t) {\n            return $t(t, l);\n          });\n          D = R.some(function (t) {\n            return t.signedDistanceFromCamera <= 0;\n          }) ? [] : R.map(function (t) {\n            return t.point;\n          });\n        }\n        var k = [];\n        if (D.length > 0) {\n          for (var B = D[0].clone(), O = D[0].clone(), F = 1; F < D.length; F++) B.x = Math.min(B.x, D[F].x), B.y = Math.min(B.y, D[F].y), O.x = Math.max(O.x, D[F].x), O.y = Math.max(O.y, D[F].y);\n          k = B.x >= I.x && O.x <= P.x && B.y >= I.y && O.y <= P.y ? [D] : O.x < I.x || B.x > P.x || O.y < I.y || B.y > P.y ? [] : t.clipLine([D], I.x, I.y, P.x, P.y);\n        }\n        for (var U = 0, N = k; U < N.length; U += 1) {\n          var Z;\n          S.reset(N[U], .25 * E), Z = S.length <= .5 * E ? 1 : Math.ceil(S.paddedLength / L) + 1;\n          for (var q = 0; q < Z; q++) {\n            var j = q / Math.max(Z - 1, 1),\n              V = S.lerp(j),\n              G = V.x + 100,\n              W = V.y + 100;\n            _.push(G, W, E, 0);\n            var X = G - E,\n              H = W - E,\n              K = G + E,\n              Y = W + E;\n            if (T = T && this.isOffscreen(X, H, K, Y), w = w || this.isInsideGrid(X, H, K, Y), !e && this.grid.hitTestCircle(G, W, E, h) && (b = !0, !c)) return {\n              circles: [],\n              offscreen: !1,\n              collisionDetected: b\n            };\n          }\n        }\n      }\n      return {\n        circles: !c && b || !w ? [] : _,\n        offscreen: T,\n        collisionDetected: b\n      };\n    }, he.prototype.queryRenderedSymbols = function (e) {\n      if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n      for (var i = [], o = 1 / 0, r = 1 / 0, a = -1 / 0, n = -1 / 0, s = 0, l = e; s < l.length; s += 1) {\n        var c = l[s],\n          u = new t.Point(c.x + 100, c.y + 100);\n        o = Math.min(o, u.x), r = Math.min(r, u.y), a = Math.max(a, u.x), n = Math.max(n, u.y), i.push(u);\n      }\n      for (var h = {}, p = {}, d = 0, _ = this.grid.query(o, r, a, n).concat(this.ignoredGrid.query(o, r, a, n)); d < _.length; d += 1) {\n        var f = _[d],\n          m = f.key;\n        if (void 0 === h[m.bucketInstanceId] && (h[m.bucketInstanceId] = {}), !h[m.bucketInstanceId][m.featureIndex]) {\n          var g = [new t.Point(f.x1, f.y1), new t.Point(f.x2, f.y1), new t.Point(f.x2, f.y2), new t.Point(f.x1, f.y2)];\n          t.polygonIntersectsPolygon(i, g) && (h[m.bucketInstanceId][m.featureIndex] = !0, void 0 === p[m.bucketInstanceId] && (p[m.bucketInstanceId] = []), p[m.bucketInstanceId].push(m.featureIndex));\n        }\n      }\n      return p;\n    }, he.prototype.insertCollisionBox = function (t, e, i, o, r) {\n      (e ? this.ignoredGrid : this.grid).insert({\n        bucketInstanceId: i,\n        featureIndex: o,\n        collisionGroupID: r\n      }, t[0], t[1], t[2], t[3]);\n    }, he.prototype.insertCollisionCircles = function (t, e, i, o, r) {\n      for (var a = e ? this.ignoredGrid : this.grid, n = {\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: r\n        }, s = 0; s < t.length; s += 4) a.insertCircle(n, t[s], t[s + 1], t[s + 2]);\n    }, he.prototype.projectAndGetPerspectiveRatio = function (e, i, o) {\n      var r = [i, o, 0, 1];\n      return ue(r, r, e), {\n        point: new t.Point((r[0] / r[3] + 1) / 2 * this.transform.width + 100, (-r[1] / r[3] + 1) / 2 * this.transform.height + 100),\n        perspectiveRatio: .5 + this.transform.cameraToCenterDistance / r[3] * .5\n      };\n    }, he.prototype.isOffscreen = function (t, e, i, o) {\n      return i < 100 || t >= this.screenRightBoundary || o < 100 || e > this.screenBottomBoundary;\n    }, he.prototype.isInsideGrid = function (t, e, i, o) {\n      return i >= 0 && t < this.gridRightBoundary && o >= 0 && e < this.gridBottomBoundary;\n    }, he.prototype.getViewportMatrix = function () {\n      var e = t.identity([]);\n      return t.translate(e, e, [-100, -100, 0]), e;\n    };\n    var de = function (t, e, i, o) {\n      this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : o && i ? 1 : 0, this.placed = i;\n    };\n    de.prototype.isHidden = function () {\n      return 0 === this.opacity && !this.placed;\n    };\n    var _e = function (t, e, i, o, r) {\n      this.text = new de(t ? t.text : null, e, i, r), this.icon = new de(t ? t.icon : null, e, o, r);\n    };\n    _e.prototype.isHidden = function () {\n      return this.text.isHidden() && this.icon.isHidden();\n    };\n    var fe = function (t, e, i) {\n        this.text = t, this.icon = e, this.skipFade = i;\n      },\n      me = function () {\n        this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];\n      },\n      ge = function (t, e, i, o, r) {\n        this.bucketInstanceId = t, this.featureIndex = e, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;\n      },\n      ve = function (t) {\n        this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};\n      };\n    function ye(e, i, o, r, a) {\n      var n = t.getAnchorAlignment(e),\n        s = -(n.horizontalAlign - .5) * i,\n        l = -(n.verticalAlign - .5) * o,\n        c = t.evaluateVariableOffset(e, r);\n      return new t.Point(s + c[0] * a, l + c[1] * a);\n    }\n    function xe(e, i, o, r, a, n) {\n      var s = e.x1,\n        l = e.x2,\n        c = e.y1,\n        u = e.y2,\n        h = e.anchorPointX,\n        p = e.anchorPointY,\n        d = new t.Point(i, o);\n      return r && d._rotate(a ? n : -n), {\n        x1: s + d.x,\n        y1: c + d.y,\n        x2: l + d.x,\n        y2: u + d.y,\n        anchorPointX: h,\n        anchorPointY: p\n      };\n    }\n    ve.prototype.get = function (t) {\n      if (this.crossSourceCollisions) return {\n        ID: 0,\n        predicate: null\n      };\n      if (!this.collisionGroups[t]) {\n        var e = ++this.maxGroupID;\n        this.collisionGroups[t] = {\n          ID: e,\n          predicate: function (t) {\n            return t.collisionGroupID === e;\n          }\n        };\n      }\n      return this.collisionGroups[t];\n    };\n    var be = function (t, e, i, o) {\n      this.transform = t.clone(), this.collisionIndex = new he(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = e, this.retainedQueryData = {}, this.collisionGroups = new ve(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n    };\n    function we(t, e, i, o, r) {\n      t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0), t.emplaceBack(e ? 1 : 0, i ? 1 : 0, o || 0, r || 0);\n    }\n    be.prototype.getBucketParts = function (e, i, o, r) {\n      var a = o.getBucket(i),\n        n = o.latestFeatureIndex;\n      if (a && n && i.id === a.layerIds[0]) {\n        var s = o.collisionBoxArray,\n          l = a.layers[0].layout,\n          c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n          u = o.tileSize / t.EXTENT,\n          h = this.transform.calculatePosMatrix(o.tileID.toUnwrapped()),\n          p = "map" === l.get("text-pitch-alignment"),\n          d = "map" === l.get("text-rotation-alignment"),\n          _ = pe(o, 1, this.transform.zoom),\n          f = Jt(h, p, d, this.transform, _),\n          m = null;\n        if (p) {\n          var g = Qt(h, p, d, this.transform, _);\n          m = t.multiply([], this.transform.labelPlaneMatrix, g);\n        }\n        this.retainedQueryData[a.bucketInstanceId] = new ge(a.bucketInstanceId, n, a.sourceLayerIndex, a.index, o.tileID);\n        var v = {\n          bucket: a,\n          layout: l,\n          posMatrix: h,\n          textLabelPlaneMatrix: f,\n          labelToScreenMatrix: m,\n          scale: c,\n          textPixelRatio: u,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: s,\n          partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a.textSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(a.sourceID)\n        };\n        if (r) for (var y = 0, x = a.sortKeyRanges; y < x.length; y += 1) {\n          var b = x[y];\n          e.push({\n            sortKey: b.sortKey,\n            symbolInstanceStart: b.symbolInstanceStart,\n            symbolInstanceEnd: b.symbolInstanceEnd,\n            parameters: v\n          });\n        } else e.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: a.symbolInstances.length,\n          parameters: v\n        });\n      }\n    }, be.prototype.attemptAnchorPlacement = function (t, e, i, o, r, a, n, s, l, c, u, h, p, d, _) {\n      var f,\n        m = [h.textOffset0, h.textOffset1],\n        g = ye(t, i, o, m, r),\n        v = this.collisionIndex.placeCollisionBox(xe(e, g.x, g.y, a, n, this.transform.angle), u, s, l, c.predicate);\n      if (!_ || 0 !== this.collisionIndex.placeCollisionBox(xe(_, g.x, g.y, a, n, this.transform.angle), u, s, l, c.predicate).box.length) return v.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[h.crossTileID] && this.prevPlacement.placements[h.crossTileID] && this.prevPlacement.placements[h.crossTileID].text && (f = this.prevPlacement.variableOffsets[h.crossTileID].anchor), this.variableOffsets[h.crossTileID] = {\n        textOffset: m,\n        width: i,\n        height: o,\n        anchor: t,\n        textBoxScale: r,\n        prevAnchor: f\n      }, this.markUsedJustification(p, t, h, d), p.allowVerticalPlacement && (this.markUsedOrientation(p, d, h), this.placedOrientations[h.crossTileID] = d), {\n        shift: g,\n        placedGlyphBoxes: v\n      }) : void 0;\n    }, be.prototype.placeLayerBucketPart = function (e, i, o) {\n      var r = this,\n        a = e.parameters,\n        n = a.bucket,\n        s = a.layout,\n        l = a.posMatrix,\n        c = a.textLabelPlaneMatrix,\n        u = a.labelToScreenMatrix,\n        h = a.textPixelRatio,\n        p = a.holdingForFade,\n        d = a.collisionBoxArray,\n        _ = a.partiallyEvaluatedTextSize,\n        f = a.collisionGroup,\n        m = s.get("text-optional"),\n        g = s.get("icon-optional"),\n        v = s.get("text-allow-overlap"),\n        y = s.get("icon-allow-overlap"),\n        x = "map" === s.get("text-rotation-alignment"),\n        b = "map" === s.get("text-pitch-alignment"),\n        w = "none" !== s.get("icon-text-fit"),\n        T = "viewport-y" === s.get("symbol-z-order"),\n        E = v && (y || !n.hasIconData() || g),\n        I = y && (v || !n.hasTextData() || m);\n      !n.collisionArrays && d && n.deserializeCollisionBoxes(d);\n      var P = function (e, a) {\n        if (!i[e.crossTileID]) if (p) r.placements[e.crossTileID] = new fe(!1, !1, !1);else {\n          var d,\n            T = !1,\n            P = !1,\n            S = !0,\n            C = null,\n            z = {\n              box: null,\n              offscreen: null\n            },\n            D = {\n              box: null,\n              offscreen: null\n            },\n            A = null,\n            M = null,\n            L = 0,\n            R = 0,\n            k = 0;\n          a.textFeatureIndex ? L = a.textFeatureIndex : e.useRuntimeCollisionCircles && (L = e.featureIndex), a.verticalTextFeatureIndex && (R = a.verticalTextFeatureIndex);\n          var B = a.textBox;\n          if (B) {\n            var O = function (i) {\n                var o = t.WritingMode.horizontal;\n                if (n.allowVerticalPlacement && !i && r.prevPlacement) {\n                  var a = r.prevPlacement.placedOrientations[e.crossTileID];\n                  a && (r.placedOrientations[e.crossTileID] = a, r.markUsedOrientation(n, o = a, e));\n                }\n                return o;\n              },\n              F = function (i, o) {\n                if (n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && a.verticalTextBox) for (var r = 0, s = n.writingModes; r < s.length && (s[r] === t.WritingMode.vertical ? (z = o(), D = z) : z = i(), !(z && z.box && z.box.length)); r += 1);else z = i();\n              };\n            if (s.get("text-variable-anchor")) {\n              var U = s.get("text-variable-anchor");\n              if (r.prevPlacement && r.prevPlacement.variableOffsets[e.crossTileID]) {\n                var N = r.prevPlacement.variableOffsets[e.crossTileID];\n                U.indexOf(N.anchor) > 0 && (U = U.filter(function (t) {\n                  return t !== N.anchor;\n                })).unshift(N.anchor);\n              }\n              var Z = function (t, i, o) {\n                for (var a = t.x2 - t.x1, s = t.y2 - t.y1, c = e.textBoxScale, u = w && !y ? i : null, p = {\n                    box: [],\n                    offscreen: !1\n                  }, d = v ? 2 * U.length : U.length, _ = 0; _ < d; ++_) {\n                  var m = r.attemptAnchorPlacement(U[_ % U.length], t, a, s, c, x, b, h, l, f, _ >= U.length, e, n, o, u);\n                  if (m && (p = m.placedGlyphBoxes) && p.box && p.box.length) {\n                    T = !0, C = m.shift;\n                    break;\n                  }\n                }\n                return p;\n              };\n              F(function () {\n                return Z(B, a.iconBox, t.WritingMode.horizontal);\n              }, function () {\n                var i = a.verticalTextBox;\n                return n.allowVerticalPlacement && !(z && z.box && z.box.length) && e.numVerticalGlyphVertices > 0 && i ? Z(i, a.verticalIconBox, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), z && (T = z.box, S = z.offscreen);\n              var q = O(z && z.box);\n              if (!T && r.prevPlacement) {\n                var j = r.prevPlacement.variableOffsets[e.crossTileID];\n                j && (r.variableOffsets[e.crossTileID] = j, r.markUsedJustification(n, j.anchor, e, q));\n              }\n            } else {\n              var V = function (t, i) {\n                var o = r.collisionIndex.placeCollisionBox(t, v, h, l, f.predicate);\n                return o && o.box && o.box.length && (r.markUsedOrientation(n, i, e), r.placedOrientations[e.crossTileID] = i), o;\n              };\n              F(function () {\n                return V(B, t.WritingMode.horizontal);\n              }, function () {\n                var i = a.verticalTextBox;\n                return n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? V(i, t.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null\n                };\n              }), O(z && z.box && z.box.length);\n            }\n          }\n          if (T = (d = z) && d.box && d.box.length > 0, S = d && d.offscreen, e.useRuntimeCollisionCircles) {\n            var G = n.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex),\n              W = t.evaluateSizeForFeature(n.textSizeData, _, G),\n              X = s.get("text-padding");\n            A = r.collisionIndex.placeCollisionCircles(v, G, n.lineVertexArray, n.glyphOffsetArray, W, l, c, u, o, b, f.predicate, e.collisionCircleDiameter, X), T = v || A.circles.length > 0 && !A.collisionDetected, S = S && A.offscreen;\n          }\n          if (a.iconFeatureIndex && (k = a.iconFeatureIndex), a.iconBox) {\n            var H = function (t) {\n              var e = w && C ? xe(t, C.x, C.y, x, b, r.transform.angle) : t;\n              return r.collisionIndex.placeCollisionBox(e, y, h, l, f.predicate);\n            };\n            P = D && D.box && D.box.length && a.verticalIconBox ? (M = H(a.verticalIconBox)).box.length > 0 : (M = H(a.iconBox)).box.length > 0, S = S && M.offscreen;\n          }\n          var K = m || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices,\n            Y = g || 0 === e.numIconVertices;\n          if (K || Y ? Y ? K || (P = P && T) : T = P && T : P = T = P && T, T && d && d.box && r.collisionIndex.insertCollisionBox(d.box, s.get("text-ignore-placement"), n.bucketInstanceId, D && D.box && R ? R : L, f.ID), P && M && r.collisionIndex.insertCollisionBox(M.box, s.get("icon-ignore-placement"), n.bucketInstanceId, k, f.ID), A && (T && r.collisionIndex.insertCollisionCircles(A.circles, s.get("text-ignore-placement"), n.bucketInstanceId, L, f.ID), o)) {\n            var J = n.bucketInstanceId,\n              Q = r.collisionCircleArrays[J];\n            void 0 === Q && (Q = r.collisionCircleArrays[J] = new me());\n            for (var $ = 0; $ < A.circles.length; $ += 4) Q.circles.push(A.circles[$ + 0]), Q.circles.push(A.circles[$ + 1]), Q.circles.push(A.circles[$ + 2]), Q.circles.push(A.collisionDetected ? 1 : 0);\n          }\n          r.placements[e.crossTileID] = new fe(T || E, P || I, S || n.justReloaded), i[e.crossTileID] = !0;\n        }\n      };\n      if (T) for (var S = n.getSortedSymbolIndexes(this.transform.angle), C = S.length - 1; C >= 0; --C) {\n        var z = S[C];\n        P(n.symbolInstances.get(z), n.collisionArrays[z]);\n      } else for (var D = e.symbolInstanceStart; D < e.symbolInstanceEnd; D++) P(n.symbolInstances.get(D), n.collisionArrays[D]);\n      if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n        var A = this.collisionCircleArrays[n.bucketInstanceId];\n        t.invert(A.invProjMatrix, l), A.viewportMatrix = this.collisionIndex.getViewportMatrix();\n      }\n      n.justReloaded = !1;\n    }, be.prototype.markUsedJustification = function (e, i, o, r) {\n      var a;\n      a = r === t.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : {\n        left: o.leftJustifiedTextSymbolIndex,\n        center: o.centerJustifiedTextSymbolIndex,\n        right: o.rightJustifiedTextSymbolIndex\n      }[t.getAnchorJustification(i)];\n      for (var n = 0, s = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex]; n < s.length; n += 1) {\n        var l = s[n];\n        l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = a >= 0 && l !== a ? 0 : o.crossTileID);\n      }\n    }, be.prototype.markUsedOrientation = function (e, i, o) {\n      for (var r = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0, a = i === t.WritingMode.vertical ? i : 0, n = 0, s = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex]; n < s.length; n += 1) e.text.placedSymbolArray.get(s[n]).placedOrientation = r;\n      o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = a);\n    }, be.prototype.commit = function (t) {\n      this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;\n      var e = this.prevPlacement,\n        i = !1;\n      this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;\n      var o = e ? e.symbolFadeChange(t) : 1,\n        r = e ? e.opacities : {},\n        a = e ? e.variableOffsets : {},\n        n = e ? e.placedOrientations : {};\n      for (var s in this.placements) {\n        var l = this.placements[s],\n          c = r[s];\n        c ? (this.opacities[s] = new _e(c, o, l.text, l.icon), i = i || l.text !== c.text.placed || l.icon !== c.icon.placed) : (this.opacities[s] = new _e(null, o, l.text, l.icon, l.skipFade), i = i || l.text || l.icon);\n      }\n      for (var u in r) {\n        var h = r[u];\n        if (!this.opacities[u]) {\n          var p = new _e(h, o, !1, !1);\n          p.isHidden() || (this.opacities[u] = p, i = i || h.text.placed || h.icon.placed);\n        }\n      }\n      for (var d in a) this.variableOffsets[d] || !this.opacities[d] || this.opacities[d].isHidden() || (this.variableOffsets[d] = a[d]);\n      for (var _ in n) this.placedOrientations[_] || !this.opacities[_] || this.opacities[_].isHidden() || (this.placedOrientations[_] = n[_]);\n      i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t);\n    }, be.prototype.updateLayerOpacities = function (t, e) {\n      for (var i = {}, o = 0, r = e; o < r.length; o += 1) {\n        var a = r[o],\n          n = a.getBucket(t);\n        n && a.latestFeatureIndex && t.id === n.layerIds[0] && this.updateBucketOpacities(n, i, a.collisionBoxArray);\n      }\n    }, be.prototype.updateBucketOpacities = function (e, i, o) {\n      var r = this;\n      e.hasTextData() && e.text.opacityVertexArray.clear(), e.hasIconData() && e.icon.opacityVertexArray.clear(), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();\n      var a = e.layers[0].layout,\n        n = new _e(null, 0, !1, !1, !0),\n        s = a.get("text-allow-overlap"),\n        l = a.get("icon-allow-overlap"),\n        c = a.get("text-variable-anchor"),\n        u = "map" === a.get("text-rotation-alignment"),\n        h = "map" === a.get("text-pitch-alignment"),\n        p = "none" !== a.get("icon-text-fit"),\n        d = new _e(null, 0, s && (l || !e.hasIconData() || a.get("icon-optional")), l && (s || !e.hasTextData() || a.get("text-optional")), !0);\n      !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o);\n      for (var _ = function (t, e, i) {\n          for (var o = 0; o < e / 4; o++) t.opacityVertexArray.emplaceBack(i);\n        }, f = function (o) {\n          var a = e.symbolInstances.get(o),\n            s = a.numHorizontalGlyphVertices,\n            l = a.numVerticalGlyphVertices,\n            f = a.crossTileID,\n            m = r.opacities[f];\n          i[f] ? m = n : m || (r.opacities[f] = m = d), i[f] = !0;\n          var g = a.numIconVertices > 0,\n            v = r.placedOrientations[a.crossTileID],\n            y = v === t.WritingMode.vertical,\n            x = v === t.WritingMode.horizontal || v === t.WritingMode.horizontalOnly;\n          if (s > 0 || l > 0) {\n            var b = De(m.text);\n            _(e.text, s, y ? Ae : b), _(e.text, l, x ? Ae : b);\n            var w = m.text.isHidden();\n            [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach(function (t) {\n              t >= 0 && (e.text.placedSymbolArray.get(t).hidden = w || y ? 1 : 0);\n            }), a.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = w || x ? 1 : 0);\n            var T = r.variableOffsets[a.crossTileID];\n            T && r.markUsedJustification(e, T.anchor, a, v);\n            var E = r.placedOrientations[a.crossTileID];\n            E && (r.markUsedJustification(e, "left", a, E), r.markUsedOrientation(e, E, a));\n          }\n          if (g) {\n            var I = De(m.icon),\n              P = !(p && a.verticalPlacedIconSymbolIndex && y);\n            a.placedIconSymbolIndex >= 0 && (_(e.icon, a.numIconVertices, P ? I : Ae), e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = m.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (_(e.icon, a.numVerticalIconVertices, P ? Ae : I), e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = m.icon.isHidden());\n          }\n          if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {\n            var S = e.collisionArrays[o];\n            if (S) {\n              var C = new t.Point(0, 0);\n              if (S.textBox || S.verticalTextBox) {\n                var z = !0;\n                if (c) {\n                  var D = r.variableOffsets[f];\n                  D ? (C = ye(D.anchor, D.width, D.height, D.textOffset, D.textBoxScale), u && C._rotate(h ? r.transform.angle : -r.transform.angle)) : z = !1;\n                }\n                S.textBox && we(e.textCollisionBox.collisionVertexArray, m.text.placed, !z || y, C.x, C.y), S.verticalTextBox && we(e.textCollisionBox.collisionVertexArray, m.text.placed, !z || x, C.x, C.y);\n              }\n              var A = Boolean(!x && S.verticalIconBox);\n              S.iconBox && we(e.iconCollisionBox.collisionVertexArray, m.icon.placed, A, p ? C.x : 0, p ? C.y : 0), S.verticalIconBox && we(e.iconCollisionBox.collisionVertexArray, m.icon.placed, !A, p ? C.x : 0, p ? C.y : 0);\n            }\n          }\n        }, m = 0; m < e.symbolInstances.length; m++) f(m);\n      if (e.sortFeatures(this.transform.angle), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.bucketInstanceId in this.collisionCircleArrays) {\n        var g = this.collisionCircleArrays[e.bucketInstanceId];\n        e.placementInvProjMatrix = g.invProjMatrix, e.placementViewportMatrix = g.viewportMatrix, e.collisionCircleArray = g.circles, delete this.collisionCircleArrays[e.bucketInstanceId];\n      }\n    }, be.prototype.symbolFadeChange = function (t) {\n      return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n    }, be.prototype.zoomAdjustment = function (t) {\n      return Math.max(0, (this.transform.zoom - t) / 1.5);\n    }, be.prototype.hasTransitions = function (t) {\n      return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;\n    }, be.prototype.stillRecent = function (t, e) {\n      var i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;\n      return this.zoomAtLastRecencyCheck = e, this.commitTime + this.fadeDuration * i > t;\n    }, be.prototype.setStale = function () {\n      this.stale = !0;\n    };\n    var Te = Math.pow(2, 25),\n      Ee = Math.pow(2, 24),\n      Ie = Math.pow(2, 17),\n      Pe = Math.pow(2, 16),\n      Se = Math.pow(2, 9),\n      Ce = Math.pow(2, 8),\n      ze = Math.pow(2, 1);\n    function De(t) {\n      if (0 === t.opacity && !t.placed) return 0;\n      if (1 === t.opacity && t.placed) return 4294967295;\n      var e = t.placed ? 1 : 0,\n        i = Math.floor(127 * t.opacity);\n      return i * Te + e * Ee + i * Ie + e * Pe + i * Se + e * Ce + i * ze + e;\n    }\n    var Ae = 0,\n      Me = function (t) {\n        this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];\n      };\n    Me.prototype.continuePlacement = function (t, e, i, o, r) {\n      for (var a = this._bucketParts; this._currentTileIndex < t.length;) if (e.getBucketParts(a, o, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;\n      for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, a.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      })); this._currentPartIndex < a.length;) if (e.placeLayerBucketPart(a[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, r()) return !0;\n      return !1;\n    };\n    var Le = function (t, e, i, o, r, a, n) {\n      this.placement = new be(t, r, a, n), this._currentPlacementIndex = e.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n    };\n    Le.prototype.isDone = function () {\n      return this._done;\n    }, Le.prototype.continuePlacement = function (e, i, o) {\n      for (var r = this, a = t.browser.now(), n = function () {\n          var e = t.browser.now() - a;\n          return !r._forceFullPlacement && e > 2;\n        }; this._currentPlacementIndex >= 0;) {\n        var s = i[e[this._currentPlacementIndex]],\n          l = this.placement.collisionIndex.transform.zoom;\n        if ("symbol" === s.type && (!s.minzoom || s.minzoom <= l) && (!s.maxzoom || s.maxzoom > l)) {\n          if (this._inProgressLayer || (this._inProgressLayer = new Me(s)), this._inProgressLayer.continuePlacement(o[s.source], this.placement, this._showCollisionBoxes, s, n)) return;\n          delete this._inProgressLayer;\n        }\n        this._currentPlacementIndex--;\n      }\n      this._done = !0;\n    }, Le.prototype.commit = function (t) {\n      return this.placement.commit(t), this.placement;\n    };\n    var Re = 512 / t.EXTENT / 2,\n      ke = function (t, e, i) {\n        this.tileID = t, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;\n        for (var o = 0; o < e.length; o++) {\n          var r = e.get(o),\n            a = r.key;\n          this.indexedSymbolInstances[a] || (this.indexedSymbolInstances[a] = []), this.indexedSymbolInstances[a].push({\n            crossTileID: r.crossTileID,\n            coord: this.getScaledCoordinates(r, t)\n          });\n        }\n      };\n    ke.prototype.getScaledCoordinates = function (e, i) {\n      var o = Re / Math.pow(2, i.canonical.z - this.tileID.canonical.z);\n      return {\n        x: Math.floor((i.canonical.x * t.EXTENT + e.anchorX) * o),\n        y: Math.floor((i.canonical.y * t.EXTENT + e.anchorY) * o)\n      };\n    }, ke.prototype.findMatches = function (t, e, i) {\n      for (var o = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z), r = 0; r < t.length; r++) {\n        var a = t.get(r);\n        if (!a.crossTileID) {\n          var n = this.indexedSymbolInstances[a.key];\n          if (n) for (var s = this.getScaledCoordinates(a, e), l = 0, c = n; l < c.length; l += 1) {\n            var u = c[l];\n            if (Math.abs(u.coord.x - s.x) <= o && Math.abs(u.coord.y - s.y) <= o && !i[u.crossTileID]) {\n              i[u.crossTileID] = !0, a.crossTileID = u.crossTileID;\n              break;\n            }\n          }\n        }\n      }\n    };\n    var Be = function () {\n      this.maxCrossTileID = 0;\n    };\n    Be.prototype.generate = function () {\n      return ++this.maxCrossTileID;\n    };\n    var Oe = function () {\n      this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n    };\n    Oe.prototype.handleWrapJump = function (t) {\n      var e = Math.round((t - this.lng) / 360);\n      if (0 !== e) for (var i in this.indexes) {\n        var o = this.indexes[i],\n          r = {};\n        for (var a in o) {\n          var n = o[a];\n          n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), r[n.tileID.key] = n;\n        }\n        this.indexes[i] = r;\n      }\n      this.lng = t;\n    }, Oe.prototype.addBucket = function (t, e, i) {\n      if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {\n        if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId) return !1;\n        this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);\n      }\n      for (var o = 0; o < e.symbolInstances.length; o++) e.symbolInstances.get(o).crossTileID = 0;\n      this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});\n      var r = this.usedCrossTileIDs[t.overscaledZ];\n      for (var a in this.indexes) {\n        var n = this.indexes[a];\n        if (Number(a) > t.overscaledZ) for (var s in n) {\n          var l = n[s];\n          l.tileID.isChildOf(t) && l.findMatches(e.symbolInstances, t, r);\n        } else {\n          var c = n[t.scaledTo(Number(a)).key];\n          c && c.findMatches(e.symbolInstances, t, r);\n        }\n      }\n      for (var u = 0; u < e.symbolInstances.length; u++) {\n        var h = e.symbolInstances.get(u);\n        h.crossTileID || (h.crossTileID = i.generate(), r[h.crossTileID] = !0);\n      }\n      return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new ke(t, e.symbolInstances, e.bucketInstanceId), !0;\n    }, Oe.prototype.removeBucketCrossTileIDs = function (t, e) {\n      for (var i in e.indexedSymbolInstances) for (var o = 0, r = e.indexedSymbolInstances[i]; o < r.length; o += 1) delete this.usedCrossTileIDs[t][r[o].crossTileID];\n    }, Oe.prototype.removeStaleBuckets = function (t) {\n      var e = !1;\n      for (var i in this.indexes) {\n        var o = this.indexes[i];\n        for (var r in o) t[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], e = !0);\n      }\n      return e;\n    };\n    var Fe = function () {\n      this.layerIndexes = {}, this.crossTileIDs = new Be(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n    };\n    Fe.prototype.addLayer = function (t, e, i) {\n      var o = this.layerIndexes[t.id];\n      void 0 === o && (o = this.layerIndexes[t.id] = new Oe());\n      var r = !1,\n        a = {};\n      o.handleWrapJump(i);\n      for (var n = 0, s = e; n < s.length; n += 1) {\n        var l = s[n],\n          c = l.getBucket(t);\n        c && t.id === c.layerIds[0] && (c.bucketInstanceId || (c.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(l.tileID, c, this.crossTileIDs) && (r = !0), a[c.bucketInstanceId] = !0);\n      }\n      return o.removeStaleBuckets(a) && (r = !0), r;\n    }, Fe.prototype.pruneUnusedLayers = function (t) {\n      var e = {};\n      for (var i in t.forEach(function (t) {\n        e[t] = !0;\n      }), this.layerIndexes) e[i] || delete this.layerIndexes[i];\n    };\n    var Ue = function (e, i) {\n        return t.emitValidationErrors(e, i && i.filter(function (t) {\n          return "source.canvas" !== t.identifier;\n        }));\n      },\n      Ne = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]),\n      Ze = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"]),\n      qe = function () {\n        var e = {},\n          i = t.styleSpec.$version;\n        for (var o in t.styleSpec.$root) {\n          var r,\n            a = t.styleSpec.$root[o];\n          if (a.required) null != (r = "version" === o ? i : "array" === a.type ? [] : {}) && (e[o] = r);\n        }\n        return e;\n      }(),\n      je = function (e) {\n        function i(o, r) {\n          var a = this;\n          void 0 === r && (r = {}), e.call(this), this.map = o, this.dispatcher = new E(Ft(), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new y(o._requestManager, r.localIdeographFontFamily), this.lineAtlas = new T(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());\n          var n = this;\n          this._rtlTextPluginCallback = i.registerForPluginStateChange(function (e) {\n            n.dispatcher.broadcast("syncRTLPluginState", {\n              pluginStatus: e.pluginStatus,\n              pluginURL: e.pluginURL\n            }, function (e, i) {\n              if (t.triggerPluginCompletionEvent(e), i && i.every(function (t) {\n                return t;\n              })) for (var o in n.sourceCaches) n.sourceCaches[o].reload();\n            });\n          }), this.on("data", function (t) {\n            if ("source" === t.dataType && "metadata" === t.sourceDataType) {\n              var e = a.sourceCaches[t.sourceId];\n              if (e) {\n                var i = e.getSource();\n                if (i && i.vectorLayerIds) for (var o in a._layers) {\n                  var r = a._layers[o];\n                  r.source === i.id && a._validateLayer(r);\n                }\n              }\n            }\n          });\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.loadURL = function (e, i) {\n          var o = this;\n          void 0 === i && (i = {}), this.fire(new t.Event("dataloading", {\n            dataType: "style"\n          }));\n          var r = "boolean" == typeof i.validate ? i.validate : !t.isMapboxURL(e);\n          e = this.map._requestManager.normalizeStyleURL(e, i.accessToken);\n          var a = this.map._requestManager.transformRequest(e, t.ResourceType.Style);\n          this._request = t.getJSON(a, function (e, i) {\n            o._request = null, e ? o.fire(new t.ErrorEvent(e)) : i && o._load(i, r);\n          });\n        }, i.prototype.loadJSON = function (e, i) {\n          var o = this;\n          void 0 === i && (i = {}), this.fire(new t.Event("dataloading", {\n            dataType: "style"\n          })), this._request = t.browser.frame(function () {\n            o._request = null, o._load(e, !1 !== i.validate);\n          });\n        }, i.prototype.loadEmpty = function () {\n          this.fire(new t.Event("dataloading", {\n            dataType: "style"\n          })), this._load(qe, !1);\n        }, i.prototype._load = function (e, i) {\n          if (!i || !Ue(this, t.validateStyle(e))) {\n            for (var o in this._loaded = !0, this.stylesheet = e, e.sources) this.addSource(o, e.sources[o], {\n              validate: !1\n            });\n            e.sprite ? this._loadSprite(e.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(e.glyphs);\n            var r = Nt(this.stylesheet.layers);\n            this._order = r.map(function (t) {\n              return t.id;\n            }), this._layers = {}, this._serializedLayers = {};\n            for (var a = 0, n = r; a < n.length; a += 1) {\n              var s = n[a];\n              (s = t.createStyleLayer(s)).setEventedParent(this, {\n                layer: {\n                  id: s.id\n                }\n              }), this._layers[s.id] = s, this._serializedLayers[s.id] = s.serialize();\n            }\n            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", {\n              dataType: "style"\n            })), this.fire(new t.Event("style.load"));\n          }\n        }, i.prototype._loadSprite = function (e) {\n          var i = this;\n          this._spriteRequest = function (e, i, o) {\n            var r,\n              a,\n              n,\n              s = t.browser.devicePixelRatio > 1 ? "@2x" : "",\n              l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, s, ".json"), t.ResourceType.SpriteJSON), function (t, e) {\n                l = null, n || (n = t, r = e, u());\n              }),\n              c = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, s, ".png"), t.ResourceType.SpriteImage), function (t, e) {\n                c = null, n || (n = t, a = e, u());\n              });\n            function u() {\n              if (n) o(n);else if (r && a) {\n                var e = t.browser.getImageData(a),\n                  i = {};\n                for (var s in r) {\n                  var l = r[s],\n                    c = l.width,\n                    u = l.height,\n                    h = l.x,\n                    p = l.y,\n                    d = l.sdf,\n                    _ = l.pixelRatio,\n                    f = l.stretchX,\n                    m = l.stretchY,\n                    g = l.content,\n                    v = new t.RGBAImage({\n                      width: c,\n                      height: u\n                    });\n                  t.RGBAImage.copy(e, v, {\n                    x: h,\n                    y: p\n                  }, {\n                    x: 0,\n                    y: 0\n                  }, {\n                    width: c,\n                    height: u\n                  }), i[s] = {\n                    data: v,\n                    pixelRatio: _,\n                    sdf: d,\n                    stretchX: f,\n                    stretchY: m,\n                    content: g\n                  };\n                }\n                o(null, i);\n              }\n            }\n            return {\n              cancel: function () {\n                l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n              }\n            };\n          }(e, this.map._requestManager, function (e, o) {\n            if (i._spriteRequest = null, e) i.fire(new t.ErrorEvent(e));else if (o) for (var r in o) i.imageManager.addImage(r, o[r]);\n            i.imageManager.setLoaded(!0), i._availableImages = i.imageManager.listImages(), i.dispatcher.broadcast("setImages", i._availableImages), i.fire(new t.Event("data", {\n              dataType: "style"\n            }));\n          });\n        }, i.prototype._validateLayer = function (e) {\n          var i = this.sourceCaches[e.source];\n          if (i) {\n            var o = e.sourceLayer;\n            if (o) {\n              var r = i.getSource();\n              ("geojson" === r.type || r.vectorLayerIds && -1 === r.vectorLayerIds.indexOf(o)) && this.fire(new t.ErrorEvent(new Error(\'Source layer "\' + o + \'" does not exist on source "\' + r.id + \'" as specified by style layer "\' + e.id + \'"\')));\n            }\n          }\n        }, i.prototype.loaded = function () {\n          if (!this._loaded) return !1;\n          if (Object.keys(this._updatedSources).length) return !1;\n          for (var t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1;\n          return !!this.imageManager.isLoaded();\n        }, i.prototype._serializeLayers = function (t) {\n          for (var e = [], i = 0, o = t; i < o.length; i += 1) {\n            var r = this._layers[o[i]];\n            "custom" !== r.type && e.push(r.serialize());\n          }\n          return e;\n        }, i.prototype.hasTransitions = function () {\n          if (this.light && this.light.hasTransition()) return !0;\n          for (var t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0;\n          for (var e in this._layers) if (this._layers[e].hasTransition()) return !0;\n          return !1;\n        }, i.prototype._checkLoaded = function () {\n          if (!this._loaded) throw new Error("Style is not done loading");\n        }, i.prototype.update = function (e) {\n          if (this._loaded) {\n            var i = this._changed;\n            if (this._changed) {\n              var o = Object.keys(this._updatedLayers),\n                r = Object.keys(this._removedLayers);\n              for (var a in (o.length || r.length) && this._updateWorkerLayers(o, r), this._updatedSources) {\n                var n = this._updatedSources[a];\n                "reload" === n ? this._reloadSource(a) : "clear" === n && this._clearSource(a);\n              }\n              for (var s in this._updateTilesForChangedImages(), this._updatedPaintProps) this._layers[s].updateTransitions(e);\n              this.light.updateTransitions(e), this._resetUpdates();\n            }\n            var l = {};\n            for (var c in this.sourceCaches) {\n              var u = this.sourceCaches[c];\n              l[c] = u.used, u.used = !1;\n            }\n            for (var h = 0, p = this._order; h < p.length; h += 1) {\n              var d = this._layers[p[h]];\n              d.recalculate(e, this._availableImages), !d.isHidden(e.zoom) && d.source && (this.sourceCaches[d.source].used = !0);\n            }\n            for (var _ in l) {\n              var f = this.sourceCaches[_];\n              l[_] !== f.used && f.fire(new t.Event("data", {\n                sourceDataType: "visibility",\n                dataType: "source",\n                sourceId: _\n              }));\n            }\n            this.light.recalculate(e), this.z = e.zoom, i && this.fire(new t.Event("data", {\n              dataType: "style"\n            }));\n          }\n        }, i.prototype._updateTilesForChangedImages = function () {\n          var t = Object.keys(this._changedImages);\n          if (t.length) {\n            for (var e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t);\n            this._changedImages = {};\n          }\n        }, i.prototype._updateWorkerLayers = function (t, e) {\n          this.dispatcher.broadcast("updateLayers", {\n            layers: this._serializeLayers(t),\n            removedIds: e\n          });\n        }, i.prototype._resetUpdates = function () {\n          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};\n        }, i.prototype.setState = function (e) {\n          var i = this;\n          if (this._checkLoaded(), Ue(this, t.validateStyle(e))) return !1;\n          (e = t.clone$1(e)).layers = Nt(e.layers);\n          var o = function (e, i) {\n            if (!e) return [{\n              command: Zt.setStyle,\n              args: [i]\n            }];\n            var o = [];\n            try {\n              if (!t.deepEqual(e.version, i.version)) return [{\n                command: Zt.setStyle,\n                args: [i]\n              }];\n              t.deepEqual(e.center, i.center) || o.push({\n                command: Zt.setCenter,\n                args: [i.center]\n              }), t.deepEqual(e.zoom, i.zoom) || o.push({\n                command: Zt.setZoom,\n                args: [i.zoom]\n              }), t.deepEqual(e.bearing, i.bearing) || o.push({\n                command: Zt.setBearing,\n                args: [i.bearing]\n              }), t.deepEqual(e.pitch, i.pitch) || o.push({\n                command: Zt.setPitch,\n                args: [i.pitch]\n              }), t.deepEqual(e.sprite, i.sprite) || o.push({\n                command: Zt.setSprite,\n                args: [i.sprite]\n              }), t.deepEqual(e.glyphs, i.glyphs) || o.push({\n                command: Zt.setGlyphs,\n                args: [i.glyphs]\n              }), t.deepEqual(e.transition, i.transition) || o.push({\n                command: Zt.setTransition,\n                args: [i.transition]\n              }), t.deepEqual(e.light, i.light) || o.push({\n                command: Zt.setLight,\n                args: [i.light]\n              });\n              var r = {},\n                a = [];\n              !function (e, i, o, r) {\n                var a;\n                for (a in i = i || {}, e = e || {}) e.hasOwnProperty(a) && (i.hasOwnProperty(a) || jt(a, o, r));\n                for (a in i) i.hasOwnProperty(a) && (e.hasOwnProperty(a) ? t.deepEqual(e[a], i[a]) || ("geojson" === e[a].type && "geojson" === i[a].type && Gt(e, i, a) ? o.push({\n                  command: Zt.setGeoJSONSourceData,\n                  args: [a, i[a].data]\n                }) : Vt(a, i, o, r)) : qt(a, i, o));\n              }(e.sources, i.sources, a, r);\n              var n = [];\n              e.layers && e.layers.forEach(function (t) {\n                r[t.source] ? o.push({\n                  command: Zt.removeLayer,\n                  args: [t.id]\n                }) : n.push(t);\n              }), o = o.concat(a), function (e, i, o) {\n                i = i || [];\n                var r,\n                  a,\n                  n,\n                  s,\n                  l,\n                  c,\n                  u,\n                  h = (e = e || []).map(Xt),\n                  p = i.map(Xt),\n                  d = e.reduce(Ht, {}),\n                  _ = i.reduce(Ht, {}),\n                  f = h.slice(),\n                  m = Object.create(null);\n                for (r = 0, a = 0; r < h.length; r++) _.hasOwnProperty(n = h[r]) ? a++ : (o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), f.splice(f.indexOf(n, a), 1));\n                for (r = 0, a = 0; r < p.length; r++) f[f.length - 1 - r] !== (n = p[p.length - 1 - r]) && (d.hasOwnProperty(n) ? (o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), f.splice(f.lastIndexOf(n, f.length - a), 1)) : a++, o.push({\n                  command: Zt.addLayer,\n                  args: [_[n], c = f[f.length - r]]\n                }), f.splice(f.length - r, 0, n), m[n] = !0);\n                for (r = 0; r < p.length; r++) if (s = d[n = p[r]], l = _[n], !m[n] && !t.deepEqual(s, l)) if (t.deepEqual(s.source, l.source) && t.deepEqual(s["source-layer"], l["source-layer"]) && t.deepEqual(s.type, l.type)) {\n                  for (u in Wt(s.layout, l.layout, o, n, null, Zt.setLayoutProperty), Wt(s.paint, l.paint, o, n, null, Zt.setPaintProperty), t.deepEqual(s.filter, l.filter) || o.push({\n                    command: Zt.setFilter,\n                    args: [n, l.filter]\n                  }), t.deepEqual(s.minzoom, l.minzoom) && t.deepEqual(s.maxzoom, l.maxzoom) || o.push({\n                    command: Zt.setLayerZoomRange,\n                    args: [n, l.minzoom, l.maxzoom]\n                  }), s) s.hasOwnProperty(u) && "layout" !== u && "paint" !== u && "filter" !== u && "metadata" !== u && "minzoom" !== u && "maxzoom" !== u && (0 === u.indexOf("paint.") ? Wt(s[u], l[u], o, n, u.slice(6), Zt.setPaintProperty) : t.deepEqual(s[u], l[u]) || o.push({\n                    command: Zt.setLayerProperty,\n                    args: [n, u, l[u]]\n                  }));\n                  for (u in l) l.hasOwnProperty(u) && !s.hasOwnProperty(u) && "layout" !== u && "paint" !== u && "filter" !== u && "metadata" !== u && "minzoom" !== u && "maxzoom" !== u && (0 === u.indexOf("paint.") ? Wt(s[u], l[u], o, n, u.slice(6), Zt.setPaintProperty) : t.deepEqual(s[u], l[u]) || o.push({\n                    command: Zt.setLayerProperty,\n                    args: [n, u, l[u]]\n                  }));\n                } else o.push({\n                  command: Zt.removeLayer,\n                  args: [n]\n                }), c = f[f.lastIndexOf(n) + 1], o.push({\n                  command: Zt.addLayer,\n                  args: [l, c]\n                });\n              }(n, i.layers, o);\n            } catch (t) {\n              console.warn("Unable to compute style diff:", t), o = [{\n                command: Zt.setStyle,\n                args: [i]\n              }];\n            }\n            return o;\n          }(this.serialize(), e).filter(function (t) {\n            return !(t.command in Ze);\n          });\n          if (0 === o.length) return !1;\n          var r = o.filter(function (t) {\n            return !(t.command in Ne);\n          });\n          if (r.length > 0) throw new Error("Unimplemented: " + r.map(function (t) {\n            return t.command;\n          }).join(", ") + ".");\n          return o.forEach(function (t) {\n            "setTransition" !== t.command && i[t.command].apply(i, t.args);\n          }), this.stylesheet = e, !0;\n        }, i.prototype.addImage = function (e, i) {\n          if (this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));\n          this.imageManager.addImage(e, i), this._afterImageUpdated(e);\n        }, i.prototype.updateImage = function (t, e) {\n          this.imageManager.updateImage(t, e);\n        }, i.prototype.getImage = function (t) {\n          return this.imageManager.getImage(t);\n        }, i.prototype.removeImage = function (e) {\n          if (!this.getImage(e)) return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));\n          this.imageManager.removeImage(e), this._afterImageUpdated(e);\n        }, i.prototype._afterImageUpdated = function (e) {\n          this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", {\n            dataType: "style"\n          }));\n        }, i.prototype.listImages = function () {\n          return this._checkLoaded(), this.imageManager.listImages();\n        }, i.prototype.addSource = function (e, i, o) {\n          var r = this;\n          if (void 0 === o && (o = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error("There is already a source with this ID");\n          if (!i.type) throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i).join(", ") + ".");\n          if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e, i, null, o))) {\n            this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n            var a = this.sourceCaches[e] = new Dt(e, i, this.dispatcher);\n            a.style = this, a.setEventedParent(this, function () {\n              return {\n                isSourceLoaded: r.loaded(),\n                source: a.serialize(),\n                sourceId: e\n              };\n            }), a.onAdd(this.map), this._changed = !0;\n          }\n        }, i.prototype.removeSource = function (e) {\n          if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID");\n          for (var i in this._layers) if (this._layers[i].source === e) return this.fire(new t.ErrorEvent(new Error(\'Source "\' + e + \'" cannot be removed while layer "\' + i + \'" is using it.\')));\n          var o = this.sourceCaches[e];\n          delete this.sourceCaches[e], delete this._updatedSources[e], o.fire(new t.Event("data", {\n            sourceDataType: "metadata",\n            dataType: "source",\n            sourceId: e\n          })), o.setEventedParent(null), o.clearTiles(), o.onRemove && o.onRemove(this.map), this._changed = !0;\n        }, i.prototype.setGeoJSONSourceData = function (t, e) {\n          this._checkLoaded(), this.sourceCaches[t].getSource().setData(e), this._changed = !0;\n        }, i.prototype.getSource = function (t) {\n          return this.sourceCaches[t] && this.sourceCaches[t].getSource();\n        }, i.prototype.addLayer = function (e, i, o) {\n          void 0 === o && (o = {}), this._checkLoaded();\n          var r = e.id;\n          if (this.getLayer(r)) this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + r + \'" already exists on this map\')));else {\n            var a;\n            if ("custom" === e.type) {\n              if (Ue(this, t.validateCustomStyleLayer(e))) return;\n              a = t.createStyleLayer(e);\n            } else {\n              if ("object" == typeof e.source && (this.addSource(r, e.source), e = t.clone$1(e), e = t.extend(e, {\n                source: r\n              })), this._validate(t.validateStyle.layer, "layers." + r, e, {\n                arrayIndex: -1\n              }, o)) return;\n              a = t.createStyleLayer(e), this._validateLayer(a), a.setEventedParent(this, {\n                layer: {\n                  id: r\n                }\n              }), this._serializedLayers[a.id] = a.serialize();\n            }\n            var n = i ? this._order.indexOf(i) : this._order.length;\n            if (i && -1 === n) this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + i + \'" does not exist on this map.\')));else {\n              if (this._order.splice(n, 0, r), this._layerOrderChanged = !0, this._layers[r] = a, this._removedLayers[r] && a.source && "custom" !== a.type) {\n                var s = this._removedLayers[r];\n                delete this._removedLayers[r], s.type !== a.type ? this._updatedSources[a.source] = "clear" : (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause());\n              }\n              this._updateLayer(a), a.onAdd && a.onAdd(this.map);\n            }\n          }\n        }, i.prototype.moveLayer = function (e, i) {\n          if (this._checkLoaded(), this._changed = !0, this._layers[e]) {\n            if (e !== i) {\n              var o = this._order.indexOf(e);\n              this._order.splice(o, 1);\n              var r = i ? this._order.indexOf(i) : this._order.length;\n              i && -1 === r ? this.fire(new t.ErrorEvent(new Error(\'Layer with id "\' + i + \'" does not exist on this map.\'))) : (this._order.splice(r, 0, e), this._layerOrderChanged = !0);\n            }\n          } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be moved.")));\n        }, i.prototype.removeLayer = function (e) {\n          this._checkLoaded();\n          var i = this._layers[e];\n          if (i) {\n            i.setEventedParent(null);\n            var o = this._order.indexOf(e);\n            this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map);\n          } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be removed.")));\n        }, i.prototype.getLayer = function (t) {\n          return this._layers[t];\n        }, i.prototype.hasLayer = function (t) {\n          return t in this._layers;\n        }, i.prototype.setLayerZoomRange = function (e, i, o) {\n          this._checkLoaded();\n          var r = this.getLayer(e);\n          r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot have zoom extent.")));\n        }, i.prototype.setFilter = function (e, i, o) {\n          void 0 === o && (o = {}), this._checkLoaded();\n          var r = this.getLayer(e);\n          if (r) {\n            if (!t.deepEqual(r.filter, i)) return null == i ? (r.filter = void 0, void this._updateLayer(r)) : void (this._validate(t.validateStyle.filter, "layers." + r.id + ".filter", i, null, o) || (r.filter = t.clone$1(i), this._updateLayer(r)));\n          } else this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be filtered.")));\n        }, i.prototype.getFilter = function (e) {\n          return t.clone$1(this.getLayer(e).filter);\n        }, i.prototype.setLayoutProperty = function (e, i, o, r) {\n          void 0 === r && (r = {}), this._checkLoaded();\n          var a = this.getLayer(e);\n          a ? t.deepEqual(a.getLayoutProperty(i), o) || (a.setLayoutProperty(i, o, r), this._updateLayer(a)) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be styled.")));\n        }, i.prototype.getLayoutProperty = function (e, i) {\n          var o = this.getLayer(e);\n          if (o) return o.getLayoutProperty(i);\n          this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style.")));\n        }, i.prototype.setPaintProperty = function (e, i, o, r) {\n          void 0 === r && (r = {}), this._checkLoaded();\n          var a = this.getLayer(e);\n          a ? t.deepEqual(a.getPaintProperty(i), o) || (a.setPaintProperty(i, o, r) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error("The layer \'" + e + "\' does not exist in the map\'s style and cannot be styled.")));\n        }, i.prototype.getPaintProperty = function (t, e) {\n          return this.getLayer(t).getPaintProperty(e);\n        }, i.prototype.setFeatureState = function (e, i) {\n          this._checkLoaded();\n          var o = e.source,\n            r = e.sourceLayer,\n            a = this.sourceCaches[o];\n          if (void 0 !== a) {\n            var n = a.getSource().type;\n            "geojson" === n && r ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n || r ? (void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a.setFeatureState(r, e.id, i)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n          } else this.fire(new t.ErrorEvent(new Error("The source \'" + o + "\' does not exist in the map\'s style.")));\n        }, i.prototype.removeFeatureState = function (e, i) {\n          this._checkLoaded();\n          var o = e.source,\n            r = this.sourceCaches[o];\n          if (void 0 !== r) {\n            var a = r.getSource().type,\n              n = "vector" === a ? e.sourceLayer : void 0;\n            "vector" !== a || n ? i && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : r.removeFeatureState(n, e.id, i) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n          } else this.fire(new t.ErrorEvent(new Error("The source \'" + o + "\' does not exist in the map\'s style.")));\n        }, i.prototype.getFeatureState = function (e) {\n          this._checkLoaded();\n          var i = e.source,\n            o = e.sourceLayer,\n            r = this.sourceCaches[i];\n          if (void 0 !== r) {\n            if ("vector" !== r.getSource().type || o) return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r.getFeatureState(o, e.id);\n            this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));\n          } else this.fire(new t.ErrorEvent(new Error("The source \'" + i + "\' does not exist in the map\'s style.")));\n        }, i.prototype.getTransition = function () {\n          return t.extend({\n            duration: 300,\n            delay: 0\n          }, this.stylesheet && this.stylesheet.transition);\n        }, i.prototype.serialize = function () {\n          return t.filterObject({\n            version: this.stylesheet.version,\n            name: this.stylesheet.name,\n            metadata: this.stylesheet.metadata,\n            light: this.stylesheet.light,\n            center: this.stylesheet.center,\n            zoom: this.stylesheet.zoom,\n            bearing: this.stylesheet.bearing,\n            pitch: this.stylesheet.pitch,\n            sprite: this.stylesheet.sprite,\n            glyphs: this.stylesheet.glyphs,\n            transition: this.stylesheet.transition,\n            sources: t.mapObject(this.sourceCaches, function (t) {\n              return t.serialize();\n            }),\n            layers: this._serializeLayers(this._order)\n          }, function (t) {\n            return void 0 !== t;\n          });\n        }, i.prototype._updateLayer = function (t) {\n          this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && "raster" !== this.sourceCaches[t.source].getSource().type && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._changed = !0;\n        }, i.prototype._flattenAndSortRenderedFeatures = function (t) {\n          for (var e = this, i = function (t) {\n              return "fill-extrusion" === e._layers[t].type;\n            }, o = {}, r = [], a = this._order.length - 1; a >= 0; a--) {\n            var n = this._order[a];\n            if (i(n)) {\n              o[n] = a;\n              for (var s = 0, l = t; s < l.length; s += 1) {\n                var c = l[s][n];\n                if (c) for (var u = 0, h = c; u < h.length; u += 1) r.push(h[u]);\n              }\n            }\n          }\n          r.sort(function (t, e) {\n            return e.intersectionZ - t.intersectionZ;\n          });\n          for (var p = [], d = this._order.length - 1; d >= 0; d--) {\n            var _ = this._order[d];\n            if (i(_)) for (var f = r.length - 1; f >= 0; f--) {\n              var m = r[f].feature;\n              if (o[m.layer.id] < d) break;\n              p.push(m), r.pop();\n            } else for (var g = 0, v = t; g < v.length; g += 1) {\n              var y = v[g][_];\n              if (y) for (var x = 0, b = y; x < b.length; x += 1) p.push(b[x].feature);\n            }\n          }\n          return p;\n        }, i.prototype.queryRenderedFeatures = function (e, i, o) {\n          i && i.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i.filter, null, i);\n          var r = {};\n          if (i && i.layers) {\n            if (!Array.isArray(i.layers)) return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];\n            for (var a = 0, n = i.layers; a < n.length; a += 1) {\n              var s = n[a],\n                l = this._layers[s];\n              if (!l) return this.fire(new t.ErrorEvent(new Error("The layer \'" + s + "\' does not exist in the map\'s style and cannot be queried for features."))), [];\n              r[l.source] = !0;\n            }\n          }\n          var c = [];\n          for (var u in i.availableImages = this._availableImages, this.sourceCaches) i.layers && !r[u] || c.push(O(this.sourceCaches[u], this._layers, this._serializedLayers, e, i, o));\n          return this.placement && c.push(function (t, e, i, o, r, a, n) {\n            for (var s = {}, l = a.queryRenderedSymbols(o), c = [], u = 0, h = Object.keys(l).map(Number); u < h.length; u += 1) c.push(n[h[u]]);\n            c.sort(F);\n            for (var p = function () {\n                var i = _[d],\n                  o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, t);\n                for (var a in o) {\n                  var n = s[a] = s[a] || [],\n                    c = o[a];\n                  c.sort(function (t, e) {\n                    var o = i.featureSortOrder;\n                    if (o) {\n                      var r = o.indexOf(t.featureIndex);\n                      return o.indexOf(e.featureIndex) - r;\n                    }\n                    return e.featureIndex - t.featureIndex;\n                  });\n                  for (var u = 0, h = c; u < h.length; u += 1) n.push(h[u]);\n                }\n              }, d = 0, _ = c; d < _.length; d += 1) p();\n            var f = function (e) {\n              s[e].forEach(function (o) {\n                var r = o.feature,\n                  a = i[t[e].source].getFeatureState(r.layer["source-layer"], r.id);\n                r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = a;\n              });\n            };\n            for (var m in s) f(m);\n            return s;\n          }(this._layers, this._serializedLayers, this.sourceCaches, e, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c);\n        }, i.prototype.querySourceFeatures = function (e, i) {\n          i && i.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i.filter, null, i);\n          var o = this.sourceCaches[e];\n          return o ? function (t, e) {\n            for (var i = t.getRenderableIds().map(function (e) {\n                return t.getTileByID(e);\n              }), o = [], r = {}, a = 0; a < i.length; a++) {\n              var n = i[a],\n                s = n.tileID.canonical.key;\n              r[s] || (r[s] = !0, n.querySourceFeatures(o, e));\n            }\n            return o;\n          }(o, i) : [];\n        }, i.prototype.addSourceType = function (t, e, o) {\n          return i.getSourceType(t) ? o(new Error(\'A source type called "\' + t + \'" already exists.\')) : (i.setSourceType(t, e), e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {\n            name: t,\n            url: e.workerSourceURL\n          }, o) : o(null, null));\n        }, i.prototype.getLight = function () {\n          return this.light.getLight();\n        }, i.prototype.setLight = function (e, i) {\n          void 0 === i && (i = {}), this._checkLoaded();\n          var o = this.light.getLight(),\n            r = !1;\n          for (var a in e) if (!t.deepEqual(e[a], o[a])) {\n            r = !0;\n            break;\n          }\n          if (r) {\n            var n = {\n              now: t.browser.now(),\n              transition: t.extend({\n                duration: 300,\n                delay: 0\n              }, this.stylesheet.transition)\n            };\n            this.light.setLight(e, i), this.light.updateTransitions(n);\n          }\n        }, i.prototype._validate = function (e, i, o, r, a) {\n          return void 0 === a && (a = {}), (!a || !1 !== a.validate) && Ue(this, e.call(t.validateStyle, t.extend({\n            key: i,\n            style: this.serialize(),\n            value: o,\n            styleSpec: t.styleSpec\n          }, r)));\n        }, i.prototype._remove = function () {\n          for (var e in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers) this._layers[e].setEventedParent(null);\n          for (var i in this.sourceCaches) this.sourceCaches[i].clearTiles(), this.sourceCaches[i].setEventedParent(null);\n          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();\n        }, i.prototype._clearSource = function (t) {\n          this.sourceCaches[t].clearTiles();\n        }, i.prototype._reloadSource = function (t) {\n          this.sourceCaches[t].resume(), this.sourceCaches[t].reload();\n        }, i.prototype._updateSources = function (t) {\n          for (var e in this.sourceCaches) this.sourceCaches[e].update(t);\n        }, i.prototype._generateCollisionBoxes = function () {\n          for (var t in this.sourceCaches) this._reloadSource(t);\n        }, i.prototype._updatePlacement = function (e, i, o, r, a) {\n          void 0 === a && (a = !1);\n          for (var n = !1, s = !1, l = {}, c = 0, u = this._order; c < u.length; c += 1) {\n            var h = this._layers[u[c]];\n            if ("symbol" === h.type) {\n              if (!l[h.source]) {\n                var p = this.sourceCaches[h.source];\n                l[h.source] = p.getRenderableIds(!0).map(function (t) {\n                  return p.getTileByID(t);\n                }).sort(function (t, e) {\n                  return e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1);\n                });\n              }\n              var d = this.crossTileSymbolIndex.addLayer(h, l[h.source], e.center.lng);\n              n = n || d;\n            }\n          }\n          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || 0 === o) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e.zoom)) && (this.pauseablePlacement = new Le(e, this._order, a, i, o, r, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s = !0), n && this.pauseablePlacement.placement.setStale()), s || n) for (var _ = 0, f = this._order; _ < f.length; _ += 1) {\n            var m = this._layers[f[_]];\n            "symbol" === m.type && this.placement.updateLayerOpacities(m, l[m.source]);\n          }\n          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());\n        }, i.prototype._releaseSymbolFadeTiles = function () {\n          for (var t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();\n        }, i.prototype.getImages = function (t, e, i) {\n          this.imageManager.getImages(e.icons, i), this._updateTilesForChangedImages();\n          var o = this.sourceCaches[e.source];\n          o && o.setDependencies(e.tileID.key, e.type, e.icons);\n        }, i.prototype.getGlyphs = function (t, e, i) {\n          this.glyphManager.getGlyphs(e.stacks, i);\n        }, i.prototype.getResource = function (e, i, o) {\n          return t.makeRequest(i, o);\n        }, i;\n      }(t.Evented);\n    je.getSourceType = function (t) {\n      return k[t];\n    }, je.setSourceType = function (t, e) {\n      k[t] = e;\n    }, je.registerForPluginStateChange = t.registerForPluginStateChange;\n    var Ve = t.createLayout([{\n        name: "a_pos",\n        type: "Int16",\n        components: 2\n      }]),\n      Ge = gi("#ifdef GL_ES\\nprecision mediump float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif", "#ifdef GL_ES\\nprecision highp float;\\n#else\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n#if !defined(highp)\\n#define highp\\n#endif\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"),\n      We = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),\n      Xe = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),\n      He = gi("varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),\n      Ke = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),\n      Ye = gi("uniform highp float u_intensity;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"),\n      Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(0.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),\n      Qe = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),\n      $e = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),\n      ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"),\n      ei = gi("#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_FragColor=color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);}"),\n      ii = gi("varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),\n      oi = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"),\n      ri = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),\n      ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),\n      ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\\n? a_pos\\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),\n      si = gi("#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),\n      li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\\n#define PI 3.141592653589793\\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),\n      ci = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),\n      ui = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"),\n      hi = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern_from\\n#pragma mapbox: define lowp vec4 pattern_to\\n#pragma mapbox: define lowp float pixel_ratio_from\\n#pragma mapbox: define lowp float pixel_ratio_to\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern_from\\n#pragma mapbox: initialize mediump vec4 pattern_to\\n#pragma mapbox: initialize lowp float pixel_ratio_from\\n#pragma mapbox: initialize lowp float pixel_ratio_to\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),\n      pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "\\n#define scale 0.015873016\\n#define LINE_DISTANCE_SCALE 2.0\\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"),\n      di = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),\n      _i = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"),\n      fi = gi("#define SDF_PX 8.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),\n      mi = gi("#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");\n    function gi(t, e) {\n      var i = /#pragma mapbox: ([\\w]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n        o = e.match(/attribute ([\\w]+) ([\\w]+)/g),\n        r = t.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n        a = e.match(/uniform ([\\w]+) ([\\w]+)([\\s]*)([\\w]*)/g),\n        n = a ? a.concat(r) : r,\n        s = {};\n      return {\n        fragmentSource: t = t.replace(i, function (t, e, i, o, r) {\n          return s[r] = !0, "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nvarying " + i + " " + o + " " + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "\\n#ifdef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n";\n        }),\n        vertexSource: e = e.replace(i, function (t, e, i, o, r) {\n          var a = "float" === o ? "vec2" : "vec4",\n            n = r.match(/color/) ? "color" : a;\n          return s[r] ? "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nuniform lowp float u_" + r + "_t;\\nattribute " + i + " " + a + " a_" + r + ";\\nvarying " + i + " " + o + " " + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "vec4" === n ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + r + " = a_" + r + ";\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + r + " = unpack_mix_" + n + "(a_" + r + ", u_" + r + "_t);\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "define" === e ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\nuniform lowp float u_" + r + "_t;\\nattribute " + i + " " + a + " a_" + r + ";\\n#else\\nuniform " + i + " " + o + " u_" + r + ";\\n#endif\\n" : "vec4" === n ? "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = a_" + r + ";\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n" : "\\n#ifndef HAS_UNIFORM_u_" + r + "\\n    " + i + " " + o + " " + r + " = unpack_mix_" + n + "(a_" + r + ", u_" + r + "_t);\\n#else\\n    " + i + " " + o + " " + r + " = u_" + r + ";\\n#endif\\n";\n        }),\n        staticAttributes: o,\n        staticUniforms: n\n      };\n    }\n    var vi = Object.freeze({\n        __proto__: null,\n        prelude: Ge,\n        background: We,\n        backgroundPattern: Xe,\n        circle: He,\n        clippingMask: Ke,\n        heatmap: Ye,\n        heatmapTexture: Je,\n        collisionBox: Qe,\n        collisionCircle: $e,\n        debug: ti,\n        fill: ei,\n        fillOutline: ii,\n        fillOutlinePattern: oi,\n        fillPattern: ri,\n        fillExtrusion: ai,\n        fillExtrusionPattern: ni,\n        hillshadePrepare: si,\n        hillshade: li,\n        line: ci,\n        lineGradient: ui,\n        linePattern: hi,\n        lineSDF: pi,\n        raster: di,\n        symbolIcon: _i,\n        symbolSDF: fi,\n        symbolTextAndIcon: mi\n      }),\n      yi = function () {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;\n      };\n    function xi(t) {\n      for (var e = [], i = 0; i < t.length; i++) if (null !== t[i]) {\n        var o = t[i].split(" ");\n        e.push(o.pop());\n      }\n      return e;\n    }\n    yi.prototype.bind = function (t, e, i, o, r, a, n, s) {\n      this.context = t;\n      for (var l = this.boundPaintVertexBuffers.length !== o.length, c = 0; !l && c < o.length; c++) this.boundPaintVertexBuffers[c] !== o[c] && (l = !0);\n      t.extVertexArrayObject && this.vao && this.boundProgram === e && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === r && this.boundVertexOffset === a && this.boundDynamicVertexBuffer === n && this.boundDynamicVertexBuffer2 === s ? (t.bindVertexArrayOES.set(this.vao), n && n.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) : this.freshBind(e, i, o, r, a, n, s);\n    }, yi.prototype.freshBind = function (t, e, i, o, r, a, n) {\n      var s,\n        l = t.numAttributes,\n        c = this.context,\n        u = c.gl;\n      if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = t, this.boundLayoutVertexBuffer = e, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = a, this.boundDynamicVertexBuffer2 = n;else {\n        s = c.currentNumAttributes || 0;\n        for (var h = l; h < s; h++) u.disableVertexAttribArray(h);\n      }\n      e.enableAttributes(u, t);\n      for (var p = 0, d = i; p < d.length; p += 1) d[p].enableAttributes(u, t);\n      a && a.enableAttributes(u, t), n && n.enableAttributes(u, t), e.bind(), e.setVertexAttribPointers(u, t, r);\n      for (var _ = 0, f = i; _ < f.length; _ += 1) {\n        var m = f[_];\n        m.bind(), m.setVertexAttribPointers(u, t, r);\n      }\n      a && (a.bind(), a.setVertexAttribPointers(u, t, r)), o && o.bind(), n && (n.bind(), n.setVertexAttribPointers(u, t, r)), c.currentNumAttributes = l;\n    }, yi.prototype.destroy = function () {\n      this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);\n    };\n    var bi = function (t, e, i, o, r, a) {\n      var n = t.gl;\n      this.program = n.createProgram();\n      for (var s = xi(i.staticAttributes), l = o ? o.getBinderAttributes() : [], c = s.concat(l), u = i.staticUniforms ? xi(i.staticUniforms) : [], h = o ? o.getBinderUniforms() : [], p = [], d = 0, _ = u.concat(h); d < _.length; d += 1) {\n        var f = _[d];\n        p.indexOf(f) < 0 && p.push(f);\n      }\n      var m = o ? o.defines() : [];\n      a && m.push("#define OVERDRAW_INSPECTOR;");\n      var g = m.concat(Ge.fragmentSource, i.fragmentSource).join("\\n"),\n        v = m.concat(Ge.vertexSource, i.vertexSource).join("\\n"),\n        y = n.createShader(n.FRAGMENT_SHADER);\n      if (n.isContextLost()) this.failedToCreate = !0;else {\n        n.shaderSource(y, g), n.compileShader(y), n.attachShader(this.program, y);\n        var x = n.createShader(n.VERTEX_SHADER);\n        if (n.isContextLost()) this.failedToCreate = !0;else {\n          n.shaderSource(x, v), n.compileShader(x), n.attachShader(this.program, x), this.attributes = {};\n          var b = {};\n          this.numAttributes = c.length;\n          for (var w = 0; w < this.numAttributes; w++) c[w] && (n.bindAttribLocation(this.program, w, c[w]), this.attributes[c[w]] = w);\n          n.linkProgram(this.program), n.deleteShader(x), n.deleteShader(y);\n          for (var T = 0; T < p.length; T++) {\n            var E = p[T];\n            if (E && !b[E]) {\n              var I = n.getUniformLocation(this.program, E);\n              I && (b[E] = I);\n            }\n          }\n          this.fixedUniforms = r(t, b), this.binderUniforms = o ? o.getUniforms(t, b) : [];\n        }\n      }\n    };\n    function wi(t, e, i) {\n      var o = 1 / pe(i, 1, e.transform.tileZoom),\n        r = Math.pow(2, i.tileID.overscaledZ),\n        a = i.tileSize * Math.pow(2, e.transform.tileZoom) / r,\n        n = a * (i.tileID.canonical.x + i.tileID.wrap * r),\n        s = a * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture.size,\n        u_scale: [o, t.fromScale, t.toScale],\n        u_fade: t.t,\n        u_pixel_coord_upper: [n >> 16, s >> 16],\n        u_pixel_coord_lower: [65535 & n, 65535 & s]\n      };\n    }\n    bi.prototype.draw = function (t, e, i, o, r, a, n, s, l, c, u, h, p, d, _, f) {\n      var m,\n        g = t.gl;\n      if (!this.failedToCreate) {\n        for (var v in t.program.set(this.program), t.setDepthMode(i), t.setStencilMode(o), t.setColorMode(r), t.setCullFace(a), this.fixedUniforms) this.fixedUniforms[v].set(n[v]);\n        d && d.setUniforms(t, this.binderUniforms, h, {\n          zoom: p\n        });\n        for (var y = (m = {}, m[g.LINES] = 2, m[g.TRIANGLES] = 3, m[g.LINE_STRIP] = 1, m)[e], x = 0, b = u.get(); x < b.length; x += 1) {\n          var w = b[x],\n            T = w.vaos || (w.vaos = {});\n          (T[s] || (T[s] = new yi())).bind(t, this, l, d ? d.getPaintVertexBuffers() : [], c, w.vertexOffset, _, f), g.drawElements(e, w.primitiveLength * y, g.UNSIGNED_SHORT, w.primitiveOffset * y * 2);\n        }\n      }\n    };\n    var Ti = function (e, i, o, r) {\n        var a = i.style.light,\n          n = a.properties.get("position"),\n          s = [n.x, n.y, n.z],\n          l = t.create$1();\n        "viewport" === a.properties.get("anchor") && t.fromRotation(l, -i.transform.angle), t.transformMat3(s, s, l);\n        var c = a.properties.get("color");\n        return {\n          u_matrix: e,\n          u_lightpos: s,\n          u_lightintensity: a.properties.get("intensity"),\n          u_lightcolor: [c.r, c.g, c.b],\n          u_vertical_gradient: +o,\n          u_opacity: r\n        };\n      },\n      Ei = function (e, i, o, r, a, n, s) {\n        return t.extend(Ti(e, i, o, r), wi(n, i, s), {\n          u_height_factor: -Math.pow(2, a.overscaledZ) / s.tileSize / 8\n        });\n      },\n      Ii = function (t) {\n        return {\n          u_matrix: t\n        };\n      },\n      Pi = function (e, i, o, r) {\n        return t.extend(Ii(e), wi(o, i, r));\n      },\n      Si = function (t, e) {\n        return {\n          u_matrix: t,\n          u_world: e\n        };\n      },\n      Ci = function (e, i, o, r, a) {\n        return t.extend(Pi(e, i, o, r), {\n          u_world: a\n        });\n      },\n      zi = function (e, i, o, r) {\n        var a,\n          n,\n          s = e.transform;\n        if ("map" === r.paint.get("circle-pitch-alignment")) {\n          var l = pe(o, 1, s.zoom);\n          a = !0, n = [l, l];\n        } else a = !1, n = s.pixelsToGLUnits;\n        return {\n          u_camera_to_center_distance: s.cameraToCenterDistance,\n          u_scale_with_map: +("map" === r.paint.get("circle-pitch-scale")),\n          u_matrix: e.translatePosMatrix(i.posMatrix, o, r.paint.get("circle-translate"), r.paint.get("circle-translate-anchor")),\n          u_pitch_with_map: +a,\n          u_device_pixel_ratio: t.browser.devicePixelRatio,\n          u_extrude_scale: n\n        };\n      },\n      Di = function (t, e, i) {\n        var o = pe(i, 1, e.zoom),\n          r = Math.pow(2, e.zoom - i.tileID.overscaledZ),\n          a = i.tileID.overscaleFactor();\n        return {\n          u_matrix: t,\n          u_camera_to_center_distance: e.cameraToCenterDistance,\n          u_pixels_to_tile_units: o,\n          u_extrude_scale: [e.pixelsToGLUnits[0] / (o * r), e.pixelsToGLUnits[1] / (o * r)],\n          u_overscale_factor: a\n        };\n      },\n      Ai = function (t, e, i) {\n        return {\n          u_matrix: t,\n          u_inv_matrix: e,\n          u_camera_to_center_distance: i.cameraToCenterDistance,\n          u_viewport_size: [i.width, i.height]\n        };\n      },\n      Mi = function (t, e, i) {\n        return void 0 === i && (i = 1), {\n          u_matrix: t,\n          u_color: e,\n          u_overlay: 0,\n          u_overlay_scale: i\n        };\n      },\n      Li = function (t) {\n        return {\n          u_matrix: t\n        };\n      },\n      Ri = function (t, e, i, o) {\n        return {\n          u_matrix: t,\n          u_extrude_scale: pe(e, 1, i),\n          u_intensity: o\n        };\n      },\n      ki = function (e, i, o) {\n        var r = e.transform;\n        return {\n          u_matrix: Ni(e, i, o),\n          u_ratio: 1 / pe(i, 1, r.zoom),\n          u_device_pixel_ratio: t.browser.devicePixelRatio,\n          u_units_to_pixels: [1 / r.pixelsToGLUnits[0], 1 / r.pixelsToGLUnits[1]]\n        };\n      },\n      Bi = function (e, i, o, r) {\n        return t.extend(ki(e, i, o), {\n          u_image: 0,\n          u_image_height: r\n        });\n      },\n      Oi = function (e, i, o, r) {\n        var a = e.transform,\n          n = Ui(i, a);\n        return {\n          u_matrix: Ni(e, i, o),\n          u_texsize: i.imageAtlasTexture.size,\n          u_ratio: 1 / pe(i, 1, a.zoom),\n          u_device_pixel_ratio: t.browser.devicePixelRatio,\n          u_image: 0,\n          u_scale: [n, r.fromScale, r.toScale],\n          u_fade: r.t,\n          u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]]\n        };\n      },\n      Fi = function (e, i, o, r, a) {\n        var n = e.lineAtlas,\n          s = Ui(i, e.transform),\n          l = "round" === o.layout.get("line-cap"),\n          c = n.getDash(r.from, l),\n          u = n.getDash(r.to, l),\n          h = c.width * a.fromScale,\n          p = u.width * a.toScale;\n        return t.extend(ki(e, i, o), {\n          u_patternscale_a: [s / h, -c.height / 2],\n          u_patternscale_b: [s / p, -u.height / 2],\n          u_sdfgamma: n.width / (256 * Math.min(h, p) * t.browser.devicePixelRatio) / 2,\n          u_image: 0,\n          u_tex_y_a: c.y,\n          u_tex_y_b: u.y,\n          u_mix: a.t\n        });\n      };\n    function Ui(t, e) {\n      return 1 / pe(t, 1, e.tileZoom);\n    }\n    function Ni(t, e, i) {\n      return t.translatePosMatrix(e.tileID.posMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));\n    }\n    var Zi = function (t, e, i, o, r) {\n      return {\n        u_matrix: t,\n        u_tl_parent: e,\n        u_scale_parent: i,\n        u_buffer_scale: 1,\n        u_fade_t: o.mix,\n        u_opacity: o.opacity * r.paint.get("raster-opacity"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: r.paint.get("raster-brightness-min"),\n        u_brightness_high: r.paint.get("raster-brightness-max"),\n        u_saturation_factor: (n = r.paint.get("raster-saturation"), n > 0 ? 1 - 1 / (1.001 - n) : -n),\n        u_contrast_factor: (a = r.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a),\n        u_spin_weights: qi(r.paint.get("raster-hue-rotate"))\n      };\n      var a, n;\n    };\n    function qi(t) {\n      t *= Math.PI / 180;\n      var e = Math.sin(t),\n        i = Math.cos(t);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3];\n    }\n    var ji,\n      Vi = function (t, e, i, o, r, a, n, s, l, c) {\n        var u = r.transform;\n        return {\n          u_is_size_zoom_constant: +("constant" === t || "source" === t),\n          u_is_size_feature_constant: +("constant" === t || "camera" === t),\n          u_size_t: e ? e.uSizeT : 0,\n          u_size: e ? e.uSize : 0,\n          u_camera_to_center_distance: u.cameraToCenterDistance,\n          u_pitch: u.pitch / 360 * 2 * Math.PI,\n          u_rotate_symbol: +i,\n          u_aspect_ratio: u.width / u.height,\n          u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,\n          u_matrix: a,\n          u_label_plane_matrix: n,\n          u_coord_matrix: s,\n          u_is_text: +l,\n          u_pitch_with_map: +o,\n          u_texsize: c,\n          u_texture: 0\n        };\n      },\n      Gi = function (e, i, o, r, a, n, s, l, c, u, h) {\n        var p = a.transform;\n        return t.extend(Vi(e, i, o, r, a, n, s, l, c, u), {\n          u_gamma_scale: r ? Math.cos(p._pitch) * p.cameraToCenterDistance : 1,\n          u_device_pixel_ratio: t.browser.devicePixelRatio,\n          u_is_halo: +h\n        });\n      },\n      Wi = function (e, i, o, r, a, n, s, l, c, u) {\n        return t.extend(Gi(e, i, o, r, a, n, s, l, !0, c, !0), {\n          u_texsize_icon: u,\n          u_texture_icon: 1\n        });\n      },\n      Xi = function (t, e, i) {\n        return {\n          u_matrix: t,\n          u_opacity: e,\n          u_color: i\n        };\n      },\n      Hi = function (e, i, o, r, a, n) {\n        return t.extend(function (t, e, i, o) {\n          var r = i.imageManager.getPattern(t.from.toString()),\n            a = i.imageManager.getPattern(t.to.toString()),\n            n = i.imageManager.getPixelSize(),\n            s = n.width,\n            l = n.height,\n            c = Math.pow(2, o.tileID.overscaledZ),\n            u = o.tileSize * Math.pow(2, i.transform.tileZoom) / c,\n            h = u * (o.tileID.canonical.x + o.tileID.wrap * c),\n            p = u * o.tileID.canonical.y;\n          return {\n            u_image: 0,\n            u_pattern_tl_a: r.tl,\n            u_pattern_br_a: r.br,\n            u_pattern_tl_b: a.tl,\n            u_pattern_br_b: a.br,\n            u_texsize: [s, l],\n            u_mix: e.t,\n            u_pattern_size_a: r.displaySize,\n            u_pattern_size_b: a.displaySize,\n            u_scale_a: e.fromScale,\n            u_scale_b: e.toScale,\n            u_tile_units_to_pixels: 1 / pe(o, 1, i.transform.tileZoom),\n            u_pixel_coord_upper: [h >> 16, p >> 16],\n            u_pixel_coord_lower: [65535 & h, 65535 & p]\n          };\n        }(r, n, o, a), {\n          u_matrix: e,\n          u_opacity: i\n        });\n      },\n      Ki = {\n        fillExtrusion: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n            u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n            u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n            u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n            u_opacity: new t.Uniform1f(e, i.u_opacity)\n          };\n        },\n        fillExtrusionPattern: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_lightpos: new t.Uniform3f(e, i.u_lightpos),\n            u_lightintensity: new t.Uniform1f(e, i.u_lightintensity),\n            u_lightcolor: new t.Uniform3f(e, i.u_lightcolor),\n            u_vertical_gradient: new t.Uniform1f(e, i.u_vertical_gradient),\n            u_height_factor: new t.Uniform1f(e, i.u_height_factor),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n            u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n            u_scale: new t.Uniform3f(e, i.u_scale),\n            u_fade: new t.Uniform1f(e, i.u_fade),\n            u_opacity: new t.Uniform1f(e, i.u_opacity)\n          };\n        },\n        fill: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n          };\n        },\n        fillPattern: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n            u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n            u_scale: new t.Uniform3f(e, i.u_scale),\n            u_fade: new t.Uniform1f(e, i.u_fade)\n          };\n        },\n        fillOutline: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_world: new t.Uniform2f(e, i.u_world)\n          };\n        },\n        fillOutlinePattern: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_world: new t.Uniform2f(e, i.u_world),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n            u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n            u_scale: new t.Uniform3f(e, i.u_scale),\n            u_fade: new t.Uniform1f(e, i.u_fade)\n          };\n        },\n        circle: function (e, i) {\n          return {\n            u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n            u_scale_with_map: new t.Uniform1i(e, i.u_scale_with_map),\n            u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n            u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n          };\n        },\n        collisionBox: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n            u_pixels_to_tile_units: new t.Uniform1f(e, i.u_pixels_to_tile_units),\n            u_extrude_scale: new t.Uniform2f(e, i.u_extrude_scale),\n            u_overscale_factor: new t.Uniform1f(e, i.u_overscale_factor)\n          };\n        },\n        collisionCircle: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_inv_matrix: new t.UniformMatrix4f(e, i.u_inv_matrix),\n            u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n            u_viewport_size: new t.Uniform2f(e, i.u_viewport_size)\n          };\n        },\n        debug: function (e, i) {\n          return {\n            u_color: new t.UniformColor(e, i.u_color),\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_overlay: new t.Uniform1i(e, i.u_overlay),\n            u_overlay_scale: new t.Uniform1f(e, i.u_overlay_scale)\n          };\n        },\n        clippingMask: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n          };\n        },\n        heatmap: function (e, i) {\n          return {\n            u_extrude_scale: new t.Uniform1f(e, i.u_extrude_scale),\n            u_intensity: new t.Uniform1f(e, i.u_intensity),\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix)\n          };\n        },\n        heatmapTexture: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_world: new t.Uniform2f(e, i.u_world),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_color_ramp: new t.Uniform1i(e, i.u_color_ramp),\n            u_opacity: new t.Uniform1f(e, i.u_opacity)\n          };\n        },\n        hillshade: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_latrange: new t.Uniform2f(e, i.u_latrange),\n            u_light: new t.Uniform2f(e, i.u_light),\n            u_shadow: new t.UniformColor(e, i.u_shadow),\n            u_highlight: new t.UniformColor(e, i.u_highlight),\n            u_accent: new t.UniformColor(e, i.u_accent)\n          };\n        },\n        hillshadePrepare: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_dimension: new t.Uniform2f(e, i.u_dimension),\n            u_zoom: new t.Uniform1f(e, i.u_zoom),\n            u_unpack: new t.Uniform4f(e, i.u_unpack)\n          };\n        },\n        line: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_ratio: new t.Uniform1f(e, i.u_ratio),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels)\n          };\n        },\n        lineGradient: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_ratio: new t.Uniform1f(e, i.u_ratio),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_image_height: new t.Uniform1f(e, i.u_image_height)\n          };\n        },\n        linePattern: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_ratio: new t.Uniform1f(e, i.u_ratio),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n            u_scale: new t.Uniform3f(e, i.u_scale),\n            u_fade: new t.Uniform1f(e, i.u_fade)\n          };\n        },\n        lineSDF: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_ratio: new t.Uniform1f(e, i.u_ratio),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_units_to_pixels: new t.Uniform2f(e, i.u_units_to_pixels),\n            u_patternscale_a: new t.Uniform2f(e, i.u_patternscale_a),\n            u_patternscale_b: new t.Uniform2f(e, i.u_patternscale_b),\n            u_sdfgamma: new t.Uniform1f(e, i.u_sdfgamma),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_tex_y_a: new t.Uniform1f(e, i.u_tex_y_a),\n            u_tex_y_b: new t.Uniform1f(e, i.u_tex_y_b),\n            u_mix: new t.Uniform1f(e, i.u_mix)\n          };\n        },\n        raster: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_tl_parent: new t.Uniform2f(e, i.u_tl_parent),\n            u_scale_parent: new t.Uniform1f(e, i.u_scale_parent),\n            u_buffer_scale: new t.Uniform1f(e, i.u_buffer_scale),\n            u_fade_t: new t.Uniform1f(e, i.u_fade_t),\n            u_opacity: new t.Uniform1f(e, i.u_opacity),\n            u_image0: new t.Uniform1i(e, i.u_image0),\n            u_image1: new t.Uniform1i(e, i.u_image1),\n            u_brightness_low: new t.Uniform1f(e, i.u_brightness_low),\n            u_brightness_high: new t.Uniform1f(e, i.u_brightness_high),\n            u_saturation_factor: new t.Uniform1f(e, i.u_saturation_factor),\n            u_contrast_factor: new t.Uniform1f(e, i.u_contrast_factor),\n            u_spin_weights: new t.Uniform3f(e, i.u_spin_weights)\n          };\n        },\n        symbolIcon: function (e, i) {\n          return {\n            u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n            u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n            u_size_t: new t.Uniform1f(e, i.u_size_t),\n            u_size: new t.Uniform1f(e, i.u_size),\n            u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n            u_pitch: new t.Uniform1f(e, i.u_pitch),\n            u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n            u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n            u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n            u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n            u_is_text: new t.Uniform1i(e, i.u_is_text),\n            u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_texture: new t.Uniform1i(e, i.u_texture)\n          };\n        },\n        symbolSDF: function (e, i) {\n          return {\n            u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n            u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n            u_size_t: new t.Uniform1f(e, i.u_size_t),\n            u_size: new t.Uniform1f(e, i.u_size),\n            u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n            u_pitch: new t.Uniform1f(e, i.u_pitch),\n            u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n            u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n            u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n            u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n            u_is_text: new t.Uniform1i(e, i.u_is_text),\n            u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_texture: new t.Uniform1i(e, i.u_texture),\n            u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n          };\n        },\n        symbolTextAndIcon: function (e, i) {\n          return {\n            u_is_size_zoom_constant: new t.Uniform1i(e, i.u_is_size_zoom_constant),\n            u_is_size_feature_constant: new t.Uniform1i(e, i.u_is_size_feature_constant),\n            u_size_t: new t.Uniform1f(e, i.u_size_t),\n            u_size: new t.Uniform1f(e, i.u_size),\n            u_camera_to_center_distance: new t.Uniform1f(e, i.u_camera_to_center_distance),\n            u_pitch: new t.Uniform1f(e, i.u_pitch),\n            u_rotate_symbol: new t.Uniform1i(e, i.u_rotate_symbol),\n            u_aspect_ratio: new t.Uniform1f(e, i.u_aspect_ratio),\n            u_fade_change: new t.Uniform1f(e, i.u_fade_change),\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_label_plane_matrix: new t.UniformMatrix4f(e, i.u_label_plane_matrix),\n            u_coord_matrix: new t.UniformMatrix4f(e, i.u_coord_matrix),\n            u_is_text: new t.Uniform1i(e, i.u_is_text),\n            u_pitch_with_map: new t.Uniform1i(e, i.u_pitch_with_map),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_texsize_icon: new t.Uniform2f(e, i.u_texsize_icon),\n            u_texture: new t.Uniform1i(e, i.u_texture),\n            u_texture_icon: new t.Uniform1i(e, i.u_texture_icon),\n            u_gamma_scale: new t.Uniform1f(e, i.u_gamma_scale),\n            u_device_pixel_ratio: new t.Uniform1f(e, i.u_device_pixel_ratio),\n            u_is_halo: new t.Uniform1i(e, i.u_is_halo)\n          };\n        },\n        background: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_opacity: new t.Uniform1f(e, i.u_opacity),\n            u_color: new t.UniformColor(e, i.u_color)\n          };\n        },\n        backgroundPattern: function (e, i) {\n          return {\n            u_matrix: new t.UniformMatrix4f(e, i.u_matrix),\n            u_opacity: new t.Uniform1f(e, i.u_opacity),\n            u_image: new t.Uniform1i(e, i.u_image),\n            u_pattern_tl_a: new t.Uniform2f(e, i.u_pattern_tl_a),\n            u_pattern_br_a: new t.Uniform2f(e, i.u_pattern_br_a),\n            u_pattern_tl_b: new t.Uniform2f(e, i.u_pattern_tl_b),\n            u_pattern_br_b: new t.Uniform2f(e, i.u_pattern_br_b),\n            u_texsize: new t.Uniform2f(e, i.u_texsize),\n            u_mix: new t.Uniform1f(e, i.u_mix),\n            u_pattern_size_a: new t.Uniform2f(e, i.u_pattern_size_a),\n            u_pattern_size_b: new t.Uniform2f(e, i.u_pattern_size_b),\n            u_scale_a: new t.Uniform1f(e, i.u_scale_a),\n            u_scale_b: new t.Uniform1f(e, i.u_scale_b),\n            u_pixel_coord_upper: new t.Uniform2f(e, i.u_pixel_coord_upper),\n            u_pixel_coord_lower: new t.Uniform2f(e, i.u_pixel_coord_lower),\n            u_tile_units_to_pixels: new t.Uniform1f(e, i.u_tile_units_to_pixels)\n          };\n        }\n      };\n    function Yi(e, i, o, r, a, n, s) {\n      for (var l = e.context, c = l.gl, u = e.useProgram("collisionBox"), h = [], p = 0, d = 0, _ = 0; _ < r.length; _++) {\n        var f = r[_],\n          m = i.getTile(f),\n          g = m.getBucket(o);\n        if (g) {\n          var v = f.posMatrix;\n          0 === a[0] && 0 === a[1] || (v = e.translatePosMatrix(f.posMatrix, m, a, n));\n          var y = s ? g.textCollisionBox : g.iconCollisionBox,\n            x = g.collisionCircleArray;\n          if (x.length > 0) {\n            var b = t.create(),\n              w = v;\n            t.mul(b, g.placementInvProjMatrix, e.transform.glCoordMatrix), t.mul(b, b, g.placementViewportMatrix), h.push({\n              circleArray: x,\n              circleOffset: d,\n              transform: w,\n              invTransform: b\n            }), d = p += x.length / 4;\n          }\n          y && u.draw(l, c.LINES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, Di(v, e.transform, m), o.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, null, e.transform.zoom, null, null, y.collisionVertexBuffer);\n        }\n      }\n      if (s && h.length) {\n        var T = e.useProgram("collisionCircle"),\n          E = new t.StructArrayLayout2f1f2i16();\n        E.resize(4 * p), E._trim();\n        for (var I = 0, P = 0, S = h; P < S.length; P += 1) for (var C = S[P], z = 0; z < C.circleArray.length / 4; z++) {\n          var D = 4 * z,\n            A = C.circleArray[D + 0],\n            M = C.circleArray[D + 1],\n            L = C.circleArray[D + 2],\n            R = C.circleArray[D + 3];\n          E.emplace(I++, A, M, L, R, 0), E.emplace(I++, A, M, L, R, 1), E.emplace(I++, A, M, L, R, 2), E.emplace(I++, A, M, L, R, 3);\n        }\n        (!ji || ji.length < 2 * p) && (ji = function (e) {\n          var i = 2 * e,\n            o = new t.StructArrayLayout3ui6();\n          o.resize(i), o._trim();\n          for (var r = 0; r < i; r++) {\n            var a = 6 * r;\n            o.uint16[a + 0] = 4 * r + 0, o.uint16[a + 1] = 4 * r + 1, o.uint16[a + 2] = 4 * r + 2, o.uint16[a + 3] = 4 * r + 2, o.uint16[a + 4] = 4 * r + 3, o.uint16[a + 5] = 4 * r + 0;\n          }\n          return o;\n        }(p));\n        for (var k = l.createIndexBuffer(ji, !0), B = l.createVertexBuffer(E, t.collisionCircleLayout.members, !0), O = 0, F = h; O < F.length; O += 1) {\n          var U = F[O],\n            N = Ai(U.transform, U.invTransform, e.transform);\n          T.draw(l, c.TRIANGLES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, N, o.id, B, k, t.SegmentVector.simpleSegment(0, 2 * U.circleOffset, U.circleArray.length, U.circleArray.length / 2), null, e.transform.zoom, null, null, null);\n        }\n        B.destroy(), k.destroy();\n      }\n    }\n    var Ji = t.identity(new Float32Array(16));\n    function Qi(e, i, o, r, a, n) {\n      var s = t.getAnchorAlignment(e),\n        l = -(s.horizontalAlign - .5) * i,\n        c = -(s.verticalAlign - .5) * o,\n        u = t.evaluateVariableOffset(e, r);\n      return new t.Point((l / a + u[0]) * n, (c / a + u[1]) * n);\n    }\n    function $i(e, i, o, r, a, n, s, l, c, u, h) {\n      var p = e.text.placedSymbolArray,\n        d = e.text.dynamicLayoutVertexArray,\n        _ = e.icon.dynamicLayoutVertexArray,\n        f = {};\n      d.clear();\n      for (var m = 0; m < p.length; m++) {\n        var g = p.get(m),\n          v = g.hidden || !g.crossTileID || e.allowVerticalPlacement && !g.placedOrientation ? null : r[g.crossTileID];\n        if (v) {\n          var y = new t.Point(g.anchorX, g.anchorY),\n            x = $t(y, o ? l : s),\n            b = te(n.cameraToCenterDistance, x.signedDistanceFromCamera),\n            w = a.evaluateSizeForFeature(e.textSizeData, u, g) * b / t.ONE_EM;\n          o && (w *= e.tilePixelRatio / c);\n          for (var T = Qi(v.anchor, v.width, v.height, v.textOffset, v.textBoxScale, w), E = o ? $t(y.add(T), s).point : x.point.add(i ? T.rotate(-n.angle) : T), I = e.allowVerticalPlacement && g.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, P = 0; P < g.numGlyphs; P++) t.addDynamicAttributes(d, E, I);\n          h && g.associatedIconIndex >= 0 && (f[g.associatedIconIndex] = {\n            shiftedAnchor: E,\n            angle: I\n          });\n        } else ce(g.numGlyphs, d);\n      }\n      if (h) {\n        _.clear();\n        for (var S = e.icon.placedSymbolArray, C = 0; C < S.length; C++) {\n          var z = S.get(C);\n          if (z.hidden) ce(z.numGlyphs, _);else {\n            var D = f[C];\n            if (D) for (var A = 0; A < z.numGlyphs; A++) t.addDynamicAttributes(_, D.shiftedAnchor, D.angle);else ce(z.numGlyphs, _);\n          }\n        }\n        e.icon.dynamicLayoutVertexBuffer.updateData(_);\n      }\n      e.text.dynamicLayoutVertexBuffer.updateData(d);\n    }\n    function to(t, e, i) {\n      return i.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon";\n    }\n    function eo(e, i, o, r, a, n, s, l, c, u, h, p) {\n      for (var d = e.context, _ = d.gl, f = e.transform, m = "map" === l, g = "map" === c, v = m && "point" !== o.layout.get("symbol-placement"), y = m && !g && !v, x = !o.layout.get("symbol-sort-key").isConstant(), b = !1, w = e.depthModeForSublayer(0, It.ReadOnly), T = o.layout.get("text-variable-anchor"), E = [], I = 0, P = r; I < P.length; I += 1) {\n        var S = P[I],\n          C = i.getTile(S),\n          z = C.getBucket(o);\n        if (z) {\n          var D = a ? z.text : z.icon;\n          if (D && D.segments.get().length) {\n            var A = D.programConfigurations.get(o.id),\n              M = a || z.sdfIcons,\n              L = a ? z.textSizeData : z.iconSizeData,\n              R = g || 0 !== f.pitch,\n              k = e.useProgram(to(M, a, z), A),\n              B = t.evaluateSizeForZoom(L, f.zoom),\n              O = void 0,\n              F = [0, 0],\n              U = void 0,\n              N = void 0,\n              Z = null,\n              q = void 0;\n            if (a) U = C.glyphAtlasTexture, N = _.LINEAR, O = C.glyphAtlasTexture.size, z.iconsInText && (F = C.imageAtlasTexture.size, Z = C.imageAtlasTexture, q = R || e.options.rotating || e.options.zooming || "composite" === L.kind || "camera" === L.kind ? _.LINEAR : _.NEAREST);else {\n              var j = 1 !== o.layout.get("icon-size").constantOr(0) || z.iconsNeedLinear;\n              U = C.imageAtlasTexture, N = M || e.options.rotating || e.options.zooming || j || R ? _.LINEAR : _.NEAREST, O = C.imageAtlasTexture.size;\n            }\n            var V = pe(C, 1, e.transform.zoom),\n              G = Jt(S.posMatrix, g, m, e.transform, V),\n              W = Qt(S.posMatrix, g, m, e.transform, V),\n              X = T && z.hasTextData(),\n              H = "none" !== o.layout.get("icon-text-fit") && X && z.hasIconData();\n            v && ie(z, S.posMatrix, e, a, G, W, g, u);\n            var K = e.translatePosMatrix(S.posMatrix, C, n, s),\n              Y = v || a && T || H ? Ji : G,\n              J = e.translatePosMatrix(W, C, n, s, !0),\n              Q = M && 0 !== o.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1),\n              $ = {\n                program: k,\n                buffers: D,\n                uniformValues: M ? z.iconsInText ? Wi(L.kind, B, y, g, e, K, Y, J, O, F) : Gi(L.kind, B, y, g, e, K, Y, J, a, O, !0) : Vi(L.kind, B, y, g, e, K, Y, J, a, O),\n                atlasTexture: U,\n                atlasTextureIcon: Z,\n                atlasInterpolation: N,\n                atlasInterpolationIcon: q,\n                isSDF: M,\n                hasHalo: Q\n              };\n            if (x && z.canOverlap) {\n              b = !0;\n              for (var tt = 0, et = D.segments.get(); tt < et.length; tt += 1) {\n                var it = et[tt];\n                E.push({\n                  segments: new t.SegmentVector([it]),\n                  sortKey: it.sortKey,\n                  state: $\n                });\n              }\n            } else E.push({\n              segments: D.segments,\n              sortKey: 0,\n              state: $\n            });\n          }\n        }\n      }\n      b && E.sort(function (t, e) {\n        return t.sortKey - e.sortKey;\n      });\n      for (var ot = 0, rt = E; ot < rt.length; ot += 1) {\n        var at = rt[ot],\n          nt = at.state;\n        if (d.activeTexture.set(_.TEXTURE0), nt.atlasTexture.bind(nt.atlasInterpolation, _.CLAMP_TO_EDGE), nt.atlasTextureIcon && (d.activeTexture.set(_.TEXTURE1), nt.atlasTextureIcon && nt.atlasTextureIcon.bind(nt.atlasInterpolationIcon, _.CLAMP_TO_EDGE)), nt.isSDF) {\n          var st = nt.uniformValues;\n          nt.hasHalo && (st.u_is_halo = 1, io(nt.buffers, at.segments, o, e, nt.program, w, h, p, st)), st.u_is_halo = 0;\n        }\n        io(nt.buffers, at.segments, o, e, nt.program, w, h, p, nt.uniformValues);\n      }\n    }\n    function io(t, e, i, o, r, a, n, s, l) {\n      var c = o.context;\n      r.draw(c, c.gl.TRIANGLES, a, n, s, Ct.disabled, l, i.id, t.layoutVertexBuffer, t.indexBuffer, e, i.paint, o.transform.zoom, t.programConfigurations.get(i.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer);\n    }\n    function oo(t, e, i, o, r, a, n) {\n      var s,\n        l,\n        c,\n        u,\n        h,\n        p = t.context.gl,\n        d = i.paint.get("fill-pattern"),\n        _ = d && d.constantOr(1),\n        f = i.getCrossfadeParameters();\n      n ? (l = _ && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s = p.LINES) : (l = _ ? "fillPattern" : "fill", s = p.TRIANGLES);\n      for (var m = 0, g = o; m < g.length; m += 1) {\n        var v = g[m],\n          y = e.getTile(v);\n        if (!_ || y.patternsLoaded()) {\n          var x = y.getBucket(i);\n          if (x) {\n            var b = x.programConfigurations.get(i.id),\n              w = t.useProgram(l, b);\n            _ && (t.context.activeTexture.set(p.TEXTURE0), y.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), b.updatePaintBuffers(f));\n            var T = d.constantOr(null);\n            if (T && y.imageAtlas) {\n              var E = y.imageAtlas,\n                I = E.patternPositions[T.to.toString()],\n                P = E.patternPositions[T.from.toString()];\n              I && P && b.setConstantPatternPositions(I, P);\n            }\n            var S = t.translatePosMatrix(v.posMatrix, y, i.paint.get("fill-translate"), i.paint.get("fill-translate-anchor"));\n            if (n) {\n              u = x.indexBuffer2, h = x.segments2;\n              var C = [p.drawingBufferWidth, p.drawingBufferHeight];\n              c = "fillOutlinePattern" === l && _ ? Ci(S, t, f, y, C) : Si(S, C);\n            } else u = x.indexBuffer, h = x.segments, c = _ ? Pi(S, t, f, y) : Ii(S);\n            w.draw(t.context, s, r, t.stencilModeForClipping(v), a, Ct.disabled, c, i.id, x.layoutVertexBuffer, u, h, i.paint, t.transform.zoom, b);\n          }\n        }\n      }\n    }\n    function ro(t, e, i, o, r, a, n) {\n      for (var s = t.context, l = s.gl, c = i.paint.get("fill-extrusion-pattern"), u = c.constantOr(1), h = i.getCrossfadeParameters(), p = i.paint.get("fill-extrusion-opacity"), d = 0, _ = o; d < _.length; d += 1) {\n        var f = _[d],\n          m = e.getTile(f),\n          g = m.getBucket(i);\n        if (g) {\n          var v = g.programConfigurations.get(i.id),\n            y = t.useProgram(u ? "fillExtrusionPattern" : "fillExtrusion", v);\n          u && (t.context.activeTexture.set(l.TEXTURE0), m.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers(h));\n          var x = c.constantOr(null);\n          if (x && m.imageAtlas) {\n            var b = m.imageAtlas,\n              w = b.patternPositions[x.to.toString()],\n              T = b.patternPositions[x.from.toString()];\n            w && T && v.setConstantPatternPositions(w, T);\n          }\n          var E = t.translatePosMatrix(f.posMatrix, m, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")),\n            I = i.paint.get("fill-extrusion-vertical-gradient"),\n            P = u ? Ei(E, t, I, p, f, h, m) : Ti(E, t, I, p);\n          y.draw(s, s.gl.TRIANGLES, r, a, n, Ct.backCCW, P, i.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, i.paint, t.transform.zoom, v);\n        }\n      }\n    }\n    function ao(e, i, o, r, a, n) {\n      var s = e.context,\n        l = s.gl,\n        c = i.fbo;\n      if (c) {\n        var u = e.useProgram("hillshade");\n        s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get());\n        var h = function (e, i, o) {\n          var r = o.paint.get("hillshade-shadow-color"),\n            a = o.paint.get("hillshade-highlight-color"),\n            n = o.paint.get("hillshade-accent-color"),\n            s = o.paint.get("hillshade-illumination-direction") * (Math.PI / 180);\n          "viewport" === o.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle);\n          var l,\n            c,\n            u,\n            h = !e.options.moving;\n          return {\n            u_matrix: e.transform.calculatePosMatrix(i.tileID.toUnwrapped(), h),\n            u_image: 0,\n            u_latrange: (l = i.tileID, c = Math.pow(2, l.canonical.z), u = l.canonical.y, [new t.MercatorCoordinate(0, u / c).toLngLat().lat, new t.MercatorCoordinate(0, (u + 1) / c).toLngLat().lat]),\n            u_light: [o.paint.get("hillshade-exaggeration"), s],\n            u_shadow: r,\n            u_highlight: a,\n            u_accent: n\n          };\n        }(e, i, o);\n        u.draw(s, l.TRIANGLES, r, a, n, Ct.disabled, h, o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments);\n      }\n    }\n    function no(e, i, o, r, a, n) {\n      var s = e.context,\n        l = s.gl,\n        c = i.dem;\n      if (c && c.data) {\n        var u = c.dim,\n          h = c.stride,\n          p = c.getPixels();\n        if (s.activeTexture.set(l.TEXTURE1), s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(h), i.demTexture) {\n          var d = i.demTexture;\n          d.update(p, {\n            premultiply: !1\n          }), d.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n        } else i.demTexture = new t.Texture(s, p, l.RGBA, {\n          premultiply: !1\n        }), i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n        s.activeTexture.set(l.TEXTURE0);\n        var _ = i.fbo;\n        if (!_) {\n          var f = new t.Texture(s, {\n            width: u,\n            height: u,\n            data: null\n          }, l.RGBA);\n          f.bind(l.LINEAR, l.CLAMP_TO_EDGE), (_ = i.fbo = s.createFramebuffer(u, u, !0)).colorAttachment.set(f.texture);\n        }\n        s.bindFramebuffer.set(_.framebuffer), s.viewport.set([0, 0, u, u]), e.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, r, a, n, Ct.disabled, function (e, i) {\n          var o = i.stride,\n            r = t.create();\n          return t.ortho(r, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r, r, [0, -t.EXTENT, 0]), {\n            u_matrix: r,\n            u_image: 1,\n            u_dimension: [o, o],\n            u_zoom: e.overscaledZ,\n            u_unpack: i.getUnpackVector()\n          };\n        }(i.tileID, c), o.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1;\n      }\n    }\n    function so(e, i, o, r, a) {\n      var n = r.paint.get("raster-fade-duration");\n      if (n > 0) {\n        var s = t.browser.now(),\n          l = (s - e.timeAdded) / n,\n          c = i ? (s - i.timeAdded) / n : -1,\n          u = o.getSource(),\n          h = a.coveringZoomLevel({\n            tileSize: u.tileSize,\n            roundZoom: u.roundZoom\n          }),\n          p = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e.tileID.overscaledZ - h),\n          d = p && e.refreshedUponExpiration ? 1 : t.clamp(p ? l : 1 - c, 0, 1);\n        return e.refreshedUponExpiration && l >= 1 && (e.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - d\n        } : {\n          opacity: d,\n          mix: 0\n        };\n      }\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n    var lo = new t.Color(1, 0, 0, 1),\n      co = new t.Color(0, 1, 0, 1),\n      uo = new t.Color(0, 0, 1, 1),\n      ho = new t.Color(1, 0, 1, 1),\n      po = new t.Color(0, 1, 1, 1);\n    function _o(t, e, i, o) {\n      mo(t, 0, e + i / 2, t.transform.width, i, o);\n    }\n    function fo(t, e, i, o) {\n      mo(t, e - i / 2, 0, i, t.transform.height, o);\n    }\n    function mo(e, i, o, r, a, n) {\n      var s = e.context,\n        l = s.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * t.browser.devicePixelRatio, o * t.browser.devicePixelRatio, r * t.browser.devicePixelRatio, a * t.browser.devicePixelRatio), s.clear({\n        color: n\n      }), l.disable(l.SCISSOR_TEST);\n    }\n    function go(e, i, o) {\n      var r = e.context,\n        a = r.gl,\n        n = o.posMatrix,\n        s = e.useProgram("debug"),\n        l = It.disabled,\n        c = Pt.disabled,\n        u = e.colorModeForRenderPass();\n      r.activeTexture.set(a.TEXTURE0), e.emptyTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), s.draw(r, a.LINE_STRIP, l, c, u, Ct.disabled, Mi(n, t.Color.red), "$debug", e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments);\n      var h = i.getTileByID(o.key).latestRawTileData,\n        p = Math.floor((h && h.byteLength || 0) / 1024),\n        d = i.getTile(o).tileSize,\n        _ = 512 / Math.min(d, 512) * (o.overscaledZ / e.transform.zoom) * .5,\n        f = o.canonical.toString();\n      o.overscaledZ !== o.canonical.z && (f += " => " + o.overscaledZ), function (t, e) {\n        t.initDebugOverlayCanvas();\n        var i = t.debugOverlayCanvas,\n          o = t.context.gl,\n          r = t.debugOverlayCanvas.getContext("2d");\n        r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(e, 5, 5), r.strokeText(e, 5, 5), t.debugOverlayTexture.update(i), t.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }(e, f + " " + p + "kb"), s.draw(r, a.TRIANGLES, l, c, St.alphaBlended, Ct.disabled, Mi(n, t.Color.transparent, _), "$debug", e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments);\n    }\n    var vo = {\n        symbol: function (e, i, o, r, a) {\n          if ("translucent" === e.renderPass) {\n            var n = Pt.disabled,\n              s = e.colorModeForRenderPass();\n            o.layout.get("text-variable-anchor") && function (e, i, o, r, a, n, s) {\n              for (var l = i.transform, c = "map" === a, u = "map" === n, h = 0, p = e; h < p.length; h += 1) {\n                var d = p[h],\n                  _ = r.getTile(d),\n                  f = _.getBucket(o);\n                if (f && f.text && f.text.segments.get().length) {\n                  var m = t.evaluateSizeForZoom(f.textSizeData, l.zoom),\n                    g = pe(_, 1, i.transform.zoom),\n                    v = Jt(d.posMatrix, u, c, i.transform, g),\n                    y = "none" !== o.layout.get("icon-text-fit") && f.hasIconData();\n                  if (m) {\n                    var x = Math.pow(2, l.zoom - _.tileID.overscaledZ);\n                    $i(f, c, u, s, t.symbolSize, l, v, d.posMatrix, x, m, y);\n                  }\n                }\n              }\n            }(r, e, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), a), 0 !== o.paint.get("icon-opacity").constantOr(1) && eo(e, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), n, s), 0 !== o.paint.get("text-opacity").constantOr(1) && eo(e, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), n, s), i.map.showCollisionBoxes && (Yi(e, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), Yi(e, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));\n          }\n        },\n        circle: function (e, i, o, r) {\n          if ("translucent" === e.renderPass) {\n            var a = o.paint.get("circle-opacity"),\n              n = o.paint.get("circle-stroke-width"),\n              s = o.paint.get("circle-stroke-opacity"),\n              l = !o.layout.get("circle-sort-key").isConstant();\n            if (0 !== a.constantOr(1) || 0 !== n.constantOr(1) && 0 !== s.constantOr(1)) {\n              for (var c = e.context, u = c.gl, h = e.depthModeForSublayer(0, It.ReadOnly), p = Pt.disabled, d = e.colorModeForRenderPass(), _ = [], f = 0; f < r.length; f++) {\n                var m = r[f],\n                  g = i.getTile(m),\n                  v = g.getBucket(o);\n                if (v) {\n                  var y = v.programConfigurations.get(o.id),\n                    x = {\n                      programConfiguration: y,\n                      program: e.useProgram("circle", y),\n                      layoutVertexBuffer: v.layoutVertexBuffer,\n                      indexBuffer: v.indexBuffer,\n                      uniformValues: zi(e, m, g, o)\n                    };\n                  if (l) for (var b = 0, w = v.segments.get(); b < w.length; b += 1) {\n                    var T = w[b];\n                    _.push({\n                      segments: new t.SegmentVector([T]),\n                      sortKey: T.sortKey,\n                      state: x\n                    });\n                  } else _.push({\n                    segments: v.segments,\n                    sortKey: 0,\n                    state: x\n                  });\n                }\n              }\n              l && _.sort(function (t, e) {\n                return t.sortKey - e.sortKey;\n              });\n              for (var E = 0, I = _; E < I.length; E += 1) {\n                var P = I[E],\n                  S = P.state;\n                S.program.draw(c, u.TRIANGLES, h, p, d, Ct.disabled, S.uniformValues, o.id, S.layoutVertexBuffer, S.indexBuffer, P.segments, o.paint, e.transform.zoom, S.programConfiguration);\n              }\n            }\n          }\n        },\n        heatmap: function (e, i, o, r) {\n          if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === e.renderPass) {\n            var a = e.context,\n              n = a.gl,\n              s = Pt.disabled,\n              l = new St([n.ONE, n.ONE], t.Color.transparent, [!0, !0, !0, !0]);\n            !function (t, e, i) {\n              var o = t.gl;\n              t.activeTexture.set(o.TEXTURE1), t.viewport.set([0, 0, e.width / 4, e.height / 4]);\n              var r = i.heatmapFbo;\n              if (r) o.bindTexture(o.TEXTURE_2D, r.colorAttachment.get()), t.bindFramebuffer.set(r.framebuffer);else {\n                var a = o.createTexture();\n                o.bindTexture(o.TEXTURE_2D, a), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), r = i.heatmapFbo = t.createFramebuffer(e.width / 4, e.height / 4, !1), function (t, e, i, o) {\n                  var r = t.gl;\n                  r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e.width / 4, e.height / 4, 0, r.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : r.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n                }(t, e, a, r);\n              }\n            }(a, e, o), a.clear({\n              color: t.Color.transparent\n            });\n            for (var c = 0; c < r.length; c++) {\n              var u = r[c];\n              if (!i.hasRenderableParent(u)) {\n                var h = i.getTile(u),\n                  p = h.getBucket(o);\n                if (p) {\n                  var d = p.programConfigurations.get(o.id);\n                  e.useProgram("heatmap", d).draw(a, n.TRIANGLES, It.disabled, s, l, Ct.disabled, Ri(u.posMatrix, h, e.transform.zoom, o.paint.get("heatmap-intensity")), o.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, o.paint, e.transform.zoom, d);\n                }\n              }\n            }\n            a.viewport.set([0, 0, e.width, e.height]);\n          } else "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()), function (e, i) {\n            var o = e.context,\n              r = o.gl,\n              a = i.heatmapFbo;\n            if (a) {\n              o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);\n              var n = i.colorRampTexture;\n              n || (n = i.colorRampTexture = new t.Texture(o, i.colorRamp, r.RGBA)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(o, r.TRIANGLES, It.disabled, Pt.disabled, e.colorModeForRenderPass(), Ct.disabled, function (e, i, o, r) {\n                var a = t.create();\n                t.ortho(a, 0, e.width, e.height, 0, 0, 1);\n                var n = e.context.gl;\n                return {\n                  u_matrix: a,\n                  u_world: [n.drawingBufferWidth, n.drawingBufferHeight],\n                  u_image: 0,\n                  u_color_ramp: 1,\n                  u_opacity: i.paint.get("heatmap-opacity")\n                };\n              }(e, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom);\n            }\n          }(e, o));\n        },\n        line: function (e, i, o, r) {\n          if ("translucent" === e.renderPass) {\n            var a = o.paint.get("line-opacity"),\n              n = o.paint.get("line-width");\n            if (0 !== a.constantOr(1) && 0 !== n.constantOr(1)) for (var s = e.depthModeForSublayer(0, It.ReadOnly), l = e.colorModeForRenderPass(), c = o.paint.get("line-dasharray"), u = o.paint.get("line-pattern"), h = u.constantOr(1), p = o.paint.get("line-gradient"), d = o.getCrossfadeParameters(), _ = h ? "linePattern" : c ? "lineSDF" : p ? "lineGradient" : "line", f = e.context, m = f.gl, g = !0, v = 0, y = r; v < y.length; v += 1) {\n              var x = y[v],\n                b = i.getTile(x);\n              if (!h || b.patternsLoaded()) {\n                var w = b.getBucket(o);\n                if (w) {\n                  var T = w.programConfigurations.get(o.id),\n                    E = e.context.program.get(),\n                    I = e.useProgram(_, T),\n                    P = g || I.program !== E,\n                    S = u.constantOr(null);\n                  if (S && b.imageAtlas) {\n                    var C = b.imageAtlas,\n                      z = C.patternPositions[S.to.toString()],\n                      D = C.patternPositions[S.from.toString()];\n                    z && D && T.setConstantPatternPositions(z, D);\n                  }\n                  var A = h ? Oi(e, b, o, d) : c ? Fi(e, b, o, c, d) : p ? Bi(e, b, o, w.lineClipsArray.length) : ki(e, b, o);\n                  if (h) f.activeTexture.set(m.TEXTURE0), b.imageAtlasTexture.bind(m.LINEAR, m.CLAMP_TO_EDGE), T.updatePaintBuffers(d);else if (c && (P || e.lineAtlas.dirty)) f.activeTexture.set(m.TEXTURE0), e.lineAtlas.bind(f);else if (p) {\n                    var M = w.gradients[o.id],\n                      L = M.texture;\n                    if (o.gradientVersion !== M.version) {\n                      var R = 256;\n                      if (o.stepInterpolant) {\n                        var k = i.getSource().maxzoom,\n                          B = x.canonical.z === k ? Math.ceil(1 << e.transform.maxZoom - x.canonical.z) : 1;\n                        R = t.clamp(t.nextPowerOfTwo(w.maxLineLength / t.EXTENT * 1024 * B), 256, f.maxTextureSize);\n                      }\n                      M.gradient = t.renderColorRamp({\n                        expression: o.gradientExpression(),\n                        evaluationKey: "lineProgress",\n                        resolution: R,\n                        image: M.gradient || void 0,\n                        clips: w.lineClipsArray\n                      }), M.texture ? M.texture.update(M.gradient) : M.texture = new t.Texture(f, M.gradient, m.RGBA), M.version = o.gradientVersion, L = M.texture;\n                    }\n                    f.activeTexture.set(m.TEXTURE0), L.bind(o.stepInterpolant ? m.NEAREST : m.LINEAR, m.CLAMP_TO_EDGE);\n                  }\n                  I.draw(f, m.TRIANGLES, s, e.stencilModeForClipping(x), l, Ct.disabled, A, o.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, o.paint, e.transform.zoom, T, w.layoutVertexBuffer2), g = !1;\n                }\n              }\n            }\n          }\n        },\n        fill: function (e, i, o, r) {\n          var a = o.paint.get("fill-color"),\n            n = o.paint.get("fill-opacity");\n          if (0 !== n.constantOr(1)) {\n            var s = e.colorModeForRenderPass(),\n              l = o.paint.get("fill-pattern"),\n              c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === a.constantOr(t.Color.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";\n            if (e.renderPass === c) {\n              var u = e.depthModeForSublayer(1, "opaque" === e.renderPass ? It.ReadWrite : It.ReadOnly);\n              oo(e, i, o, r, u, s, !1);\n            }\n            if ("translucent" === e.renderPass && o.paint.get("fill-antialias")) {\n              var h = e.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);\n              oo(e, i, o, r, h, s, !0);\n            }\n          }\n        },\n        "fill-extrusion": function (t, e, i, o) {\n          var r = i.paint.get("fill-extrusion-opacity");\n          if (0 !== r && "translucent" === t.renderPass) {\n            var a = new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D);\n            if (1 !== r || i.paint.get("fill-extrusion-pattern").constantOr(1)) ro(t, e, i, o, a, Pt.disabled, St.disabled), ro(t, e, i, o, a, t.stencilModeFor3D(), t.colorModeForRenderPass());else {\n              var n = t.colorModeForRenderPass();\n              ro(t, e, i, o, a, Pt.disabled, n);\n            }\n          }\n        },\n        hillshade: function (t, e, i, o) {\n          if ("offscreen" === t.renderPass || "translucent" === t.renderPass) {\n            for (var r = t.context, a = t.depthModeForSublayer(0, It.ReadOnly), n = t.colorModeForRenderPass(), s = "translucent" === t.renderPass ? t.stencilConfigForOverlap(o) : [{}, o], l = s[0], c = 0, u = s[1]; c < u.length; c += 1) {\n              var h = u[c],\n                p = e.getTile(h);\n              p.needsHillshadePrepare && "offscreen" === t.renderPass ? no(t, p, i, a, Pt.disabled, n) : "translucent" === t.renderPass && ao(t, p, i, a, l[h.overscaledZ], n);\n            }\n            r.viewport.set([0, 0, t.width, t.height]);\n          }\n        },\n        raster: function (t, e, i, o) {\n          if ("translucent" === t.renderPass && 0 !== i.paint.get("raster-opacity") && o.length) for (var r = t.context, a = r.gl, n = e.getSource(), s = t.useProgram("raster"), l = t.colorModeForRenderPass(), c = n instanceof M ? [{}, o] : t.stencilConfigForOverlap(o), u = c[0], h = c[1], p = h[h.length - 1].overscaledZ, d = !t.options.moving, _ = 0, f = h; _ < f.length; _ += 1) {\n            var m = f[_],\n              g = t.depthModeForSublayer(m.overscaledZ - p, 1 === i.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a.LESS),\n              v = e.getTile(m),\n              y = t.transform.calculatePosMatrix(m.toUnwrapped(), d);\n            v.registerFadeDuration(i.paint.get("raster-fade-duration"));\n            var x = e.findLoadedParent(m, 0),\n              b = so(v, x, e, i, t.transform),\n              w = void 0,\n              T = void 0,\n              E = "nearest" === i.paint.get("raster-resampling") ? a.NEAREST : a.LINEAR;\n            r.activeTexture.set(a.TEXTURE0), v.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), r.activeTexture.set(a.TEXTURE1), x ? (x.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST), w = Math.pow(2, x.tileID.overscaledZ - v.tileID.overscaledZ), T = [v.tileID.canonical.x * w % 1, v.tileID.canonical.y * w % 1]) : v.texture.bind(E, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);\n            var I = Zi(y, T || [0, 0], w || 1, b, i);\n            n instanceof M ? s.draw(r, a.TRIANGLES, g, Pt.disabled, l, Ct.disabled, I, i.id, n.boundsBuffer, t.quadTriangleIndexBuffer, n.boundsSegments) : s.draw(r, a.TRIANGLES, g, u[m.overscaledZ], l, Ct.disabled, I, i.id, t.rasterBoundsBuffer, t.quadTriangleIndexBuffer, t.rasterBoundsSegments);\n          }\n        },\n        background: function (t, e, i) {\n          var o = i.paint.get("background-color"),\n            r = i.paint.get("background-opacity");\n          if (0 !== r) {\n            var a = t.context,\n              n = a.gl,\n              s = t.transform,\n              l = s.tileSize,\n              c = i.paint.get("background-pattern");\n            if (!t.isPatternMissing(c)) {\n              var u = !c && 1 === o.a && 1 === r && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";\n              if (t.renderPass === u) {\n                var h = Pt.disabled,\n                  p = t.depthModeForSublayer(0, "opaque" === u ? It.ReadWrite : It.ReadOnly),\n                  d = t.colorModeForRenderPass(),\n                  _ = t.useProgram(c ? "backgroundPattern" : "background"),\n                  f = s.coveringTiles({\n                    tileSize: l\n                  });\n                c && (a.activeTexture.set(n.TEXTURE0), t.imageManager.bind(t.context));\n                for (var m = i.getCrossfadeParameters(), g = 0, v = f; g < v.length; g += 1) {\n                  var y = v[g],\n                    x = t.transform.calculatePosMatrix(y.toUnwrapped()),\n                    b = c ? Hi(x, r, t, c, {\n                      tileID: y,\n                      tileSize: l\n                    }, m) : Xi(x, r, o);\n                  _.draw(a, n.TRIANGLES, p, h, d, Ct.disabled, b, i.id, t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments);\n                }\n              }\n            }\n          }\n        },\n        debug: function (t, e, i) {\n          for (var o = 0; o < i.length; o++) go(t, e, i[o]);\n        },\n        custom: function (t, e, i) {\n          var o = t.context,\n            r = i.implementation;\n          if ("offscreen" === t.renderPass) {\n            var a = r.prerender;\n            a && (t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), a.call(r, o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState());\n          } else if ("translucent" === t.renderPass) {\n            t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), o.setStencilMode(Pt.disabled);\n            var n = "3d" === r.renderingMode ? new It(t.context.gl.LEQUAL, It.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, It.ReadOnly);\n            o.setDepthMode(n), r.render(o.gl, t.transform.customLayerMatrix()), o.setDirty(), t.setBaseState(), o.bindFramebuffer.set(null);\n          }\n        }\n      },\n      yo = function (t, e) {\n        this.context = new zt(t), this.transform = e, this._tileTextures = {}, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {};\n      };\n    yo.prototype.resize = function (e, i) {\n      if (this.width = e * t.browser.devicePixelRatio, this.height = i * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (var o = 0, r = this.style._order; o < r.length; o += 1) this.style._layers[r[o]].resize();\n    }, yo.prototype.setup = function () {\n      var e = this.context,\n        i = new t.StructArrayLayout2i4();\n      i.emplaceBack(0, 0), i.emplaceBack(t.EXTENT, 0), i.emplaceBack(0, t.EXTENT), i.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e.createVertexBuffer(i, Ve.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var o = new t.StructArrayLayout2i4();\n      o.emplaceBack(0, 0), o.emplaceBack(t.EXTENT, 0), o.emplaceBack(0, t.EXTENT), o.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e.createVertexBuffer(o, Ve.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);\n      var r = new t.StructArrayLayout4i8();\n      r.emplaceBack(0, 0, 0, 0), r.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e.createVertexBuffer(r, A.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var a = new t.StructArrayLayout2i4();\n      a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(a, Ve.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);\n      var n = new t.StructArrayLayout1ui2();\n      n.emplaceBack(0), n.emplaceBack(1), n.emplaceBack(3), n.emplaceBack(2), n.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(n);\n      var s = new t.StructArrayLayout3ui6();\n      s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(s), this.emptyTexture = new t.Texture(e, {\n        width: 1,\n        height: 1,\n        data: new Uint8Array([0, 0, 0, 0])\n      }, e.gl.RGBA);\n      var l = this.context.gl;\n      this.stencilClearMode = new Pt({\n        func: l.ALWAYS,\n        mask: 0\n      }, 0, 255, l.ZERO, l.ZERO, l.ZERO);\n    }, yo.prototype.clearStencil = function () {\n      var e = this.context,\n        i = e.gl;\n      this.nextStencilID = 1, this.currentStencilSource = void 0;\n      var o = t.create();\n      t.ortho(o, 0, this.width, this.height, 0, 0, 1), t.scale(o, o, [i.drawingBufferWidth, i.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e, i.TRIANGLES, It.disabled, this.stencilClearMode, St.disabled, Ct.disabled, Li(o), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n    }, yo.prototype._renderTileClippingMasks = function (t, e) {\n      if (this.currentStencilSource !== t.source && t.isTileClipped() && e && e.length) {\n        this.currentStencilSource = t.source;\n        var i = this.context,\n          o = i.gl;\n        this.nextStencilID + e.length > 256 && this.clearStencil(), i.setColorMode(St.disabled), i.setDepthMode(It.disabled);\n        var r = this.useProgram("clippingMask");\n        this._tileClippingMaskIDs = {};\n        for (var a = 0, n = e; a < n.length; a += 1) {\n          var s = n[a],\n            l = this._tileClippingMaskIDs[s.key] = this.nextStencilID++;\n          r.draw(i, o.TRIANGLES, It.disabled, new Pt({\n            func: o.ALWAYS,\n            mask: 0\n          }, l, 255, o.KEEP, o.KEEP, o.REPLACE), St.disabled, Ct.disabled, Li(s.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);\n        }\n      }\n    }, yo.prototype.stencilModeFor3D = function () {\n      this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n      var t = this.nextStencilID++,\n        e = this.context.gl;\n      return new Pt({\n        func: e.NOTEQUAL,\n        mask: 255\n      }, t, 255, e.KEEP, e.KEEP, e.REPLACE);\n    }, yo.prototype.stencilModeForClipping = function (t) {\n      var e = this.context.gl;\n      return new Pt({\n        func: e.EQUAL,\n        mask: 255\n      }, this._tileClippingMaskIDs[t.key], 0, e.KEEP, e.KEEP, e.REPLACE);\n    }, yo.prototype.stencilConfigForOverlap = function (t) {\n      var e,\n        i = this.context.gl,\n        o = t.sort(function (t, e) {\n          return e.overscaledZ - t.overscaledZ;\n        }),\n        r = o[o.length - 1].overscaledZ,\n        a = o[0].overscaledZ - r + 1;\n      if (a > 1) {\n        this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();\n        for (var n = {}, s = 0; s < a; s++) n[s + r] = new Pt({\n          func: i.GEQUAL,\n          mask: 255\n        }, s + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);\n        return this.nextStencilID += a, [n, o];\n      }\n      return [(e = {}, e[r] = Pt.disabled, e), o];\n    }, yo.prototype.colorModeForRenderPass = function () {\n      var e = this.context.gl;\n      return this._showOverdrawInspector ? new St([e.CONSTANT_COLOR, e.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [!0, !0, !0, !0]) : "opaque" === this.renderPass ? St.unblended : St.alphaBlended;\n    }, yo.prototype.depthModeForSublayer = function (t, e, i) {\n      if (!this.opaquePassEnabledForLayer()) return It.disabled;\n      var o = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;\n      return new It(i || this.context.gl.LEQUAL, e, [o, o]);\n    }, yo.prototype.opaquePassEnabledForLayer = function () {\n      return this.currentLayer < this.opaquePassCutoff;\n    }, yo.prototype.render = function (e, i) {\n      var o = this;\n      this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();\n      var r = this.style._order,\n        a = this.style.sourceCaches;\n      for (var n in a) {\n        var s = a[n];\n        s.used && s.prepare(this.context);\n      }\n      var l,\n        c,\n        u = {},\n        h = {},\n        p = {};\n      for (var d in a) {\n        var _ = a[d];\n        u[d] = _.getVisibleCoordinates(), h[d] = u[d].slice().reverse(), p[d] = _.getVisibleCoordinates(!0).reverse();\n      }\n      this.opaquePassCutoff = 1 / 0;\n      for (var f = 0; f < r.length; f++) if (this.style._layers[r[f]].is3D()) {\n        this.opaquePassCutoff = f;\n        break;\n      }\n      this.renderPass = "offscreen";\n      for (var m = 0, g = r; m < g.length; m += 1) {\n        var v = this.style._layers[g[m]];\n        if (v.hasOffscreenPass() && !v.isHidden(this.transform.zoom)) {\n          var y = h[v.source];\n          ("custom" === v.type || y.length) && this.renderLayer(this, a[v.source], v, y);\n        }\n      }\n      for (this.context.bindFramebuffer.set(null), this.context.clear({\n        color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,\n        depth: 1\n      }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n        var x = this.style._layers[r[this.currentLayer]],\n          b = a[x.source],\n          w = u[x.source];\n        this._renderTileClippingMasks(x, w), this.renderLayer(this, b, x, w);\n      }\n      for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {\n        var T = this.style._layers[r[this.currentLayer]],\n          E = a[T.source],\n          I = ("symbol" === T.type ? p : h)[T.source];\n        this._renderTileClippingMasks(T, u[T.source]), this.renderLayer(this, E, T, I);\n      }\n      this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function (t) {\n        t.source && !t.isHidden(o.transform.zoom) && (t.source !== (c && c.id) && (c = o.style.sourceCaches[t.source]), (!l || l.getSource().maxzoom < c.getSource().maxzoom) && (l = c));\n      }), l && vo.debug(this, l, l.getVisibleCoordinates())), this.options.showPadding && function (t) {\n        var e = t.transform.padding;\n        _o(t, t.transform.height - (e.top || 0), 3, lo), _o(t, e.bottom || 0, 3, co), fo(t, e.left || 0, 3, uo), fo(t, t.transform.width - (e.right || 0), 3, ho);\n        var i = t.transform.centerPoint;\n        !function (t, e, i, o) {\n          mo(t, e - 1, i - 10, 2, 20, o), mo(t, e - 10, i - 1, 20, 2, o);\n        }(t, i.x, t.transform.height - i.y, po);\n      }(this), this.context.setDefault();\n    }, yo.prototype.renderLayer = function (t, e, i, o) {\n      i.isHidden(this.transform.zoom) || ("background" === i.type || "custom" === i.type || o.length) && (this.id = i.id, this.gpuTimingStart(i), vo[i.type](t, e, i, o, this.style.placement.variableOffsets), this.gpuTimingEnd());\n    }, yo.prototype.gpuTimingStart = function (t) {\n      if (this.options.gpuTiming) {\n        var e = this.context.extTimerQuery,\n          i = this.gpuTimers[t.id];\n        i || (i = this.gpuTimers[t.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: e.createQueryEXT()\n        }), i.calls++, e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query);\n      }\n    }, yo.prototype.gpuTimingEnd = function () {\n      if (this.options.gpuTiming) {\n        var t = this.context.extTimerQuery;\n        t.endQueryEXT(t.TIME_ELAPSED_EXT);\n      }\n    }, yo.prototype.collectGpuTimers = function () {\n      var t = this.gpuTimers;\n      return this.gpuTimers = {}, t;\n    }, yo.prototype.queryGpuTimers = function (t) {\n      var e = {};\n      for (var i in t) {\n        var o = t[i],\n          r = this.context.extTimerQuery,\n          a = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;\n        r.deleteQueryEXT(o.query), e[i] = a;\n      }\n      return e;\n    }, yo.prototype.translatePosMatrix = function (e, i, o, r, a) {\n      if (!o[0] && !o[1]) return e;\n      var n = a ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;\n      if (n) {\n        var s = Math.sin(n),\n          l = Math.cos(n);\n        o = [o[0] * l - o[1] * s, o[0] * s + o[1] * l];\n      }\n      var c = [a ? o[0] : pe(i, o[0], this.transform.zoom), a ? o[1] : pe(i, o[1], this.transform.zoom), 0],\n        u = new Float32Array(16);\n      return t.translate(u, e, c), u;\n    }, yo.prototype.saveTileTexture = function (t) {\n      var e = this._tileTextures[t.size[0]];\n      e ? e.push(t) : this._tileTextures[t.size[0]] = [t];\n    }, yo.prototype.getTileTexture = function (t) {\n      var e = this._tileTextures[t];\n      return e && e.length > 0 ? e.pop() : null;\n    }, yo.prototype.isPatternMissing = function (t) {\n      if (!t) return !1;\n      if (!t.from || !t.to) return !0;\n      var e = this.imageManager.getPattern(t.from.toString()),\n        i = this.imageManager.getPattern(t.to.toString());\n      return !e || !i;\n    }, yo.prototype.useProgram = function (t, e) {\n      this.cache = this.cache || {};\n      var i = "" + t + (e ? e.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");\n      return this.cache[i] || (this.cache[i] = new bi(this.context, t, vi[t], e, Ki[t], this._showOverdrawInspector)), this.cache[i];\n    }, yo.prototype.setCustomLayerDefaults = function () {\n      this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n    }, yo.prototype.setBaseState = function () {\n      var t = this.context.gl;\n      this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);\n    }, yo.prototype.initDebugOverlayCanvas = function () {\n      null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n    }, yo.prototype.destroy = function () {\n      this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();\n    };\n    var xo = function (t, e) {\n      this.points = t, this.planes = e;\n    };\n    xo.fromInvProjectionMatrix = function (e, i, o) {\n      var r = Math.pow(2, o),\n        a = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function (i) {\n          return t.transformMat4([], i, e);\n        }).map(function (e) {\n          return t.scale$1([], e, 1 / e[3] / i * r);\n        }),\n        n = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function (e) {\n          var i = t.sub([], a[e[0]], a[e[1]]),\n            o = t.sub([], a[e[2]], a[e[1]]),\n            r = t.normalize([], t.cross([], i, o)),\n            n = -t.dot(r, a[e[1]]);\n          return r.concat(n);\n        });\n      return new xo(a, n);\n    };\n    var bo = function (e, i) {\n      this.min = e, this.max = i, this.center = t.scale$2([], t.add([], this.min, this.max), .5);\n    };\n    bo.prototype.quadrant = function (e) {\n      for (var i = [e % 2 == 0, e < 2], o = t.clone$2(this.min), r = t.clone$2(this.max), a = 0; a < i.length; a++) o[a] = i[a] ? this.min[a] : this.center[a], r[a] = i[a] ? this.center[a] : this.max[a];\n      return r[2] = this.max[2], new bo(o, r);\n    }, bo.prototype.distanceX = function (t) {\n      return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n    }, bo.prototype.distanceY = function (t) {\n      return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n    }, bo.prototype.intersects = function (e) {\n      for (var i = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], o = !0, r = 0; r < e.planes.length; r++) {\n        for (var a = e.planes[r], n = 0, s = 0; s < i.length; s++) n += t.dot$1(a, i[s]) >= 0;\n        if (0 === n) return 0;\n        n !== i.length && (o = !1);\n      }\n      if (o) return 2;\n      for (var l = 0; l < 3; l++) {\n        for (var c = Number.MAX_VALUE, u = -Number.MAX_VALUE, h = 0; h < e.points.length; h++) {\n          var p = e.points[h][l] - this.min[l];\n          c = Math.min(c, p), u = Math.max(u, p);\n        }\n        if (u < 0 || c > this.max[l] - this.min[l]) return 0;\n      }\n      return 1;\n    };\n    var wo = function (t, e, i, o) {\n      if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");\n      this.top = t, this.bottom = e, this.left = i, this.right = o;\n    };\n    wo.prototype.interpolate = function (e, i, o) {\n      return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, o)), null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, o)), null != i.left && null != e.left && (this.left = t.number(e.left, i.left, o)), null != i.right && null != e.right && (this.right = t.number(e.right, i.right, o)), this;\n    }, wo.prototype.getCenter = function (e, i) {\n      var o = t.clamp((this.left + e - this.right) / 2, 0, e),\n        r = t.clamp((this.top + i - this.bottom) / 2, 0, i);\n      return new t.Point(o, r);\n    }, wo.prototype.equals = function (t) {\n      return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;\n    }, wo.prototype.clone = function () {\n      return new wo(this.top, this.bottom, this.left, this.right);\n    }, wo.prototype.toJSON = function () {\n      return {\n        top: this.top,\n        bottom: this.bottom,\n        left: this.left,\n        right: this.right\n      };\n    };\n    var To = function (e, i, o, r, a) {\n        this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a || a, this._minZoom = e || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new wo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n      },\n      Eo = {\n        minZoom: {\n          configurable: !0\n        },\n        maxZoom: {\n          configurable: !0\n        },\n        minPitch: {\n          configurable: !0\n        },\n        maxPitch: {\n          configurable: !0\n        },\n        renderWorldCopies: {\n          configurable: !0\n        },\n        worldSize: {\n          configurable: !0\n        },\n        centerOffset: {\n          configurable: !0\n        },\n        size: {\n          configurable: !0\n        },\n        bearing: {\n          configurable: !0\n        },\n        pitch: {\n          configurable: !0\n        },\n        fov: {\n          configurable: !0\n        },\n        zoom: {\n          configurable: !0\n        },\n        center: {\n          configurable: !0\n        },\n        padding: {\n          configurable: !0\n        },\n        centerPoint: {\n          configurable: !0\n        },\n        unmodified: {\n          configurable: !0\n        },\n        point: {\n          configurable: !0\n        }\n      };\n    To.prototype.clone = function () {\n      var t = new To(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);\n      return t.tileSize = this.tileSize, t.latRange = this.latRange, t.width = this.width, t.height = this.height, t._center = this._center, t.zoom = this.zoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._calcMatrices(), t;\n    }, Eo.minZoom.get = function () {\n      return this._minZoom;\n    }, Eo.minZoom.set = function (t) {\n      this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));\n    }, Eo.maxZoom.get = function () {\n      return this._maxZoom;\n    }, Eo.maxZoom.set = function (t) {\n      this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));\n    }, Eo.minPitch.get = function () {\n      return this._minPitch;\n    }, Eo.minPitch.set = function (t) {\n      this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));\n    }, Eo.maxPitch.get = function () {\n      return this._maxPitch;\n    }, Eo.maxPitch.set = function (t) {\n      this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));\n    }, Eo.renderWorldCopies.get = function () {\n      return this._renderWorldCopies;\n    }, Eo.renderWorldCopies.set = function (t) {\n      void 0 === t ? t = !0 : null === t && (t = !1), this._renderWorldCopies = t;\n    }, Eo.worldSize.get = function () {\n      return this.tileSize * this.scale;\n    }, Eo.centerOffset.get = function () {\n      return this.centerPoint._sub(this.size._div(2));\n    }, Eo.size.get = function () {\n      return new t.Point(this.width, this.height);\n    }, Eo.bearing.get = function () {\n      return -this.angle / Math.PI * 180;\n    }, Eo.bearing.set = function (e) {\n      var i = -t.wrap(e, -180, 180) * Math.PI / 180;\n      this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));\n    }, Eo.pitch.get = function () {\n      return this._pitch / Math.PI * 180;\n    }, Eo.pitch.set = function (e) {\n      var i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;\n      this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n    }, Eo.fov.get = function () {\n      return this._fov / Math.PI * 180;\n    }, Eo.fov.set = function (t) {\n      t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());\n    }, Eo.zoom.get = function () {\n      return this._zoom;\n    }, Eo.zoom.set = function (t) {\n      var e = Math.min(Math.max(t, this.minZoom), this.maxZoom);\n      this._zoom !== e && (this._unmodified = !1, this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom, this._constrain(), this._calcMatrices());\n    }, Eo.center.get = function () {\n      return this._center;\n    }, Eo.center.set = function (t) {\n      t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());\n    }, Eo.padding.get = function () {\n      return this._edgeInsets.toJSON();\n    }, Eo.padding.set = function (t) {\n      this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());\n    }, Eo.centerPoint.get = function () {\n      return this._edgeInsets.getCenter(this.width, this.height);\n    }, To.prototype.isPaddingEqual = function (t) {\n      return this._edgeInsets.equals(t);\n    }, To.prototype.interpolatePadding = function (t, e, i) {\n      this._unmodified = !1, this._edgeInsets.interpolate(t, e, i), this._constrain(), this._calcMatrices();\n    }, To.prototype.coveringZoomLevel = function (t) {\n      var e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));\n      return Math.max(0, e);\n    }, To.prototype.getVisibleUnwrappedCoordinates = function (e) {\n      var i = [new t.UnwrappedTileID(0, e)];\n      if (this._renderWorldCopies) for (var o = this.pointCoordinate(new t.Point(0, 0)), r = this.pointCoordinate(new t.Point(this.width, 0)), a = this.pointCoordinate(new t.Point(this.width, this.height)), n = this.pointCoordinate(new t.Point(0, this.height)), s = Math.floor(Math.min(o.x, r.x, a.x, n.x)), l = Math.floor(Math.max(o.x, r.x, a.x, n.x)), c = s - 1; c <= l + 1; c++) 0 !== c && i.push(new t.UnwrappedTileID(c, e));\n      return i;\n    }, To.prototype.coveringTiles = function (e) {\n      var i = this.coveringZoomLevel(e),\n        o = i;\n      if (void 0 !== e.minzoom && i < e.minzoom) return [];\n      void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);\n      var r = t.MercatorCoordinate.fromLngLat(this.center),\n        a = Math.pow(2, i),\n        n = [a * r.x, a * r.y, 0],\n        s = xo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i),\n        l = e.minzoom || 0;\n      this.pitch <= 60 && this._edgeInsets.top < .1 && (l = i);\n      var c = function (t) {\n          return {\n            aabb: new bo([t * a, 0, 0], [(t + 1) * a, a, 0]),\n            zoom: 0,\n            x: 0,\n            y: 0,\n            wrap: t,\n            fullyVisible: !1\n          };\n        },\n        u = [],\n        h = [],\n        p = i,\n        d = e.reparseOverscaled ? o : i;\n      if (this._renderWorldCopies) for (var _ = 1; _ <= 3; _++) u.push(c(-_)), u.push(c(_));\n      for (u.push(c(0)); u.length > 0;) {\n        var f = u.pop(),\n          m = f.x,\n          g = f.y,\n          v = f.fullyVisible;\n        if (!v) {\n          var y = f.aabb.intersects(s);\n          if (0 === y) continue;\n          v = 2 === y;\n        }\n        var x = f.aabb.distanceX(n),\n          b = f.aabb.distanceY(n),\n          w = Math.max(Math.abs(x), Math.abs(b));\n        if (f.zoom === p || w > 3 + (1 << p - f.zoom) - 2 && f.zoom >= l) h.push({\n          tileID: new t.OverscaledTileID(f.zoom === p ? d : f.zoom, f.wrap, f.zoom, m, g),\n          distanceSq: t.sqrLen([n[0] - .5 - m, n[1] - .5 - g])\n        });else for (var T = 0; T < 4; T++) {\n          var E = (m << 1) + T % 2,\n            I = (g << 1) + (T >> 1);\n          u.push({\n            aabb: f.aabb.quadrant(T),\n            zoom: f.zoom + 1,\n            x: E,\n            y: I,\n            wrap: f.wrap,\n            fullyVisible: v\n          });\n        }\n      }\n      return h.sort(function (t, e) {\n        return t.distanceSq - e.distanceSq;\n      }).map(function (t) {\n        return t.tileID;\n      });\n    }, To.prototype.resize = function (t, e) {\n      this.width = t, this.height = e, this.pixelsToGLUnits = [2 / t, -2 / e], this._constrain(), this._calcMatrices();\n    }, Eo.unmodified.get = function () {\n      return this._unmodified;\n    }, To.prototype.zoomScale = function (t) {\n      return Math.pow(2, t);\n    }, To.prototype.scaleZoom = function (t) {\n      return Math.log(t) / Math.LN2;\n    }, To.prototype.project = function (e) {\n      var i = t.clamp(e.lat, -this.maxValidLatitude, this.maxValidLatitude);\n      return new t.Point(t.mercatorXfromLng(e.lng) * this.worldSize, t.mercatorYfromLat(i) * this.worldSize);\n    }, To.prototype.unproject = function (e) {\n      return new t.MercatorCoordinate(e.x / this.worldSize, e.y / this.worldSize).toLngLat();\n    }, Eo.point.get = function () {\n      return this.project(this.center);\n    }, To.prototype.setLocationAtPoint = function (e, i) {\n      var o = this.pointCoordinate(i),\n        r = this.pointCoordinate(this.centerPoint),\n        a = this.locationCoordinate(e),\n        n = new t.MercatorCoordinate(a.x - (o.x - r.x), a.y - (o.y - r.y));\n      this.center = this.coordinateLocation(n), this._renderWorldCopies && (this.center = this.center.wrap());\n    }, To.prototype.locationPoint = function (t) {\n      return this.coordinatePoint(this.locationCoordinate(t));\n    }, To.prototype.pointLocation = function (t) {\n      return this.coordinateLocation(this.pointCoordinate(t));\n    }, To.prototype.locationCoordinate = function (e) {\n      return t.MercatorCoordinate.fromLngLat(e);\n    }, To.prototype.coordinateLocation = function (t) {\n      return t.toLngLat();\n    }, To.prototype.pointCoordinate = function (e) {\n      var i = [e.x, e.y, 0, 1],\n        o = [e.x, e.y, 1, 1];\n      t.transformMat4(i, i, this.pixelMatrixInverse), t.transformMat4(o, o, this.pixelMatrixInverse);\n      var r = i[3],\n        a = o[3],\n        n = i[1] / r,\n        s = o[1] / a,\n        l = i[2] / r,\n        c = o[2] / a,\n        u = l === c ? 0 : (0 - l) / (c - l);\n      return new t.MercatorCoordinate(t.number(i[0] / r, o[0] / a, u) / this.worldSize, t.number(n, s, u) / this.worldSize);\n    }, To.prototype.coordinatePoint = function (e) {\n      var i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n      return t.transformMat4(i, i, this.pixelMatrix), new t.Point(i[0] / i[3], i[1] / i[3]);\n    }, To.prototype.getBounds = function () {\n      return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));\n    }, To.prototype.getMaxBounds = function () {\n      return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;\n    }, To.prototype.setMaxBounds = function (t) {\n      t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);\n    }, To.prototype.calculatePosMatrix = function (e, i) {\n      void 0 === i && (i = !1);\n      var o = e.key,\n        r = i ? this._alignedPosMatrixCache : this._posMatrixCache;\n      if (r[o]) return r[o];\n      var a = e.canonical,\n        n = this.worldSize / this.zoomScale(a.z),\n        s = a.x + Math.pow(2, a.z) * e.wrap,\n        l = t.identity(new Float64Array(16));\n      return t.translate(l, l, [s * n, a.y * n, 0]), t.scale(l, l, [n / t.EXTENT, n / t.EXTENT, 1]), t.multiply(l, i ? this.alignedProjMatrix : this.projMatrix, l), r[o] = new Float32Array(l), r[o];\n    }, To.prototype.customLayerMatrix = function () {\n      return this.mercatorMatrix.slice();\n    }, To.prototype._constrain = function () {\n      if (this.center && this.width && this.height && !this._constraining) {\n        this._constraining = !0;\n        var e,\n          i,\n          o,\n          r,\n          a = -90,\n          n = 90,\n          s = -180,\n          l = 180,\n          c = this.size,\n          u = this._unmodified;\n        if (this.latRange) {\n          var h = this.latRange;\n          a = t.mercatorYfromLat(h[1]) * this.worldSize, e = (n = t.mercatorYfromLat(h[0]) * this.worldSize) - a < c.y ? c.y / (n - a) : 0;\n        }\n        if (this.lngRange) {\n          var p = this.lngRange;\n          s = t.mercatorXfromLng(p[0]) * this.worldSize, i = (l = t.mercatorXfromLng(p[1]) * this.worldSize) - s < c.x ? c.x / (l - s) : 0;\n        }\n        var d = this.point,\n          _ = Math.max(i || 0, e || 0);\n        if (_) return this.center = this.unproject(new t.Point(i ? (l + s) / 2 : d.x, e ? (n + a) / 2 : d.y)), this.zoom += this.scaleZoom(_), this._unmodified = u, void (this._constraining = !1);\n        if (this.latRange) {\n          var f = d.y,\n            m = c.y / 2;\n          f - m < a && (r = a + m), f + m > n && (r = n - m);\n        }\n        if (this.lngRange) {\n          var g = d.x,\n            v = c.x / 2;\n          g - v < s && (o = s + v), g + v > l && (o = l - v);\n        }\n        void 0 === o && void 0 === r || (this.center = this.unproject(new t.Point(void 0 !== o ? o : d.x, void 0 !== r ? r : d.y))), this._unmodified = u, this._constraining = !1;\n      }\n    }, To.prototype._calcMatrices = function () {\n      if (this.height) {\n        var e = this.centerOffset;\n        this.cameraToCenterDistance = .5 / Math.tan(this._fov / 2) * this.height;\n        var i = Math.PI / 2 + this._pitch,\n          o = this._fov * (.5 + e.y / this.height),\n          r = Math.sin(o) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i - o, .01, Math.PI - .01)),\n          a = this.point,\n          n = a.x,\n          s = a.y,\n          l = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * r + this.cameraToCenterDistance),\n          c = this.height / 50,\n          u = new Float64Array(16);\n        t.perspective(u, this._fov, this.width / this.height, c, l), u[8] = 2 * -e.x / this.width, u[9] = 2 * e.y / this.height, t.scale(u, u, [1, -1, 1]), t.translate(u, u, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u, u, this._pitch), t.rotateZ(u, u, this.angle), t.translate(u, u, [-n, -s, 0]), this.mercatorMatrix = t.scale([], u, [this.worldSize, this.worldSize, this.worldSize]), t.scale(u, u, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = u, this.invProjMatrix = t.invert([], this.projMatrix);\n        var h = this.width % 2 / 2,\n          p = this.height % 2 / 2,\n          d = Math.cos(this.angle),\n          _ = Math.sin(this.angle),\n          f = n - Math.round(n) + d * h + _ * p,\n          m = s - Math.round(s) + d * p + _ * h,\n          g = new Float64Array(u);\n        if (t.translate(g, g, [f > .5 ? f - 1 : f, m > .5 ? m - 1 : m, 0]), this.alignedProjMatrix = g, u = t.create(), t.scale(u, u, [this.width / 2, -this.height / 2, 1]), t.translate(u, u, [1, -1, 0]), this.labelPlaneMatrix = u, u = t.create(), t.scale(u, u, [1, -1, 1]), t.translate(u, u, [-1, -1, 0]), t.scale(u, u, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(u = t.invert(new Float64Array(16), this.pixelMatrix))) throw new Error("failed to invert matrix");\n        this.pixelMatrixInverse = u, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};\n      }\n    }, To.prototype.maxPitchScaleFactor = function () {\n      if (!this.pixelMatrixInverse) return 1;\n      var e = this.pointCoordinate(new t.Point(0, 0)),\n        i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];\n      return t.transformMat4(i, i, this.pixelMatrix)[3] / this.cameraToCenterDistance;\n    }, To.prototype.getCameraPoint = function () {\n      var e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n      return this.centerPoint.add(new t.Point(0, e));\n    }, To.prototype.getCameraQueryGeometry = function (e) {\n      var i = this.getCameraPoint();\n      if (1 === e.length) return [e[0], i];\n      for (var o = i.x, r = i.y, a = i.x, n = i.y, s = 0, l = e; s < l.length; s += 1) {\n        var c = l[s];\n        o = Math.min(o, c.x), r = Math.min(r, c.y), a = Math.max(a, c.x), n = Math.max(n, c.y);\n      }\n      return [new t.Point(o, r), new t.Point(a, r), new t.Point(a, n), new t.Point(o, n), new t.Point(o, r)];\n    }, Object.defineProperties(To.prototype, Eo);\n    var Io = function (e) {\n      var i, o, r, a;\n      this._hashName = e && encodeURIComponent(e), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i = this._updateHashUnthrottled.bind(this), o = !1, r = null, a = function () {\n        r = null, o && (i(), r = setTimeout(a, 300), o = !1);\n      }, function () {\n        return o = !0, r || a(), r;\n      });\n    };\n    Io.prototype.addTo = function (e) {\n      return this._map = e, t.window.addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;\n    }, Io.prototype.remove = function () {\n      return t.window.removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;\n    }, Io.prototype.getHashString = function (e) {\n      var i = this._map.getCenter(),\n        o = Math.round(100 * this._map.getZoom()) / 100,\n        r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n        a = Math.pow(10, r),\n        n = Math.round(i.lng * a) / a,\n        s = Math.round(i.lat * a) / a,\n        l = this._map.getBearing(),\n        c = this._map.getPitch(),\n        u = "";\n      if (u += e ? "/" + n + "/" + s + "/" + o : o + "/" + s + "/" + n, (l || c) && (u += "/" + Math.round(10 * l) / 10), c && (u += "/" + Math.round(c)), this._hashName) {\n        var h = this._hashName,\n          p = !1,\n          d = t.window.location.hash.slice(1).split("&").map(function (t) {\n            var e = t.split("=")[0];\n            return e === h ? (p = !0, e + "=" + u) : t;\n          }).filter(function (t) {\n            return t;\n          });\n        return p || d.push(h + "=" + u), "#" + d.join("&");\n      }\n      return "#" + u;\n    }, Io.prototype._getCurrentHash = function () {\n      var e,\n        i = this,\n        o = t.window.location.hash.replace("#", "");\n      return this._hashName ? (o.split("&").map(function (t) {\n        return t.split("=");\n      }).forEach(function (t) {\n        t[0] === i._hashName && (e = t);\n      }), (e && e[1] || "").split("/")) : o.split("/");\n    }, Io.prototype._onHashChange = function () {\n      var t = this._getCurrentHash();\n      if (t.length >= 3 && !t.some(function (t) {\n        return isNaN(t);\n      })) {\n        var e = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t[3] || 0) : this._map.getBearing();\n        return this._map.jumpTo({\n          center: [+t[2], +t[1]],\n          zoom: +t[0],\n          bearing: e,\n          pitch: +(t[4] || 0)\n        }), !0;\n      }\n      return !1;\n    }, Io.prototype._updateHashUnthrottled = function () {\n      var e = t.window.location.href.replace(/(#.+)?$/, this.getHashString());\n      try {\n        t.window.history.replaceState(t.window.history.state, null, e);\n      } catch (t) {}\n    };\n    var Po = {\n        linearity: .3,\n        easing: t.bezier(0, 0, .3, 1)\n      },\n      So = t.extend({\n        deceleration: 2500,\n        maxSpeed: 1400\n      }, Po),\n      Co = t.extend({\n        deceleration: 20,\n        maxSpeed: 1400\n      }, Po),\n      zo = t.extend({\n        deceleration: 1e3,\n        maxSpeed: 360\n      }, Po),\n      Do = t.extend({\n        deceleration: 1e3,\n        maxSpeed: 90\n      }, Po),\n      Ao = function (t) {\n        this._map = t, this.clear();\n      };\n    function Mo(t, e) {\n      (!t.duration || t.duration < e.duration) && (t.duration = e.duration, t.easing = e.easing);\n    }\n    function Lo(e, i, o) {\n      var r = o.maxSpeed,\n        a = o.linearity,\n        n = o.deceleration,\n        s = t.clamp(e * a / (i / 1e3), -r, r),\n        l = Math.abs(s) / (n * a);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: s * (l / 2)\n      };\n    }\n    Ao.prototype.clear = function () {\n      this._inertiaBuffer = [];\n    }, Ao.prototype.record = function (e) {\n      this._drainInertiaBuffer(), this._inertiaBuffer.push({\n        time: t.browser.now(),\n        settings: e\n      });\n    }, Ao.prototype._drainInertiaBuffer = function () {\n      for (var e = this._inertiaBuffer, i = t.browser.now(); e.length > 0 && i - e[0].time > 160;) e.shift();\n    }, Ao.prototype._onMoveEnd = function (e) {\n      if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {\n        for (var i = {\n            zoom: 0,\n            bearing: 0,\n            pitch: 0,\n            pan: new t.Point(0, 0),\n            pinchAround: void 0,\n            around: void 0\n          }, o = 0, r = this._inertiaBuffer; o < r.length; o += 1) {\n          var a = r[o].settings;\n          i.zoom += a.zoomDelta || 0, i.bearing += a.bearingDelta || 0, i.pitch += a.pitchDelta || 0, a.panDelta && i.pan._add(a.panDelta), a.around && (i.around = a.around), a.pinchAround && (i.pinchAround = a.pinchAround);\n        }\n        var n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n          s = {};\n        if (i.pan.mag()) {\n          var l = Lo(i.pan.mag(), n, t.extend({}, So, e || {}));\n          s.offset = i.pan.mult(l.amount / i.pan.mag()), s.center = this._map.transform.center, Mo(s, l);\n        }\n        if (i.zoom) {\n          var c = Lo(i.zoom, n, Co);\n          s.zoom = this._map.transform.zoom + c.amount, Mo(s, c);\n        }\n        if (i.bearing) {\n          var u = Lo(i.bearing, n, zo);\n          s.bearing = this._map.transform.bearing + t.clamp(u.amount, -179, 179), Mo(s, u);\n        }\n        if (i.pitch) {\n          var h = Lo(i.pitch, n, Do);\n          s.pitch = this._map.transform.pitch + h.amount, Mo(s, h);\n        }\n        if (s.zoom || s.bearing) {\n          var p = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          s.around = p ? this._map.unproject(p) : this._map.getCenter();\n        }\n        return this.clear(), t.extend(s, {\n          noMoveStart: !0\n        });\n      }\n    };\n    var Ro = function (e) {\n        function o(o, r, a, n) {\n          void 0 === n && (n = {});\n          var s = i.mousePos(r.getCanvasContainer(), a),\n            l = r.unproject(s);\n          e.call(this, o, t.extend({\n            point: s,\n            lngLat: l,\n            originalEvent: a\n          }, n)), this._defaultPrevented = !1, this.target = r;\n        }\n        e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o;\n        var r = {\n          defaultPrevented: {\n            configurable: !0\n          }\n        };\n        return o.prototype.preventDefault = function () {\n          this._defaultPrevented = !0;\n        }, r.defaultPrevented.get = function () {\n          return this._defaultPrevented;\n        }, Object.defineProperties(o.prototype, r), o;\n      }(t.Event),\n      ko = function (e) {\n        function o(o, r, a) {\n          var n = "touchend" === o ? a.changedTouches : a.touches,\n            s = i.touchPos(r.getCanvasContainer(), n),\n            l = s.map(function (t) {\n              return r.unproject(t);\n            }),\n            c = s.reduce(function (t, e, i, o) {\n              return t.add(e.div(o.length));\n            }, new t.Point(0, 0)),\n            u = r.unproject(c);\n          e.call(this, o, {\n            points: s,\n            point: c,\n            lngLats: l,\n            lngLat: u,\n            originalEvent: a\n          }), this._defaultPrevented = !1;\n        }\n        e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o;\n        var r = {\n          defaultPrevented: {\n            configurable: !0\n          }\n        };\n        return o.prototype.preventDefault = function () {\n          this._defaultPrevented = !0;\n        }, r.defaultPrevented.get = function () {\n          return this._defaultPrevented;\n        }, Object.defineProperties(o.prototype, r), o;\n      }(t.Event),\n      Bo = function (t) {\n        function e(e, i, o) {\n          t.call(this, e, {\n            originalEvent: o\n          }), this._defaultPrevented = !1;\n        }\n        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;\n        var i = {\n          defaultPrevented: {\n            configurable: !0\n          }\n        };\n        return e.prototype.preventDefault = function () {\n          this._defaultPrevented = !0;\n        }, i.defaultPrevented.get = function () {\n          return this._defaultPrevented;\n        }, Object.defineProperties(e.prototype, i), e;\n      }(t.Event),\n      Oo = function (t, e) {\n        this._map = t, this._clickTolerance = e.clickTolerance;\n      };\n    Oo.prototype.reset = function () {\n      delete this._mousedownPos;\n    }, Oo.prototype.wheel = function (t) {\n      return this._firePreventable(new Bo(t.type, this._map, t));\n    }, Oo.prototype.mousedown = function (t, e) {\n      return this._mousedownPos = e, this._firePreventable(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseup = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.click = function (t, e) {\n      this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.dblclick = function (t) {\n      return this._firePreventable(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseover = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.mouseout = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Oo.prototype.touchstart = function (t) {\n      return this._firePreventable(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchmove = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchend = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype.touchcancel = function (t) {\n      this._map.fire(new ko(t.type, this._map, t));\n    }, Oo.prototype._firePreventable = function (t) {\n      if (this._map.fire(t), t.defaultPrevented) return {};\n    }, Oo.prototype.isEnabled = function () {\n      return !0;\n    }, Oo.prototype.isActive = function () {\n      return !1;\n    }, Oo.prototype.enable = function () {}, Oo.prototype.disable = function () {};\n    var Fo = function (t) {\n      this._map = t;\n    };\n    Fo.prototype.reset = function () {\n      this._delayContextMenu = !1, delete this._contextMenuEvent;\n    }, Fo.prototype.mousemove = function (t) {\n      this._map.fire(new Ro(t.type, this._map, t));\n    }, Fo.prototype.mousedown = function () {\n      this._delayContextMenu = !0;\n    }, Fo.prototype.mouseup = function () {\n      this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ro("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n    }, Fo.prototype.contextmenu = function (t) {\n      this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Ro(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();\n    }, Fo.prototype.isEnabled = function () {\n      return !0;\n    }, Fo.prototype.isActive = function () {\n      return !1;\n    }, Fo.prototype.enable = function () {}, Fo.prototype.disable = function () {};\n    var Uo = function (t, e) {\n      this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = e.clickTolerance || 1;\n    };\n    function No(t, e) {\n      for (var i = {}, o = 0; o < t.length; o++) i[t[o].identifier] = e[o];\n      return i;\n    }\n    Uo.prototype.isEnabled = function () {\n      return !!this._enabled;\n    }, Uo.prototype.isActive = function () {\n      return !!this._active;\n    }, Uo.prototype.enable = function () {\n      this.isEnabled() || (this._enabled = !0);\n    }, Uo.prototype.disable = function () {\n      this.isEnabled() && (this._enabled = !1);\n    }, Uo.prototype.mousedown = function (t, e) {\n      this.isEnabled() && t.shiftKey && 0 === t.button && (i.disableDrag(), this._startPos = this._lastPos = e, this._active = !0);\n    }, Uo.prototype.mousemoveWindow = function (t, e) {\n      if (this._active) {\n        var o = e;\n        if (!(this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance)) {\n          var r = this._startPos;\n          this._lastPos = o, this._box || (this._box = i.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));\n          var a = Math.min(r.x, o.x),\n            n = Math.max(r.x, o.x),\n            s = Math.min(r.y, o.y),\n            l = Math.max(r.y, o.y);\n          i.setTransform(this._box, "translate(" + a + "px," + s + "px)"), this._box.style.width = n - a + "px", this._box.style.height = l - s + "px";\n        }\n      }\n    }, Uo.prototype.mouseupWindow = function (e, o) {\n      var r = this;\n      if (this._active && 0 === e.button) {\n        var a = this._startPos,\n          n = o;\n        if (this.reset(), i.suppressClick(), a.x !== n.x || a.y !== n.y) return this._map.fire(new t.Event("boxzoomend", {\n          originalEvent: e\n        })), {\n          cameraAnimation: function (t) {\n            return t.fitScreenCoordinates(a, n, r._map.getBearing(), {\n              linear: !0\n            });\n          }\n        };\n        this._fireEvent("boxzoomcancel", e);\n      }\n    }, Uo.prototype.keydown = function (t) {\n      this._active && 27 === t.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t));\n    }, Uo.prototype.reset = function () {\n      this._active = !1, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos;\n    }, Uo.prototype._fireEvent = function (e, i) {\n      return this._map.fire(new t.Event(e, {\n        originalEvent: i\n      }));\n    };\n    var Zo = function (t) {\n      this.reset(), this.numTouches = t.numTouches;\n    };\n    Zo.prototype.reset = function () {\n      delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;\n    }, Zo.prototype.touchstart = function (e, i, o) {\n      (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function (e) {\n        for (var i = new t.Point(0, 0), o = 0, r = e; o < r.length; o += 1) i._add(r[o]);\n        return i.div(e.length);\n      }(i), this.touches = No(o, i)));\n    }, Zo.prototype.touchmove = function (t, e, i) {\n      if (!this.aborted && this.centroid) {\n        var o = No(i, e);\n        for (var r in this.touches) {\n          var a = o[r];\n          (!a || a.dist(this.touches[r]) > 30) && (this.aborted = !0);\n        }\n      }\n    }, Zo.prototype.touchend = function (t, e, i) {\n      if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n        var o = !this.aborted && this.centroid;\n        if (this.reset(), o) return o;\n      }\n    };\n    var qo = function (t) {\n      this.singleTap = new Zo(t), this.numTaps = t.numTaps, this.reset();\n    };\n    qo.prototype.reset = function () {\n      this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();\n    }, qo.prototype.touchstart = function (t, e, i) {\n      this.singleTap.touchstart(t, e, i);\n    }, qo.prototype.touchmove = function (t, e, i) {\n      this.singleTap.touchmove(t, e, i);\n    }, qo.prototype.touchend = function (t, e, i) {\n      var o = this.singleTap.touchend(t, e, i);\n      if (o) {\n        var r = t.timeStamp - this.lastTime < 500,\n          a = !this.lastTap || this.lastTap.dist(o) < 30;\n        if (r && a || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n      }\n    };\n    var jo = function () {\n      this._zoomIn = new qo({\n        numTouches: 1,\n        numTaps: 2\n      }), this._zoomOut = new qo({\n        numTouches: 2,\n        numTaps: 1\n      }), this.reset();\n    };\n    jo.prototype.reset = function () {\n      this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n    }, jo.prototype.touchstart = function (t, e, i) {\n      this._zoomIn.touchstart(t, e, i), this._zoomOut.touchstart(t, e, i);\n    }, jo.prototype.touchmove = function (t, e, i) {\n      this._zoomIn.touchmove(t, e, i), this._zoomOut.touchmove(t, e, i);\n    }, jo.prototype.touchend = function (t, e, i) {\n      var o = this,\n        r = this._zoomIn.touchend(t, e, i),\n        a = this._zoomOut.touchend(t, e, i);\n      return r ? (this._active = !0, t.preventDefault(), setTimeout(function () {\n        return o.reset();\n      }, 0), {\n        cameraAnimation: function (e) {\n          return e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() + 1,\n            around: e.unproject(r)\n          }, {\n            originalEvent: t\n          });\n        }\n      }) : a ? (this._active = !0, t.preventDefault(), setTimeout(function () {\n        return o.reset();\n      }, 0), {\n        cameraAnimation: function (e) {\n          return e.easeTo({\n            duration: 300,\n            zoom: e.getZoom() - 1,\n            around: e.unproject(a)\n          }, {\n            originalEvent: t\n          });\n        }\n      }) : void 0;\n    }, jo.prototype.touchcancel = function () {\n      this.reset();\n    }, jo.prototype.enable = function () {\n      this._enabled = !0;\n    }, jo.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, jo.prototype.isEnabled = function () {\n      return this._enabled;\n    }, jo.prototype.isActive = function () {\n      return this._active;\n    };\n    var Vo = {\n        0: 1,\n        2: 2\n      },\n      Go = function (t) {\n        this.reset(), this._clickTolerance = t.clickTolerance || 1;\n      };\n    Go.prototype.reset = function () {\n      this._active = !1, this._moved = !1, delete this._lastPoint, delete this._eventButton;\n    }, Go.prototype._correctButton = function (t, e) {\n      return !1;\n    }, Go.prototype._move = function (t, e) {\n      return {};\n    }, Go.prototype.mousedown = function (t, e) {\n      if (!this._lastPoint) {\n        var o = i.mouseButton(t);\n        this._correctButton(t, o) && (this._lastPoint = e, this._eventButton = o);\n      }\n    }, Go.prototype.mousemoveWindow = function (t, e) {\n      var i = this._lastPoint;\n      if (i) if (t.preventDefault(), function (t, e) {\n        var i = Vo[e];\n        return void 0 === t.buttons || (t.buttons & i) !== i;\n      }(t, this._eventButton)) this.reset();else if (this._moved || !(e.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = e, this._move(i, e);\n    }, Go.prototype.mouseupWindow = function (t) {\n      this._lastPoint && i.mouseButton(t) === this._eventButton && (this._moved && i.suppressClick(), this.reset());\n    }, Go.prototype.enable = function () {\n      this._enabled = !0;\n    }, Go.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Go.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Go.prototype.isActive = function () {\n      return this._active;\n    };\n    var Wo = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.mousedown = function (e, i) {\n          t.prototype.mousedown.call(this, e, i), this._lastPoint && (this._active = !0);\n        }, e.prototype._correctButton = function (t, e) {\n          return 0 === e && !t.ctrlKey;\n        }, e.prototype._move = function (t, e) {\n          return {\n            around: e,\n            panDelta: e.sub(t)\n          };\n        }, e;\n      }(Go),\n      Xo = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) {\n          return 0 === e && t.ctrlKey || 2 === e;\n        }, e.prototype._move = function (t, e) {\n          var i = .8 * (e.x - t.x);\n          if (i) return this._active = !0, {\n            bearingDelta: i\n          };\n        }, e.prototype.contextmenu = function (t) {\n          t.preventDefault();\n        }, e;\n      }(Go),\n      Ho = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype._correctButton = function (t, e) {\n          return 0 === e && t.ctrlKey || 2 === e;\n        }, e.prototype._move = function (t, e) {\n          var i = -.5 * (e.y - t.y);\n          if (i) return this._active = !0, {\n            pitchDelta: i\n          };\n        }, e.prototype.contextmenu = function (t) {\n          t.preventDefault();\n        }, e;\n      }(Go),\n      Ko = function (t) {\n        this._minTouches = 1, this._clickTolerance = t.clickTolerance || 1, this.reset();\n      };\n    Ko.prototype.reset = function () {\n      this._active = !1, this._touches = {}, this._sum = new t.Point(0, 0);\n    }, Ko.prototype.touchstart = function (t, e, i) {\n      return this._calculateTransform(t, e, i);\n    }, Ko.prototype.touchmove = function (t, e, i) {\n      if (this._active && !(i.length < this._minTouches)) return t.preventDefault(), this._calculateTransform(t, e, i);\n    }, Ko.prototype.touchend = function (t, e, i) {\n      this._calculateTransform(t, e, i), this._active && i.length < this._minTouches && this.reset();\n    }, Ko.prototype.touchcancel = function () {\n      this.reset();\n    }, Ko.prototype._calculateTransform = function (e, i, o) {\n      o.length > 0 && (this._active = !0);\n      var r = No(o, i),\n        a = new t.Point(0, 0),\n        n = new t.Point(0, 0),\n        s = 0;\n      for (var l in r) {\n        var c = r[l],\n          u = this._touches[l];\n        u && (a._add(c), n._add(c.sub(u)), s++, r[l] = c);\n      }\n      if (this._touches = r, !(s < this._minTouches) && n.mag()) {\n        var h = n.div(s);\n        if (this._sum._add(h), !(this._sum.mag() < this._clickTolerance)) return {\n          around: a.div(s),\n          panDelta: h\n        };\n      }\n    }, Ko.prototype.enable = function () {\n      this._enabled = !0;\n    }, Ko.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Ko.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Ko.prototype.isActive = function () {\n      return this._active;\n    };\n    var Yo = function () {\n      this.reset();\n    };\n    function Jo(t, e, i) {\n      for (var o = 0; o < t.length; o++) if (t[o].identifier === i) return e[o];\n    }\n    function Qo(t, e) {\n      return Math.log(t / e) / Math.LN2;\n    }\n    Yo.prototype.reset = function () {\n      this._active = !1, delete this._firstTwoTouches;\n    }, Yo.prototype._start = function (t) {}, Yo.prototype._move = function (t, e, i) {\n      return {};\n    }, Yo.prototype.touchstart = function (t, e, i) {\n      this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([e[0], e[1]]));\n    }, Yo.prototype.touchmove = function (t, e, i) {\n      if (this._firstTwoTouches) {\n        t.preventDefault();\n        var o = this._firstTwoTouches,\n          r = o[1],\n          a = Jo(i, e, o[0]),\n          n = Jo(i, e, r);\n        if (a && n) {\n          var s = this._aroundCenter ? null : a.add(n).div(2);\n          return this._move([a, n], s, t);\n        }\n      }\n    }, Yo.prototype.touchend = function (t, e, o) {\n      if (this._firstTwoTouches) {\n        var r = this._firstTwoTouches,\n          a = r[1],\n          n = Jo(o, e, r[0]),\n          s = Jo(o, e, a);\n        n && s || (this._active && i.suppressClick(), this.reset());\n      }\n    }, Yo.prototype.touchcancel = function () {\n      this.reset();\n    }, Yo.prototype.enable = function (t) {\n      this._enabled = !0, this._aroundCenter = !!t && "center" === t.around;\n    }, Yo.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, Yo.prototype.isEnabled = function () {\n      return this._enabled;\n    }, Yo.prototype.isActive = function () {\n      return this._active;\n    };\n    var $o = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), delete this._distance, delete this._startDistance;\n      }, e.prototype._start = function (t) {\n        this._startDistance = this._distance = t[0].dist(t[1]);\n      }, e.prototype._move = function (t, e) {\n        var i = this._distance;\n        if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Qo(this._distance, i),\n          pinchAround: e\n        };\n      }, e;\n    }(Yo);\n    function tr(t, e) {\n      return 180 * t.angleWith(e) / Math.PI;\n    }\n    var er = function (t) {\n      function e() {\n        t.apply(this, arguments);\n      }\n      return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n        t.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;\n      }, e.prototype._start = function (t) {\n        this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);\n      }, e.prototype._move = function (t, e) {\n        var i = this._vector;\n        if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {\n          bearingDelta: tr(this._vector, i),\n          pinchAround: e\n        };\n      }, e.prototype._isBelowThreshold = function (t) {\n        this._minDiameter = Math.min(this._minDiameter, t.mag());\n        var e = 25 / (Math.PI * this._minDiameter) * 360,\n          i = tr(t, this._startVector);\n        return Math.abs(i) < e;\n      }, e;\n    }(Yo);\n    function ir(t) {\n      return Math.abs(t.y) > Math.abs(t.x);\n    }\n    var or = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e.prototype.reset = function () {\n          t.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;\n        }, e.prototype._start = function (t) {\n          this._lastPoints = t, ir(t[0].sub(t[1])) && (this._valid = !1);\n        }, e.prototype._move = function (t, e, i) {\n          var o = t[0].sub(this._lastPoints[0]),\n            r = t[1].sub(this._lastPoints[1]);\n          if (this._valid = this.gestureBeginsVertically(o, r, i.timeStamp), this._valid) return this._lastPoints = t, this._active = !0, {\n            pitchDelta: (o.y + r.y) / 2 * -.5\n          };\n        }, e.prototype.gestureBeginsVertically = function (t, e, i) {\n          if (void 0 !== this._valid) return this._valid;\n          var o = t.mag() >= 2,\n            r = e.mag() >= 2;\n          if (o || r) {\n            if (!o || !r) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n            var a = t.y > 0 == e.y > 0;\n            return ir(t) && ir(e) && a;\n          }\n        }, e;\n      }(Yo),\n      rr = {\n        panStep: 100,\n        bearingStep: 15,\n        pitchStep: 10\n      },\n      ar = function () {\n        var t = rr;\n        this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;\n      };\n    function nr(t) {\n      return t * (2 - t);\n    }\n    ar.prototype.reset = function () {\n      this._active = !1;\n    }, ar.prototype.keydown = function (t) {\n      var e = this;\n      if (!(t.altKey || t.ctrlKey || t.metaKey)) {\n        var i = 0,\n          o = 0,\n          r = 0,\n          a = 0,\n          n = 0;\n        switch (t.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            i = 1;\n            break;\n          case 189:\n          case 109:\n          case 173:\n            i = -1;\n            break;\n          case 37:\n            t.shiftKey ? o = -1 : (t.preventDefault(), a = -1);\n            break;\n          case 39:\n            t.shiftKey ? o = 1 : (t.preventDefault(), a = 1);\n            break;\n          case 38:\n            t.shiftKey ? r = 1 : (t.preventDefault(), n = -1);\n            break;\n          case 40:\n            t.shiftKey ? r = -1 : (t.preventDefault(), n = 1);\n            break;\n          default:\n            return;\n        }\n        return this._rotationDisabled && (o = 0, r = 0), {\n          cameraAnimation: function (s) {\n            var l = s.getZoom();\n            s.easeTo({\n              duration: 300,\n              easeId: "keyboardHandler",\n              easing: nr,\n              zoom: i ? Math.round(l) + i * (t.shiftKey ? 2 : 1) : l,\n              bearing: s.getBearing() + o * e._bearingStep,\n              pitch: s.getPitch() + r * e._pitchStep,\n              offset: [-a * e._panStep, -n * e._panStep],\n              center: s.getCenter()\n            }, {\n              originalEvent: t\n            });\n          }\n        };\n      }\n    }, ar.prototype.enable = function () {\n      this._enabled = !0;\n    }, ar.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, ar.prototype.isEnabled = function () {\n      return this._enabled;\n    }, ar.prototype.isActive = function () {\n      return this._active;\n    }, ar.prototype.disableRotation = function () {\n      this._rotationDisabled = !0;\n    }, ar.prototype.enableRotation = function () {\n      this._rotationDisabled = !1;\n    };\n    var sr = function (e, i) {\n      this._map = e, this._el = e.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this);\n    };\n    sr.prototype.setZoomRate = function (t) {\n      this._defaultZoomRate = t;\n    }, sr.prototype.setWheelZoomRate = function (t) {\n      this._wheelZoomRate = t;\n    }, sr.prototype.isEnabled = function () {\n      return !!this._enabled;\n    }, sr.prototype.isActive = function () {\n      return !!this._active || void 0 !== this._finishTimeout;\n    }, sr.prototype.isZooming = function () {\n      return !!this._zooming;\n    }, sr.prototype.enable = function (t) {\n      this.isEnabled() || (this._enabled = !0, this._aroundCenter = t && "center" === t.around);\n    }, sr.prototype.disable = function () {\n      this.isEnabled() && (this._enabled = !1);\n    }, sr.prototype.wheel = function (e) {\n      if (this.isEnabled()) {\n        var i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY,\n          o = t.browser.now(),\n          r = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault();\n      }\n    }, sr.prototype._onTimeout = function (t) {\n      this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);\n    }, sr.prototype._start = function (e) {\n      if (this._delta) {\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        var o = i.mousePos(this._el, e);\n        this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n    }, sr.prototype.renderFrame = function () {\n      var e = this;\n      if (this._frameId && (this._frameId = null, this.isActive())) {\n        var i = this._map.transform;\n        if (0 !== this._delta) {\n          var o = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate,\n            r = 2 / (1 + Math.exp(-Math.abs(this._delta * o)));\n          this._delta < 0 && 0 !== r && (r = 1 / r);\n          var a = "number" == typeof this._targetZoom ? i.zoomScale(this._targetZoom) : i.scale;\n          this._targetZoom = Math.min(i.maxZoom, Math.max(i.minZoom, i.scaleZoom(a * r))), "wheel" === this._type && (this._startZoom = i.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;\n        }\n        var n,\n          s = "number" == typeof this._targetZoom ? this._targetZoom : i.zoom,\n          l = this._startZoom,\n          c = this._easing,\n          u = !1;\n        if ("wheel" === this._type && l && c) {\n          var h = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1),\n            p = c(h);\n          n = t.number(l, s, p), h < 1 ? this._frameId || (this._frameId = !0) : u = !0;\n        } else n = s, u = !0;\n        return this._active = !0, u && (this._active = !1, this._finishTimeout = setTimeout(function () {\n          e._zooming = !1, e._handler._triggerRenderFrame(), delete e._targetZoom, delete e._finishTimeout;\n        }, 200)), {\n          noInertia: !0,\n          needsRenderFrame: !u,\n          zoomDelta: n - i.zoom,\n          around: this._aroundPoint,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n    }, sr.prototype._smoothOutEasing = function (e) {\n      var i = t.ease;\n      if (this._prevEase) {\n        var o = this._prevEase,\n          r = (t.browser.now() - o.start) / o.duration,\n          a = o.easing(r + .01) - o.easing(r),\n          n = .27 / Math.sqrt(a * a + 1e-4) * .01,\n          s = Math.sqrt(.0729 - n * n);\n        i = t.bezier(n, s, .25, 1);\n      }\n      return this._prevEase = {\n        start: t.browser.now(),\n        duration: e,\n        easing: i\n      }, i;\n    }, sr.prototype.reset = function () {\n      this._active = !1;\n    };\n    var lr = function (t, e) {\n      this._clickZoom = t, this._tapZoom = e;\n    };\n    lr.prototype.enable = function () {\n      this._clickZoom.enable(), this._tapZoom.enable();\n    }, lr.prototype.disable = function () {\n      this._clickZoom.disable(), this._tapZoom.disable();\n    }, lr.prototype.isEnabled = function () {\n      return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n    }, lr.prototype.isActive = function () {\n      return this._clickZoom.isActive() || this._tapZoom.isActive();\n    };\n    var cr = function () {\n      this.reset();\n    };\n    cr.prototype.reset = function () {\n      this._active = !1;\n    }, cr.prototype.dblclick = function (t, e) {\n      return t.preventDefault(), {\n        cameraAnimation: function (i) {\n          i.easeTo({\n            duration: 300,\n            zoom: i.getZoom() + (t.shiftKey ? -1 : 1),\n            around: i.unproject(e)\n          }, {\n            originalEvent: t\n          });\n        }\n      };\n    }, cr.prototype.enable = function () {\n      this._enabled = !0;\n    }, cr.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, cr.prototype.isEnabled = function () {\n      return this._enabled;\n    }, cr.prototype.isActive = function () {\n      return this._active;\n    };\n    var ur = function () {\n      this._tap = new qo({\n        numTouches: 1,\n        numTaps: 1\n      }), this.reset();\n    };\n    ur.prototype.reset = function () {\n      this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();\n    }, ur.prototype.touchstart = function (t, e, i) {\n      this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = e[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i));\n    }, ur.prototype.touchmove = function (t, e, i) {\n      if (this._tapTime) {\n        if (this._swipePoint) {\n          if (i[0].identifier !== this._swipeTouch) return;\n          var o = e[0],\n            r = o.y - this._swipePoint.y;\n          return this._swipePoint = o, t.preventDefault(), this._active = !0, {\n            zoomDelta: r / 128\n          };\n        }\n      } else this._tap.touchmove(t, e, i);\n    }, ur.prototype.touchend = function (t, e, i) {\n      this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp);\n    }, ur.prototype.touchcancel = function () {\n      this.reset();\n    }, ur.prototype.enable = function () {\n      this._enabled = !0;\n    }, ur.prototype.disable = function () {\n      this._enabled = !1, this.reset();\n    }, ur.prototype.isEnabled = function () {\n      return this._enabled;\n    }, ur.prototype.isActive = function () {\n      return this._active;\n    };\n    var hr = function (t, e, i) {\n      this._el = t, this._mousePan = e, this._touchPan = i;\n    };\n    hr.prototype.enable = function (t) {\n      this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");\n    }, hr.prototype.disable = function () {\n      this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");\n    }, hr.prototype.isEnabled = function () {\n      return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n    }, hr.prototype.isActive = function () {\n      return this._mousePan.isActive() || this._touchPan.isActive();\n    };\n    var pr = function (t, e, i) {\n      this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = e, this._mousePitch = i;\n    };\n    pr.prototype.enable = function () {\n      this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n    }, pr.prototype.disable = function () {\n      this._mouseRotate.disable(), this._mousePitch.disable();\n    }, pr.prototype.isEnabled = function () {\n      return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n    }, pr.prototype.isActive = function () {\n      return this._mouseRotate.isActive() || this._mousePitch.isActive();\n    };\n    var dr = function (t, e, i, o) {\n      this._el = t, this._touchZoom = e, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n    };\n    dr.prototype.enable = function (t) {\n      this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");\n    }, dr.prototype.disable = function () {\n      this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");\n    }, dr.prototype.isEnabled = function () {\n      return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n    }, dr.prototype.isActive = function () {\n      return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n    }, dr.prototype.disableRotation = function () {\n      this._rotationDisabled = !0, this._touchRotate.disable();\n    }, dr.prototype.enableRotation = function () {\n      this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n    };\n    var _r = function (t) {\n        return t.zoom || t.drag || t.pitch || t.rotate;\n      },\n      fr = function (t) {\n        function e() {\n          t.apply(this, arguments);\n        }\n        return t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e, e;\n      }(t.Event);\n    function mr(t) {\n      return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta;\n    }\n    var gr = function (e, o) {\n      this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao(e), this._bearingSnap = o.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o), t.bindAll(["handleEvent", "handleWindowEvent"], this);\n      var r = this._el;\n      this._listeners = [[r, "touchstart", {\n        passive: !0\n      }], [r, "touchmove", {\n        passive: !1\n      }], [r, "touchend", void 0], [r, "touchcancel", void 0], [r, "mousedown", void 0], [r, "mousemove", void 0], [r, "mouseup", void 0], [t.window.document, "mousemove", {\n        capture: !0\n      }], [t.window.document, "mouseup", void 0], [r, "mouseover", void 0], [r, "mouseout", void 0], [r, "dblclick", void 0], [r, "click", void 0], [r, "keydown", {\n        capture: !1\n      }], [r, "keyup", void 0], [r, "wheel", {\n        passive: !1\n      }], [r, "contextmenu", void 0], [t.window, "blur", void 0]];\n      for (var a = 0, n = this._listeners; a < n.length; a += 1) {\n        var s = n[a],\n          l = s[0];\n        i.addEventListener(l, s[1], l === t.window.document ? this.handleWindowEvent : this.handleEvent, s[2]);\n      }\n    };\n    gr.prototype.destroy = function () {\n      for (var e = 0, o = this._listeners; e < o.length; e += 1) {\n        var r = o[e],\n          a = r[0];\n        i.removeEventListener(a, r[1], a === t.window.document ? this.handleWindowEvent : this.handleEvent, r[2]);\n      }\n    }, gr.prototype._addDefaultHandlers = function (t) {\n      var e = this._map,\n        i = e.getCanvasContainer();\n      this._add("mapEvent", new Oo(e, t));\n      var o = e.boxZoom = new Uo(e, t);\n      this._add("boxZoom", o);\n      var r = new jo(),\n        a = new cr();\n      e.doubleClickZoom = new lr(a, r), this._add("tapZoom", r), this._add("clickZoom", a);\n      var n = new ur();\n      this._add("tapDragZoom", n);\n      var s = e.touchPitch = new or();\n      this._add("touchPitch", s);\n      var l = new Xo(t),\n        c = new Ho(t);\n      e.dragRotate = new pr(t, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);\n      var u = new Wo(t),\n        h = new Ko(t);\n      e.dragPan = new hr(i, u, h), this._add("mousePan", u), this._add("touchPan", h, ["touchZoom", "touchRotate"]);\n      var p = new er(),\n        d = new $o();\n      e.touchZoomRotate = new dr(i, d, p, n), this._add("touchRotate", p, ["touchPan", "touchZoom"]), this._add("touchZoom", d, ["touchPan", "touchRotate"]);\n      var _ = e.scrollZoom = new sr(e, this);\n      this._add("scrollZoom", _, ["mousePan"]);\n      var f = e.keyboard = new ar();\n      this._add("keyboard", f), this._add("blockableMapEvent", new Fo(e));\n      for (var m = 0, g = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; m < g.length; m += 1) {\n        var v = g[m];\n        t.interactive && t[v] && e[v].enable(t[v]);\n      }\n    }, gr.prototype._add = function (t, e, i) {\n      this._handlers.push({\n        handlerName: t,\n        handler: e,\n        allowed: i\n      }), this._handlersById[t] = e;\n    }, gr.prototype.stop = function (t) {\n      if (!this._updatingCamera) {\n        for (var e = 0, i = this._handlers; e < i.length; e += 1) i[e].handler.reset();\n        this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];\n      }\n    }, gr.prototype.isActive = function () {\n      for (var t = 0, e = this._handlers; t < e.length; t += 1) if (e[t].handler.isActive()) return !0;\n      return !1;\n    }, gr.prototype.isZooming = function () {\n      return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n    }, gr.prototype.isRotating = function () {\n      return !!this._eventsInProgress.rotate;\n    }, gr.prototype.isMoving = function () {\n      return Boolean(_r(this._eventsInProgress)) || this.isZooming();\n    }, gr.prototype._blockedByActive = function (t, e, i) {\n      for (var o in t) if (o !== i && (!e || e.indexOf(o) < 0)) return !0;\n      return !1;\n    }, gr.prototype.handleWindowEvent = function (t) {\n      this.handleEvent(t, t.type + "Window");\n    }, gr.prototype._getMapTouches = function (t) {\n      for (var e = [], i = 0, o = t; i < o.length; i += 1) {\n        var r = o[i];\n        this._el.contains(r.target) && e.push(r);\n      }\n      return e;\n    }, gr.prototype.handleEvent = function (t, e) {\n      if ("blur" !== t.type) {\n        this._updatingCamera = !0;\n        for (var o = "renderFrame" === t.type ? void 0 : t, r = {\n            needsRenderFrame: !1\n          }, a = {}, n = {}, s = t.touches ? this._getMapTouches(t.touches) : void 0, l = s ? i.touchPos(this._el, s) : i.mousePos(this._el, t), c = 0, u = this._handlers; c < u.length; c += 1) {\n          var h = u[c],\n            p = h.handlerName,\n            d = h.handler,\n            _ = h.allowed;\n          if (d.isEnabled()) {\n            var f = void 0;\n            this._blockedByActive(n, _, p) ? d.reset() : d[e || t.type] && (f = d[e || t.type](t, l, s), this.mergeHandlerResult(r, a, f, p, o), f && f.needsRenderFrame && this._triggerRenderFrame()), (f || d.isActive()) && (n[p] = d);\n          }\n        }\n        var m = {};\n        for (var g in this._previousActiveHandlers) n[g] || (m[g] = o);\n        this._previousActiveHandlers = n, (Object.keys(m).length || mr(r)) && (this._changes.push([r, a, m]), this._triggerRenderFrame()), (Object.keys(n).length || mr(r)) && this._map._stop(!0), this._updatingCamera = !1;\n        var v = r.cameraAnimation;\n        v && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], v(this._map));\n      } else this.stop(!0);\n    }, gr.prototype.mergeHandlerResult = function (e, i, o, r, a) {\n      if (o) {\n        t.extend(e, o);\n        var n = {\n          handlerName: r,\n          originalEvent: o.originalEvent || a\n        };\n        void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);\n      }\n    }, gr.prototype._applyChanges = function () {\n      for (var e = {}, i = {}, o = {}, r = 0, a = this._changes; r < a.length; r += 1) {\n        var n = a[r],\n          s = n[0],\n          l = n[1],\n          c = n[2];\n        s.panDelta && (e.panDelta = (e.panDelta || new t.Point(0, 0))._add(s.panDelta)), s.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (e.around = s.around), void 0 !== s.pinchAround && (e.pinchAround = s.pinchAround), s.noInertia && (e.noInertia = s.noInertia), t.extend(i, l), t.extend(o, c);\n      }\n      this._updateMapTransform(e, i, o), this._changes = [];\n    }, gr.prototype._updateMapTransform = function (t, e, i) {\n      var o = this._map,\n        r = o.transform;\n      if (!mr(t)) return this._fireEvents(e, i, !0);\n      var a = t.panDelta,\n        n = t.zoomDelta,\n        s = t.bearingDelta,\n        l = t.pitchDelta,\n        c = t.around,\n        u = t.pinchAround;\n      void 0 !== u && (c = u), o._stop(!0), c = c || o.transform.centerPoint;\n      var h = r.pointLocation(a ? c.sub(a) : c);\n      s && (r.bearing += s), l && (r.pitch += l), n && (r.zoom += n), r.setLocationAtPoint(h, c), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(e, i, !0);\n    }, gr.prototype._fireEvents = function (e, i, o) {\n      var r = this,\n        a = _r(this._eventsInProgress),\n        n = _r(e),\n        s = {};\n      for (var l in e) this._eventsInProgress[l] || (s[l + "start"] = e[l].originalEvent), this._eventsInProgress[l] = e[l];\n      for (var c in !a && n && this._fireEvent("movestart", n.originalEvent), s) this._fireEvent(c, s[c]);\n      for (var u in n && this._fireEvent("move", n.originalEvent), e) this._fireEvent(u, e[u].originalEvent);\n      var h,\n        p = {};\n      for (var d in this._eventsInProgress) {\n        var _ = this._eventsInProgress[d],\n          f = _.handlerName,\n          m = _.originalEvent;\n        this._handlersById[f].isActive() || (delete this._eventsInProgress[d], p[d + "end"] = h = i[f] || m);\n      }\n      for (var g in p) this._fireEvent(g, p[g]);\n      var v = _r(this._eventsInProgress);\n      if (o && (a || n) && !v) {\n        this._updatingCamera = !0;\n        var y = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n          x = function (t) {\n            return 0 !== t && -r._bearingSnap < t && t < r._bearingSnap;\n          };\n        y ? (x(y.bearing || this._map.getBearing()) && (y.bearing = 0), this._map.easeTo(y, {\n          originalEvent: h\n        })) : (this._map.fire(new t.Event("moveend", {\n          originalEvent: h\n        })), x(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n      }\n    }, gr.prototype._fireEvent = function (e, i) {\n      this._map.fire(new t.Event(e, i ? {\n        originalEvent: i\n      } : {}));\n    }, gr.prototype._requestFrame = function () {\n      var t = this;\n      return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function (e) {\n        delete t._frameId, t.handleEvent(new fr("renderFrame", {\n          timeStamp: e\n        })), t._applyChanges();\n      });\n    }, gr.prototype._triggerRenderFrame = function () {\n      void 0 === this._frameId && (this._frameId = this._requestFrame());\n    };\n    var vr = function (e) {\n        function i(i, o) {\n          e.call(this), this._moving = !1, this._zooming = !1, this.transform = i, this._bearingSnap = o.bearingSnap, t.bindAll(["_renderFrameCallback"], this);\n        }\n        return e && (i.__proto__ = e), (i.prototype = Object.create(e && e.prototype)).constructor = i, i.prototype.getCenter = function () {\n          return new t.LngLat(this.transform.center.lng, this.transform.center.lat);\n        }, i.prototype.setCenter = function (t, e) {\n          return this.jumpTo({\n            center: t\n          }, e);\n        }, i.prototype.panBy = function (e, i, o) {\n          return e = t.Point.convert(e).mult(-1), this.panTo(this.transform.center, t.extend({\n            offset: e\n          }, i), o);\n        }, i.prototype.panTo = function (e, i, o) {\n          return this.easeTo(t.extend({\n            center: e\n          }, i), o);\n        }, i.prototype.getZoom = function () {\n          return this.transform.zoom;\n        }, i.prototype.setZoom = function (t, e) {\n          return this.jumpTo({\n            zoom: t\n          }, e), this;\n        }, i.prototype.zoomTo = function (e, i, o) {\n          return this.easeTo(t.extend({\n            zoom: e\n          }, i), o);\n        }, i.prototype.zoomIn = function (t, e) {\n          return this.zoomTo(this.getZoom() + 1, t, e), this;\n        }, i.prototype.zoomOut = function (t, e) {\n          return this.zoomTo(this.getZoom() - 1, t, e), this;\n        }, i.prototype.getBearing = function () {\n          return this.transform.bearing;\n        }, i.prototype.setBearing = function (t, e) {\n          return this.jumpTo({\n            bearing: t\n          }, e), this;\n        }, i.prototype.getPadding = function () {\n          return this.transform.padding;\n        }, i.prototype.setPadding = function (t, e) {\n          return this.jumpTo({\n            padding: t\n          }, e), this;\n        }, i.prototype.rotateTo = function (e, i, o) {\n          return this.easeTo(t.extend({\n            bearing: e\n          }, i), o);\n        }, i.prototype.resetNorth = function (e, i) {\n          return this.rotateTo(0, t.extend({\n            duration: 1e3\n          }, e), i), this;\n        }, i.prototype.resetNorthPitch = function (e, i) {\n          return this.easeTo(t.extend({\n            bearing: 0,\n            pitch: 0,\n            duration: 1e3\n          }, e), i), this;\n        }, i.prototype.snapToNorth = function (t, e) {\n          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this;\n        }, i.prototype.getPitch = function () {\n          return this.transform.pitch;\n        }, i.prototype.setPitch = function (t, e) {\n          return this.jumpTo({\n            pitch: t\n          }, e), this;\n        }, i.prototype.cameraForBounds = function (e, i) {\n          e = t.LngLatBounds.convert(e);\n          var o = i && i.bearing || 0;\n          return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, i);\n        }, i.prototype._cameraForBoxAndBearing = function (e, i, o, r) {\n          var a = {\n            top: 0,\n            bottom: 0,\n            right: 0,\n            left: 0\n          };\n          if ("number" == typeof (r = t.extend({\n            padding: a,\n            offset: [0, 0],\n            maxZoom: this.transform.maxZoom\n          }, r)).padding) {\n            var n = r.padding;\n            r.padding = {\n              top: n,\n              bottom: n,\n              right: n,\n              left: n\n            };\n          }\n          r.padding = t.extend(a, r.padding);\n          var s = this.transform,\n            l = s.padding,\n            c = s.project(t.LngLat.convert(e)),\n            u = s.project(t.LngLat.convert(i)),\n            h = c.rotate(-o * Math.PI / 180),\n            p = u.rotate(-o * Math.PI / 180),\n            d = new t.Point(Math.max(h.x, p.x), Math.max(h.y, p.y)),\n            _ = new t.Point(Math.min(h.x, p.x), Math.min(h.y, p.y)),\n            f = d.sub(_),\n            m = (s.width - (l.left + l.right + r.padding.left + r.padding.right)) / f.x,\n            g = (s.height - (l.top + l.bottom + r.padding.top + r.padding.bottom)) / f.y;\n          if (!(g < 0 || m < 0)) {\n            var v = Math.min(s.scaleZoom(s.scale * Math.min(m, g)), r.maxZoom),\n              y = "number" == typeof r.offset.x ? new t.Point(r.offset.x, r.offset.y) : t.Point.convert(r.offset),\n              x = new t.Point((r.padding.left - r.padding.right) / 2, (r.padding.top - r.padding.bottom) / 2).rotate(o * Math.PI / 180),\n              b = y.add(x).mult(s.scale / s.zoomScale(v));\n            return {\n              center: s.unproject(c.add(u).div(2).sub(b)),\n              zoom: v,\n              bearing: o\n            };\n          }\n          t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");\n        }, i.prototype.fitBounds = function (t, e, i) {\n          return this._fitInternal(this.cameraForBounds(t, e), e, i);\n        }, i.prototype.fitScreenCoordinates = function (e, i, o, r, a) {\n          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e)), this.transform.pointLocation(t.Point.convert(i)), o, r), r, a);\n        }, i.prototype._fitInternal = function (e, i, o) {\n          return e ? (delete (i = t.extend(e, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n        }, i.prototype.jumpTo = function (e, i) {\n          this.stop();\n          var o = this.transform,\n            r = !1,\n            a = !1,\n            n = !1;\n          return "zoom" in e && o.zoom !== +e.zoom && (r = !0, o.zoom = +e.zoom), void 0 !== e.center && (o.center = t.LngLat.convert(e.center)), "bearing" in e && o.bearing !== +e.bearing && (a = !0, o.bearing = +e.bearing), "pitch" in e && o.pitch !== +e.pitch && (n = !0, o.pitch = +e.pitch), null == e.padding || o.isPaddingEqual(e.padding) || (o.padding = e.padding), this.fire(new t.Event("movestart", i)).fire(new t.Event("move", i)), r && this.fire(new t.Event("zoomstart", i)).fire(new t.Event("zoom", i)).fire(new t.Event("zoomend", i)), a && this.fire(new t.Event("rotatestart", i)).fire(new t.Event("rotate", i)).fire(new t.Event("rotateend", i)), n && this.fire(new t.Event("pitchstart", i)).fire(new t.Event("pitch", i)).fire(new t.Event("pitchend", i)), this.fire(new t.Event("moveend", i));\n        }, i.prototype.easeTo = function (e, i) {\n          var o = this;\n          this._stop(!1, e.easeId), (!1 === (e = t.extend({\n            offset: [0, 0],\n            duration: 500,\n            easing: t.ease\n          }, e)).animate || !e.essential && t.browser.prefersReducedMotion) && (e.duration = 0);\n          var r = this.transform,\n            a = this.getZoom(),\n            n = this.getBearing(),\n            s = this.getPitch(),\n            l = this.getPadding(),\n            c = "zoom" in e ? +e.zoom : a,\n            u = "bearing" in e ? this._normalizeBearing(e.bearing, n) : n,\n            h = "pitch" in e ? +e.pitch : s,\n            p = "padding" in e ? e.padding : r.padding,\n            d = t.Point.convert(e.offset),\n            _ = r.centerPoint.add(d),\n            f = r.pointLocation(_),\n            m = t.LngLat.convert(e.center || f);\n          this._normalizeCenter(m);\n          var g,\n            v,\n            y = r.project(f),\n            x = r.project(m).sub(y),\n            b = r.zoomScale(c - a);\n          e.around && (g = t.LngLat.convert(e.around), v = r.locationPoint(g));\n          var w = {\n            moving: this._moving,\n            zooming: this._zooming,\n            rotating: this._rotating,\n            pitching: this._pitching\n          };\n          return this._zooming = this._zooming || c !== a, this._rotating = this._rotating || n !== u, this._pitching = this._pitching || h !== s, this._padding = !r.isPaddingEqual(p), this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, w), this._ease(function (e) {\n            if (o._zooming && (r.zoom = t.number(a, c, e)), o._rotating && (r.bearing = t.number(n, u, e)), o._pitching && (r.pitch = t.number(s, h, e)), o._padding && (r.interpolatePadding(l, p, e), _ = r.centerPoint.add(d)), g) r.setLocationAtPoint(g, v);else {\n              var f = r.zoomScale(r.zoom - a),\n                m = c > a ? Math.min(2, b) : Math.max(.5, b),\n                w = Math.pow(m, 1 - e),\n                T = r.unproject(y.add(x.mult(e * w)).mult(f));\n              r.setLocationAtPoint(r.renderWorldCopies ? T.wrap() : T, _);\n            }\n            o._fireMoveEvents(i);\n          }, function (t) {\n            o._afterEase(i, t);\n          }, e), this;\n        }, i.prototype._prepareEase = function (e, i, o) {\n          void 0 === o && (o = {}), this._moving = !0, i || o.moving || this.fire(new t.Event("movestart", e)), this._zooming && !o.zooming && this.fire(new t.Event("zoomstart", e)), this._rotating && !o.rotating && this.fire(new t.Event("rotatestart", e)), this._pitching && !o.pitching && this.fire(new t.Event("pitchstart", e));\n        }, i.prototype._fireMoveEvents = function (e) {\n          this.fire(new t.Event("move", e)), this._zooming && this.fire(new t.Event("zoom", e)), this._rotating && this.fire(new t.Event("rotate", e)), this._pitching && this.fire(new t.Event("pitch", e));\n        }, i.prototype._afterEase = function (e, i) {\n          if (!this._easeId || !i || this._easeId !== i) {\n            delete this._easeId;\n            var o = this._zooming,\n              r = this._rotating,\n              a = this._pitching;\n            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new t.Event("zoomend", e)), r && this.fire(new t.Event("rotateend", e)), a && this.fire(new t.Event("pitchend", e)), this.fire(new t.Event("moveend", e));\n          }\n        }, i.prototype.flyTo = function (e, i) {\n          var o = this;\n          if (!e.essential && t.browser.prefersReducedMotion) {\n            var r = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]);\n            return this.jumpTo(r, i);\n          }\n          this.stop(), e = t.extend({\n            offset: [0, 0],\n            speed: 1.2,\n            curve: 1.42,\n            easing: t.ease\n          }, e);\n          var a = this.transform,\n            n = this.getZoom(),\n            s = this.getBearing(),\n            l = this.getPitch(),\n            c = this.getPadding(),\n            u = "zoom" in e ? t.clamp(+e.zoom, a.minZoom, a.maxZoom) : n,\n            h = "bearing" in e ? this._normalizeBearing(e.bearing, s) : s,\n            p = "pitch" in e ? +e.pitch : l,\n            d = "padding" in e ? e.padding : a.padding,\n            _ = a.zoomScale(u - n),\n            f = t.Point.convert(e.offset),\n            m = a.centerPoint.add(f),\n            g = a.pointLocation(m),\n            v = t.LngLat.convert(e.center || g);\n          this._normalizeCenter(v);\n          var y = a.project(g),\n            x = a.project(v).sub(y),\n            b = e.curve,\n            w = Math.max(a.width, a.height),\n            T = w / _,\n            E = x.mag();\n          if ("minZoom" in e) {\n            var I = t.clamp(Math.min(e.minZoom, n, u), a.minZoom, a.maxZoom),\n              P = w / a.zoomScale(I - n);\n            b = Math.sqrt(P / E * 2);\n          }\n          var S = b * b;\n          function C(t) {\n            var e = (T * T - w * w + (t ? -1 : 1) * S * S * E * E) / (2 * (t ? T : w) * S * E);\n            return Math.log(Math.sqrt(e * e + 1) - e);\n          }\n          function z(t) {\n            return (Math.exp(t) - Math.exp(-t)) / 2;\n          }\n          function D(t) {\n            return (Math.exp(t) + Math.exp(-t)) / 2;\n          }\n          var A = C(0),\n            M = function (t) {\n              return D(A) / D(A + b * t);\n            },\n            L = function (t) {\n              return w * ((D(A) * (z(e = A + b * t) / D(e)) - z(A)) / S) / E;\n              var e;\n            },\n            R = (C(1) - A) / b;\n          if (Math.abs(E) < 1e-6 || !isFinite(R)) {\n            if (Math.abs(w - T) < 1e-6) return this.easeTo(e, i);\n            var k = T < w ? -1 : 1;\n            R = Math.abs(Math.log(T / w)) / b, L = function () {\n              return 0;\n            }, M = function (t) {\n              return Math.exp(k * b * t);\n            };\n          }\n          return e.duration = "duration" in e ? +e.duration : 1e3 * R / ("screenSpeed" in e ? +e.screenSpeed / b : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = s !== h, this._pitching = p !== l, this._padding = !a.isPaddingEqual(d), this._prepareEase(i, !1), this._ease(function (e) {\n            var r = e * R,\n              _ = 1 / M(r);\n            a.zoom = 1 === e ? u : n + a.scaleZoom(_), o._rotating && (a.bearing = t.number(s, h, e)), o._pitching && (a.pitch = t.number(l, p, e)), o._padding && (a.interpolatePadding(c, d, e), m = a.centerPoint.add(f));\n            var g = 1 === e ? v : a.unproject(y.add(x.mult(L(r))).mult(_));\n            a.setLocationAtPoint(a.renderWorldCopies ? g.wrap() : g, m), o._fireMoveEvents(i);\n          }, function () {\n            return o._afterEase(i);\n          }, e), this;\n        }, i.prototype.isEasing = function () {\n          return !!this._easeFrameId;\n        }, i.prototype.stop = function () {\n          return this._stop();\n        }, i.prototype._stop = function (t, e) {\n          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {\n            var i = this._onEaseEnd;\n            delete this._onEaseEnd, i.call(this, e);\n          }\n          if (!t) {\n            var o = this.handlers;\n            o && o.stop(!1);\n          }\n          return this;\n        }, i.prototype._ease = function (e, i, o) {\n          !1 === o.animate || 0 === o.duration ? (e(1), i()) : (this._easeStart = t.browser.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n        }, i.prototype._renderFrameCallback = function () {\n          var e = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);\n          this._onEaseFrame(this._easeOptions.easing(e)), e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n        }, i.prototype._normalizeBearing = function (e, i) {\n          e = t.wrap(e, -180, 180);\n          var o = Math.abs(e - i);\n          return Math.abs(e - 360 - i) < o && (e -= 360), Math.abs(e + 360 - i) < o && (e += 360), e;\n        }, i.prototype._normalizeCenter = function (t) {\n          var e = this.transform;\n          if (e.renderWorldCopies && !e.lngRange) {\n            var i = t.lng - e.center.lng;\n            t.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n          }\n        }, i;\n      }(t.Evented),\n      yr = function (e) {\n        void 0 === e && (e = {}), this.options = e, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);\n      };\n    yr.prototype.getDefaultPosition = function () {\n      return "bottom-right";\n    }, yr.prototype.onAdd = function (t) {\n      var e = this.options && this.options.compact;\n      return this._map = t, this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = i.create("button", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.type = "button", this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e && this._container.classList.add("maplibregl-compact", "mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;\n    }, yr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n    }, yr.prototype._setElementTitle = function (t, e) {\n      var i = this._map._getUIString("AttributionControl." + e);\n      t.title = i, t.setAttribute("aria-label", i);\n    }, yr.prototype._toggleAttribution = function () {\n      this._container.classList.contains("maplibregl-compact-show") || this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));\n    }, yr.prototype._updateEditLink = function () {\n      var e = this._editLink;\n      e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map"));\n      var i = [{\n        key: "owner",\n        value: this.styleOwner\n      }, {\n        key: "id",\n        value: this.styleId\n      }, {\n        key: "access_token",\n        value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN\n      }];\n      if (e) {\n        var o = i.reduce(function (t, e, o) {\n          return e.value && (t += e.key + "=" + e.value + (o < i.length - 1 ? "&" : "")), t;\n        }, "?");\n        e.href = t.config.FEEDBACK_URL + "/" + o + (this._map._hash ? this._map._hash.getHashString(!0) : ""), e.rel = "noopener nofollow", this._setElementTitle(e, "MapFeedback");\n      }\n    }, yr.prototype._updateData = function (t) {\n      !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(), this._updateEditLink());\n    }, yr.prototype._updateAttributions = function () {\n      if (this._map.style) {\n        var t = [];\n        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(function (t) {\n          return "string" != typeof t ? "" : t;\n        })) : "string" == typeof this.options.customAttribution && t.push(this.options.customAttribution)), this._map.style.stylesheet) {\n          var e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n        var i = this._map.style.sourceCaches;\n        for (var o in i) {\n          var r = i[o];\n          if (r.used) {\n            var a = r.getSource();\n            a.attribution && t.indexOf(a.attribution) < 0 && t.push(a.attribution);\n          }\n        }\n        t.sort(function (t, e) {\n          return t.length - e.length;\n        });\n        var n = (t = t.filter(function (e, i) {\n          for (var o = i + 1; o < t.length; o++) if (t[o].indexOf(e) >= 0) return !1;\n          return !0;\n        })).join(" | ");\n        n !== this._attribHTML && (this._attribHTML = n, t.length ? (this._innerContainer.innerHTML = n, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._editLink = null);\n      }\n    }, yr.prototype._updateCompact = function () {\n      this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("maplibregl-compact", "mapboxgl-compact") : this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show");\n    };\n    var xr = function () {\n      t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);\n    };\n    xr.prototype.onAdd = function (t) {\n      this._map = t, this._container = i.create("div", "maplibregl-ctrl mapboxgl-ctrl");\n      var e = i.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");\n      return e.target = "_blank", e.rel = "noopener nofollow", e.href = "https://maplibre.org/", e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;\n    }, xr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);\n    }, xr.prototype.getDefaultPosition = function () {\n      return "bottom-left";\n    }, xr.prototype._updateLogo = function (t) {\n      t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");\n    }, xr.prototype._logoRequired = function () {\n      if (this._map.style) {\n        var t = this._map.style.sourceCaches;\n        for (var e in t) if (t[e].getSource().mapbox_logo) return !0;\n        return !1;\n      }\n    }, xr.prototype._updateCompact = function () {\n      var t = this._container.children;\n      if (t.length) {\n        var e = t[0];\n        this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("maplibregl-compact", "mapboxgl-compact") : e.classList.remove("maplibregl-compact", "mapboxgl-compact");\n      }\n    };\n    var br = function () {\n      this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n    };\n    br.prototype.add = function (t) {\n      var e = ++this._id;\n      return this._queue.push({\n        callback: t,\n        id: e,\n        cancelled: !1\n      }), e;\n    }, br.prototype.remove = function (t) {\n      for (var e = this._currentlyRunning, i = 0, o = e ? this._queue.concat(e) : this._queue; i < o.length; i += 1) {\n        var r = o[i];\n        if (r.id === t) return void (r.cancelled = !0);\n      }\n    }, br.prototype.run = function (t) {\n      void 0 === t && (t = 0);\n      var e = this._currentlyRunning = this._queue;\n      this._queue = [];\n      for (var i = 0, o = e; i < o.length; i += 1) {\n        var r = o[i];\n        if (!r.cancelled && (r.callback(t), this._cleared)) break;\n      }\n      this._cleared = !1, this._currentlyRunning = !1;\n    }, br.prototype.clear = function () {\n      this._currentlyRunning && (this._cleared = !0), this._queue = [];\n    };\n    var wr = {\n        "AttributionControl.ToggleAttribution": "Toggle attribution",\n        "AttributionControl.MapFeedback": "Map feedback",\n        "FullscreenControl.Enter": "Enter fullscreen",\n        "FullscreenControl.Exit": "Exit fullscreen",\n        "GeolocateControl.FindMyLocation": "Find my location",\n        "GeolocateControl.LocationNotAvailable": "Location not available",\n        "LogoControl.Title": "Mapbox logo",\n        "NavigationControl.ResetBearing": "Reset bearing to north",\n        "NavigationControl.ZoomIn": "Zoom in",\n        "NavigationControl.ZoomOut": "Zoom out",\n        "ScaleControl.Feet": "ft",\n        "ScaleControl.Meters": "m",\n        "ScaleControl.Kilometers": "km",\n        "ScaleControl.Miles": "mi",\n        "ScaleControl.NauticalMiles": "nm"\n      },\n      Tr = t.window.HTMLImageElement,\n      Er = t.window.HTMLElement,\n      Ir = t.window.ImageBitmap,\n      Pr = {\n        center: [0, 0],\n        zoom: 0,\n        bearing: 0,\n        pitch: 0,\n        minZoom: -2,\n        maxZoom: 22,\n        minPitch: 0,\n        maxPitch: 60,\n        interactive: !0,\n        scrollZoom: !0,\n        boxZoom: !0,\n        dragRotate: !0,\n        dragPan: !0,\n        keyboard: !0,\n        doubleClickZoom: !0,\n        touchZoomRotate: !0,\n        touchPitch: !0,\n        bearingSnap: 7,\n        clickTolerance: 3,\n        pitchWithRotate: !0,\n        hash: !1,\n        attributionControl: !0,\n        failIfMajorPerformanceCaveat: !1,\n        preserveDrawingBuffer: !1,\n        trackResize: !0,\n        renderWorldCopies: !0,\n        refreshExpiredTiles: !0,\n        maxTileCacheSize: null,\n        localIdeographFontFamily: "sans-serif",\n        transformRequest: null,\n        accessToken: null,\n        fadeDuration: 300,\n        crossSourceCollisions: !0\n      },\n      Sr = function (o) {\n        function r(e) {\n          var i = this;\n          if (null != (e = t.extend({}, Pr, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");\n          if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");\n          if (null != e.minPitch && e.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");\n          if (null != e.maxPitch && e.maxPitch > 60) throw new Error("maxPitch must be less than or equal to 60");\n          var r = new To(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies);\n          if (o.call(this, r, e), this._interactive = e.interactive, this._maxTileCacheSize = e.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e.preserveDrawingBuffer, this._antialias = e.antialias, this._trackResize = e.trackResize, this._bearingSnap = e.bearingSnap, this._refreshExpiredTiles = e.refreshExpiredTiles, this._fadeDuration = e.fadeDuration, this._crossSourceCollisions = e.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e.collectResourceTiming, this._renderTaskQueue = new br(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wr, e.locale), this._clickTolerance = e.clickTolerance, this._requestManager = new t.RequestManager(e.transformRequest, e.accessToken), "string" == typeof e.container) {\n            if (this._container = t.window.document.getElementById(e.container), !this._container) throw new Error("Container \'" + e.container + "\' not found.");\n          } else {\n            if (!(e.container instanceof Er)) throw new Error("Invalid type: \'container\' must be a String or HTMLElement.");\n            this._container = e.container;\n          }\n          if (e.maxBounds && this.setMaxBounds(e.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");\n          this.on("move", function () {\n            return i._update(!1);\n          }), this.on("moveend", function () {\n            return i._update(!1);\n          }), this.on("zoom", function () {\n            return i._update(!0);\n          }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1), t.window.addEventListener("resize", this._onWindowResize, !1), t.window.addEventListener("orientationchange", this._onWindowResize, !1)), this.handlers = new gr(this, e), this._hash = e.hash && new Io("string" == typeof e.hash && e.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({\n            center: e.center,\n            zoom: e.zoom,\n            bearing: e.bearing,\n            pitch: e.pitch\n          }), e.bounds && (this.resize(), this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {\n            duration: 0\n          })))), this.resize(), this._localIdeographFontFamily = e.localIdeographFontFamily, e.style && this.setStyle(e.style, {\n            localIdeographFontFamily: e.localIdeographFontFamily\n          }), e.attributionControl && this.addControl(new yr({\n            customAttribution: e.customAttribution\n          })), this.addControl(new xr(), e.logoPosition), this.on("style.load", function () {\n            i.transform.unmodified && i.jumpTo(i.style.stylesheet);\n          }), this.on("data", function (e) {\n            i._update("style" === e.dataType), i.fire(new t.Event(e.dataType + "data", e));\n          }), this.on("dataloading", function (e) {\n            i.fire(new t.Event(e.dataType + "dataloading", e));\n          });\n        }\n        o && (r.__proto__ = o), (r.prototype = Object.create(o && o.prototype)).constructor = r;\n        var a = {\n          showTileBoundaries: {\n            configurable: !0\n          },\n          showPadding: {\n            configurable: !0\n          },\n          showCollisionBoxes: {\n            configurable: !0\n          },\n          showOverdrawInspector: {\n            configurable: !0\n          },\n          repaint: {\n            configurable: !0\n          },\n          vertices: {\n            configurable: !0\n          },\n          version: {\n            configurable: !0\n          }\n        };\n        return r.prototype._getMapId = function () {\n          return this._mapId;\n        }, r.prototype.addControl = function (e, i) {\n          if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));\n          var o = e.onAdd(this);\n          this._controls.push(e);\n          var r = this._controlPositions[i];\n          return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;\n        }, r.prototype.removeControl = function (e) {\n          if (!e || !e.onRemove) return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));\n          var i = this._controls.indexOf(e);\n          return i > -1 && this._controls.splice(i, 1), e.onRemove(this), this;\n        }, r.prototype.hasControl = function (t) {\n          return this._controls.indexOf(t) > -1;\n        }, r.prototype.resize = function (e) {\n          var i = this._containerDimensions(),\n            o = i[0],\n            r = i[1];\n          this._resizeCanvas(o, r), this.transform.resize(o, r), this.painter.resize(o, r);\n          var a = !this._moving;\n          return a && (this.stop(), this.fire(new t.Event("movestart", e)).fire(new t.Event("move", e))), this.fire(new t.Event("resize", e)), a && this.fire(new t.Event("moveend", e)), this;\n        }, r.prototype.getBounds = function () {\n          return this.transform.getBounds();\n        }, r.prototype.getMaxBounds = function () {\n          return this.transform.getMaxBounds();\n        }, r.prototype.setMaxBounds = function (e) {\n          return this.transform.setMaxBounds(t.LngLatBounds.convert(e)), this._update();\n        }, r.prototype.setMinZoom = function (t) {\n          if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t && this.setZoom(t), this;\n          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");\n        }, r.prototype.getMinZoom = function () {\n          return this.transform.minZoom;\n        }, r.prototype.setMaxZoom = function (t) {\n          if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t && this.setZoom(t), this;\n          throw new Error("maxZoom must be greater than the current minZoom");\n        }, r.prototype.getMaxZoom = function () {\n          return this.transform.maxZoom;\n        }, r.prototype.setMinPitch = function (t) {\n          if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");\n          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t && this.setPitch(t), this;\n          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");\n        }, r.prototype.getMinPitch = function () {\n          return this.transform.minPitch;\n        }, r.prototype.setMaxPitch = function (t) {\n          if ((t = null == t ? 60 : t) > 60) throw new Error("maxPitch must be less than or equal to 60");\n          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t && this.setPitch(t), this;\n          throw new Error("maxPitch must be greater than the current minPitch");\n        }, r.prototype.getMaxPitch = function () {\n          return this.transform.maxPitch;\n        }, r.prototype.getRenderWorldCopies = function () {\n          return this.transform.renderWorldCopies;\n        }, r.prototype.setRenderWorldCopies = function (t) {\n          return this.transform.renderWorldCopies = t, this._update();\n        }, r.prototype.project = function (e) {\n          return this.transform.locationPoint(t.LngLat.convert(e));\n        }, r.prototype.unproject = function (e) {\n          return this.transform.pointLocation(t.Point.convert(e));\n        }, r.prototype.isMoving = function () {\n          return this._moving || this.handlers.isMoving();\n        }, r.prototype.isZooming = function () {\n          return this._zooming || this.handlers.isZooming();\n        }, r.prototype.isRotating = function () {\n          return this._rotating || this.handlers.isRotating();\n        }, r.prototype._createDelegatedListener = function (t, e, i) {\n          var o,\n            r = this;\n          if ("mouseenter" === t || "mouseover" === t) {\n            var a = !1;\n            return {\n              layer: e,\n              listener: i,\n              delegates: {\n                mousemove: function (o) {\n                  var n = r.getLayer(e) ? r.queryRenderedFeatures(o.point, {\n                    layers: [e]\n                  }) : [];\n                  n.length ? a || (a = !0, i.call(r, new Ro(t, r, o.originalEvent, {\n                    features: n\n                  }))) : a = !1;\n                },\n                mouseout: function () {\n                  a = !1;\n                }\n              }\n            };\n          }\n          if ("mouseleave" === t || "mouseout" === t) {\n            var n = !1;\n            return {\n              layer: e,\n              listener: i,\n              delegates: {\n                mousemove: function (o) {\n                  (r.getLayer(e) ? r.queryRenderedFeatures(o.point, {\n                    layers: [e]\n                  }) : []).length ? n = !0 : n && (n = !1, i.call(r, new Ro(t, r, o.originalEvent)));\n                },\n                mouseout: function (e) {\n                  n && (n = !1, i.call(r, new Ro(t, r, e.originalEvent)));\n                }\n              }\n            };\n          }\n          return {\n            layer: e,\n            listener: i,\n            delegates: (o = {}, o[t] = function (t) {\n              var o = r.getLayer(e) ? r.queryRenderedFeatures(t.point, {\n                layers: [e]\n              }) : [];\n              o.length && (t.features = o, i.call(r, t), delete t.features);\n            }, o)\n          };\n        }, r.prototype.on = function (t, e, i) {\n          if (void 0 === i) return o.prototype.on.call(this, t, e);\n          var r = this._createDelegatedListener(t, e, i);\n          for (var a in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t] = this._delegatedListeners[t] || [], this._delegatedListeners[t].push(r), r.delegates) this.on(a, r.delegates[a]);\n          return this;\n        }, r.prototype.once = function (t, e, i) {\n          if (void 0 === i) return o.prototype.once.call(this, t, e);\n          var r = this._createDelegatedListener(t, e, i);\n          for (var a in r.delegates) this.once(a, r.delegates[a]);\n          return this;\n        }, r.prototype.off = function (t, e, i) {\n          var r = this;\n          return void 0 === i ? o.prototype.off.call(this, t, e) : (this._delegatedListeners && this._delegatedListeners[t] && function (o) {\n            for (var a = o[t], n = 0; n < a.length; n++) {\n              var s = a[n];\n              if (s.layer === e && s.listener === i) {\n                for (var l in s.delegates) r.off(l, s.delegates[l]);\n                return a.splice(n, 1), r;\n              }\n            }\n          }(this._delegatedListeners), this);\n        }, r.prototype.queryRenderedFeatures = function (e, i) {\n          if (!this.style) return [];\n          var o;\n          if (void 0 !== i || void 0 === e || e instanceof t.Point || Array.isArray(e) || (i = e, e = void 0), i = i || {}, (e = e || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e[0]) o = [t.Point.convert(e)];else {\n            var r = t.Point.convert(e[0]),\n              a = t.Point.convert(e[1]);\n            o = [r, new t.Point(a.x, r.y), a, new t.Point(r.x, a.y), r];\n          }\n          return this.style.queryRenderedFeatures(o, i, this.transform);\n        }, r.prototype.querySourceFeatures = function (t, e) {\n          return this.style.querySourceFeatures(t, e);\n        }, r.prototype.setStyle = function (e, i) {\n          return !1 !== (i = t.extend({}, {\n            localIdeographFontFamily: this._localIdeographFontFamily\n          }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e, i));\n        }, r.prototype.setTransformRequest = function (t) {\n          return this._requestManager.setTransformRequest(t), this;\n        }, r.prototype._getUIString = function (t) {\n          var e = this._locale[t];\n          if (null == e) throw new Error("Missing UI string \'" + t + "\'");\n          return e;\n        }, r.prototype._updateStyle = function (t, e) {\n          return this.style && (this.style.setEventedParent(null), this.style._remove()), t ? (this.style = new je(this, e || {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t), this) : (delete this.style, this);\n        }, r.prototype._lazyInitEmptyStyle = function () {\n          this.style || (this.style = new je(this, {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), this.style.loadEmpty());\n        }, r.prototype._diffStyle = function (e, i) {\n          var o = this;\n          if ("string" == typeof e) {\n            var r = this._requestManager.normalizeStyleURL(e),\n              a = this._requestManager.transformRequest(r, t.ResourceType.Style);\n            t.getJSON(a, function (e, r) {\n              e ? o.fire(new t.ErrorEvent(e)) : r && o._updateDiff(r, i);\n            });\n          } else "object" == typeof e && this._updateDiff(e, i);\n        }, r.prototype._updateDiff = function (e, i) {\n          try {\n            this.style.setState(e) && this._update(!0);\n          } catch (o) {\n            t.warnOnce("Unable to perform style diff: " + (o.message || o.error || o) + ".  Rebuilding the style from scratch."), this._updateStyle(e, i);\n          }\n        }, r.prototype.getStyle = function () {\n          if (this.style) return this.style.serialize();\n        }, r.prototype.isStyleLoaded = function () {\n          return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");\n        }, r.prototype.addSource = function (t, e) {\n          return this._lazyInitEmptyStyle(), this.style.addSource(t, e), this._update(!0);\n        }, r.prototype.isSourceLoaded = function (e) {\n          var i = this.style && this.style.sourceCaches[e];\n          if (void 0 !== i) return i.loaded();\n          this.fire(new t.ErrorEvent(new Error("There is no source with ID \'" + e + "\'")));\n        }, r.prototype.areTilesLoaded = function () {\n          var t = this.style && this.style.sourceCaches;\n          for (var e in t) {\n            var i = t[e]._tiles;\n            for (var o in i) {\n              var r = i[o];\n              if ("loaded" !== r.state && "errored" !== r.state) return !1;\n            }\n          }\n          return !0;\n        }, r.prototype.addSourceType = function (t, e, i) {\n          return this._lazyInitEmptyStyle(), this.style.addSourceType(t, e, i);\n        }, r.prototype.removeSource = function (t) {\n          return this.style.removeSource(t), this._update(!0);\n        }, r.prototype.getSource = function (t) {\n          return this.style.getSource(t);\n        }, r.prototype.addImage = function (e, i, o) {\n          void 0 === o && (o = {});\n          var r = o.pixelRatio;\n          void 0 === r && (r = 1);\n          var a = o.sdf;\n          void 0 === a && (a = !1);\n          var n = o.stretchX,\n            s = o.stretchY,\n            l = o.content;\n          if (this._lazyInitEmptyStyle(), i instanceof Tr || Ir && i instanceof Ir) {\n            var c = t.browser.getImageData(i);\n            this.style.addImage(e, {\n              data: new t.RGBAImage({\n                width: c.width,\n                height: c.height\n              }, c.data),\n              pixelRatio: r,\n              stretchX: n,\n              stretchY: s,\n              content: l,\n              sdf: a,\n              version: 0\n            });\n          } else {\n            if (void 0 === i.width || void 0 === i.height) return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));\n            var u = i;\n            this.style.addImage(e, {\n              data: new t.RGBAImage({\n                width: i.width,\n                height: i.height\n              }, new Uint8Array(i.data)),\n              pixelRatio: r,\n              stretchX: n,\n              stretchY: s,\n              content: l,\n              sdf: a,\n              version: 0,\n              userImage: u\n            }), u.onAdd && u.onAdd(this, e);\n          }\n        }, r.prototype.updateImage = function (e, i) {\n          var o = this.style.getImage(e);\n          if (!o) return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));\n          var r = i instanceof Tr || Ir && i instanceof Ir ? t.browser.getImageData(i) : i,\n            a = r.width,\n            n = r.height,\n            s = r.data;\n          return void 0 === a || void 0 === n ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a !== o.data.width || n !== o.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o.data.replace(s, !(i instanceof Tr || Ir && i instanceof Ir)), void this.style.updateImage(e, o));\n        }, r.prototype.hasImage = function (e) {\n          return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), !1);\n        }, r.prototype.removeImage = function (t) {\n          this.style.removeImage(t);\n        }, r.prototype.loadImage = function (e, i) {\n          t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), i);\n        }, r.prototype.listImages = function () {\n          return this.style.listImages();\n        }, r.prototype.addLayer = function (t, e) {\n          return this._lazyInitEmptyStyle(), this.style.addLayer(t, e), this._update(!0);\n        }, r.prototype.moveLayer = function (t, e) {\n          return this.style.moveLayer(t, e), this._update(!0);\n        }, r.prototype.removeLayer = function (t) {\n          return this.style.removeLayer(t), this._update(!0);\n        }, r.prototype.getLayer = function (t) {\n          return this.style.getLayer(t);\n        }, r.prototype.setLayerZoomRange = function (t, e, i) {\n          return this.style.setLayerZoomRange(t, e, i), this._update(!0);\n        }, r.prototype.setFilter = function (t, e, i) {\n          return void 0 === i && (i = {}), this.style.setFilter(t, e, i), this._update(!0);\n        }, r.prototype.getFilter = function (t) {\n          return this.style.getFilter(t);\n        }, r.prototype.setPaintProperty = function (t, e, i, o) {\n          return void 0 === o && (o = {}), this.style.setPaintProperty(t, e, i, o), this._update(!0);\n        }, r.prototype.getPaintProperty = function (t, e) {\n          return this.style.getPaintProperty(t, e);\n        }, r.prototype.setLayoutProperty = function (t, e, i, o) {\n          return void 0 === o && (o = {}), this.style.setLayoutProperty(t, e, i, o), this._update(!0);\n        }, r.prototype.getLayoutProperty = function (t, e) {\n          return this.style.getLayoutProperty(t, e);\n        }, r.prototype.setLight = function (t, e) {\n          return void 0 === e && (e = {}), this._lazyInitEmptyStyle(), this.style.setLight(t, e), this._update(!0);\n        }, r.prototype.getLight = function () {\n          return this.style.getLight();\n        }, r.prototype.setFeatureState = function (t, e) {\n          return this.style.setFeatureState(t, e), this._update();\n        }, r.prototype.removeFeatureState = function (t, e) {\n          return this.style.removeFeatureState(t, e), this._update();\n        }, r.prototype.getFeatureState = function (t) {\n          return this.style.getFeatureState(t);\n        }, r.prototype.getContainer = function () {\n          return this._container;\n        }, r.prototype.getCanvasContainer = function () {\n          return this._canvasContainer;\n        }, r.prototype.getCanvas = function () {\n          return this._canvas;\n        }, r.prototype._containerDimensions = function () {\n          var t = 0,\n            e = 0;\n          return this._container && (t = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [t, e];\n        }, r.prototype._setupContainer = function () {\n          var t = this._container;\n          t.classList.add("maplibregl-map", "mapboxgl-map");\n          var e = this._canvasContainer = i.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", t);\n          this._interactive && e.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = i.create("canvas", "maplibregl-canvas mapboxgl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");\n          var o = this._containerDimensions();\n          this._resizeCanvas(o[0], o[1]);\n          var r = this._controlContainer = i.create("div", "maplibregl-control-container mapboxgl-control-container", t),\n            a = this._controlPositions = {};\n          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function (t) {\n            a[t] = i.create("div", "maplibregl-ctrl-" + t + " mapboxgl-ctrl-" + t, r);\n          }), this._container.addEventListener("scroll", this._onMapScroll, !1);\n        }, r.prototype._resizeCanvas = function (e, i) {\n          var o = t.browser.devicePixelRatio || 1;\n          this._canvas.width = o * e, this._canvas.height = o * i, this._canvas.style.width = e + "px", this._canvas.style.height = i + "px";\n        }, r.prototype._setupPainter = function () {\n          var i = t.extend({}, e.webGLContextAttributes, {\n              failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n              preserveDrawingBuffer: this._preserveDrawingBuffer,\n              antialias: this._antialias || !1\n            }),\n            o = this._canvas.getContext("webgl", i) || this._canvas.getContext("experimental-webgl", i);\n          o ? (this.painter = new yo(o, this.transform), t.webpSupported.testSupport(o)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));\n        }, r.prototype._contextLost = function (e) {\n          e.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", {\n            originalEvent: e\n          }));\n        }, r.prototype._contextRestored = function (e) {\n          this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", {\n            originalEvent: e\n          }));\n        }, r.prototype._onMapScroll = function (t) {\n          if (t.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n        }, r.prototype.loaded = function () {\n          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n        }, r.prototype._update = function (t) {\n          return this.style ? (this._styleDirty = this._styleDirty || t, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n        }, r.prototype._requestRenderFrame = function (t) {\n          return this._update(), this._renderTaskQueue.add(t);\n        }, r.prototype._cancelRenderFrame = function (t) {\n          this._renderTaskQueue.remove(t);\n        }, r.prototype._render = function (e) {\n          var i,\n            o = this,\n            r = 0,\n            a = this.painter.context.extTimerQuery;\n          if (this.listens("gpu-timing-frame") && (i = a.createQueryEXT(), a.beginQueryEXT(a.TIME_ELAPSED_EXT, i), r = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), !this._removed) {\n            var n = !1;\n            if (this.style && this._styleDirty) {\n              this._styleDirty = !1;\n              var s = this.transform.zoom,\n                l = t.browser.now();\n              this.style.zoomHistory.update(s, l);\n              var c = new t.EvaluationParameters(s, {\n                  now: l,\n                  fadeDuration: this._fadeDuration,\n                  zoomHistory: this.style.zoomHistory,\n                  transition: this.style.getTransition()\n                }),\n                u = c.crossFadingFactor();\n              1 === u && u === this._crossFadingFactor || (n = !0, this._crossFadingFactor = u), this.style.update(c);\n            }\n            if (this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, {\n              showTileBoundaries: this.showTileBoundaries,\n              showOverdrawInspector: this._showOverdrawInspector,\n              rotating: this.isRotating(),\n              zooming: this.isZooming(),\n              moving: this.isMoving(),\n              fadeDuration: this._fadeDuration,\n              showPadding: this.showPadding,\n              gpuTiming: !!this.listens("gpu-timing-layer")\n            }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {\n              var h = t.browser.now() - r;\n              a.endQueryEXT(a.TIME_ELAPSED_EXT, i), setTimeout(function () {\n                var e = a.getQueryObjectEXT(i, a.QUERY_RESULT_EXT) / 1e6;\n                a.deleteQueryEXT(i), o.fire(new t.Event("gpu-timing-frame", {\n                  cpuTime: h,\n                  gpuTime: e\n                }));\n              }, 50);\n            }\n            if (this.listens("gpu-timing-layer")) {\n              var p = this.painter.collectGpuTimers();\n              setTimeout(function () {\n                var e = o.painter.queryGpuTimers(p);\n                o.fire(new t.Event("gpu-timing-layer", {\n                  layerTimes: e\n                }));\n              }, 50);\n            }\n            var d = this._sourcesDirty || this._styleDirty || this._placementDirty;\n            return d || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0), this;\n          }\n        }, r.prototype.remove = function () {\n          this._hash && this._hash.remove();\n          for (var e = 0, i = this._controls; e < i.length; e += 1) i[e].onRemove(this);\n          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1), t.window.removeEventListener("orientationchange", this._onWindowResize, !1), t.window.removeEventListener("online", this._onWindowOnline, !1));\n          var o = this.painter.context.gl.getExtension("WEBGL_lose_context");\n          o && o.loseContext(), Cr(this._canvasContainer), Cr(this._controlContainer), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), this._removed = !0, this.fire(new t.Event("remove"));\n        }, r.prototype.triggerRepaint = function () {\n          var e = this;\n          this.style && !this._frame && (this._frame = t.browser.frame(function (t) {\n            e._frame = null, e._render(t);\n          }));\n        }, r.prototype._onWindowOnline = function () {\n          this._update();\n        }, r.prototype._onWindowResize = function (t) {\n          this._trackResize && this.resize({\n            originalEvent: t\n          })._update();\n        }, a.showTileBoundaries.get = function () {\n          return !!this._showTileBoundaries;\n        }, a.showTileBoundaries.set = function (t) {\n          this._showTileBoundaries !== t && (this._showTileBoundaries = t, this._update());\n        }, a.showPadding.get = function () {\n          return !!this._showPadding;\n        }, a.showPadding.set = function (t) {\n          this._showPadding !== t && (this._showPadding = t, this._update());\n        }, a.showCollisionBoxes.get = function () {\n          return !!this._showCollisionBoxes;\n        }, a.showCollisionBoxes.set = function (t) {\n          this._showCollisionBoxes !== t && (this._showCollisionBoxes = t, t ? this.style._generateCollisionBoxes() : this._update());\n        }, a.showOverdrawInspector.get = function () {\n          return !!this._showOverdrawInspector;\n        }, a.showOverdrawInspector.set = function (t) {\n          this._showOverdrawInspector !== t && (this._showOverdrawInspector = t, this._update());\n        }, a.repaint.get = function () {\n          return !!this._repaint;\n        }, a.repaint.set = function (t) {\n          this._repaint !== t && (this._repaint = t, this.triggerRepaint());\n        }, a.vertices.get = function () {\n          return !!this._vertices;\n        }, a.vertices.set = function (t) {\n          this._vertices = t, this._update();\n        }, r.prototype._setCacheLimits = function (e, i) {\n          t.setCacheLimits(e, i);\n        }, a.version.get = function () {\n          return t.version;\n        }, Object.defineProperties(r.prototype, a), r;\n      }(vr);\n    function Cr(t) {\n      t.parentNode && t.parentNode.removeChild(t);\n    }\n    var zr = {\n        showCompass: !0,\n        showZoom: !0,\n        visualizePitch: !1\n      },\n      Dr = function (e) {\n        var o = this;\n        this.options = t.extend({}, zr, e), this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function (t) {\n          return t.preventDefault();\n        }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", function (t) {\n          return o._map.zoomIn({}, {\n            originalEvent: t\n          });\n        }), i.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", !0), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", function (t) {\n          return o._map.zoomOut({}, {\n            originalEvent: t\n          });\n        }), i.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", !0)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", function (t) {\n          o.options.visualizePitch ? o._map.resetNorthPitch({}, {\n            originalEvent: t\n          }) : o._map.resetNorth({}, {\n            originalEvent: t\n          });\n        }), this._compassIcon = i.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", !0));\n      };\n    Dr.prototype._updateZoomButtons = function () {\n      var t = this._map.getZoom(),\n        e = t === this._map.getMaxZoom(),\n        i = t === this._map.getMinZoom();\n      this._zoomInButton.disabled = e, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", e.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString());\n    }, Dr.prototype._rotateCompassArrow = function () {\n      var t = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), .5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";\n      this._compassIcon.style.transform = t;\n    }, Dr.prototype.onAdd = function (t) {\n      return this._map = t, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ar(this._map, this._compass, this.options.visualizePitch)), this._container;\n    }, Dr.prototype.onRemove = function () {\n      i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;\n    }, Dr.prototype._createButton = function (t, e) {\n      var o = i.create("button", t, this._container);\n      return o.type = "button", o.addEventListener("click", e), o;\n    }, Dr.prototype._setButtonTitle = function (t, e) {\n      var i = this._map._getUIString("NavigationControl." + e);\n      t.title = i, t.setAttribute("aria-label", i);\n    };\n    var Ar = function (e, o, r) {\n      void 0 === r && (r = !1), this._clickTolerance = 10, this.element = o, this.mouseRotate = new Xo({\n        clickTolerance: e.dragRotate._mouseRotate._clickTolerance\n      }), this.map = e, r && (this.mousePitch = new Ho({\n        clickTolerance: e.dragRotate._mousePitch._clickTolerance\n      })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener(o, "mousedown", this.mousedown), i.addEventListener(o, "touchstart", this.touchstart, {\n        passive: !1\n      }), i.addEventListener(o, "touchmove", this.touchmove), i.addEventListener(o, "touchend", this.touchend), i.addEventListener(o, "touchcancel", this.reset);\n    };\n    function Mr(e, i, o) {\n      if (e = new t.LngLat(e.lng, e.lat), i) {\n        var r = new t.LngLat(e.lng - 360, e.lat),\n          a = new t.LngLat(e.lng + 360, e.lat),\n          n = o.locationPoint(e).distSqr(i);\n        o.locationPoint(r).distSqr(i) < n ? e = r : o.locationPoint(a).distSqr(i) < n && (e = a);\n      }\n      for (; Math.abs(e.lng - o.center.lng) > 180;) {\n        var s = o.locationPoint(e);\n        if (s.x >= 0 && s.y >= 0 && s.x <= o.width && s.y <= o.height) break;\n        e.lng > o.center.lng ? e.lng -= 360 : e.lng += 360;\n      }\n      return e;\n    }\n    Ar.prototype.down = function (t, e) {\n      this.mouseRotate.mousedown(t, e), this.mousePitch && this.mousePitch.mousedown(t, e), i.disableDrag();\n    }, Ar.prototype.move = function (t, e) {\n      var i = this.map,\n        o = this.mouseRotate.mousemoveWindow(t, e);\n      if (o && o.bearingDelta && i.setBearing(i.getBearing() + o.bearingDelta), this.mousePitch) {\n        var r = this.mousePitch.mousemoveWindow(t, e);\n        r && r.pitchDelta && i.setPitch(i.getPitch() + r.pitchDelta);\n      }\n    }, Ar.prototype.off = function () {\n      var t = this.element;\n      i.removeEventListener(t, "mousedown", this.mousedown), i.removeEventListener(t, "touchstart", this.touchstart, {\n        passive: !1\n      }), i.removeEventListener(t, "touchmove", this.touchmove), i.removeEventListener(t, "touchend", this.touchend), i.removeEventListener(t, "touchcancel", this.reset), this.offTemp();\n    }, Ar.prototype.offTemp = function () {\n      i.enableDrag(), i.removeEventListener(t.window, "mousemove", this.mousemove), i.removeEventListener(t.window, "mouseup", this.mouseup);\n    }, Ar.prototype.mousedown = function (e) {\n      this.down(t.extend({}, e, {\n        ctrlKey: !0,\n        preventDefault: function () {\n          return e.preventDefault();\n        }\n      }), i.mousePos(this.element, e)), i.addEventListener(t.window, "mousemove", this.mousemove), i.addEventListener(t.window, "mouseup", this.mouseup);\n    }, Ar.prototype.mousemove = function (t) {\n      this.move(t, i.mousePos(this.element, t));\n    }, Ar.prototype.mouseup = function (t) {\n      this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();\n    }, Ar.prototype.touchstart = function (t) {\n      1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.down({\n        type: "mousedown",\n        button: 0,\n        ctrlKey: !0,\n        preventDefault: function () {\n          return t.preventDefault();\n        }\n      }, this._startPos));\n    }, Ar.prototype.touchmove = function (t) {\n      1 !== t.targetTouches.length ? this.reset() : (this._lastPos = i.touchPos(this.element, t.targetTouches)[0], this.move({\n        preventDefault: function () {\n          return t.preventDefault();\n        }\n      }, this._lastPos));\n    }, Ar.prototype.touchend = function (t) {\n      0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n    }, Ar.prototype.reset = function () {\n      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n    };\n    var Lr = {\n      center: "translate(-50%,-50%)",\n      top: "translate(-50%,0)",\n      "top-left": "translate(0,0)",\n      "top-right": "translate(-100%,0)",\n      bottom: "translate(-50%,-100%)",\n      "bottom-left": "translate(0,-100%)",\n      "bottom-right": "translate(-100%,-100%)",\n      left: "translate(0,-50%)",\n      right: "translate(-100%,-50%)"\n    };\n    function Rr(t, e, i) {\n      var o = t.classList;\n      for (var r in Lr) o.remove("maplibregl-" + i + "-anchor-" + r, "mapboxgl-" + i + "-anchor-" + r);\n      o.add("maplibregl-" + i + "-anchor-" + e, "mapboxgl-" + i + "-anchor-" + e);\n    }\n    var kr,\n      Br = function (e) {\n        function o(o, r) {\n          if (e.call(this), (o instanceof t.window.HTMLElement || r) && (o = t.extend({\n            element: o\n          }, r)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o && o.anchor || "center", this._color = o && o.color || "#3FB1CE", this._scale = o && o.scale || 1, this._draggable = o && o.draggable || !1, this._clickTolerance = o && o.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = o && o.rotation || 0, this._rotationAlignment = o && o.rotationAlignment || "auto", this._pitchAlignment = o && o.pitchAlignment && "auto" !== o.pitchAlignment ? o.pitchAlignment : this._rotationAlignment, o && o.element) this._element = o.element, this._offset = t.Point.convert(o && o.offset || [0, 0]);else {\n            this._defaultMarker = !0, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker");\n            var a = i.createNS("http://www.w3.org/2000/svg", "svg");\n            a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", "41px"), a.setAttributeNS(null, "width", "27px"), a.setAttributeNS(null, "viewBox", "0 0 27 41");\n            var n = i.createNS("http://www.w3.org/2000/svg", "g");\n            n.setAttributeNS(null, "stroke", "none"), n.setAttributeNS(null, "stroke-width", "1"), n.setAttributeNS(null, "fill", "none"), n.setAttributeNS(null, "fill-rule", "evenodd");\n            var s = i.createNS("http://www.w3.org/2000/svg", "g");\n            s.setAttributeNS(null, "fill-rule", "nonzero");\n            var l = i.createNS("http://www.w3.org/2000/svg", "g");\n            l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000");\n            for (var c = 0, u = [{\n                rx: "10.5",\n                ry: "5.25002273"\n              }, {\n                rx: "10.5",\n                ry: "5.25002273"\n              }, {\n                rx: "9.5",\n                ry: "4.77275007"\n              }, {\n                rx: "8.5",\n                ry: "4.29549936"\n              }, {\n                rx: "7.5",\n                ry: "3.81822308"\n              }, {\n                rx: "6.5",\n                ry: "3.34094679"\n              }, {\n                rx: "5.5",\n                ry: "2.86367051"\n              }, {\n                rx: "4.5",\n                ry: "2.38636864"\n              }]; c < u.length; c += 1) {\n              var h = u[c],\n                p = i.createNS("http://www.w3.org/2000/svg", "ellipse");\n              p.setAttributeNS(null, "opacity", "0.04"), p.setAttributeNS(null, "cx", "10.5"), p.setAttributeNS(null, "cy", "5.80029008"), p.setAttributeNS(null, "rx", h.rx), p.setAttributeNS(null, "ry", h.ry), l.appendChild(p);\n            }\n            var d = i.createNS("http://www.w3.org/2000/svg", "g");\n            d.setAttributeNS(null, "fill", this._color);\n            var _ = i.createNS("http://www.w3.org/2000/svg", "path");\n            _.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d.appendChild(_);\n            var f = i.createNS("http://www.w3.org/2000/svg", "g");\n            f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "fill", "#000000");\n            var m = i.createNS("http://www.w3.org/2000/svg", "path");\n            m.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f.appendChild(m);\n            var g = i.createNS("http://www.w3.org/2000/svg", "g");\n            g.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g.setAttributeNS(null, "fill", "#FFFFFF");\n            var v = i.createNS("http://www.w3.org/2000/svg", "g");\n            v.setAttributeNS(null, "transform", "translate(8.0, 8.0)");\n            var y = i.createNS("http://www.w3.org/2000/svg", "circle");\n            y.setAttributeNS(null, "fill", "#000000"), y.setAttributeNS(null, "opacity", "0.25"), y.setAttributeNS(null, "cx", "5.5"), y.setAttributeNS(null, "cy", "5.5"), y.setAttributeNS(null, "r", "5.4999962");\n            var x = i.createNS("http://www.w3.org/2000/svg", "circle");\n            x.setAttributeNS(null, "fill", "#FFFFFF"), x.setAttributeNS(null, "cx", "5.5"), x.setAttributeNS(null, "cy", "5.5"), x.setAttributeNS(null, "r", "5.4999962"), v.appendChild(y), v.appendChild(x), s.appendChild(l), s.appendChild(d), s.appendChild(f), s.appendChild(g), s.appendChild(v), a.appendChild(s), a.setAttributeNS(null, "height", 41 * this._scale + "px"), a.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a), this._offset = t.Point.convert(o && o.offset || [0, -14]);\n          }\n          this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", function (t) {\n            t.preventDefault();\n          }), this._element.addEventListener("mousedown", function (t) {\n            t.preventDefault();\n          }), Rr(this._element, this._anchor, "marker"), this._popup = null;\n        }\n        return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.addTo = function (t) {\n          return this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;\n        }, o.prototype.remove = function () {\n          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this;\n        }, o.prototype.getLngLat = function () {\n          return this._lngLat;\n        }, o.prototype.setLngLat = function (e) {\n          return this._lngLat = t.LngLat.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;\n        }, o.prototype.getElement = function () {\n          return this._element;\n        }, o.prototype.setPopup = function (t) {\n          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {\n            if (!("offset" in t.options)) {\n              var e = Math.sqrt(Math.pow(13.5, 2) / 2);\n              t.options.offset = this._defaultMarker ? {\n                top: [0, 0],\n                "top-left": [0, 0],\n                "top-right": [0, 0],\n                bottom: [0, -38.1],\n                "bottom-left": [e, -1 * (24.6 + e)],\n                "bottom-right": [-e, -1 * (24.6 + e)],\n                left: [13.5, -24.6],\n                right: [-13.5, -24.6]\n              } : this._offset;\n            }\n            this._popup = t, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);\n          }\n          return this;\n        }, o.prototype._onKeyPress = function (t) {\n          var e = t.code,\n            i = t.charCode || t.keyCode;\n          "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup();\n        }, o.prototype._onMapClick = function (t) {\n          var e = t.originalEvent.target,\n            i = this._element;\n          this._popup && (e === i || i.contains(e)) && this.togglePopup();\n        }, o.prototype.getPopup = function () {\n          return this._popup;\n        }, o.prototype.togglePopup = function () {\n          var t = this._popup;\n          return t ? (t.isOpen() ? t.remove() : t.addTo(this._map), this) : this;\n        }, o.prototype._update = function (t) {\n          if (this._map) {\n            this._map.transform.renderWorldCopies && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);\n            var e = "";\n            "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");\n            var o = "";\n            "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o = "rotateX(0deg)" : "map" === this._pitchAlignment && (o = "rotateX(" + this._map.getPitch() + "deg)"), t && "moveend" !== t.type || (this._pos = this._pos.round()), i.setTransform(this._element, Lr[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o + " " + e);\n          }\n        }, o.prototype.getOffset = function () {\n          return this._offset;\n        }, o.prototype.setOffset = function (e) {\n          return this._offset = t.Point.convert(e), this._update(), this;\n        }, o.prototype._onMove = function (e) {\n          if (!this._isDragging) {\n            var i = this._clickTolerance || this._map._clickTolerance;\n            this._isDragging = e.point.dist(this._pointerdownPos) >= i;\n          }\n          this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));\n        }, o.prototype._onUp = function () {\n          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";\n        }, o.prototype._addDragHandler = function (t) {\n          this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(this._pos).add(this._offset), this._pointerdownPos = t.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));\n        }, o.prototype.setDraggable = function (t) {\n          return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;\n        }, o.prototype.isDraggable = function () {\n          return this._draggable;\n        }, o.prototype.setRotation = function (t) {\n          return this._rotation = t || 0, this._update(), this;\n        }, o.prototype.getRotation = function () {\n          return this._rotation;\n        }, o.prototype.setRotationAlignment = function (t) {\n          return this._rotationAlignment = t || "auto", this._update(), this;\n        }, o.prototype.getRotationAlignment = function () {\n          return this._rotationAlignment;\n        }, o.prototype.setPitchAlignment = function (t) {\n          return this._pitchAlignment = t && "auto" !== t ? t : this._rotationAlignment, this._update(), this;\n        }, o.prototype.getPitchAlignment = function () {\n          return this._pitchAlignment;\n        }, o;\n      }(t.Evented),\n      Or = {\n        positionOptions: {\n          enableHighAccuracy: !1,\n          maximumAge: 0,\n          timeout: 6e3\n        },\n        fitBoundsOptions: {\n          maxZoom: 15\n        },\n        trackUserLocation: !1,\n        showAccuracyCircle: !0,\n        showUserLocation: !0\n      },\n      Fr = 0,\n      Ur = !1,\n      Nr = function (e) {\n        function o(i) {\n          e.call(this), this.options = t.extend({}, Or, i), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);\n        }\n        return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.onAdd = function (e) {\n          var o;\n          return this._map = e, this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), o = this._setupUI, void 0 !== kr ? o(kr) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({\n            name: "geolocation"\n          }).then(function (t) {\n            o(kr = "denied" !== t.state);\n          }) : o(kr = !!t.window.navigator.geolocation), this._container;\n        }, o.prototype.onRemove = function () {\n          void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fr = 0, Ur = !1;\n        }, o.prototype._isOutOfMapMaxBounds = function (t) {\n          var e = this._map.getMaxBounds(),\n            i = t.coords;\n          return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth());\n        }, o.prototype._setErrorState = function () {\n          switch (this._watchState) {\n            case "WAITING_ACTIVE":\n              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");\n              break;\n            case "ACTIVE_LOCK":\n              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");\n              break;\n            case "BACKGROUND":\n              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");\n          }\n        }, o.prototype._onSuccess = function (e) {\n          if (this._map) {\n            if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e)), this._updateMarker(), void this._finish();\n            if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {\n              case "WAITING_ACTIVE":\n              case "ACTIVE_LOCK":\n              case "ACTIVE_ERROR":\n                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");\n                break;\n              case "BACKGROUND":\n              case "BACKGROUND_ERROR":\n                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");\n            }\n            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e)), this._finish();\n          }\n        }, o.prototype._updateCamera = function (e) {\n          var i = new t.LngLat(e.coords.longitude, e.coords.latitude),\n            o = e.coords.accuracy,\n            r = this._map.getBearing(),\n            a = t.extend({\n              bearing: r\n            }, this.options.fitBoundsOptions);\n          this._map.fitBounds(i.toBounds(o), a, {\n            geolocateSource: !0\n          });\n        }, o.prototype._updateMarker = function (e) {\n          if (e) {\n            var i = new t.LngLat(e.coords.longitude, e.coords.latitude);\n            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n        }, o.prototype._updateCircleRadius = function () {\n          var t = this._map._container.clientHeight / 2,\n            e = this._map.unproject([0, t]),\n            i = this._map.unproject([1, t]),\n            o = e.distanceTo(i),\n            r = Math.ceil(2 * this._accuracy / o);\n          this._circleElement.style.width = r + "px", this._circleElement.style.height = r + "px";\n        }, o.prototype._onZoom = function () {\n          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        }, o.prototype._onError = function (e) {\n          if (this._map) {\n            if (this.options.trackUserLocation) if (1 === e.code) {\n              this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;\n              var i = this._map._getUIString("GeolocateControl.LocationNotAvailable");\n              this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), void 0 !== this._geolocationWatchID && this._clearWatch();\n            } else {\n              if (3 === e.code && Ur) return;\n              this._setErrorState();\n            }\n            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e)), this._finish();\n          }\n        }, o.prototype._finish = function () {\n          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n        }, o.prototype._setupUI = function (e) {\n          var o = this;\n          if (this._container.addEventListener("contextmenu", function (t) {\n            return t.preventDefault();\n          }), this._geolocateButton = i.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), i.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", !0), this._geolocateButton.type = "button", !1 === e) {\n            t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");\n            var r = this._map._getUIString("GeolocateControl.LocationNotAvailable");\n            this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);\n          } else {\n            var a = this._map._getUIString("GeolocateControl.FindMyLocation");\n            this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);\n          }\n          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new Br(this._dotElement), this._circleElement = i.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Br({\n            element: this._circleElement,\n            pitchAlignment: "map"\n          }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", function (e) {\n            e.geolocateSource || "ACTIVE_LOCK" !== o._watchState || e.originalEvent && "resize" === e.originalEvent.type || (o._watchState = "BACKGROUND", o._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), o._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), o.fire(new t.Event("trackuserlocationend")));\n          });\n        }, o.prototype.trigger = function () {\n          if (!this._setup) return t.warnOnce("Geolocate control triggered before added to a map"), !1;\n          if (this.options.trackUserLocation) {\n            switch (this._watchState) {\n              case "OFF":\n                this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));\n                break;\n              case "WAITING_ACTIVE":\n              case "ACTIVE_LOCK":\n              case "ACTIVE_ERROR":\n              case "BACKGROUND_ERROR":\n                Fr--, Ur = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));\n                break;\n              case "BACKGROUND":\n                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));\n            }\n            switch (this._watchState) {\n              case "WAITING_ACTIVE":\n                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");\n                break;\n              case "ACTIVE_LOCK":\n                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");\n                break;\n              case "ACTIVE_ERROR":\n                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");\n                break;\n              case "BACKGROUND":\n                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");\n                break;\n              case "BACKGROUND_ERROR":\n                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error");\n            }\n            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n              var e;\n              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fr > 1 ? (e = {\n                maximumAge: 6e5,\n                timeout: 0\n              }, Ur = !0) : (e = this.options.positionOptions, Ur = !1), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e);\n            }\n          } else t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n          return !0;\n        }, o.prototype._clearWatch = function () {\n          t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);\n        }, o;\n      }(t.Evented),\n      Zr = {\n        maxWidth: 100,\n        unit: "metric"\n      },\n      qr = function (e) {\n        this.options = t.extend({}, Zr, e), t.bindAll(["_onMove", "setUnit"], this);\n      };\n    function jr(t, e, i) {\n      var o = i && i.maxWidth || 100,\n        r = t._container.clientHeight / 2,\n        a = t.unproject([0, r]),\n        n = t.unproject([o, r]),\n        s = a.distanceTo(n);\n      if (i && "imperial" === i.unit) {\n        var l = 3.2808 * s;\n        l > 5280 ? Vr(e, o, l / 5280, t._getUIString("ScaleControl.Miles")) : Vr(e, o, l, t._getUIString("ScaleControl.Feet"));\n      } else i && "nautical" === i.unit ? Vr(e, o, s / 1852, t._getUIString("ScaleControl.NauticalMiles")) : s >= 1e3 ? Vr(e, o, s / 1e3, t._getUIString("ScaleControl.Kilometers")) : Vr(e, o, s, t._getUIString("ScaleControl.Meters"));\n    }\n    function Vr(t, e, i, o) {\n      var r,\n        a,\n        n,\n        s = (r = i, (a = Math.pow(10, ("" + Math.floor(r)).length - 1)) * (n = (n = r / a) >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : n >= 1 ? 1 : function (t) {\n          var e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));\n          return Math.round(t * e) / e;\n        }(n)));\n      t.style.width = e * (s / i) + "px", t.innerHTML = s + "&nbsp;" + o;\n    }\n    qr.prototype.getDefaultPosition = function () {\n      return "bottom-left";\n    }, qr.prototype._onMove = function () {\n      jr(this._map, this._container, this.options);\n    }, qr.prototype.onAdd = function (t) {\n      return this._map = t, this._container = i.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;\n    }, qr.prototype.onRemove = function () {\n      i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;\n    }, qr.prototype.setUnit = function (t) {\n      this.options.unit = t, jr(this._map, this._container, this.options);\n    };\n    var Gr = function (e) {\n      this._fullscreen = !1, e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control \'container\' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");\n    };\n    Gr.prototype.onAdd = function (e) {\n      return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;\n    }, Gr.prototype.onRemove = function () {\n      i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n    }, Gr.prototype._checkFullscreenSupport = function () {\n      return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);\n    }, Gr.prototype._setupUI = function () {\n      var e = this._fullscreenButton = i.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);\n      i.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", !0), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n    }, Gr.prototype._updateTitle = function () {\n      var t = this._getTitle();\n      this._fullscreenButton.setAttribute("aria-label", t), this._fullscreenButton.title = t;\n    }, Gr.prototype._getTitle = function () {\n      return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");\n    }, Gr.prototype._isFullscreen = function () {\n      return this._fullscreen;\n    }, Gr.prototype._changeIcon = function () {\n      (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());\n    }, Gr.prototype._onClickFullscreen = function () {\n      this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n    };\n    var Wr = {\n        closeButton: !0,\n        closeOnClick: !0,\n        focusAfterOpen: !0,\n        className: "",\n        maxWidth: "240px"\n      },\n      Xr = ["a[href]", "[tabindex]:not([tabindex=\'-1\'])", "[contenteditable]:not([contenteditable=\'false\'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "),\n      Hr = function (e) {\n        function o(i) {\n          e.call(this), this.options = t.extend(Object.create(Wr), i), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);\n        }\n        return e && (o.__proto__ = e), (o.prototype = Object.create(e && e.prototype)).constructor = o, o.prototype.addTo = function (e) {\n          return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;\n        }, o.prototype.isOpen = function () {\n          return !!this._map;\n        }, o.prototype.remove = function () {\n          return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;\n        }, o.prototype.getLngLat = function () {\n          return this._lngLat;\n        }, o.prototype.setLngLat = function (e) {\n          return this._lngLat = t.LngLat.convert(e), this._pos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;\n        }, o.prototype.trackPointer = function () {\n          return this._trackPointer = !0, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;\n        }, o.prototype.getElement = function () {\n          return this._container;\n        }, o.prototype.setText = function (e) {\n          return this.setDOMContent(t.window.document.createTextNode(e));\n        }, o.prototype.setHTML = function (e) {\n          var i,\n            o = t.window.document.createDocumentFragment(),\n            r = t.window.document.createElement("body");\n          for (r.innerHTML = e; i = r.firstChild;) o.appendChild(i);\n          return this.setDOMContent(o);\n        }, o.prototype.getMaxWidth = function () {\n          return this._container && this._container.style.maxWidth;\n        }, o.prototype.setMaxWidth = function (t) {\n          return this.options.maxWidth = t, this._update(), this;\n        }, o.prototype.setDOMContent = function (t) {\n          if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);else this._content = i.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);\n          return this._content.appendChild(t), this._createCloseButton(), this._update(), this._focusFirstElement(), this;\n        }, o.prototype.addClassName = function (t) {\n          this._container && this._container.classList.add(t);\n        }, o.prototype.removeClassName = function (t) {\n          this._container && this._container.classList.remove(t);\n        }, o.prototype.setOffset = function (t) {\n          return this.options.offset = t, this._update(), this;\n        }, o.prototype.toggleClassName = function (t) {\n          if (this._container) return this._container.classList.toggle(t);\n        }, o.prototype._createCloseButton = function () {\n          this.options.closeButton && (this._closeButton = i.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));\n        }, o.prototype._onMouseUp = function (t) {\n          this._update(t.point);\n        }, o.prototype._onMouseMove = function (t) {\n          this._update(t.point);\n        }, o.prototype._onDrag = function (t) {\n          this._update(t.point);\n        }, o.prototype._update = function (e) {\n          var o = this;\n          if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = i.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function (t) {\n            return o._container.classList.add(t);\n          }), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e)) {\n            var r = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat),\n              a = this.options.anchor,\n              n = function e(i) {\n                if (i) {\n                  if ("number" == typeof i) {\n                    var o = Math.round(Math.sqrt(.5 * Math.pow(i, 2)));\n                    return {\n                      center: new t.Point(0, 0),\n                      top: new t.Point(0, i),\n                      "top-left": new t.Point(o, o),\n                      "top-right": new t.Point(-o, o),\n                      bottom: new t.Point(0, -i),\n                      "bottom-left": new t.Point(o, -o),\n                      "bottom-right": new t.Point(-o, -o),\n                      left: new t.Point(i, 0),\n                      right: new t.Point(-i, 0)\n                    };\n                  }\n                  if (i instanceof t.Point || Array.isArray(i)) {\n                    var r = t.Point.convert(i);\n                    return {\n                      center: r,\n                      top: r,\n                      "top-left": r,\n                      "top-right": r,\n                      bottom: r,\n                      "bottom-left": r,\n                      "bottom-right": r,\n                      left: r,\n                      right: r\n                    };\n                  }\n                  return {\n                    center: t.Point.convert(i.center || [0, 0]),\n                    top: t.Point.convert(i.top || [0, 0]),\n                    "top-left": t.Point.convert(i["top-left"] || [0, 0]),\n                    "top-right": t.Point.convert(i["top-right"] || [0, 0]),\n                    bottom: t.Point.convert(i.bottom || [0, 0]),\n                    "bottom-left": t.Point.convert(i["bottom-left"] || [0, 0]),\n                    "bottom-right": t.Point.convert(i["bottom-right"] || [0, 0]),\n                    left: t.Point.convert(i.left || [0, 0]),\n                    right: t.Point.convert(i.right || [0, 0])\n                  };\n                }\n                return e(new t.Point(0, 0));\n              }(this.options.offset);\n            if (!a) {\n              var s,\n                l = this._container.offsetWidth,\n                c = this._container.offsetHeight;\n              s = r.y + n.bottom.y < c ? ["top"] : r.y > this._map.transform.height - c ? ["bottom"] : [], r.x < l / 2 ? s.push("left") : r.x > this._map.transform.width - l / 2 && s.push("right"), a = 0 === s.length ? "bottom" : s.join("-");\n            }\n            var u = r.add(n[a]).round();\n            i.setTransform(this._container, Lr[a] + " translate(" + u.x + "px," + u.y + "px)"), Rr(this._container, a, "popup");\n          }\n        }, o.prototype._focusFirstElement = function () {\n          if (this.options.focusAfterOpen && this._container) {\n            var t = this._container.querySelector(Xr);\n            t && t.focus();\n          }\n        }, o.prototype._onClose = function () {\n          this.remove();\n        }, o;\n      }(t.Evented),\n      Kr = {\n        version: t.version,\n        supported: e,\n        setRTLTextPlugin: t.setRTLTextPlugin,\n        getRTLTextPluginStatus: t.getRTLTextPluginStatus,\n        Map: Sr,\n        NavigationControl: Dr,\n        GeolocateControl: Nr,\n        AttributionControl: yr,\n        ScaleControl: qr,\n        FullscreenControl: Gr,\n        Popup: Hr,\n        Marker: Br,\n        Style: je,\n        LngLat: t.LngLat,\n        LngLatBounds: t.LngLatBounds,\n        Point: t.Point,\n        MercatorCoordinate: t.MercatorCoordinate,\n        Evented: t.Evented,\n        config: t.config,\n        prewarm: function () {\n          Ft().acquire(Rt);\n        },\n        clearPrewarmedResources: function () {\n          var t = Bt;\n          t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Rt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));\n        },\n        get accessToken() {\n          return t.config.ACCESS_TOKEN;\n        },\n        set accessToken(e) {\n          t.config.ACCESS_TOKEN = e;\n        },\n        get baseApiUrl() {\n          return t.config.API_URL;\n        },\n        set baseApiUrl(e) {\n          t.config.API_URL = e;\n        },\n        get workerCount() {\n          return kt.workerCount;\n        },\n        set workerCount(t) {\n          kt.workerCount = t;\n        },\n        get maxParallelImageRequests() {\n          return t.config.MAX_PARALLEL_IMAGE_REQUESTS;\n        },\n        set maxParallelImageRequests(e) {\n          t.config.MAX_PARALLEL_IMAGE_REQUESTS = e;\n        },\n        clearStorage: function (e) {\n          t.clearTileCache(e);\n        },\n        workerUrl: "",\n        addProtocol: function (e, i) {\n          t.config.REGISTERED_PROTOCOLS[e] = i;\n        },\n        removeProtocol: function (e) {\n          delete t.config.REGISTERED_PROTOCOLS[e];\n        }\n      };\n    return Kr;\n  });\n\n  //\n\n  return maplibregl;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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QUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3REFBd0QsY0FBYztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCx5REFBeUQsY0FBYztBQUN2RTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSx3REFBd0Q7QUFDeEQsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUMsY0FBYztBQUMvQztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUMsY0FBYztBQUMvQztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFzRCxnQ0FBZ0MsUUFBUTtBQUMzSTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLGtDQUFrQztBQUMxRTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQixvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0IsNEJBQTRCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2T0FBNk87QUFDN087QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixNQUFNO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBEQUEwRCxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNB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Y0FBYztBQUN4QztBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGdGQUFnRixjQUFjO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBEQUEwRCxjQUFjO0FBQ3hF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Q1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGNBQWM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0hBQXdIO0FBQ3hILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsdUVBQXVFLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QixRQUFRLGdCQUFnQixjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHVDQUF1QyxjQUFjO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxjQUFjO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtQ0FBbUM7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNB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QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsY0FBYztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWMsa0NBQWtDLDhCQUE4QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0lBQWtJLGNBQWM7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJRQUEyUSxpQkFBaUI7QUFDNVI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLG1DQUFtQyxpQkFBaUIseURBQXlEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNFVBQTRVLGNBQWM7QUFDMVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlJBQTJSO0FBQzNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlNQUFpTSxjQUFjO0FBQy9NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNGRBQTRkO0FBQzVkLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZXQUE2VyxZQUFZO0FBQ3pYO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0QseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLHFCQUFxQixPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDZEQUE2RCxvQ0FBb0M7QUFDakcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHNDQUFzQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUNBQXFDO0FBQzVDLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1Q0FBdUM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcscUhBQXFILDZCQUE2QjtBQUM5UDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SkFBNkosY0FBYztBQUMzSztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQsa0RBQWtELElBQUk7QUFDdEQ7QUFDQSxLQUFLO0FBQ0wsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxRQUFRLGlKQUFpSixjQUFjO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixRQUFRLFFBQVEsNEJBQTRCLGNBQWM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpUUFBaVE7QUFDalE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULGlDQUFpQztBQUNqQyxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxL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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9tYXBsaWJyZS1nbC9kaXN0L21hcGxpYnJlLWdsLmpzPzJjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTWFwTGlicmUgR0wgSlMgaXMgbGljZW5zZWQgdW5kZXIgdGhlIDMtQ2xhdXNlIEJTRCBMaWNlbnNlLiBGdWxsIHRleHQgb2YgbGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL21hcGxpYnJlL21hcGxpYnJlLWdsLWpzL2Jsb2IvdjEuMTUuMy9MSUNFTlNFLnR4dCAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOiAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5tYXBsaWJyZWdsID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIHZhciBzaGFyZWQsIHdvcmtlciwgbWFwbGlicmVnbDtcbiAgLy8gZGVmaW5lIGdldHMgY2FsbGVkIHRocmVlIHRpbWVzOiBvbmUgZm9yIGVhY2ggY2h1bmsuIHdlIHJlbHkgb24gdGhlIG9yZGVyXG4gIC8vIHRoZXkncmUgaW1wb3J0ZWQgdG8ga25vdyB3aGljaCBpcyB3aGljaFxuICBmdW5jdGlvbiBkZWZpbmUoXywgY2h1bmspIHtcbiAgICBpZiAoIXNoYXJlZCkge1xuICAgICAgc2hhcmVkID0gY2h1bms7XG4gICAgfSBlbHNlIGlmICghd29ya2VyKSB7XG4gICAgICB3b3JrZXIgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdvcmtlckJ1bmRsZVN0cmluZyA9ICd2YXIgc2hhcmVkQ2h1bmsgPSB7fTsgKCcgKyBzaGFyZWQgKyAnKShzaGFyZWRDaHVuayk7ICgnICsgd29ya2VyICsgJykoc2hhcmVkQ2h1bmspOyc7XG4gICAgICB2YXIgc2hhcmVkQ2h1bmsgPSB7fTtcbiAgICAgIHNoYXJlZChzaGFyZWRDaHVuayk7XG4gICAgICBtYXBsaWJyZWdsID0gY2h1bmsoc2hhcmVkQ2h1bmspO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1hcGxpYnJlZ2wud29ya2VyVXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dvcmtlckJ1bmRsZVN0cmluZ10sIHtcbiAgICAgICAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlZmluZShbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAodCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gZSh0LCBlKSB7XG4gICAgICByZXR1cm4gdChlID0ge1xuICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgfSwgZS5leHBvcnRzKSwgZS5leHBvcnRzO1xuICAgIH1cbiAgICB2YXIgciA9IG47XG4gICAgZnVuY3Rpb24gbih0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmN4ID0gMyAqIHQsIHRoaXMuYnggPSAzICogKHIgLSB0KSAtIHRoaXMuY3gsIHRoaXMuYXggPSAxIC0gdGhpcy5jeCAtIHRoaXMuYngsIHRoaXMuY3kgPSAzICogZSwgdGhpcy5ieSA9IDMgKiAobiAtIGUpIC0gdGhpcy5jeSwgdGhpcy5heSA9IDEgLSB0aGlzLmN5IC0gdGhpcy5ieSwgdGhpcy5wMXggPSB0LCB0aGlzLnAxeSA9IG4sIHRoaXMucDJ4ID0gciwgdGhpcy5wMnkgPSBuO1xuICAgIH1cbiAgICBuLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG4gICAgfSwgbi5wcm90b3R5cGUuc2FtcGxlQ3VydmVZID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAoKHRoaXMuYXkgKiB0ICsgdGhpcy5ieSkgKiB0ICsgdGhpcy5jeSkgKiB0O1xuICAgIH0sIG4ucHJvdG90eXBlLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVggPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICgzICogdGhpcy5heCAqIHQgKyAyICogdGhpcy5ieCkgKiB0ICsgdGhpcy5jeDtcbiAgICB9LCBuLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciwgbiwgaSwgYSwgbztcbiAgICAgIGZvciAodm9pZCAwID09PSBlICYmIChlID0gMWUtNiksIGkgPSB0LCBvID0gMDsgbyA8IDg7IG8rKykge1xuICAgICAgICBpZiAoYSA9IHRoaXMuc2FtcGxlQ3VydmVYKGkpIC0gdCwgTWF0aC5hYnMoYSkgPCBlKSByZXR1cm4gaTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgoaSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhzKSA8IDFlLTYpIGJyZWFrO1xuICAgICAgICBpIC09IGEgLyBzO1xuICAgICAgfVxuICAgICAgaWYgKChpID0gdCkgPCAociA9IDApKSByZXR1cm4gcjtcbiAgICAgIGlmIChpID4gKG4gPSAxKSkgcmV0dXJuIG47XG4gICAgICBmb3IgKDsgciA8IG47KSB7XG4gICAgICAgIGlmIChhID0gdGhpcy5zYW1wbGVDdXJ2ZVgoaSksIE1hdGguYWJzKGEgLSB0KSA8IGUpIHJldHVybiBpO1xuICAgICAgICB0ID4gYSA/IHIgPSBpIDogbiA9IGksIGkgPSAuNSAqIChuIC0gcikgKyByO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgbi5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgodCwgZSkpO1xuICAgIH07XG4gICAgdmFyIGkgPSBhO1xuICAgIGZ1bmN0aW9uIGEodCwgZSkge1xuICAgICAgdGhpcy54ID0gdCwgdGhpcy55ID0gZTtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUgPSB7XG4gICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGEodGhpcy54LCB0aGlzLnkpO1xuICAgICAgfSxcbiAgICAgIGFkZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHQpO1xuICAgICAgfSxcbiAgICAgIHN1YjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHQpO1xuICAgICAgfSxcbiAgICAgIG11bHRCeVBvaW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0QnlQb2ludCh0KTtcbiAgICAgIH0sXG4gICAgICBkaXZCeVBvaW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZCeVBvaW50KHQpO1xuICAgICAgfSxcbiAgICAgIG11bHQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX211bHQodCk7XG4gICAgICB9LFxuICAgICAgZGl2OiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYodCk7XG4gICAgICB9LFxuICAgICAgcm90YXRlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUodCk7XG4gICAgICB9LFxuICAgICAgcm90YXRlQXJvdW5kOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGVBcm91bmQodCwgZSk7XG4gICAgICB9LFxuICAgICAgbWF0TXVsdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbWF0TXVsdCh0KTtcbiAgICAgIH0sXG4gICAgICB1bml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTtcbiAgICAgIH0sXG4gICAgICBwZXJwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTtcbiAgICAgIH0sXG4gICAgICByb3VuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xuICAgICAgfSxcbiAgICAgIG1hZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgICB9LFxuICAgICAgZXF1YWxzOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSB0LnggJiYgdGhpcy55ID09PSB0Lnk7XG4gICAgICB9LFxuICAgICAgZGlzdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIodCkpO1xuICAgICAgfSxcbiAgICAgIGRpc3RTcXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdC54IC0gdGhpcy54LFxuICAgICAgICAgIHIgPSB0LnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBlICogZSArIHIgKiByO1xuICAgICAgfSxcbiAgICAgIGFuZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICAgIH0sXG4gICAgICBhbmdsZVRvOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnkgLSB0LnksIHRoaXMueCAtIHQueCk7XG4gICAgICB9LFxuICAgICAgYW5nbGVXaXRoOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmdsZVdpdGhTZXAodC54LCB0LnkpO1xuICAgICAgfSxcbiAgICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy54ICogZSAtIHRoaXMueSAqIHQsIHRoaXMueCAqIHQgKyB0aGlzLnkgKiBlKTtcbiAgICAgIH0sXG4gICAgICBfbWF0TXVsdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0WzJdICogdGhpcy54ICsgdFszXSAqIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IHRbMF0gKiB0aGlzLnggKyB0WzFdICogdGhpcy55LCB0aGlzLnkgPSBlLCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9hZGQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKz0gdC54LCB0aGlzLnkgKz0gdC55LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9zdWI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLT0gdC54LCB0aGlzLnkgLT0gdC55LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9tdWx0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICo9IHQsIHRoaXMueSAqPSB0LCB0aGlzO1xuICAgICAgfSxcbiAgICAgIF9kaXY6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLz0gdCwgdGhpcy55IC89IHQsIHRoaXM7XG4gICAgICB9LFxuICAgICAgX211bHRCeVBvaW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICo9IHQueCwgdGhpcy55ICo9IHQueSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfZGl2QnlQb2ludDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAvPSB0LngsIHRoaXMueSAvPSB0LnksIHRoaXM7XG4gICAgICB9LFxuICAgICAgX3VuaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpdih0aGlzLm1hZygpKSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcGVycDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXMueSA9IHRoaXMueCwgdGhpcy54ID0gLXQsIHRoaXM7XG4gICAgICB9LFxuICAgICAgX3JvdGF0ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNvcyh0KSxcbiAgICAgICAgICByID0gTWF0aC5zaW4odCksXG4gICAgICAgICAgbiA9IHIgKiB0aGlzLnggKyBlICogdGhpcy55O1xuICAgICAgICByZXR1cm4gdGhpcy54ID0gZSAqIHRoaXMueCAtIHIgKiB0aGlzLnksIHRoaXMueSA9IG4sIHRoaXM7XG4gICAgICB9LFxuICAgICAgX3JvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBNYXRoLmNvcyh0KSxcbiAgICAgICAgICBuID0gTWF0aC5zaW4odCksXG4gICAgICAgICAgaSA9IGUueSArIG4gKiAodGhpcy54IC0gZS54KSArIHIgKiAodGhpcy55IC0gZS55KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IGUueCArIHIgKiAodGhpcy54IC0gZS54KSAtIG4gKiAodGhpcy55IC0gZS55KSwgdGhpcy55ID0gaSwgdGhpcztcbiAgICAgIH0sXG4gICAgICBfcm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzO1xuICAgICAgfVxuICAgIH0sIGEuY29udmVydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIGEgPyB0IDogQXJyYXkuaXNBcnJheSh0KSA/IG5ldyBhKHRbMF0sIHRbMV0pIDogdDtcbiAgICB9O1xuICAgIHZhciBvID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB7fSxcbiAgICAgIHMgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICAgIGZ1bmN0aW9uIHUodCwgZSwgbiwgaSkge1xuICAgICAgdmFyIGEgPSBuZXcgcih0LCBlLCBuLCBpKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gYS5zb2x2ZSh0KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBsID0gdSguMjUsIC4xLCAuMjUsIDEpO1xuICAgIGZ1bmN0aW9uIHAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHIsIE1hdGgubWF4KGUsIHQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYyh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHIgLSBlLFxuICAgICAgICBpID0gKCh0IC0gZSkgJSBuICsgbikgJSBuICsgZTtcbiAgICAgIHJldHVybiBpID09PSBlID8gciA6IGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGgodCkge1xuICAgICAgZm9yICh2YXIgZSA9IFtdLCByID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IHItLSA+IDA7KSBlW3JdID0gYXJndW1lbnRzW3IgKyAxXTtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuICAgICAgICBmb3IgKHZhciBvIGluIGEpIHRbb10gPSBhW29dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHZhciBmID0gMTtcbiAgICBmdW5jdGlvbiB5KCkge1xuICAgICAgcmV0dXJuIGYrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgPyAoZSBeIDE2ICogTWF0aC5yYW5kb20oKSA+PiBlIC8gNCkudG9TdHJpbmcoMTYpIDogKFsxZTddICsgLVsxZTNdICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgdCk7XG4gICAgICB9KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG0odCkge1xuICAgICAgcmV0dXJuICEhdCAmJiAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVs0XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQvaS50ZXN0KHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2KHQsIGUpIHtcbiAgICAgIHQuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICBlW3RdICYmIChlW3RdID0gZVt0XS5iaW5kKGUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnKHQsIGUpIHtcbiAgICAgIHJldHVybiAtMSAhPT0gdC5pbmRleE9mKGUsIHQubGVuZ3RoIC0gZS5sZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0ge307XG4gICAgICBmb3IgKHZhciBpIGluIHQpIG5baV0gPSBlLmNhbGwociB8fCB0aGlzLCB0W2ldLCBpLCB0KTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0ge307XG4gICAgICBmb3IgKHZhciBpIGluIHQpIGUuY2FsbChyIHx8IHRoaXMsIHRbaV0sIGksIHQpICYmIChuW2ldID0gdFtpXSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdyh0KSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IHQubWFwKHcpIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiB0ID8geCh0LCB3KSA6IHQ7XG4gICAgfVxuICAgIHZhciBfID0ge307XG4gICAgZnVuY3Rpb24gQSh0KSB7XG4gICAgICBfW3RdIHx8IChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBjb25zb2xlICYmIGNvbnNvbGUud2Fybih0KSwgX1t0XSA9ICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUyh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gKHIueSAtIHQueSkgKiAoZS54IC0gdC54KSA+IChlLnkgLSB0LnkpICogKHIueCAtIHQueCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGsodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gdC5sZW5ndGgsIGkgPSBuIC0gMSwgYSA9IHZvaWQgMCwgbyA9IHZvaWQgMDsgciA8IG47IGkgPSByKyspIGUgKz0gKChvID0gdFtpXSkueCAtIChhID0gdFtyXSkueCkgKiAoYS55ICsgby55KTtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJKCkge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6KHQpIHtcbiAgICAgIHZhciBlID0ge307XG4gICAgICBpZiAodC5yZXBsYWNlKC8oPzpefCg/OlxccypcXCxcXHMqKSkoW15cXHgwMC1cXHgyMFxcKFxcKTw+QFxcLDtcXDpcXFxcXCJcXC9cXFtcXF1cXD9cXD1cXHtcXH1cXHg3Rl0rKSg/OlxcPSg/OihbXlxceDAwLVxceDIwXFwoXFwpPD5AXFwsO1xcOlxcXFxcIlxcL1xcW1xcXVxcP1xcPVxce1xcfVxceDdGXSspfCg/OlxcXCIoKD86W15cIlxcXFxdfFxcXFwuKSopXFxcIikpKT8vZywgZnVuY3Rpb24gKHQsIHIsIG4sIGkpIHtcbiAgICAgICAgdmFyIGEgPSBuIHx8IGk7XG4gICAgICAgIHJldHVybiBlW3JdID0gIWEgfHwgYS50b0xvd2VyQ2FzZSgpLCBcIlwiO1xuICAgICAgfSksIGVbXCJtYXgtYWdlXCJdKSB7XG4gICAgICAgIHZhciByID0gcGFyc2VJbnQoZVtcIm1heC1hZ2VcIl0sIDEwKTtcbiAgICAgICAgaXNOYU4ocikgPyBkZWxldGUgZVtcIm1heC1hZ2VcIl0gOiBlW1wibWF4LWFnZVwiXSA9IHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgdmFyIEMgPSBudWxsO1xuICAgIGZ1bmN0aW9uIEUodCkge1xuICAgICAgaWYgKG51bGwgPT0gQykge1xuICAgICAgICB2YXIgZSA9IHQubmF2aWdhdG9yID8gdC5uYXZpZ2F0b3IudXNlckFnZW50IDogbnVsbDtcbiAgICAgICAgQyA9ICEhdC5zYWZhcmkgfHwgISghZSB8fCAhKC9cXGIoaVBhZHxpUGhvbmV8aVBvZClcXGIvLnRlc3QoZSkgfHwgZS5tYXRjaChcIlNhZmFyaVwiKSAmJiAhZS5tYXRjaChcIkNocm9tZVwiKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFAodCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGUgPSBvW3RdO1xuICAgICAgICByZXR1cm4gZS5zZXRJdGVtKFwiX21hcGJveF90ZXN0X1wiLCAxKSwgZS5yZW1vdmVJdGVtKFwiX21hcGJveF90ZXN0X1wiKSwgITA7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIE0sXG4gICAgICBCLFxuICAgICAgVCxcbiAgICAgIFYsXG4gICAgICBGID0gby5wZXJmb3JtYW5jZSAmJiBvLnBlcmZvcm1hbmNlLm5vdyA/IG8ucGVyZm9ybWFuY2Uubm93LmJpbmQoby5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vdy5iaW5kKERhdGUpLFxuICAgICAgRCA9IG8ucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IG8ubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IG8ud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IG8ubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICBMID0gby5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBvLm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IG8ud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgby5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lLFxuICAgICAgUiA9IHtcbiAgICAgICAgbm93OiBGLFxuICAgICAgICBmcmFtZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IEQodCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gTChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbWFnZURhdGE6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMCk7XG4gICAgICAgICAgdmFyIHIgPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgICAgICBuID0gci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgaWYgKCFuKSB0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyAyZCBjb250ZXh0XCIpO1xuICAgICAgICAgIHJldHVybiByLndpZHRoID0gdC53aWR0aCwgci5oZWlnaHQgPSB0LmhlaWdodCwgbi5kcmF3SW1hZ2UodCwgMCwgMCwgdC53aWR0aCwgdC5oZWlnaHQpLCBuLmdldEltYWdlRGF0YSgtZSwgLWUsIHQud2lkdGggKyAyICogZSwgdC5oZWlnaHQgKyAyICogZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmVVUkw6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIE0gfHwgKE0gPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKSwgTS5ocmVmID0gdCwgTS5ocmVmO1xuICAgICAgICB9LFxuICAgICAgICBoYXJkd2FyZUNvbmN1cnJlbmN5OiBvLm5hdmlnYXRvciAmJiBvLm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDQsXG4gICAgICAgIGdldCBkZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgICAgICAgIHJldHVybiBvLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gISFvLm1hdGNoTWVkaWEgJiYgKG51bGwgPT0gQiAmJiAoQiA9IG8ubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpKSwgQi5tYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIE8gPSB7XG4gICAgICAgIEFQSV9VUkw6IFwiaHR0cHM6Ly9hcGkubWFwYm94LmNvbVwiLFxuICAgICAgICBnZXQgRVZFTlRTX1VSTCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5BUElfVVJMID8gMCA9PT0gdGhpcy5BUElfVVJMLmluZGV4T2YoXCJodHRwczovL2FwaS5tYXBib3guY25cIikgPyBcImh0dHBzOi8vZXZlbnRzLm1hcGJveC5jbi9ldmVudHMvdjJcIiA6IDAgPT09IHRoaXMuQVBJX1VSTC5pbmRleE9mKFwiaHR0cHM6Ly9hcGkubWFwYm94LmNvbVwiKSA/IFwiaHR0cHM6Ly9ldmVudHMubWFwYm94LmNvbS9ldmVudHMvdjJcIiA6IG51bGwgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBGRUVEQkFDS19VUkw6IFwiaHR0cHM6Ly9hcHBzLm1hcGJveC5jb20vZmVlZGJhY2tcIixcbiAgICAgICAgUkVRVUlSRV9BQ0NFU1NfVE9LRU46ICEwLFxuICAgICAgICBBQ0NFU1NfVE9LRU46IG51bGwsXG4gICAgICAgIE1BWF9QQVJBTExFTF9JTUFHRV9SRVFVRVNUUzogMTYsXG4gICAgICAgIFJFR0lTVEVSRURfUFJPVE9DT0xTOiB7fVxuICAgICAgfSxcbiAgICAgIFUgPSB7XG4gICAgICAgIHN1cHBvcnRlZDogITEsXG4gICAgICAgIHRlc3RTdXBwb3J0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICFqICYmIFYgJiYgKHEgPyBOKHQpIDogVCA9IHQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaiA9ICExLFxuICAgICAgcSA9ICExO1xuICAgIGZ1bmN0aW9uIE4odCkge1xuICAgICAgdmFyIGUgPSB0LmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELCBlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0LnRleEltYWdlMkQodC5URVhUVVJFXzJELCAwLCB0LlJHQkEsIHQuUkdCQSwgdC5VTlNJR05FRF9CWVRFLCBWKSwgdC5pc0NvbnRleHRMb3N0KCkpIHJldHVybjtcbiAgICAgICAgVS5zdXBwb3J0ZWQgPSAhMDtcbiAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICB0LmRlbGV0ZVRleHR1cmUoZSksIGogPSAhMDtcbiAgICB9XG4gICAgby5kb2N1bWVudCAmJiAoKFYgPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIikpLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIFQgJiYgTihUKSwgVCA9IG51bGwsIHEgPSAhMDtcbiAgICB9LCBWLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBqID0gITAsIFQgPSBudWxsO1xuICAgIH0sIFYuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaDRBQUFCWFJVSlFWbEE0VEJFQUFBQXZBUUFBQUFmUS8vNzN2LytCaU9oL0FBQT1cIik7XG4gICAgdmFyIEsgPSBcIjAxXCIsXG4gICAgICBHID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuID0gdCwgdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gPSBlLCB0aGlzLl9jcmVhdGVTa3VUb2tlbigpO1xuICAgICAgfTtcbiAgICBmdW5jdGlvbiBaKHQpIHtcbiAgICAgIHJldHVybiAwID09PSB0LmluZGV4T2YoXCJtYXBib3g6XCIpO1xuICAgIH1cbiAgICBHLnByb3RvdHlwZS5fY3JlYXRlU2t1VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IFwiXCIsIGUgPSAwOyBlIDwgMTA7IGUrKykgdCArPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCJbTWF0aC5mbG9vcig2MiAqIE1hdGgucmFuZG9tKCkpXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbjogW1wiMVwiLCBLLCB0XS5qb2luKFwiXCIpLFxuICAgICAgICAgIHRva2VuRXhwaXJlc0F0OiBEYXRlLm5vdygpICsgNDMyZTVcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcbiAgICAgIHRoaXMuX3NrdVRva2VuID0gdC50b2tlbiwgdGhpcy5fc2t1VG9rZW5FeHBpcmVzQXQgPSB0LnRva2VuRXhwaXJlc0F0O1xuICAgIH0sIEcucHJvdG90eXBlLl9pc1NrdVRva2VuRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpID4gdGhpcy5fc2t1VG9rZW5FeHBpcmVzQXQ7XG4gICAgfSwgRy5wcm90b3R5cGUudHJhbnNmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtUmVxdWVzdEZuICYmIHRoaXMuX3RyYW5zZm9ybVJlcXVlc3RGbih0LCBlKSB8fCB7XG4gICAgICAgIHVybDogdFxuICAgICAgfTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgcmV0dXJuIHIucGF0aCA9IFwiL3N0eWxlcy92MVwiICsgci5wYXRoLCB0aGlzLl9tYWtlQVBJVVJMKHIsIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IGUpO1xuICAgIH0sIEcucHJvdG90eXBlLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgcmV0dXJuIHIucGF0aCA9IFwiL2ZvbnRzL3YxXCIgKyByLnBhdGgsIHRoaXMuX21ha2VBUElVUkwociwgdGhpcy5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgZSk7XG4gICAgfSwgRy5wcm90b3R5cGUubm9ybWFsaXplU291cmNlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICghWih0KSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgciA9IFkodCk7XG4gICAgICByZXR1cm4gci5wYXRoID0gXCIvdjQvXCIgKyByLmF1dGhvcml0eSArIFwiLmpzb25cIiwgci5wYXJhbXMucHVzaChcInNlY3VyZVwiKSwgdGhpcy5fbWFrZUFQSVVSTChyLCB0aGlzLl9jdXN0b21BY2Nlc3NUb2tlbiB8fCBlKTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVTcHJpdGVVUkwgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBZKHQpO1xuICAgICAgcmV0dXJuIFoodCkgPyAoaS5wYXRoID0gXCIvc3R5bGVzL3YxXCIgKyBpLnBhdGggKyBcIi9zcHJpdGVcIiArIGUgKyByLCB0aGlzLl9tYWtlQVBJVVJMKGksIHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IG4pKSA6IChpLnBhdGggKz0gXCJcIiArIGUgKyByLCAkKGkpKTtcbiAgICB9LCBHLnByb3RvdHlwZS5ub3JtYWxpemVUaWxlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NrdVRva2VuRXhwaXJlZCgpICYmIHRoaXMuX2NyZWF0ZVNrdVRva2VuKCksIHQgJiYgIVoodCkpIHJldHVybiB0O1xuICAgICAgdmFyIHIgPSBZKHQpO1xuICAgICAgci5wYXRoID0gci5wYXRoLnJlcGxhY2UoLyhcXC4ocG5nfGpwZylcXGQqKSg/PSQpLywgKFIuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyIHx8IDUxMiA9PT0gZSA/IFwiQDJ4XCIgOiBcIlwiKSArIChVLnN1cHBvcnRlZCA/IFwiLndlYnBcIiA6IFwiJDFcIikpLCByLnBhdGggPSByLnBhdGgucmVwbGFjZSgvXi4rXFwvdjRcXC8vLCBcIi9cIiksIHIucGF0aCA9IFwiL3Y0XCIgKyByLnBhdGg7XG4gICAgICB2YXIgbiA9IHRoaXMuX2N1c3RvbUFjY2Vzc1Rva2VuIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICB2YXIgbiA9IHJbZV0ubWF0Y2goL15hY2Nlc3NfdG9rZW49KC4qKSQvKTtcbiAgICAgICAgICBpZiAobikgcmV0dXJuIG5bMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KHIucGFyYW1zKSB8fCBPLkFDQ0VTU19UT0tFTjtcbiAgICAgIHJldHVybiBPLlJFUVVJUkVfQUNDRVNTX1RPS0VOICYmIG4gJiYgdGhpcy5fc2t1VG9rZW4gJiYgci5wYXJhbXMucHVzaChcInNrdT1cIiArIHRoaXMuX3NrdVRva2VuKSwgdGhpcy5fbWFrZUFQSVVSTChyLCBuKTtcbiAgICB9LCBHLnByb3RvdHlwZS5jYW5vbmljYWxpemVUaWxlVVJMID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gWSh0KTtcbiAgICAgIGlmICghci5wYXRoLm1hdGNoKC8oXlxcL3Y0XFwvKS8pIHx8ICFyLnBhdGgubWF0Y2goL1xcLltcXHddKyQvKSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgbiA9IFwibWFwYm94Oi8vdGlsZXMvXCI7XG4gICAgICBuICs9IHIucGF0aC5yZXBsYWNlKFwiL3Y0L1wiLCBcIlwiKTtcbiAgICAgIHZhciBpID0gci5wYXJhbXM7XG4gICAgICByZXR1cm4gZSAmJiAoaSA9IGkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAhdC5tYXRjaCgvXmFjY2Vzc190b2tlbj0vKTtcbiAgICAgIH0pKSwgaS5sZW5ndGggJiYgKG4gKz0gXCI/XCIgKyBpLmpvaW4oXCImXCIpKSwgbjtcbiAgICB9LCBHLnByb3RvdHlwZS5jYW5vbmljYWxpemVUaWxlc2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAhIWUgJiYgWihlKSwgbiA9IFtdLCBpID0gMCwgYSA9IHQudGlsZXMgfHwgW107IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgSihvKSA/IG4ucHVzaCh0aGlzLmNhbm9uaWNhbGl6ZVRpbGVVUkwobywgcikpIDogbi5wdXNoKG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgRy5wcm90b3R5cGUuX21ha2VBUElVUkwgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBcIlNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2FwaS1kb2N1bWVudGF0aW9uLyNhY2Nlc3MtdG9rZW5zLWFuZC10b2tlbi1zY29wZXNcIixcbiAgICAgICAgbiA9IFkoTy5BUElfVVJMKTtcbiAgICAgIGlmICh0LnByb3RvY29sID0gbi5wcm90b2NvbCwgdC5hdXRob3JpdHkgPSBuLmF1dGhvcml0eSwgXCJodHRwXCIgPT09IHQucHJvdG9jb2wpIHtcbiAgICAgICAgdmFyIGkgPSB0LnBhcmFtcy5pbmRleE9mKFwic2VjdXJlXCIpO1xuICAgICAgICBpID49IDAgJiYgdC5wYXJhbXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgICAgaWYgKFwiL1wiICE9PSBuLnBhdGggJiYgKHQucGF0aCA9IFwiXCIgKyBuLnBhdGggKyB0LnBhdGgpLCAhTy5SRVFVSVJFX0FDQ0VTU19UT0tFTikgcmV0dXJuICQodCk7XG4gICAgICBpZiAoIShlID0gZSB8fCBPLkFDQ0VTU19UT0tFTikpIHRocm93IG5ldyBFcnJvcihcIkFuIEFQSSBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQgdG8gdXNlIE1hcGJveCBHTC4gXCIgKyByKTtcbiAgICAgIGlmIChcInNcIiA9PT0gZVswXSkgdGhyb3cgbmV3IEVycm9yKFwiVXNlIGEgcHVibGljIGFjY2VzcyB0b2tlbiAocGsuKikgd2l0aCBNYXBib3ggR0wsIG5vdCBhIHNlY3JldCBhY2Nlc3MgdG9rZW4gKHNrLiopLiBcIiArIHIpO1xuICAgICAgcmV0dXJuIHQucGFyYW1zID0gdC5wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAtMSA9PT0gdC5pbmRleE9mKFwiYWNjZXNzX3Rva2VuXCIpO1xuICAgICAgfSksIHQucGFyYW1zLnB1c2goXCJhY2Nlc3NfdG9rZW49XCIgKyBlKSwgJCh0KTtcbiAgICB9LCBHLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm1SZXF1ZXN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybVJlcXVlc3RGbiA9IHQ7XG4gICAgfTtcbiAgICB2YXIgWCA9IC9eKChodHRwcz86KT9cXC9cXC8pPyhbXlxcL10rXFwuKT9tYXBib3hcXC5jKG58b20pKFxcL3xcXD98JCkvaTtcbiAgICBmdW5jdGlvbiBKKHQpIHtcbiAgICAgIHJldHVybiBYLnRlc3QodCk7XG4gICAgfVxuICAgIHZhciBIID0gL14oXFx3Kyk6XFwvXFwvKFteLz9dKikoXFwvW14/XSspP1xcPz8oLispPy87XG4gICAgZnVuY3Rpb24gWSh0KSB7XG4gICAgICB2YXIgZSA9IHQubWF0Y2goSCk7XG4gICAgICBpZiAoIWUpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwYXJzZSBVUkwgb2JqZWN0XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdG9jb2w6IGVbMV0sXG4gICAgICAgIGF1dGhvcml0eTogZVsyXSxcbiAgICAgICAgcGF0aDogZVszXSB8fCBcIi9cIixcbiAgICAgICAgcGFyYW1zOiBlWzRdID8gZVs0XS5zcGxpdChcIiZcIikgOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJCh0KSB7XG4gICAgICB2YXIgZSA9IHQucGFyYW1zLmxlbmd0aCA/IFwiP1wiICsgdC5wYXJhbXMuam9pbihcIiZcIikgOiBcIlwiO1xuICAgICAgcmV0dXJuIHQucHJvdG9jb2wgKyBcIjovL1wiICsgdC5hdXRob3JpdHkgKyB0LnBhdGggKyBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXKHQpIHtcbiAgICAgIGlmICghdCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZSA9IHQuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKCFlIHx8IDMgIT09IGUubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudChvLmF0b2IoZVsxXSkuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiJVwiICsgKFwiMDBcIiArIHQuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgICAgfSkuam9pbihcIlwiKSkpO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5hbm9uSWQgPSBudWxsLCB0aGlzLmV2ZW50RGF0YSA9IHt9LCB0aGlzLnF1ZXVlID0gW10sIHRoaXMucGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIH07XG4gICAgUS5wcm90b3R5cGUuZ2V0U3RvcmFnZUtleSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSxcbiAgICAgICAgciA9IFcoTy5BQ0NFU1NfVE9LRU4pO1xuICAgICAgcmV0dXJuIGUgPSByICYmIHIudSA/IG8uYnRvYShlbmNvZGVVUklDb21wb25lbnQoci51KS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoXCIweFwiICsgZSkpO1xuICAgICAgfSkpIDogTy5BQ0NFU1NfVE9LRU4gfHwgXCJcIiwgdCA/IFwibWFwYm94LmV2ZW50RGF0YS5cIiArIHQgKyBcIjpcIiArIGUgOiBcIm1hcGJveC5ldmVudERhdGE6XCIgKyBlO1xuICAgIH0sIFEucHJvdG90eXBlLmZldGNoRXZlbnREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBQKFwibG9jYWxTdG9yYWdlXCIpLFxuICAgICAgICBlID0gdGhpcy5nZXRTdG9yYWdlS2V5KCksXG4gICAgICAgIHIgPSB0aGlzLmdldFN0b3JhZ2VLZXkoXCJ1dWlkXCIpO1xuICAgICAgaWYgKHQpIHRyeSB7XG4gICAgICAgIHZhciBuID0gby5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKTtcbiAgICAgICAgbiAmJiAodGhpcy5ldmVudERhdGEgPSBKU09OLnBhcnNlKG4pKTtcbiAgICAgICAgdmFyIGkgPSBvLmxvY2FsU3RvcmFnZS5nZXRJdGVtKHIpO1xuICAgICAgICBpICYmICh0aGlzLmFub25JZCA9IGkpO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICBBKFwiVW5hYmxlIHRvIHJlYWQgZnJvbSBMb2NhbFN0b3JhZ2VcIik7XG4gICAgICB9XG4gICAgfSwgUS5wcm90b3R5cGUuc2F2ZUV2ZW50RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gUChcImxvY2FsU3RvcmFnZVwiKSxcbiAgICAgICAgZSA9IHRoaXMuZ2V0U3RvcmFnZUtleSgpLFxuICAgICAgICByID0gdGhpcy5nZXRTdG9yYWdlS2V5KFwidXVpZFwiKTtcbiAgICAgIGlmICh0KSB0cnkge1xuICAgICAgICBvLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHIsIHRoaXMuYW5vbklkKSwgT2JqZWN0LmtleXModGhpcy5ldmVudERhdGEpLmxlbmd0aCA+PSAxICYmIG8ubG9jYWxTdG9yYWdlLnNldEl0ZW0oZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5ldmVudERhdGEpKTtcbiAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgQShcIlVuYWJsZSB0byB3cml0ZSB0byBMb2NhbFN0b3JhZ2VcIik7XG4gICAgICB9XG4gICAgfSwgUS5wcm90b3R5cGUucHJvY2Vzc1JlcXVlc3RzID0gZnVuY3Rpb24gKHQpIHt9LCBRLnByb3RvdHlwZS5wb3N0RXZlbnQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgaWYgKE8uRVZFTlRTX1VSTCkge1xuICAgICAgICB2YXIgYSA9IFkoTy5FVkVOVFNfVVJMKTtcbiAgICAgICAgYS5wYXJhbXMucHVzaChcImFjY2Vzc190b2tlbj1cIiArIChuIHx8IE8uQUNDRVNTX1RPS0VOIHx8IFwiXCIpKTtcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICBldmVudDogdGhpcy50eXBlLFxuICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUodCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHNka0lkZW50aWZpZXI6IFwibWFwYm94LWdsLWpzXCIsXG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBcIjEuMTUuM1wiLFxuICAgICAgICAgICAgc2t1SWQ6IEssXG4gICAgICAgICAgICB1c2VySWQ6IHRoaXMuYW5vbklkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzID0gZSA/IGgobywgZSkgOiBvLFxuICAgICAgICAgIHUgPSB7XG4gICAgICAgICAgICB1cmw6ICQoYSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoW3NdKVxuICAgICAgICAgIH07XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3QgPSBfdCh1LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGkucGVuZGluZ1JlcXVlc3QgPSBudWxsLCByKHQpLCBpLnNhdmVFdmVudERhdGEoKSwgaS5wcm9jZXNzUmVxdWVzdHMobik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFEucHJvdG90eXBlLnF1ZXVlUmVxdWVzdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2godCksIHRoaXMucHJvY2Vzc1JlcXVlc3RzKGUpO1xuICAgIH07XG4gICAgdmFyIHR0LFxuICAgICAgZXQsXG4gICAgICBydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIFwibWFwLmxvYWRcIiksIHRoaXMuc3VjY2VzcyA9IHt9LCB0aGlzLnNrdVRva2VuID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5wb3N0TWFwTG9hZEV2ZW50ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICB0aGlzLnNrdVRva2VuID0gciwgKE8uRVZFTlRTX1VSTCAmJiBuIHx8IE8uQUNDRVNTX1RPS0VOICYmIEFycmF5LmlzQXJyYXkodCkgJiYgdC5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gWih0KSB8fCBKKHQpO1xuICAgICAgICAgIH0pKSAmJiB0aGlzLnF1ZXVlUmVxdWVzdCh7XG4gICAgICAgICAgICBpZDogZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgIH0sIG4pO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5wcm9jZXNzUmVxdWVzdHMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1JlcXVlc3QgJiYgMCAhPT0gdGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5xdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICBuID0gci5pZCxcbiAgICAgICAgICAgICAgaSA9IHIudGltZXN0YW1wO1xuICAgICAgICAgICAgbiAmJiB0aGlzLnN1Y2Nlc3Nbbl0gfHwgKHRoaXMuYW5vbklkIHx8IHRoaXMuZmV0Y2hFdmVudERhdGEoKSwgbSh0aGlzLmFub25JZCkgfHwgKHRoaXMuYW5vbklkID0gZCgpKSwgdGhpcy5wb3N0RXZlbnQoaSwge1xuICAgICAgICAgICAgICBza3VUb2tlbjogdGhpcy5za3VUb2tlblxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgdCB8fCBuICYmIChlLnN1Y2Nlc3Nbbl0gPSAhMCk7XG4gICAgICAgICAgICB9LCB0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShRKSxcbiAgICAgIG50ID0gbmV3IChmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgICB0LmNhbGwodGhpcywgXCJhcHBVc2VyVHVybnN0aWxlXCIpLCB0aGlzLl9jdXN0b21BY2Nlc3NUb2tlbiA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucG9zdFR1cm5zdGlsZUV2ZW50ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBPLkVWRU5UU19VUkwgJiYgTy5BQ0NFU1NfVE9LRU4gJiYgQXJyYXkuaXNBcnJheSh0KSAmJiB0LnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBaKHQpIHx8IEoodCk7XG4gICAgICAgICAgfSkgJiYgdGhpcy5xdWV1ZVJlcXVlc3QoRGF0ZS5ub3coKSwgZSk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnByb2Nlc3NSZXF1ZXN0cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nUmVxdWVzdCAmJiAwICE9PSB0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hbm9uSWQgJiYgdGhpcy5ldmVudERhdGEubGFzdFN1Y2Nlc3MgJiYgdGhpcy5ldmVudERhdGEudG9rZW5VIHx8IHRoaXMuZmV0Y2hFdmVudERhdGEoKTtcbiAgICAgICAgICAgIHZhciByID0gVyhPLkFDQ0VTU19UT0tFTiksXG4gICAgICAgICAgICAgIG4gPSByID8gci51IDogTy5BQ0NFU1NfVE9LRU4sXG4gICAgICAgICAgICAgIGkgPSBuICE9PSB0aGlzLmV2ZW50RGF0YS50b2tlblU7XG4gICAgICAgICAgICBtKHRoaXMuYW5vbklkKSB8fCAodGhpcy5hbm9uSWQgPSBkKCksIGkgPSAhMCk7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGF0YS5sYXN0U3VjY2Vzcykge1xuICAgICAgICAgICAgICB2YXIgbyA9IG5ldyBEYXRlKHRoaXMuZXZlbnREYXRhLmxhc3RTdWNjZXNzKSxcbiAgICAgICAgICAgICAgICBzID0gbmV3IERhdGUoYSksXG4gICAgICAgICAgICAgICAgdSA9IChhIC0gdGhpcy5ldmVudERhdGEubGFzdFN1Y2Nlc3MpIC8gODY0ZTU7XG4gICAgICAgICAgICAgIGkgPSBpIHx8IHUgPj0gMSB8fCB1IDwgLTEgfHwgby5nZXREYXRlKCkgIT09IHMuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGkgPSAhMDtcbiAgICAgICAgICAgIGlmICghaSkgcmV0dXJuIHRoaXMucHJvY2Vzc1JlcXVlc3RzKCk7XG4gICAgICAgICAgICB0aGlzLnBvc3RFdmVudChhLCB7XG4gICAgICAgICAgICAgIFwiZW5hYmxlZC50ZWxlbWV0cnlcIjogITFcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHQgfHwgKGUuZXZlbnREYXRhLmxhc3RTdWNjZXNzID0gYSwgZS5ldmVudERhdGEudG9rZW5VID0gbik7XG4gICAgICAgICAgICB9LCB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KFEpKSgpLFxuICAgICAgaXQgPSBudC5wb3N0VHVybnN0aWxlRXZlbnQuYmluZChudCksXG4gICAgICBhdCA9IG5ldyBydCgpLFxuICAgICAgb3QgPSBhdC5wb3N0TWFwTG9hZEV2ZW50LmJpbmQoYXQpLFxuICAgICAgc3QgPSA1MDAsXG4gICAgICB1dCA9IDUwO1xuICAgIGZ1bmN0aW9uIGx0KCkge1xuICAgICAgby5jYWNoZXMgJiYgIXR0ICYmICh0dCA9IG8uY2FjaGVzLm9wZW4oXCJtYXBib3gtdGlsZXNcIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdCh0KSB7XG4gICAgICB2YXIgZSA9IHQuaW5kZXhPZihcIj9cIik7XG4gICAgICByZXR1cm4gZSA8IDAgPyB0IDogdC5zbGljZSgwLCBlKTtcbiAgICB9XG4gICAgdmFyIGN0LFxuICAgICAgaHQgPSAxIC8gMDtcbiAgICBmdW5jdGlvbiBmdCgpIHtcbiAgICAgIHJldHVybiBudWxsID09IGN0ICYmIChjdCA9IG8uT2Zmc2NyZWVuQ2FudmFzICYmIG5ldyBvLk9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KFwiMmRcIikgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBvLmNyZWF0ZUltYWdlQml0bWFwKSwgY3Q7XG4gICAgfVxuICAgIHZhciB5dCA9IHtcbiAgICAgIFVua25vd246IFwiVW5rbm93blwiLFxuICAgICAgU3R5bGU6IFwiU3R5bGVcIixcbiAgICAgIFNvdXJjZTogXCJTb3VyY2VcIixcbiAgICAgIFRpbGU6IFwiVGlsZVwiLFxuICAgICAgR2x5cGhzOiBcIkdseXBoc1wiLFxuICAgICAgU3ByaXRlSW1hZ2U6IFwiU3ByaXRlSW1hZ2VcIixcbiAgICAgIFNwcml0ZUpTT046IFwiU3ByaXRlSlNPTlwiLFxuICAgICAgSW1hZ2U6IFwiSW1hZ2VcIlxuICAgIH07XG4gICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoeXQpO1xuICAgIHZhciBkdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSwgciwgbikge1xuICAgICAgICAgIDQwMSA9PT0gciAmJiBKKG4pICYmIChlICs9IFwiOiB5b3UgbWF5IGhhdmUgcHJvdmlkZWQgYW4gaW52YWxpZCBNYXBib3ggYWNjZXNzIHRva2VuLiBTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9hcGktZG9jdW1lbnRhdGlvbi8jYWNjZXNzLXRva2Vucy1hbmQtdG9rZW4tc2NvcGVzXCIpLCB0LmNhbGwodGhpcywgZSksIHRoaXMuc3RhdHVzID0gciwgdGhpcy51cmwgPSBuLCB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHRoaXMubWVzc2FnZSA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIFwiIChcIiArIHRoaXMuc3RhdHVzICsgXCIpOiBcIiArIHRoaXMudXJsO1xuICAgICAgICB9LCBlO1xuICAgICAgfShFcnJvciksXG4gICAgICBtdCA9IEkoKSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYud29ya2VyICYmIHNlbGYud29ya2VyLnJlZmVycmVyO1xuICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcImJsb2I6XCIgPT09IG8ubG9jYXRpb24ucHJvdG9jb2wgPyBvLnBhcmVudCA6IG8pLmxvY2F0aW9uLmhyZWY7XG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIHZ0KHQsIGUpIHtcbiAgICAgIHZhciByLFxuICAgICAgICBuID0gbmV3IG8uQWJvcnRDb250cm9sbGVyKCksXG4gICAgICAgIGkgPSBuZXcgby5SZXF1ZXN0KHQudXJsLCB7XG4gICAgICAgICAgbWV0aG9kOiB0Lm1ldGhvZCB8fCBcIkdFVFwiLFxuICAgICAgICAgIGJvZHk6IHQuYm9keSxcbiAgICAgICAgICBjcmVkZW50aWFsczogdC5jcmVkZW50aWFscyxcbiAgICAgICAgICBoZWFkZXJzOiB0LmhlYWRlcnMsXG4gICAgICAgICAgcmVmZXJyZXI6IG10KCksXG4gICAgICAgICAgc2lnbmFsOiBuLnNpZ25hbFxuICAgICAgICB9KSxcbiAgICAgICAgYSA9ICExLFxuICAgICAgICBzID0gITEsXG4gICAgICAgIHUgPSAociA9IGkudXJsKS5pbmRleE9mKFwic2t1PVwiKSA+IDAgJiYgSihyKTtcbiAgICAgIFwianNvblwiID09PSB0LnR5cGUgJiYgaS5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICB2YXIgbCA9IGZ1bmN0aW9uIChyLCBuLCBhKSB7XG4gICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICBpZiAociAmJiBcIlNlY3VyaXR5RXJyb3JcIiAhPT0gci5tZXNzYWdlICYmIEEociksIG4gJiYgYSkgcmV0dXJuIHAobik7XG4gICAgICAgICAgICB2YXIgbCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBvLmZldGNoKGkpLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgaWYgKHIub2spIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHUgPyByLmNsb25lKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBwKHIsIG4sIGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBlKG5ldyBkdChyLnN0YXR1c1RleHQsIHIuc3RhdHVzLCB0LnVybCkpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgMjAgIT09IHQuY29kZSAmJiBlKG5ldyBFcnJvcih0Lm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcCA9IGZ1bmN0aW9uIChyLCBuLCB1KSB7XG4gICAgICAgICAgKFwiYXJyYXlCdWZmZXJcIiA9PT0gdC50eXBlID8gci5hcnJheUJ1ZmZlcigpIDogXCJqc29uXCIgPT09IHQudHlwZSA/IHIuanNvbigpIDogci50ZXh0KCkpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHMgfHwgKG4gJiYgdSAmJiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgICBpZiAobHQoKSwgdHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgby5IZWFkZXJzKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGUuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbi5oZWFkZXJzLnNldChlLCB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHooZS5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIikgfHwgXCJcIik7XG4gICAgICAgICAgICAgICAgaVtcIm5vLXN0b3JlXCJdIHx8IChpW1wibWF4LWFnZVwiXSAmJiBuLmhlYWRlcnMuc2V0KFwiRXhwaXJlc1wiLCBuZXcgRGF0ZShyICsgMWUzICogaVtcIm1heC1hZ2VcIl0pLnRvVVRDU3RyaW5nKCkpLCBuZXcgRGF0ZShuLmhlYWRlcnMuZ2V0KFwiRXhwaXJlc1wiKSkuZ2V0VGltZSgpIC0gciA8IDQyZTQgfHwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGV0KSB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgUmVzcG9uc2UobmV3IFJlYWRhYmxlU3RyZWFtKCkpLCBldCA9ICEwO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICAgICAgICBldCA9ICExO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXQgPyBlKHQuYm9keSkgOiB0LmJsb2IoKS50aGVuKGUpO1xuICAgICAgICAgICAgICAgIH0oZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByID0gbmV3IG8uUmVzcG9uc2UoZSwgbik7XG4gICAgICAgICAgICAgICAgICBsdCgpLCB0dCAmJiB0dC50aGVuKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnB1dChwdCh0LnVybCksIHIpO1xuICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEEodC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShpLCBuLCB1KSwgYSA9ICEwLCBlKG51bGwsIHQsIHIuaGVhZGVycy5nZXQoXCJDYWNoZS1Db250cm9sXCIpLCByLmhlYWRlcnMuZ2V0KFwiRXhwaXJlc1wiKSkpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBzIHx8IGUobmV3IEVycm9yKHQubWVzc2FnZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIHUgPyBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpZiAobHQoKSwgIXR0KSByZXR1cm4gZShudWxsKTtcbiAgICAgICAgdmFyIHIgPSBwdCh0LnVybCk7XG4gICAgICAgIHR0LnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0Lm1hdGNoKHIpLnRoZW4oZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgIHZhciBlID0gbmV3IERhdGUodC5oZWFkZXJzLmdldChcIkV4cGlyZXNcIikgfHwgMCksXG4gICAgICAgICAgICAgICAgciA9IHoodC5oZWFkZXJzLmdldChcIkNhY2hlLUNvbnRyb2xcIikgfHwgXCJcIik7XG4gICAgICAgICAgICAgIHJldHVybiBlID4gRGF0ZS5ub3coKSAmJiAhcltcIm5vLWNhY2hlXCJdO1xuICAgICAgICAgICAgfShuKTtcbiAgICAgICAgICAgIHQuZGVsZXRlKHIpLCBpICYmIHQucHV0KHIsIG4uY2xvbmUoKSksIGUobnVsbCwgbiwgaSk7XG4gICAgICAgICAgfSkuY2F0Y2goZSk7XG4gICAgICAgIH0pLmNhdGNoKGUpO1xuICAgICAgfShpLCBsKSA6IGwobnVsbCwgbnVsbCksIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcyA9ICEwLCBhIHx8IG4uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGd0LFxuICAgICAgeHQsXG4gICAgICBidCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGlmICgvOlxcL1xcLy8udGVzdCh0LnVybCkgJiYgIS9eaHR0cHM/OnxeZmlsZTovLnRlc3QodC51cmwpKSB7XG4gICAgICAgICAgaWYgKEkoKSAmJiBzZWxmLndvcmtlciAmJiBzZWxmLndvcmtlci5hY3RvcikgcmV0dXJuIHNlbGYud29ya2VyLmFjdG9yLnNlbmQoXCJnZXRSZXNvdXJjZVwiLCB0LCBlKTtcbiAgICAgICAgICBpZiAoIUkoKSkge1xuICAgICAgICAgICAgdmFyIHIgPSB0LnVybC5zdWJzdHJpbmcoMCwgdC51cmwuaW5kZXhPZihcIjovL1wiKSk7XG4gICAgICAgICAgICByZXR1cm4gKE8uUkVHSVNURVJFRF9QUk9UT0NPTFNbcl0gfHwgdnQpKHQsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISgvXmZpbGU6Ly50ZXN0KG4gPSB0LnVybCkgfHwgL15maWxlOi8udGVzdChtdCgpKSAmJiAhL15cXHcrOi8udGVzdChuKSkpIHtcbiAgICAgICAgICBpZiAoby5mZXRjaCAmJiBvLlJlcXVlc3QgJiYgby5BYm9ydENvbnRyb2xsZXIgJiYgby5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInNpZ25hbFwiKSkgcmV0dXJuIHZ0KHQsIGUpO1xuICAgICAgICAgIGlmIChJKCkgJiYgc2VsZi53b3JrZXIgJiYgc2VsZi53b3JrZXIuYWN0b3IpIHJldHVybiBzZWxmLndvcmtlci5hY3Rvci5zZW5kKFwiZ2V0UmVzb3VyY2VcIiwgdCwgZSwgdm9pZCAwLCAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gbmV3IG8uWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICBmb3IgKHZhciBuIGluIHIub3Blbih0Lm1ldGhvZCB8fCBcIkdFVFwiLCB0LnVybCwgITApLCBcImFycmF5QnVmZmVyXCIgPT09IHQudHlwZSAmJiAoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCIpLCB0LmhlYWRlcnMpIHIuc2V0UmVxdWVzdEhlYWRlcihuLCB0LmhlYWRlcnNbbl0pO1xuICAgICAgICAgIHJldHVybiBcImpzb25cIiA9PT0gdC50eXBlICYmIChyLnJlc3BvbnNlVHlwZSA9IFwidGV4dFwiLCByLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpKSwgci53aXRoQ3JlZGVudGlhbHMgPSBcImluY2x1ZGVcIiA9PT0gdC5jcmVkZW50aWFscywgci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZShuZXcgRXJyb3Ioci5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgfSwgci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKHIuc3RhdHVzID49IDIwMCAmJiByLnN0YXR1cyA8IDMwMCB8fCAwID09PSByLnN0YXR1cykgJiYgbnVsbCAhPT0gci5yZXNwb25zZSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgIGlmIChcImpzb25cIiA9PT0gdC50eXBlKSB0cnkge1xuICAgICAgICAgICAgICAgIG4gPSBKU09OLnBhcnNlKHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZShudWxsLCBuLCByLmdldFJlc3BvbnNlSGVhZGVyKFwiQ2FjaGUtQ29udHJvbFwiKSwgci5nZXRSZXNwb25zZUhlYWRlcihcIkV4cGlyZXNcIikpO1xuICAgICAgICAgICAgfSBlbHNlIGUobmV3IGR0KHIuc3RhdHVzVGV4dCwgci5zdGF0dXMsIHQudXJsKSk7XG4gICAgICAgICAgfSwgci5zZW5kKHQuYm9keSksIHtcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0odCwgZSk7XG4gICAgICB9LFxuICAgICAgd3QgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gYnQoaCh0LCB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheUJ1ZmZlclwiXG4gICAgICAgIH0pLCBlKTtcbiAgICAgIH0sXG4gICAgICBfdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBidChoKHQsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgICAgIH0pLCBlKTtcbiAgICAgIH0sXG4gICAgICBBdCA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQUMwbEVRVlFZVjJOZ0FBSUFBQVVBQWFyVnlGRUFBQUFBU1VWT1JLNUNZSUk9XCI7XG4gICAgZ3QgPSBbXSwgeHQgPSAwO1xuICAgIHZhciBTdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoVS5zdXBwb3J0ZWQgJiYgKHQuaGVhZGVycyB8fCAodC5oZWFkZXJzID0ge30pLCB0LmhlYWRlcnMuYWNjZXB0ID0gXCJpbWFnZS93ZWJwLCovKlwiKSwgeHQgPj0gTy5NQVhfUEFSQUxMRUxfSU1BR0VfUkVRVUVTVFMpIHtcbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgcmVxdWVzdFBhcmFtZXRlcnM6IHQsXG4gICAgICAgICAgY2FsbGJhY2s6IGUsXG4gICAgICAgICAgY2FuY2VsbGVkOiAhMSxcbiAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3QucHVzaChyKSwgcjtcbiAgICAgIH1cbiAgICAgIHh0Kys7XG4gICAgICB2YXIgbiA9ICExLFxuICAgICAgICBpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghbikgZm9yIChuID0gITAsIHh0LS07IGd0Lmxlbmd0aCAmJiB4dCA8IE8uTUFYX1BBUkFMTEVMX0lNQUdFX1JFUVVFU1RTOykge1xuICAgICAgICAgICAgdmFyIHQgPSBndC5zaGlmdCgpO1xuICAgICAgICAgICAgdC5jYW5jZWxsZWQgfHwgKHQuY2FuY2VsID0gU3QodC5yZXF1ZXN0UGFyYW1ldGVycywgdC5jYWxsYmFjaykuY2FuY2VsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGEgPSB3dCh0LCBmdW5jdGlvbiAodCwgciwgbiwgYSkge1xuICAgICAgICAgIGkoKSwgdCA/IGUodCkgOiByICYmIChmdCgpID8gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHZhciByID0gbmV3IG8uQmxvYihbbmV3IFVpbnQ4QXJyYXkodCldLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2UvcG5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgby5jcmVhdGVJbWFnZUJpdG1hcChyKS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGUobnVsbCwgdCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBlKG5ldyBFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlIGJlY2F1c2Ugb2YgXCIgKyB0Lm1lc3NhZ2UgKyBcIi4gUGxlYXNlIG1ha2Ugc3VyZSB0byB1c2UgYSBzdXBwb3J0ZWQgaW1hZ2UgdHlwZSBzdWNoIGFzIFBORyBvciBKUEVHLiBOb3RlIHRoYXQgU1ZHcyBhcmUgbm90IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfShyLCBlKSA6IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG5ldyBvLkltYWdlKCksXG4gICAgICAgICAgICAgIGEgPSBvLlVSTDtcbiAgICAgICAgICAgIGkub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBlKG51bGwsIGkpLCBhLnJldm9rZU9iamVjdFVSTChpLnNyYyksIGkub25sb2FkID0gbnVsbCwgby5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGkuc3JjID0gQXQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgaS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZShuZXcgRXJyb3IoXCJDb3VsZCBub3QgbG9hZCBpbWFnZS4gUGxlYXNlIG1ha2Ugc3VyZSB0byB1c2UgYSBzdXBwb3J0ZWQgaW1hZ2UgdHlwZSBzdWNoIGFzIFBORyBvciBKUEVHLiBOb3RlIHRoYXQgU1ZHcyBhcmUgbm90IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IG8uQmxvYihbbmV3IFVpbnQ4QXJyYXkodCldLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2UvcG5nXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaS5jYWNoZUNvbnRyb2wgPSByLCBpLmV4cGlyZXMgPSBuLCBpLnNyYyA9IHQuYnl0ZUxlbmd0aCA/IGEuY3JlYXRlT2JqZWN0VVJMKHMpIDogQXQ7XG4gICAgICAgICAgfShyLCBlLCBuLCBhKSk7XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5jYW5jZWwoKSwgaSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24ga3QodCwgZSwgcikge1xuICAgICAgclt0XSAmJiAtMSAhPT0gclt0XS5pbmRleE9mKGUpIHx8IChyW3RdID0gclt0XSB8fCBbXSwgclt0XS5wdXNoKGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXQodCwgZSwgcikge1xuICAgICAgaWYgKHIgJiYgclt0XSkge1xuICAgICAgICB2YXIgbiA9IHJbdF0uaW5kZXhPZihlKTtcbiAgICAgICAgLTEgIT09IG4gJiYgclt0XS5zcGxpY2UobiwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB6dCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHt9KSwgaCh0aGlzLCBlKSwgdGhpcy50eXBlID0gdDtcbiAgICAgIH0sXG4gICAgICBDdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgdC5jYWxsKHRoaXMsIFwiZXJyb3JcIiwgaCh7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0sIHIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlO1xuICAgICAgfSh6dCksXG4gICAgICBFdCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIEV0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzIHx8IHt9LCBrdCh0LCBlLCB0aGlzLl9saXN0ZW5lcnMpLCB0aGlzO1xuICAgIH0sIEV0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIEl0KHQsIGUsIHRoaXMuX2xpc3RlbmVycyksIEl0KHQsIGUsIHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMpLCB0aGlzO1xuICAgIH0sIEV0LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzID0gdGhpcy5fb25lVGltZUxpc3RlbmVycyB8fCB7fSwga3QodCwgZSwgdGhpcy5fb25lVGltZUxpc3RlbmVycyksIHRoaXM7XG4gICAgfSwgRXQucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiAodCA9IG5ldyB6dCh0LCBlIHx8IHt9KSk7XG4gICAgICB2YXIgciA9IHQudHlwZTtcbiAgICAgIGlmICh0aGlzLmxpc3RlbnMocikpIHtcbiAgICAgICAgdC50YXJnZXQgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnNbcl0gPyB0aGlzLl9saXN0ZW5lcnNbcl0uc2xpY2UoKSA6IFtdOyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkgaVtuXS5jYWxsKHRoaXMsIHQpO1xuICAgICAgICBmb3IgKHZhciBhID0gMCwgbyA9IHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMgJiYgdGhpcy5fb25lVGltZUxpc3RlbmVyc1tyXSA/IHRoaXMuX29uZVRpbWVMaXN0ZW5lcnNbcl0uc2xpY2UoKSA6IFtdOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgIHZhciBzID0gb1thXTtcbiAgICAgICAgICBJdChyLCBzLCB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzKSwgcy5jYWxsKHRoaXMsIHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1ID0gdGhpcy5fZXZlbnRlZFBhcmVudDtcbiAgICAgICAgdSAmJiAoaCh0LCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMuX2V2ZW50ZWRQYXJlbnREYXRhID8gdGhpcy5fZXZlbnRlZFBhcmVudERhdGEoKSA6IHRoaXMuX2V2ZW50ZWRQYXJlbnREYXRhKSwgdS5maXJlKHQpKTtcbiAgICAgIH0gZWxzZSB0IGluc3RhbmNlb2YgQ3QgJiYgY29uc29sZS5lcnJvcih0LmVycm9yKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIEV0LnByb3RvdHlwZS5saXN0ZW5zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzW3RdICYmIHRoaXMuX2xpc3RlbmVyc1t0XS5sZW5ndGggPiAwIHx8IHRoaXMuX29uZVRpbWVMaXN0ZW5lcnMgJiYgdGhpcy5fb25lVGltZUxpc3RlbmVyc1t0XSAmJiB0aGlzLl9vbmVUaW1lTGlzdGVuZXJzW3RdLmxlbmd0aCA+IDAgfHwgdGhpcy5fZXZlbnRlZFBhcmVudCAmJiB0aGlzLl9ldmVudGVkUGFyZW50Lmxpc3RlbnModCk7XG4gICAgfSwgRXQucHJvdG90eXBlLnNldEV2ZW50ZWRQYXJlbnQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50ZWRQYXJlbnQgPSB0LCB0aGlzLl9ldmVudGVkUGFyZW50RGF0YSA9IGUsIHRoaXM7XG4gICAgfTtcbiAgICB2YXIgUHQgPSB7XG4gICAgICAgICR2ZXJzaW9uOiA4LFxuICAgICAgICAkcm9vdDoge1xuICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiBbOF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbToge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmVhcmluZzoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICBwZXJpb2Q6IDM2MCxcbiAgICAgICAgICAgIHVuaXRzOiBcImRlZ3JlZXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGl0Y2g6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwiZGVncmVlc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgdHlwZTogXCJsaWdodFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzb3VyY2VzOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgICB0eXBlOiBcInNvdXJjZXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3ByaXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnbHlwaHM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwidHJhbnNpdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsYXllcnM6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIHZhbHVlOiBcImxheWVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZXM6IHtcbiAgICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJzb3VyY2VcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlOiBbXCJzb3VyY2VfdmVjdG9yXCIsIFwic291cmNlX3Jhc3RlclwiLCBcInNvdXJjZV9yYXN0ZXJfZGVtXCIsIFwic291cmNlX2dlb2pzb25cIiwgXCJzb3VyY2VfdmlkZW9cIiwgXCJzb3VyY2VfaW1hZ2VcIl0sXG4gICAgICAgIHNvdXJjZV92ZWN0b3I6IHtcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICB2ZWN0b3I6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbGVzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjaGVtZToge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgeHl6OiB7fSxcbiAgICAgICAgICAgICAgdG1zOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwieHl6XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pbnpvb206IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXh6b29tOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMjJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJpYnV0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9tb3RlSWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvbW90ZUlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZvbGF0aWxlOiB7XG4gICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIGRlZmF1bHQ6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIipcIjoge1xuICAgICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZV9yYXN0ZXI6IHtcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICByYXN0ZXI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbGVzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pbnpvb206IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXh6b29tOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMjJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbGVTaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogNTEyLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNjaGVtZToge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgeHl6OiB7fSxcbiAgICAgICAgICAgICAgdG1zOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwieHl6XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJpYnV0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2b2xhdGlsZToge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VfcmFzdGVyX2RlbToge1xuICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIFwicmFzdGVyLWRlbVwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXJsOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWxlczoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgICBkZWZhdWx0OiBbLTE4MCwgLTg1LjA1MTEyOSwgMTgwLCA4NS4wNTExMjldXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtaW56b29tOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4em9vbToge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDIyXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWxlU2l6ZToge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDUxMixcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyaWJ1dGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIHRlcnJhcml1bToge30sXG4gICAgICAgICAgICAgIG1hcGJveDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcIm1hcGJveFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2b2xhdGlsZToge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiKlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VfZ2VvanNvbjoge1xuICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGdlb2pzb246IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4em9vbToge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDE4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyaWJ1dGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnVmZmVyOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMTI4LFxuICAgICAgICAgICAgbWF4aW11bTogNTEyLFxuICAgICAgICAgICAgbWluaW11bTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9sZXJhbmNlOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogLjM3NVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2x1c3Rlcjoge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2x1c3RlclJhZGl1czoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDUwLFxuICAgICAgICAgICAgbWluaW11bTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2x1c3Rlck1heFpvb206IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsdXN0ZXJNaW5Qb2ludHM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsdXN0ZXJQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICB0eXBlOiBcIipcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGluZU1ldHJpY3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVmYXVsdDogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlSWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVmYXVsdDogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb21vdGVJZDoge1xuICAgICAgICAgICAgdHlwZTogXCJwcm9tb3RlSWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlX3ZpZGVvOiB7XG4gICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgdmlkZW86IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmxzOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlX2ltYWdlOiB7XG4gICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgcmVxdWlyZWQ6ICEwLFxuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgaW1hZ2U6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmw6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMCxcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogITAsXG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICBsZW5ndGg6IDQsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGZpbGw6IHt9LFxuICAgICAgICAgICAgICBsaW5lOiB7fSxcbiAgICAgICAgICAgICAgc3ltYm9sOiB7fSxcbiAgICAgICAgICAgICAgY2lyY2xlOiB7fSxcbiAgICAgICAgICAgICAgaGVhdG1hcDoge30sXG4gICAgICAgICAgICAgIFwiZmlsbC1leHRydXNpb25cIjoge30sXG4gICAgICAgICAgICAgIHJhc3Rlcjoge30sXG4gICAgICAgICAgICAgIGhpbGxzaGFkZToge30sXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6ICEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgdHlwZTogXCIqXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzb3VyY2UtbGF5ZXJcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWluem9vbToge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAyNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4em9vbToge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAyNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbHRlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibGF5b3V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcInBhaW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dDogW1wibGF5b3V0X2ZpbGxcIiwgXCJsYXlvdXRfbGluZVwiLCBcImxheW91dF9jaXJjbGVcIiwgXCJsYXlvdXRfaGVhdG1hcFwiLCBcImxheW91dF9maWxsLWV4dHJ1c2lvblwiLCBcImxheW91dF9zeW1ib2xcIiwgXCJsYXlvdXRfcmFzdGVyXCIsIFwibGF5b3V0X2hpbGxzaGFkZVwiLCBcImxheW91dF9iYWNrZ3JvdW5kXCJdLFxuICAgICAgICBsYXlvdXRfYmFja2dyb3VuZDoge1xuICAgICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGF5b3V0X2ZpbGw6IHtcbiAgICAgICAgICBcImZpbGwtc29ydC1rZXlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dF9jaXJjbGU6IHtcbiAgICAgICAgICBcImNpcmNsZS1zb3J0LWtleVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIHZpc2libGU6IHt9LFxuICAgICAgICAgICAgICBub25lOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwidmlzaWJsZVwiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGF5b3V0X2hlYXRtYXA6IHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCI6IHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dF9saW5lOiB7XG4gICAgICAgICAgXCJsaW5lLWNhcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBidXR0OiB7fSxcbiAgICAgICAgICAgICAgcm91bmQ6IHt9LFxuICAgICAgICAgICAgICBzcXVhcmU6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJidXR0XCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGluZS1qb2luXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGJldmVsOiB7fSxcbiAgICAgICAgICAgICAgcm91bmQ6IHt9LFxuICAgICAgICAgICAgICBtaXRlcjoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcIm1pdGVyXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAyLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICAgIFwibGluZS1qb2luXCI6IFwibWl0ZXJcIlxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMS4wNSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgICBcImxpbmUtam9pblwiOiBcInJvdW5kXCJcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImxpbmUtc29ydC1rZXlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICB2aXNpYmxlOiB7fSxcbiAgICAgICAgICAgICAgbm9uZToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcInZpc2libGVcIixcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxheW91dF9zeW1ib2w6IHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHt9LFxuICAgICAgICAgICAgICBsaW5lOiB7fSxcbiAgICAgICAgICAgICAgXCJsaW5lLWNlbnRlclwiOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwicG9pbnRcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzeW1ib2wtc3BhY2luZ1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMjUwLFxuICAgICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcImxpbmVcIlxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic3ltYm9sLXNvcnQta2V5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzeW1ib2wtei1vcmRlclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBhdXRvOiB7fSxcbiAgICAgICAgICAgICAgXCJ2aWV3cG9ydC15XCI6IHt9LFxuICAgICAgICAgICAgICBzb3VyY2U6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImljb24tb3B0aW9uYWxcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwidGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgICB2aWV3cG9ydDoge30sXG4gICAgICAgICAgICAgIGF1dG86IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJhdXRvXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLXNpemVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwiZmFjdG9yIG9mIHRoZSBvcmlnaW5hbCBpY29uIHNpemVcIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBub25lOiB7fSxcbiAgICAgICAgICAgICAgd2lkdGg6IHt9LFxuICAgICAgICAgICAgICBoZWlnaHQ6IHt9LFxuICAgICAgICAgICAgICBib3RoOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGxlbmd0aDogNCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgICAgXCJpY29uLXRleHQtZml0XCI6IFtcImJvdGhcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaWNvbi1pbWFnZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgICAgICAgIHRva2VuczogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIGRlZmF1bHQ6ICExLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwge1xuICAgICAgICAgICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImljb24tYW5jaG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICAgIGxlZnQ6IHt9LFxuICAgICAgICAgICAgICByaWdodDoge30sXG4gICAgICAgICAgICAgIHRvcDoge30sXG4gICAgICAgICAgICAgIGJvdHRvbToge30sXG4gICAgICAgICAgICAgIFwidG9wLWxlZnRcIjoge30sXG4gICAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IHt9LFxuICAgICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgICAgICAgICBcImJvdHRvbS1yaWdodFwiOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgICAgICAgICAgYXV0bzoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgICAgICAgICAgYXV0bzoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB7fSxcbiAgICAgICAgICAgICAgYXV0bzoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtZmllbGRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJmb3JtYXR0ZWRcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiXCIsXG4gICAgICAgICAgICB0b2tlbnM6ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1mb250XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgZGVmYXVsdDogW1wiT3BlbiBTYW5zIFJlZ3VsYXJcIiwgXCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIl0sXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtc2l6ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMTYsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICB1bml0czogXCJlbXNcIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMS4yLFxuICAgICAgICAgICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtanVzdGlmeVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBhdXRvOiB7fSxcbiAgICAgICAgICAgICAgbGVmdDoge30sXG4gICAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICAgIHJpZ2h0OiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtcmFkaWFsLW9mZnNldFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgY2VudGVyOiB7fSxcbiAgICAgICAgICAgICAgbGVmdDoge30sXG4gICAgICAgICAgICAgIHJpZ2h0OiB7fSxcbiAgICAgICAgICAgICAgdG9wOiB7fSxcbiAgICAgICAgICAgICAgYm90dG9tOiB7fSxcbiAgICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJ0b3AtcmlnaHRcIjoge30sXG4gICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjoge30sXG4gICAgICAgICAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wicG9pbnRcIl1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtYW5jaG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGNlbnRlcjoge30sXG4gICAgICAgICAgICAgIGxlZnQ6IHt9LFxuICAgICAgICAgICAgICByaWdodDoge30sXG4gICAgICAgICAgICAgIHRvcDoge30sXG4gICAgICAgICAgICAgIGJvdHRvbToge30sXG4gICAgICAgICAgICAgIFwidG9wLWxlZnRcIjoge30sXG4gICAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IHt9LFxuICAgICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IHt9LFxuICAgICAgICAgICAgICBcImJvdHRvbS1yaWdodFwiOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICAgICAgICAgIFwiIVwiOiBcInRleHQtdmFyaWFibGUtYW5jaG9yXCJcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1tYXgtYW5nbGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDQ1LFxuICAgICAgICAgICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wibGluZVwiLCBcImxpbmUtY2VudGVyXCJdXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgaG9yaXpvbnRhbDoge30sXG4gICAgICAgICAgICAgIHZlcnRpY2FsOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcInBvaW50XCJdXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LXJvdGF0ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LWtlZXAtdXByaWdodFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIGRlZmF1bHQ6ICEwLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgICAgICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgbm9uZToge30sXG4gICAgICAgICAgICAgIHVwcGVyY2FzZToge30sXG4gICAgICAgICAgICAgIGxvd2VyY2FzZToge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcIm5vbmVcIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1vZmZzZXRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICB1bml0czogXCJlbXNcIixcbiAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFswLCAwXSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgICAgICAgICAgXCIhXCI6IFwidGV4dC1yYWRpYWwtb2Zmc2V0XCJcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVmYXVsdDogITEsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtb3B0aW9uYWxcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAhMSxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIFwiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYXlvdXRfcmFzdGVyOiB7XG4gICAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYXlvdXRfaGlsbHNoYWRlOiB7XG4gICAgICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgdmlzaWJsZToge30sXG4gICAgICAgICAgICAgIG5vbmU6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJ2aXNpYmxlXCIsXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgdmFsdWU6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcl9vcGVyYXRvcjoge1xuICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgXCI9PVwiOiB7fSxcbiAgICAgICAgICAgIFwiIT1cIjoge30sXG4gICAgICAgICAgICBcIj5cIjoge30sXG4gICAgICAgICAgICBcIj49XCI6IHt9LFxuICAgICAgICAgICAgXCI8XCI6IHt9LFxuICAgICAgICAgICAgXCI8PVwiOiB7fSxcbiAgICAgICAgICAgIGluOiB7fSxcbiAgICAgICAgICAgIFwiIWluXCI6IHt9LFxuICAgICAgICAgICAgYWxsOiB7fSxcbiAgICAgICAgICAgIGFueToge30sXG4gICAgICAgICAgICBub25lOiB7fSxcbiAgICAgICAgICAgIGhhczoge30sXG4gICAgICAgICAgICBcIiFoYXNcIjoge30sXG4gICAgICAgICAgICB3aXRoaW46IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeV90eXBlOiB7XG4gICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBQb2ludDoge30sXG4gICAgICAgICAgICBMaW5lU3RyaW5nOiB7fSxcbiAgICAgICAgICAgIFBvbHlnb246IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXhwcmVzc2lvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wczoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYXNlOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIkem9vbVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBpZGVudGl0eToge30sXG4gICAgICAgICAgICAgIGV4cG9uZW50aWFsOiB7fSxcbiAgICAgICAgICAgICAgaW50ZXJ2YWw6IHt9LFxuICAgICAgICAgICAgICBjYXRlZ29yaWNhbDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcImV4cG9uZW50aWFsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yU3BhY2U6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIHJnYjoge30sXG4gICAgICAgICAgICAgIGxhYjoge30sXG4gICAgICAgICAgICAgIGhjbDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcInJnYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0eXBlOiBcIipcIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiAhMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb25fc3RvcDoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDI0LFxuICAgICAgICAgIHZhbHVlOiBbXCJudW1iZXJcIiwgXCJjb2xvclwiXSxcbiAgICAgICAgICBsZW5ndGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICB2YWx1ZTogXCIqXCIsXG4gICAgICAgICAgbWluaW11bTogMVxuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICBkZWZhdWx0OiBbMS4xNSwgMjEwLCAzMF0sXG4gICAgICAgICAgICBsZW5ndGg6IDMsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjZmZmZmZmXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZW5zaXR5OiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgICAgICAgICAgZGVmYXVsdDogLjUsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYWludDogW1wicGFpbnRfZmlsbFwiLCBcInBhaW50X2xpbmVcIiwgXCJwYWludF9jaXJjbGVcIiwgXCJwYWludF9oZWF0bWFwXCIsIFwicGFpbnRfZmlsbC1leHRydXNpb25cIiwgXCJwYWludF9zeW1ib2xcIiwgXCJwYWludF9yYXN0ZXJcIiwgXCJwYWludF9oaWxsc2hhZGVcIiwgXCJwYWludF9iYWNrZ3JvdW5kXCJdLFxuICAgICAgICBwYWludF9maWxsOiB7XG4gICAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIGRlZmF1bHQ6ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmlsbC1jb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICByZXF1aXJlczogW3tcbiAgICAgICAgICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiAhMFxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImZpbGwtdHJhbnNsYXRlXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZpbGwtcGF0dGVyblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGFpbnRfZmlsbC1leHRydXNpb25cIjoge1xuICAgICAgICAgIFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmlsbC1leHRydXNpb24tY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgICBcIiFcIjogXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCJcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFswLCAwXSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdW5pdHM6IFwibWV0ZXJzXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIHVuaXRzOiBcIm1ldGVyc1wiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiZmlsbC1leHRydXNpb24taGVpZ2h0XCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVmYXVsdDogITAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnRfbGluZToge1xuICAgICAgICAgIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICByZXF1aXJlczogW3tcbiAgICAgICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJsaW5lLXRyYW5zbGF0ZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGluZS1nYXAtd2lkdGhcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJsaW5lLW9mZnNldFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGluZS1ibHVyXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGluZS1kYXNoYXJyYXlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJsaW5lIHdpZHRoc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICAgIFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibGluZS1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJsaW5lLWdyYWRpZW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFt7XG4gICAgICAgICAgICAgIFwiIVwiOiBcImxpbmUtZGFzaGFycmF5XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgc291cmNlOiBcImdlb2pzb25cIixcbiAgICAgICAgICAgICAgaGFzOiB7XG4gICAgICAgICAgICAgICAgbGluZU1ldHJpY3M6ICEwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJsaW5lLXByb2dyZXNzXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYWludF9jaXJjbGU6IHtcbiAgICAgICAgICBcImNpcmNsZS1yYWRpdXNcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjaXJjbGUtY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjaXJjbGUtYmx1clwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNpcmNsZS1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgbGVuZ3RoOiAyLFxuICAgICAgICAgICAgZGVmYXVsdDogWzAsIDBdLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcIm1hcFwiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImNpcmNsZS10cmFuc2xhdGVcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgICAgICB2aWV3cG9ydDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYWludF9oZWF0bWFwOiB7XG4gICAgICAgICAgXCJoZWF0bWFwLXJhZGl1c1wiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMzAsXG4gICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoZWF0bWFwLXdlaWdodFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoZWF0bWFwLWludGVuc2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoZWF0bWFwLWNvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiaGVhdG1hcC1kZW5zaXR5XCJdLCAwLCBcInJnYmEoMCwgMCwgMjU1LCAwKVwiLCAuMSwgXCJyb3lhbGJsdWVcIiwgLjMsIFwiY3lhblwiLCAuNSwgXCJsaW1lXCIsIC43LCBcInllbGxvd1wiLCAxLCBcInJlZFwiXSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJoZWF0bWFwLWRlbnNpdHlcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb2xvci1yYW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnRfc3ltYm9sOiB7XG4gICAgICAgICAgXCJpY29uLW9wYWNpdHlcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaWNvbi1jb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLWhhbG8td2lkdGhcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImljb24taGFsby1ibHVyXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGxlbmd0aDogMixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFswLCAwXSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICAgICAgdmlld3BvcnQ6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogXCJtYXBcIixcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwiaWNvbi10cmFuc2xhdGVcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIG92ZXJyaWRhYmxlOiAhMCxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInRleHQtaGFsby1jb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBsZW5ndGg6IDIsXG4gICAgICAgICAgICBkZWZhdWx0OiBbMCwgMF0sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgICAgICAgICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwibWFwXCIsXG4gICAgICAgICAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCBcInRleHQtdHJhbnNsYXRlXCJdLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYWludF9yYXN0ZXI6IHtcbiAgICAgICAgICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgIHBlcmlvZDogMzYwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDEsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJhc3Rlci1zYXR1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogLTEsXG4gICAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogLTEsXG4gICAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmFzdGVyLXJlc2FtcGxpbmdcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgbGluZWFyOiB7fSxcbiAgICAgICAgICAgICAgbmVhcmVzdDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0OiBcImxpbmVhclwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICExLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAzMDAsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITEsXG4gICAgICAgICAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnRfaGlsbHNoYWRlOiB7XG4gICAgICAgICAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMzM1LFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIG1heGltdW06IDM1OSxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICExLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwidmlld3BvcnRcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMSxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAuNSxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICEwLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWQ6ICEwLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkOiAhMCxcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhaW50X2JhY2tncm91bmQ6IHtcbiAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICAgICAgICBcIiFcIjogXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIlxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImJhY2tncm91bmQtb3BhY2l0eVwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICBtYXhpbXVtOiAxLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICAgICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlZDogITAsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICBkdXJhdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDMwMCxcbiAgICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgIHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInByb3BlcnR5LXR5cGVcIjoge1xuICAgICAgICAgIFwiZGF0YS1kcml2ZW5cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY3Jvc3MtZmFkZWRcIjoge1xuICAgICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIjoge1xuICAgICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY29sb3ItcmFtcFwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkYXRhLWNvbnN0YW50XCI6IHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25zdGFudDoge1xuICAgICAgICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByb21vdGVJZDoge1xuICAgICAgICAgIFwiKlwiOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgTXQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAodCA/IHQgKyBcIjogXCIgOiBcIlwiKSArIHIsIG4gJiYgKHRoaXMuaWRlbnRpZmllciA9IG4pLCBudWxsICE9IGUgJiYgZS5fX2xpbmVfXyAmJiAodGhpcy5saW5lID0gZS5fX2xpbmVfXyk7XG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIEJ0KHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZTtcbiAgICAgIHJldHVybiBlID8gW25ldyBNdCh0LmtleSwgZSwgXCJjb25zdGFudHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjhcIildIDogW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIFR0KHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSBbXSwgciA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyByLS0gPiAwOykgZVtyXSA9IGFyZ3VtZW50c1tyICsgMV07XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IGU7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgZm9yICh2YXIgbyBpbiBhKSB0W29dID0gYVtvXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWdCh0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIE51bWJlciB8fCB0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHQgaW5zdGFuY2VvZiBCb29sZWFuID8gdC52YWx1ZU9mKCkgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBGdCh0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIHQubWFwKEZ0KTtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgT2JqZWN0ICYmICEodCBpbnN0YW5jZW9mIE51bWJlciB8fCB0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHQgaW5zdGFuY2VvZiBCb29sZWFuKSkge1xuICAgICAgICB2YXIgZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciByIGluIHQpIGVbcl0gPSBGdCh0W3JdKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gVnQodCk7XG4gICAgfVxuICAgIHZhciBEdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCByKSwgdGhpcy5tZXNzYWdlID0gciwgdGhpcy5rZXkgPSBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgICB9KEVycm9yKSxcbiAgICAgIEx0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gW10pLCB0aGlzLnBhcmVudCA9IHQsIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSBlOyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIHZhciBpID0gbltyXTtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2lbMF1dID0gaVsxXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBMdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgTHQodGhpcywgdCk7XG4gICAgfSwgTHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodGhpcy5iaW5kaW5nc1t0XSkgcmV0dXJuIHRoaXMuYmluZGluZ3NbdF07XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHJldHVybiB0aGlzLnBhcmVudC5nZXQodCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodCArIFwiIG5vdCBmb3VuZCBpbiBzY29wZS5cIik7XG4gICAgfSwgTHQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gISF0aGlzLmJpbmRpbmdzW3RdIHx8ICEhdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaGFzKHQpO1xuICAgIH07XG4gICAgdmFyIFJ0ID0ge1xuICAgICAgICBraW5kOiBcIm51bGxcIlxuICAgICAgfSxcbiAgICAgIE90ID0ge1xuICAgICAgICBraW5kOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAgVXQgPSB7XG4gICAgICAgIGtpbmQ6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICBqdCA9IHtcbiAgICAgICAga2luZDogXCJib29sZWFuXCJcbiAgICAgIH0sXG4gICAgICBxdCA9IHtcbiAgICAgICAga2luZDogXCJjb2xvclwiXG4gICAgICB9LFxuICAgICAgTnQgPSB7XG4gICAgICAgIGtpbmQ6IFwib2JqZWN0XCJcbiAgICAgIH0sXG4gICAgICBLdCA9IHtcbiAgICAgICAga2luZDogXCJ2YWx1ZVwiXG4gICAgICB9LFxuICAgICAgR3QgPSB7XG4gICAgICAgIGtpbmQ6IFwiY29sbGF0b3JcIlxuICAgICAgfSxcbiAgICAgIFp0ID0ge1xuICAgICAgICBraW5kOiBcImZvcm1hdHRlZFwiXG4gICAgICB9LFxuICAgICAgWHQgPSB7XG4gICAgICAgIGtpbmQ6IFwicmVzb2x2ZWRJbWFnZVwiXG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIEp0KHQsIGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwiYXJyYXlcIixcbiAgICAgICAgaXRlbVR5cGU6IHQsXG4gICAgICAgIE46IGVcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEh0KHQpIHtcbiAgICAgIGlmIChcImFycmF5XCIgPT09IHQua2luZCkge1xuICAgICAgICB2YXIgZSA9IEh0KHQuaXRlbVR5cGUpO1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgdC5OID8gXCJhcnJheTxcIiArIGUgKyBcIiwgXCIgKyB0Lk4gKyBcIj5cIiA6IFwidmFsdWVcIiA9PT0gdC5pdGVtVHlwZS5raW5kID8gXCJhcnJheVwiIDogXCJhcnJheTxcIiArIGUgKyBcIj5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LmtpbmQ7XG4gICAgfVxuICAgIHZhciBZdCA9IFtSdCwgT3QsIFV0LCBqdCwgcXQsIFp0LCBOdCwgSnQoS3QpLCBYdF07XG4gICAgZnVuY3Rpb24gJHQodCwgZSkge1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gZS5raW5kKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImFycmF5XCIgPT09IHQua2luZCkge1xuICAgICAgICBpZiAoXCJhcnJheVwiID09PSBlLmtpbmQgJiYgKDAgPT09IGUuTiAmJiBcInZhbHVlXCIgPT09IGUuaXRlbVR5cGUua2luZCB8fCAhJHQodC5pdGVtVHlwZSwgZS5pdGVtVHlwZSkpICYmIChcIm51bWJlclwiICE9IHR5cGVvZiB0Lk4gfHwgdC5OID09PSBlLk4pKSByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0LmtpbmQgPT09IGUua2luZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChcInZhbHVlXCIgPT09IHQua2luZCkgZm9yICh2YXIgciA9IDAsIG4gPSBZdDsgciA8IG4ubGVuZ3RoOyByICs9IDEpIGlmICghJHQobltyXSwgZSkpIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBIdCh0KSArIFwiIGJ1dCBmb3VuZCBcIiArIEh0KGUpICsgXCIgaW5zdGVhZC5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3QodCwgZSkge1xuICAgICAgcmV0dXJuIGUuc29tZShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS5raW5kID09PSB0LmtpbmQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUXQodCwgZSkge1xuICAgICAgcmV0dXJuIGUuc29tZShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCIgPT09IGUgPyBudWxsID09PSB0IDogXCJhcnJheVwiID09PSBlID8gQXJyYXkuaXNBcnJheSh0KSA6IFwib2JqZWN0XCIgPT09IGUgPyB0ICYmICFBcnJheS5pc0FycmF5KHQpICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgOiBlID09PSB0eXBlb2YgdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgdGUgPSBlKGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0ge1xuICAgICAgICAgIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NSwgMV0sXG4gICAgICAgICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNSwgMV0sXG4gICAgICAgICAgYXF1YTogWzAsIDI1NSwgMjU1LCAxXSxcbiAgICAgICAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMiwgMV0sXG4gICAgICAgICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1LCAxXSxcbiAgICAgICAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjAsIDFdLFxuICAgICAgICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTYsIDFdLFxuICAgICAgICAgIGJsYWNrOiBbMCwgMCwgMCwgMV0sXG4gICAgICAgICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1LCAxXSxcbiAgICAgICAgICBibHVlOiBbMCwgMCwgMjU1LCAxXSxcbiAgICAgICAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2LCAxXSxcbiAgICAgICAgICBicm93bjogWzE2NSwgNDIsIDQyLCAxXSxcbiAgICAgICAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1LCAxXSxcbiAgICAgICAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjAsIDFdLFxuICAgICAgICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMCwgMV0sXG4gICAgICAgICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwLCAxXSxcbiAgICAgICAgICBjb3JhbDogWzI1NSwgMTI3LCA4MCwgMV0sXG4gICAgICAgICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3LCAxXSxcbiAgICAgICAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjAsIDFdLFxuICAgICAgICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MCwgMV0sXG4gICAgICAgICAgY3lhbjogWzAsIDI1NSwgMjU1LCAxXSxcbiAgICAgICAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOSwgMV0sXG4gICAgICAgICAgZGFya2N5YW46IFswLCAxMzksIDEzOSwgMV0sXG4gICAgICAgICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMSwgMV0sXG4gICAgICAgICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgICAgICAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDAsIDFdLFxuICAgICAgICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICAgICAgICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwNywgMV0sXG4gICAgICAgICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOSwgMV0sXG4gICAgICAgICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0NywgMV0sXG4gICAgICAgICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwLCAxXSxcbiAgICAgICAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0LCAxXSxcbiAgICAgICAgICBkYXJrcmVkOiBbMTM5LCAwLCAwLCAxXSxcbiAgICAgICAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMiwgMV0sXG4gICAgICAgICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0MywgMV0sXG4gICAgICAgICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5LCAxXSxcbiAgICAgICAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OSwgMV0sXG4gICAgICAgICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzksIDFdLFxuICAgICAgICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOSwgMV0sXG4gICAgICAgICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExLCAxXSxcbiAgICAgICAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0NywgMV0sXG4gICAgICAgICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NSwgMV0sXG4gICAgICAgICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAgICAgICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgICAgICAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1LCAxXSxcbiAgICAgICAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNCwgMV0sXG4gICAgICAgICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwLCAxXSxcbiAgICAgICAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0LCAxXSxcbiAgICAgICAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAgICAgICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjAsIDFdLFxuICAgICAgICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1LCAxXSxcbiAgICAgICAgICBnb2xkOiBbMjU1LCAyMTUsIDAsIDFdLFxuICAgICAgICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMiwgMV0sXG4gICAgICAgICAgZ3JheTogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAgICAgICAgIGdyZWVuOiBbMCwgMTI4LCAwLCAxXSxcbiAgICAgICAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0NywgMV0sXG4gICAgICAgICAgZ3JleTogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAgICAgICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MCwgMV0sXG4gICAgICAgICAgaG90cGluazogWzI1NSwgMTA1LCAxODAsIDFdLFxuICAgICAgICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyLCAxXSxcbiAgICAgICAgICBpbmRpZ286IFs3NSwgMCwgMTMwLCAxXSxcbiAgICAgICAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDAsIDFdLFxuICAgICAgICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MCwgMV0sXG4gICAgICAgICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwLCAxXSxcbiAgICAgICAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NSwgMV0sXG4gICAgICAgICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDAsIDFdLFxuICAgICAgICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDUsIDFdLFxuICAgICAgICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzAsIDFdLFxuICAgICAgICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4LCAxXSxcbiAgICAgICAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1LCAxXSxcbiAgICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTAsIDFdLFxuICAgICAgICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAgICAgICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0LCAxXSxcbiAgICAgICAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgICAgICAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzLCAxXSxcbiAgICAgICAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjIsIDFdLFxuICAgICAgICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzAsIDFdLFxuICAgICAgICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTAsIDFdLFxuICAgICAgICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1MywgMV0sXG4gICAgICAgICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgICAgICAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjIsIDFdLFxuICAgICAgICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNCwgMV0sXG4gICAgICAgICAgbGltZTogWzAsIDI1NSwgMCwgMV0sXG4gICAgICAgICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTAsIDFdLFxuICAgICAgICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMCwgMV0sXG4gICAgICAgICAgbWFnZW50YTogWzI1NSwgMCwgMjU1LCAxXSxcbiAgICAgICAgICBtYXJvb246IFsxMjgsIDAsIDAsIDFdLFxuICAgICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwLCAxXSxcbiAgICAgICAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1LCAxXSxcbiAgICAgICAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTEsIDFdLFxuICAgICAgICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTksIDFdLFxuICAgICAgICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzLCAxXSxcbiAgICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4LCAxXSxcbiAgICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0LCAxXSxcbiAgICAgICAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDQsIDFdLFxuICAgICAgICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzMywgMV0sXG4gICAgICAgICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTIsIDFdLFxuICAgICAgICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTAsIDFdLFxuICAgICAgICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjUsIDFdLFxuICAgICAgICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MSwgMV0sXG4gICAgICAgICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczLCAxXSxcbiAgICAgICAgICBuYXZ5OiBbMCwgMCwgMTI4LCAxXSxcbiAgICAgICAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMCwgMV0sXG4gICAgICAgICAgb2xpdmU6IFsxMjgsIDEyOCwgMCwgMV0sXG4gICAgICAgICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1LCAxXSxcbiAgICAgICAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMCwgMV0sXG4gICAgICAgICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMCwgMV0sXG4gICAgICAgICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNCwgMV0sXG4gICAgICAgICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzAsIDFdLFxuICAgICAgICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTIsIDFdLFxuICAgICAgICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4LCAxXSxcbiAgICAgICAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0NywgMV0sXG4gICAgICAgICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTMsIDFdLFxuICAgICAgICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODUsIDFdLFxuICAgICAgICAgIHBlcnU6IFsyMDUsIDEzMywgNjMsIDFdLFxuICAgICAgICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzLCAxXSxcbiAgICAgICAgICBwbHVtOiBbMjIxLCAxNjAsIDIyMSwgMV0sXG4gICAgICAgICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzAsIDFdLFxuICAgICAgICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4LCAxXSxcbiAgICAgICAgICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzLCAxXSxcbiAgICAgICAgICByZWQ6IFsyNTUsIDAsIDAsIDFdLFxuICAgICAgICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDMsIDFdLFxuICAgICAgICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNSwgMV0sXG4gICAgICAgICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOSwgMV0sXG4gICAgICAgICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNCwgMV0sXG4gICAgICAgICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5NiwgMV0sXG4gICAgICAgICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4NywgMV0sXG4gICAgICAgICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4LCAxXSxcbiAgICAgICAgICBzaWVubmE6IFsxNjAsIDgyLCA0NSwgMV0sXG4gICAgICAgICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5MiwgMV0sXG4gICAgICAgICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzUsIDFdLFxuICAgICAgICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNSwgMV0sXG4gICAgICAgICAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICAgICAgICAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICAgICAgICAgc25vdzogWzI1NSwgMjUwLCAyNTAsIDFdLFxuICAgICAgICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjcsIDFdLFxuICAgICAgICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MCwgMV0sXG4gICAgICAgICAgdGFuOiBbMjEwLCAxODAsIDE0MCwgMV0sXG4gICAgICAgICAgdGVhbDogWzAsIDEyOCwgMTI4LCAxXSxcbiAgICAgICAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNiwgMV0sXG4gICAgICAgICAgdG9tYXRvOiBbMjU1LCA5OSwgNzEsIDFdLFxuICAgICAgICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOCwgMV0sXG4gICAgICAgICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOCwgMV0sXG4gICAgICAgICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5LCAxXSxcbiAgICAgICAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTUsIDFdLFxuICAgICAgICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1LCAxXSxcbiAgICAgICAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMCwgMV0sXG4gICAgICAgICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTAsIDFdXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG4odCkge1xuICAgICAgICAgIHJldHVybiAodCA9IE1hdGgucm91bmQodCkpIDwgMCA/IDAgOiB0ID4gMjU1ID8gMjU1IDogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICByZXR1cm4gbihcIiVcIiA9PT0gdFt0Lmxlbmd0aCAtIDFdID8gcGFyc2VGbG9hdCh0KSAvIDEwMCAqIDI1NSA6IHBhcnNlSW50KHQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhKHQpIHtcbiAgICAgICAgICByZXR1cm4gKGUgPSBcIiVcIiA9PT0gdFt0Lmxlbmd0aCAtIDFdID8gcGFyc2VGbG9hdCh0KSAvIDEwMCA6IHBhcnNlRmxvYXQodCkpIDwgMCA/IDAgOiBlID4gMSA/IDEgOiBlO1xuICAgICAgICAgIHZhciBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG8odCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiByIDwgMCA/IHIgKz0gMSA6IHIgPiAxICYmIChyIC09IDEpLCA2ICogciA8IDEgPyB0ICsgKGUgLSB0KSAqIHIgKiA2IDogMiAqIHIgPCAxID8gZSA6IDMgKiByIDwgMiA/IHQgKyAoZSAtIHQpICogKDIgLyAzIC0gcikgKiA2IDogdDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGUucGFyc2VDU1NDb2xvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgICAgcyA9IHQucmVwbGFjZSgvIC9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHMgaW4gcikgcmV0dXJuIHJbc10uc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChcIiNcIiA9PT0gc1swXSkgcmV0dXJuIDQgPT09IHMubGVuZ3RoID8gKGUgPSBwYXJzZUludChzLnN1YnN0cigxKSwgMTYpKSA+PSAwICYmIGUgPD0gNDA5NSA/IFsoMzg0MCAmIGUpID4+IDQgfCAoMzg0MCAmIGUpID4+IDgsIDI0MCAmIGUgfCAoMjQwICYgZSkgPj4gNCwgMTUgJiBlIHwgKDE1ICYgZSkgPDwgNCwgMV0gOiBudWxsIDogNyA9PT0gcy5sZW5ndGggJiYgKGUgPSBwYXJzZUludChzLnN1YnN0cigxKSwgMTYpKSA+PSAwICYmIGUgPD0gMTY3NzcyMTUgPyBbKDE2NzExNjgwICYgZSkgPj4gMTYsICg2NTI4MCAmIGUpID4+IDgsIDI1NSAmIGUsIDFdIDogbnVsbDtcbiAgICAgICAgICAgIHZhciB1ID0gcy5pbmRleE9mKFwiKFwiKSxcbiAgICAgICAgICAgICAgbCA9IHMuaW5kZXhPZihcIilcIik7XG4gICAgICAgICAgICBpZiAoLTEgIT09IHUgJiYgbCArIDEgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gcy5zdWJzdHIoMCwgdSksXG4gICAgICAgICAgICAgICAgYyA9IHMuc3Vic3RyKHUgKyAxLCBsIC0gKHUgKyAxKSkuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgICAgIGggPSAxO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmdiYVwiOlxuICAgICAgICAgICAgICAgICAgaWYgKDQgIT09IGMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGggPSBhKGMucG9wKCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAzICE9PSBjLmxlbmd0aCA/IG51bGwgOiBbaShjWzBdKSwgaShjWzFdKSwgaShjWzJdKSwgaF07XG4gICAgICAgICAgICAgICAgY2FzZSBcImhzbGFcIjpcbiAgICAgICAgICAgICAgICAgIGlmICg0ICE9PSBjLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICBoID0gYShjLnBvcCgpKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaHNsXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoMyAhPT0gYy5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgdmFyIGYgPSAocGFyc2VGbG9hdChjWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjAsXG4gICAgICAgICAgICAgICAgICAgIHkgPSBhKGNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBkID0gYShjWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGQgPD0gLjUgPyBkICogKHkgKyAxKSA6IGQgKyB5IC0gZCAqIHksXG4gICAgICAgICAgICAgICAgICAgIHYgPSAyICogZCAtIG07XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW24oMjU1ICogbyh2LCBtLCBmICsgMSAvIDMpKSwgbigyNTUgKiBvKHYsIG0sIGYpKSwgbigyNTUgKiBvKHYsIG0sIGYgLSAxIC8gMykpLCBoXTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKHQpIHt9XG4gICAgICB9KS5wYXJzZUNTU0NvbG9yLFxuICAgICAgZWUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSAxKSwgdGhpcy5yID0gdCwgdGhpcy5nID0gZSwgdGhpcy5iID0gciwgdGhpcy5hID0gbjtcbiAgICAgIH07XG4gICAgZWUucGFyc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBlZSkgcmV0dXJuIHQ7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0ZSh0KTtcbiAgICAgICAgICBpZiAoZSkgcmV0dXJuIG5ldyBlZShlWzBdIC8gMjU1ICogZVszXSwgZVsxXSAvIDI1NSAqIGVbM10sIGVbMl0gLyAyNTUgKiBlWzNdLCBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy50b0FycmF5KCksXG4gICAgICAgIGUgPSB0WzFdLFxuICAgICAgICByID0gdFsyXSxcbiAgICAgICAgbiA9IHRbM107XG4gICAgICByZXR1cm4gXCJyZ2JhKFwiICsgTWF0aC5yb3VuZCh0WzBdKSArIFwiLFwiICsgTWF0aC5yb3VuZChlKSArIFwiLFwiICsgTWF0aC5yb3VuZChyKSArIFwiLFwiICsgbiArIFwiKVwiO1xuICAgIH0sIGVlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmE7XG4gICAgICByZXR1cm4gMCA9PT0gdCA/IFswLCAwLCAwLCAwXSA6IFsyNTUgKiB0aGlzLnIgLyB0LCAyNTUgKiB0aGlzLmcgLyB0LCAyNTUgKiB0aGlzLmIgLyB0LCB0XTtcbiAgICB9LCBlZS5ibGFjayA9IG5ldyBlZSgwLCAwLCAwLCAxKSwgZWUud2hpdGUgPSBuZXcgZWUoMSwgMSwgMSwgMSksIGVlLnRyYW5zcGFyZW50ID0gbmV3IGVlKDAsIDAsIDAsIDApLCBlZS5yZWQgPSBuZXcgZWUoMSwgMCwgMCwgMSk7XG4gICAgdmFyIHJlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSB0ID8gZSA/IFwidmFyaWFudFwiIDogXCJjYXNlXCIgOiBlID8gXCJhY2NlbnRcIiA6IFwiYmFzZVwiLCB0aGlzLmxvY2FsZSA9IHIsIHRoaXMuY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10sIHtcbiAgICAgICAgc2Vuc2l0aXZpdHk6IHRoaXMuc2Vuc2l0aXZpdHksXG4gICAgICAgIHVzYWdlOiBcInNlYXJjaFwiXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJlLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yLmNvbXBhcmUodCwgZSk7XG4gICAgfSwgcmUucHJvdG90eXBlLnJlc29sdmVkTG9jYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xuICAgIH07XG4gICAgdmFyIG5lID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdCwgdGhpcy5pbWFnZSA9IGUsIHRoaXMuc2NhbGUgPSByLCB0aGlzLmZvbnRTdGFjayA9IG4sIHRoaXMudGV4dENvbG9yID0gaTtcbiAgICAgIH0sXG4gICAgICBpZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSB0O1xuICAgICAgfTtcbiAgICBpZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgaWUoW25ldyBuZSh0LCBudWxsLCBudWxsLCBudWxsLCBudWxsKV0pO1xuICAgIH0sIGllLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMuc2VjdGlvbnMubGVuZ3RoIHx8ICF0aGlzLnNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIDAgIT09IHQudGV4dC5sZW5ndGggfHwgdC5pbWFnZSAmJiAwICE9PSB0LmltYWdlLm5hbWUubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgfSwgaWUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIGllID8gdCA6IGllLmZyb21TdHJpbmcodCk7XG4gICAgfSwgaWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMuc2VjdGlvbnMubGVuZ3RoID8gXCJcIiA6IHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnRleHQ7XG4gICAgICB9KS5qb2luKFwiXCIpO1xuICAgIH0sIGllLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gW1wiZm9ybWF0XCJdLCBlID0gMCwgciA9IHRoaXMuc2VjdGlvbnM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXTtcbiAgICAgICAgaWYgKG4uaW1hZ2UpIHQucHVzaChbXCJpbWFnZVwiLCBuLmltYWdlLm5hbWVdKTtlbHNlIHtcbiAgICAgICAgICB0LnB1c2gobi50ZXh0KTtcbiAgICAgICAgICB2YXIgaSA9IHt9O1xuICAgICAgICAgIG4uZm9udFN0YWNrICYmIChpW1widGV4dC1mb250XCJdID0gW1wibGl0ZXJhbFwiLCBuLmZvbnRTdGFjay5zcGxpdChcIixcIildKSwgbi5zY2FsZSAmJiAoaVtcImZvbnQtc2NhbGVcIl0gPSBuLnNjYWxlKSwgbi50ZXh0Q29sb3IgJiYgKGlbXCJ0ZXh0LWNvbG9yXCJdID0gW1wicmdiYVwiXS5jb25jYXQobi50ZXh0Q29sb3IudG9BcnJheSgpKSksIHQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB2YXIgYWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5uYW1lID0gdC5uYW1lLCB0aGlzLmF2YWlsYWJsZSA9IHQuYXZhaWxhYmxlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gb2UodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgJiYgdCA+PSAwICYmIHQgPD0gMjU1ICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGUgJiYgZSA+PSAwICYmIGUgPD0gMjU1ICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIHIgJiYgciA+PSAwICYmIHIgPD0gMjU1ID8gdm9pZCAwID09PSBuIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIG4gJiYgbiA+PSAwICYmIG4gPD0gMSA/IG51bGwgOiBcIkludmFsaWQgcmdiYSB2YWx1ZSBbXCIgKyBbdCwgZSwgciwgbl0uam9pbihcIiwgXCIpICsgXCJdOiAnYScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXCIgOiBcIkludmFsaWQgcmdiYSB2YWx1ZSBbXCIgKyAoXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IFt0LCBlLCByLCBuXSA6IFt0LCBlLCByXSkuam9pbihcIiwgXCIpICsgXCJdOiAncicsICdnJywgYW5kICdiJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1LlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZSh0KSB7XG4gICAgICBpZiAobnVsbCA9PT0gdCkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHJldHVybiAhMDtcbiAgICAgIGlmIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCkgcmV0dXJuICEwO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHQpIHJldHVybiAhMDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgZWUpIHJldHVybiAhMDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgcmUpIHJldHVybiAhMDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgaWUpIHJldHVybiAhMDtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgYWUpIHJldHVybiAhMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIGlmICghc2UocltlXSkpIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgZm9yICh2YXIgbiBpbiB0KSBpZiAoIXNlKHRbbl0pKSByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWUodCkge1xuICAgICAgaWYgKG51bGwgPT09IHQpIHJldHVybiBSdDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSByZXR1cm4gVXQ7XG4gICAgICBpZiAoXCJib29sZWFuXCIgPT0gdHlwZW9mIHQpIHJldHVybiBqdDtcbiAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB0KSByZXR1cm4gT3Q7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGVlKSByZXR1cm4gcXQ7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIHJlKSByZXR1cm4gR3Q7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGllKSByZXR1cm4gWnQ7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGFlKSByZXR1cm4gWHQ7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBmb3IgKHZhciBlLCByID0gdC5sZW5ndGgsIG4gPSAwLCBpID0gdDsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHVlKGlbbl0pO1xuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBpZiAoZSA9PT0gYSkgY29udGludWU7XG4gICAgICAgICAgICBlID0gS3Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZSA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEp0KGUgfHwgS3QsIHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZSh0KSB7XG4gICAgICB2YXIgZSA9IHR5cGVvZiB0O1xuICAgICAgcmV0dXJuIG51bGwgPT09IHQgPyBcIlwiIDogXCJzdHJpbmdcIiA9PT0gZSB8fCBcIm51bWJlclwiID09PSBlIHx8IFwiYm9vbGVhblwiID09PSBlID8gU3RyaW5nKHQpIDogdCBpbnN0YW5jZW9mIGVlIHx8IHQgaW5zdGFuY2VvZiBpZSB8fCB0IGluc3RhbmNlb2YgYWUgPyB0LnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeSh0KTtcbiAgICB9XG4gICAgYWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9LCBhZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ID8gbmV3IGFlKHtcbiAgICAgICAgbmFtZTogdCxcbiAgICAgICAgYXZhaWxhYmxlOiAhMVxuICAgICAgfSkgOiBudWxsO1xuICAgIH0sIGFlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1wiaW1hZ2VcIiwgdGhpcy5uYW1lXTtcbiAgICB9O1xuICAgIHZhciBwZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLnZhbHVlID0gZTtcbiAgICB9O1xuICAgIHBlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCInbGl0ZXJhbCcgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIGlmICghc2UodFsxXSkpIHJldHVybiBlLmVycm9yKFwiaW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIHZhciByID0gdFsxXSxcbiAgICAgICAgbiA9IHVlKHIpLFxuICAgICAgICBpID0gZS5leHBlY3RlZFR5cGU7XG4gICAgICByZXR1cm4gXCJhcnJheVwiICE9PSBuLmtpbmQgfHwgMCAhPT0gbi5OIHx8ICFpIHx8IFwiYXJyYXlcIiAhPT0gaS5raW5kIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIGkuTiAmJiAwICE9PSBpLk4gfHwgKG4gPSBpKSwgbmV3IHBlKG4sIHIpO1xuICAgIH0sIHBlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sIHBlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAoKSB7fSwgcGUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgcGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImFycmF5XCIgPT09IHRoaXMudHlwZS5raW5kIHx8IFwib2JqZWN0XCIgPT09IHRoaXMudHlwZS5raW5kID8gW1wibGl0ZXJhbFwiLCB0aGlzLnZhbHVlXSA6IHRoaXMudmFsdWUgaW5zdGFuY2VvZiBlZSA/IFtcInJnYmFcIl0uY29uY2F0KHRoaXMudmFsdWUudG9BcnJheSgpKSA6IHRoaXMudmFsdWUgaW5zdGFuY2VvZiBpZSA/IHRoaXMudmFsdWUuc2VyaWFsaXplKCkgOiB0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIGNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMubmFtZSA9IFwiRXhwcmVzc2lvbkV2YWx1YXRpb25FcnJvclwiLCB0aGlzLm1lc3NhZ2UgPSB0O1xuICAgIH07XG4gICAgY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcbiAgICB2YXIgaGUgPSB7XG4gICAgICAgIHN0cmluZzogVXQsXG4gICAgICAgIG51bWJlcjogT3QsXG4gICAgICAgIGJvb2xlYW46IGp0LFxuICAgICAgICBvYmplY3Q6IE50XG4gICAgICB9LFxuICAgICAgZmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmFyZ3MgPSBlO1xuICAgICAgfTtcbiAgICBmZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCAyKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgcixcbiAgICAgICAgbiA9IDEsXG4gICAgICAgIGkgPSB0WzBdO1xuICAgICAgaWYgKFwiYXJyYXlcIiA9PT0gaSkge1xuICAgICAgICB2YXIgYSwgbztcbiAgICAgICAgaWYgKHQubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBzID0gdFsxXTtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgcyB8fCAhKHMgaW4gaGUpIHx8IFwib2JqZWN0XCIgPT09IHMpIHJldHVybiBlLmVycm9yKCdUaGUgaXRlbSB0eXBlIGFyZ3VtZW50IG9mIFwiYXJyYXlcIiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIG51bWJlciwgYm9vbGVhbicsIDEpO1xuICAgICAgICAgIGEgPSBoZVtzXSwgbisrO1xuICAgICAgICB9IGVsc2UgYSA9IEt0O1xuICAgICAgICBpZiAodC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHRbMl0gJiYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHRbMl0gfHwgdFsyXSA8IDAgfHwgdFsyXSAhPT0gTWF0aC5mbG9vcih0WzJdKSkpIHJldHVybiBlLmVycm9yKCdUaGUgbGVuZ3RoIGFyZ3VtZW50IHRvIFwiYXJyYXlcIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7XG4gICAgICAgICAgbyA9IHRbMl0sIG4rKztcbiAgICAgICAgfVxuICAgICAgICByID0gSnQoYSwgbyk7XG4gICAgICB9IGVsc2UgciA9IGhlW2ldO1xuICAgICAgZm9yICh2YXIgdSA9IFtdOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbCA9IGUucGFyc2UodFtuXSwgbiwgS3QpO1xuICAgICAgICBpZiAoIWwpIHJldHVybiBudWxsO1xuICAgICAgICB1LnB1c2gobCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGZlKHIsIHUpO1xuICAgIH0sIGZlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHRoaXMuYXJncy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYXJnc1tlXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgaWYgKCEkdCh0aGlzLnR5cGUsIHVlKHIpKSkgcmV0dXJuIHI7XG4gICAgICAgIGlmIChlID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSBcIiArIEh0KHRoaXMudHlwZSkgKyBcIiwgYnV0IGZvdW5kIFwiICsgSHQodWUocikpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBmZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKHQpO1xuICAgIH0sIGZlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9LCBmZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLnR5cGUsXG4gICAgICAgIGUgPSBbdC5raW5kXTtcbiAgICAgIGlmIChcImFycmF5XCIgPT09IHQua2luZCkge1xuICAgICAgICB2YXIgciA9IHQuaXRlbVR5cGU7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSByLmtpbmQgfHwgXCJudW1iZXJcIiA9PT0gci5raW5kIHx8IFwiYm9vbGVhblwiID09PSByLmtpbmQpIHtcbiAgICAgICAgICBlLnB1c2goci5raW5kKTtcbiAgICAgICAgICB2YXIgbiA9IHQuTjtcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PSB0eXBlb2YgbiB8fCB0aGlzLmFyZ3MubGVuZ3RoID4gMSkgJiYgZS5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5jb25jYXQodGhpcy5hcmdzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHZhciB5ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnR5cGUgPSBadCwgdGhpcy5zZWN0aW9ucyA9IHQ7XG4gICAgfTtcbiAgICB5ZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPCAyKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgciA9IHRbMV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocikgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgcikgcmV0dXJuIGUuZXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi5cIik7XG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAhMSwgYSA9IDE7IGEgPD0gdC5sZW5ndGggLSAxOyArK2EpIHtcbiAgICAgICAgdmFyIG8gPSB0W2FdO1xuICAgICAgICBpZiAoaSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBvICYmICFBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgICAgaSA9ICExO1xuICAgICAgICAgIHZhciBzID0gbnVsbDtcbiAgICAgICAgICBpZiAob1tcImZvbnQtc2NhbGVcIl0gJiYgIShzID0gZS5wYXJzZShvW1wiZm9udC1zY2FsZVwiXSwgMSwgT3QpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIHUgPSBudWxsO1xuICAgICAgICAgIGlmIChvW1widGV4dC1mb250XCJdICYmICEodSA9IGUucGFyc2Uob1tcInRleHQtZm9udFwiXSwgMSwgSnQoVXQpKSkpIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBsID0gbnVsbDtcbiAgICAgICAgICBpZiAob1tcInRleHQtY29sb3JcIl0gJiYgIShsID0gZS5wYXJzZShvW1widGV4dC1jb2xvclwiXSwgMSwgcXQpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIHAgPSBuW24ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcC5zY2FsZSA9IHMsIHAuZm9udCA9IHUsIHAudGV4dENvbG9yID0gbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYyA9IGUucGFyc2UodFthXSwgMSwgS3QpO1xuICAgICAgICAgIGlmICghYykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIGggPSBjLnR5cGUua2luZDtcbiAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gaCAmJiBcInZhbHVlXCIgIT09IGggJiYgXCJudWxsXCIgIT09IGggJiYgXCJyZXNvbHZlZEltYWdlXCIgIT09IGgpIHJldHVybiBlLmVycm9yKFwiRm9ybWF0dGVkIHRleHQgdHlwZSBtdXN0IGJlICdzdHJpbmcnLCAndmFsdWUnLCAnaW1hZ2UnIG9yICdudWxsJy5cIik7XG4gICAgICAgICAgaSA9ICEwLCBuLnB1c2goe1xuICAgICAgICAgICAgY29udGVudDogYyxcbiAgICAgICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICAgICAgZm9udDogbnVsbCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHllKG4pO1xuICAgIH0sIHllLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IGllKHRoaXMuc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciByID0gZS5jb250ZW50LmV2YWx1YXRlKHQpO1xuICAgICAgICByZXR1cm4gdWUocikgPT09IFh0ID8gbmV3IG5lKFwiXCIsIHIsIG51bGwsIG51bGwsIG51bGwpIDogbmV3IG5lKGxlKHIpLCBudWxsLCBlLnNjYWxlID8gZS5zY2FsZS5ldmFsdWF0ZSh0KSA6IG51bGwsIGUuZm9udCA/IGUuZm9udC5ldmFsdWF0ZSh0KS5qb2luKFwiLFwiKSA6IG51bGwsIGUudGV4dENvbG9yID8gZS50ZXh0Q29sb3IuZXZhbHVhdGUodCkgOiBudWxsKTtcbiAgICAgIH0pKTtcbiAgICB9LCB5ZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5zZWN0aW9uczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICB0KG4uY29udGVudCksIG4uc2NhbGUgJiYgdChuLnNjYWxlKSwgbi5mb250ICYmIHQobi5mb250KSwgbi50ZXh0Q29sb3IgJiYgdChuLnRleHRDb2xvcik7XG4gICAgICB9XG4gICAgfSwgeWUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgeWUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSBbXCJmb3JtYXRcIl0sIGUgPSAwLCByID0gdGhpcy5zZWN0aW9uczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG4gPSByW2VdO1xuICAgICAgICB0LnB1c2gobi5jb250ZW50LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgdmFyIGkgPSB7fTtcbiAgICAgICAgbi5zY2FsZSAmJiAoaVtcImZvbnQtc2NhbGVcIl0gPSBuLnNjYWxlLnNlcmlhbGl6ZSgpKSwgbi5mb250ICYmIChpW1widGV4dC1mb250XCJdID0gbi5mb250LnNlcmlhbGl6ZSgpKSwgbi50ZXh0Q29sb3IgJiYgKGlbXCJ0ZXh0LWNvbG9yXCJdID0gbi50ZXh0Q29sb3Iuc2VyaWFsaXplKCkpLCB0LnB1c2goaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHZhciBkZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnR5cGUgPSBYdCwgdGhpcy5pbnB1dCA9IHQ7XG4gICAgfTtcbiAgICBkZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAoMiAhPT0gdC5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgdHdvIGFyZ3VtZW50cy5cIik7XG4gICAgICB2YXIgciA9IGUucGFyc2UodFsxXSwgMSwgVXQpO1xuICAgICAgcmV0dXJuIHIgPyBuZXcgZGUocikgOiBlLmVycm9yKFwiTm8gaW1hZ2UgbmFtZSBwcm92aWRlZC5cIik7XG4gICAgfSwgZGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KSxcbiAgICAgICAgciA9IGFlLmZyb21TdHJpbmcoZSk7XG4gICAgICByZXR1cm4gciAmJiB0LmF2YWlsYWJsZUltYWdlcyAmJiAoci5hdmFpbGFibGUgPSB0LmF2YWlsYWJsZUltYWdlcy5pbmRleE9mKGUpID4gLTEpLCByO1xuICAgIH0sIGRlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KTtcbiAgICB9LCBkZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBkZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtcImltYWdlXCIsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuICAgIH07XG4gICAgdmFyIG1lID0ge1xuICAgICAgICBcInRvLWJvb2xlYW5cIjoganQsXG4gICAgICAgIFwidG8tY29sb3JcIjogcXQsXG4gICAgICAgIFwidG8tbnVtYmVyXCI6IE90LFxuICAgICAgICBcInRvLXN0cmluZ1wiOiBVdFxuICAgICAgfSxcbiAgICAgIHZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5hcmdzID0gZTtcbiAgICAgIH07XG4gICAgdmUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgMikgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIgPSB0WzBdO1xuICAgICAgaWYgKChcInRvLWJvb2xlYW5cIiA9PT0gciB8fCBcInRvLXN0cmluZ1wiID09PSByKSAmJiAyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgZm9yICh2YXIgbiA9IG1lW3JdLCBpID0gW10sIGEgPSAxOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbyA9IGUucGFyc2UodFthXSwgYSwgS3QpO1xuICAgICAgICBpZiAoIW8pIHJldHVybiBudWxsO1xuICAgICAgICBpLnB1c2gobyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHZlKG4sIGkpO1xuICAgIH0sIHZlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAoXCJib29sZWFuXCIgPT09IHRoaXMudHlwZS5raW5kKSByZXR1cm4gQm9vbGVhbih0aGlzLmFyZ3NbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgaWYgKFwiY29sb3JcIiA9PT0gdGhpcy50eXBlLmtpbmQpIHtcbiAgICAgICAgZm9yICh2YXIgZSwgciwgbiA9IDAsIGkgPSB0aGlzLmFyZ3M7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgICAgaWYgKHIgPSBudWxsLCAoZSA9IGlbbl0uZXZhbHVhdGUodCkpIGluc3RhbmNlb2YgZWUpIHJldHVybiBlO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHQucGFyc2VDb2xvcihlKTtcbiAgICAgICAgICAgIGlmIChhKSByZXR1cm4gYTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZSkgJiYgIShyID0gZS5sZW5ndGggPCAzIHx8IGUubGVuZ3RoID4gNCA/IFwiSW52YWxpZCByYmdhIHZhbHVlIFwiICsgSlNPTi5zdHJpbmdpZnkoZSkgKyBcIjogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy5cIiA6IG9lKGVbMF0sIGVbMV0sIGVbMl0sIGVbM10pKSkgcmV0dXJuIG5ldyBlZShlWzBdIC8gMjU1LCBlWzFdIC8gMjU1LCBlWzJdIC8gMjU1LCBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgY2UociB8fCBcIkNvdWxkIG5vdCBwYXJzZSBjb2xvciBmcm9tIHZhbHVlICdcIiArIChcInN0cmluZ1wiID09IHR5cGVvZiBlID8gZSA6IFN0cmluZyhKU09OLnN0cmluZ2lmeShlKSkpICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHRoaXMudHlwZS5raW5kKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSBudWxsLCBzID0gMCwgdSA9IHRoaXMuYXJnczsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gKG8gPSB1W3NdLmV2YWx1YXRlKHQpKSkgcmV0dXJuIDA7XG4gICAgICAgICAgdmFyIGwgPSBOdW1iZXIobyk7XG4gICAgICAgICAgaWYgKCFpc05hTihsKSkgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGNlKFwiQ291bGQgbm90IGNvbnZlcnQgXCIgKyBKU09OLnN0cmluZ2lmeShvKSArIFwiIHRvIG51bWJlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJmb3JtYXR0ZWRcIiA9PT0gdGhpcy50eXBlLmtpbmQgPyBpZS5mcm9tU3RyaW5nKGxlKHRoaXMuYXJnc1swXS5ldmFsdWF0ZSh0KSkpIDogXCJyZXNvbHZlZEltYWdlXCIgPT09IHRoaXMudHlwZS5raW5kID8gYWUuZnJvbVN0cmluZyhsZSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUodCkpKSA6IGxlKHRoaXMuYXJnc1swXS5ldmFsdWF0ZSh0KSk7XG4gICAgfSwgdmUucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaCh0KTtcbiAgICB9LCB2ZS5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSwgdmUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChcImZvcm1hdHRlZFwiID09PSB0aGlzLnR5cGUua2luZCkgcmV0dXJuIG5ldyB5ZShbe1xuICAgICAgICBjb250ZW50OiB0aGlzLmFyZ3NbMF0sXG4gICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICBmb250OiBudWxsLFxuICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgIH1dKS5zZXJpYWxpemUoKTtcbiAgICAgIGlmIChcInJlc29sdmVkSW1hZ2VcIiA9PT0gdGhpcy50eXBlLmtpbmQpIHJldHVybiBuZXcgZGUodGhpcy5hcmdzWzBdKS5zZXJpYWxpemUoKTtcbiAgICAgIHZhciB0ID0gW1widG8tXCIgKyB0aGlzLnR5cGUua2luZF07XG4gICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdC5wdXNoKGUuc2VyaWFsaXplKCkpO1xuICAgICAgfSksIHQ7XG4gICAgfTtcbiAgICB2YXIgZ2UgPSBbXCJVbmtub3duXCIsIFwiUG9pbnRcIiwgXCJMaW5lU3RyaW5nXCIsIFwiUG9seWdvblwiXSxcbiAgICAgIHhlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdsb2JhbHMgPSBudWxsLCB0aGlzLmZlYXR1cmUgPSBudWxsLCB0aGlzLmZlYXR1cmVTdGF0ZSA9IG51bGwsIHRoaXMuZm9ybWF0dGVkU2VjdGlvbiA9IG51bGwsIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9LCB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IG51bGwsIHRoaXMuY2Fub25pY2FsID0gbnVsbDtcbiAgICAgIH07XG4gICAgeGUucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiBcImlkXCIgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmlkIDogbnVsbDtcbiAgICB9LCB4ZS5wcm90b3R5cGUuZ2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSA/IFwibnVtYmVyXCIgPT0gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID8gZ2VbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsO1xuICAgIH0sIHhlLnByb3RvdHlwZS5nZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgXCJnZW9tZXRyeVwiIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5nZW9tZXRyeSA6IG51bGw7XG4gICAgfSwgeGUucHJvdG90eXBlLmNhbm9uaWNhbElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsO1xuICAgIH0sIHhlLnByb3RvdHlwZS5wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICB9LCB4ZS5wcm90b3R5cGUucGFyc2VDb2xvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX3BhcnNlQ29sb3JDYWNoZVt0XTtcbiAgICAgIHJldHVybiBlIHx8IChlID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW3RdID0gZWUucGFyc2UodCkpLCBlO1xuICAgIH07XG4gICAgdmFyIGJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMubmFtZSA9IHQsIHRoaXMudHlwZSA9IGUsIHRoaXMuX2V2YWx1YXRlID0gciwgdGhpcy5hcmdzID0gbjtcbiAgICB9O1xuICAgIGJlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGUodCwgdGhpcy5hcmdzKTtcbiAgICB9LCBiZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKHQpO1xuICAgIH0sIGJlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGJlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3RoaXMubmFtZV0uY29uY2F0KHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuc2VyaWFsaXplKCk7XG4gICAgICB9KSk7XG4gICAgfSwgYmUucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIsXG4gICAgICAgIG4gPSB0WzBdLFxuICAgICAgICBpID0gYmUuZGVmaW5pdGlvbnNbbl07XG4gICAgICBpZiAoIWkpIHJldHVybiBlLmVycm9yKCdVbmtub3duIGV4cHJlc3Npb24gXCInICsgbiArICdcIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKTtcbiAgICAgIGZvciAodmFyIGEgPSBBcnJheS5pc0FycmF5KGkpID8gaVswXSA6IGkudHlwZSwgbyA9IEFycmF5LmlzQXJyYXkoaSkgPyBbW2lbMV0sIGlbMl1dXSA6IGkub3ZlcmxvYWRzLCBzID0gby5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMF07XG4gICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoID09PSB0Lmxlbmd0aCAtIDE7XG4gICAgICAgIH0pLCB1ID0gbnVsbCwgbCA9IDAsIHAgPSBzOyBsIDwgcC5sZW5ndGg7IGwgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHBbbF0sXG4gICAgICAgICAgaCA9IGNbMF0sXG4gICAgICAgICAgZiA9IGNbMV07XG4gICAgICAgIHUgPSBuZXcgcWUoZS5yZWdpc3RyeSwgZS5wYXRoLCBudWxsLCBlLnNjb3BlKTtcbiAgICAgICAgZm9yICh2YXIgeSA9IFtdLCBkID0gITEsIG0gPSAxOyBtIDwgdC5sZW5ndGg7IG0rKykge1xuICAgICAgICAgIHZhciB2ID0gdFttXSxcbiAgICAgICAgICAgIGcgPSBBcnJheS5pc0FycmF5KGgpID8gaFttIC0gMV0gOiBoLnR5cGUsXG4gICAgICAgICAgICB4ID0gdS5wYXJzZSh2LCAxICsgeS5sZW5ndGgsIGcpO1xuICAgICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgZCA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHkucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWQpIGlmIChBcnJheS5pc0FycmF5KGgpICYmIGgubGVuZ3RoICE9PSB5Lmxlbmd0aCkgdS5lcnJvcihcIkV4cGVjdGVkIFwiICsgaC5sZW5ndGggKyBcIiBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIiArIHkubGVuZ3RoICsgXCIgaW5zdGVhZC5cIik7ZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCB5Lmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IEFycmF5LmlzQXJyYXkoaCkgPyBoW2JdIDogaC50eXBlLFxuICAgICAgICAgICAgICBfID0geVtiXTtcbiAgICAgICAgICAgIHUuY29uY2F0KGIgKyAxKS5jaGVja1N1YnR5cGUodywgXy50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDAgPT09IHUuZXJyb3JzLmxlbmd0aCkgcmV0dXJuIG5ldyBiZShuLCBhLCBmLCB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKDEgPT09IHMubGVuZ3RoKSAociA9IGUuZXJyb3JzKS5wdXNoLmFwcGx5KHIsIHUuZXJyb3JzKTtlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgQSA9IChzLmxlbmd0aCA/IHMgOiBvKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBlO1xuICAgICAgICAgICAgcmV0dXJuIGUgPSB0WzBdLCBBcnJheS5pc0FycmF5KGUpID8gXCIoXCIgKyBlLm1hcChIdCkuam9pbihcIiwgXCIpICsgXCIpXCIgOiBcIihcIiArIEh0KGUudHlwZSkgKyBcIi4uLilcIjtcbiAgICAgICAgICB9KS5qb2luKFwiIHwgXCIpLCBTID0gW10sIGsgPSAxOyBrIDwgdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHZhciBJID0gZS5wYXJzZSh0W2tdLCAxICsgUy5sZW5ndGgpO1xuICAgICAgICAgIGlmICghSSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgUy5wdXNoKEh0KEkudHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGUuZXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSBcIiArIEEgKyBcIiwgYnV0IGZvdW5kIChcIiArIFMuam9pbihcIiwgXCIpICsgXCIpIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgYmUucmVnaXN0ZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciBpbiBiZS5kZWZpbml0aW9ucyA9IGUsIGUpIHRbcl0gPSBiZTtcbiAgICB9O1xuICAgIHZhciB3ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnR5cGUgPSBHdCwgdGhpcy5sb2NhbGUgPSByLCB0aGlzLmNhc2VTZW5zaXRpdmUgPSB0LCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSA9IGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZSh0LCBlKSB7XG4gICAgICB0WzBdID0gTWF0aC5taW4odFswXSwgZVswXSksIHRbMV0gPSBNYXRoLm1pbih0WzFdLCBlWzFdKSwgdFsyXSA9IE1hdGgubWF4KHRbMl0sIGVbMF0pLCB0WzNdID0gTWF0aC5tYXgodFszXSwgZVsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFlKHQsIGUpIHtcbiAgICAgIHJldHVybiAhKHRbMF0gPD0gZVswXSB8fCB0WzJdID49IGVbMl0gfHwgdFsxXSA8PSBlWzFdIHx8IHRbM10gPj0gZVszXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNlKHQsIGUpIHtcbiAgICAgIHZhciByID0gKDE4MCArIHRbMF0pIC8gMzYwLFxuICAgICAgICBuID0gKDE4MCAtIDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIHRbMV0gKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwLFxuICAgICAgICBpID0gTWF0aC5wb3coMiwgZS56KTtcbiAgICAgIHJldHVybiBbTWF0aC5yb3VuZChyICogaSAqIDgxOTIpLCBNYXRoLnJvdW5kKG4gKiBpICogODE5MildO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrZSh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gZVsxXSA+IHRbMV0gIT0gclsxXSA+IHRbMV0gJiYgdFswXSA8IChyWzBdIC0gZVswXSkgKiAodFsxXSAtIGVbMV0pIC8gKHJbMV0gLSBlWzFdKSArIGVbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEllKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwgPSAhMSwgcCA9IDAsIGMgPSBlLmxlbmd0aDsgcCA8IGM7IHArKykgZm9yICh2YXIgaCA9IGVbcF0sIGYgPSAwLCB5ID0gaC5sZW5ndGg7IGYgPCB5IC0gMTsgZisrKSB7XG4gICAgICAgIGlmICgoYSA9IChyID0gdClbMF0gLSAobiA9IGhbZl0pWzBdKSAqICh1ID0gclsxXSAtIChpID0gaFtmICsgMV0pWzFdKSAtIChzID0gclswXSAtIGlbMF0pICogKG8gPSByWzFdIC0gblsxXSkgPT0gMCAmJiBhICogcyA8PSAwICYmIG8gKiB1IDw9IDApIHJldHVybiAhMTtcbiAgICAgICAga2UodCwgaFtmXSwgaFtmICsgMV0pICYmIChsID0gIWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHplKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykgaWYgKEllKHQsIGVbcl0pKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENlKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gblswXSAtIHJbMF0sXG4gICAgICAgIGEgPSBuWzFdIC0gclsxXSxcbiAgICAgICAgbyA9ICh0WzBdIC0gclswXSkgKiBhIC0gaSAqICh0WzFdIC0gclsxXSksXG4gICAgICAgIHMgPSAoZVswXSAtIHJbMF0pICogYSAtIGkgKiAoZVsxXSAtIHJbMV0pO1xuICAgICAgcmV0dXJuIG8gPiAwICYmIHMgPCAwIHx8IG8gPCAwICYmIHMgPiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFZSh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHI7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSBmb3IgKHZhciBhID0gaVtuXSwgbyA9IDA7IG8gPCBhLmxlbmd0aCAtIDE7ICsrbykgaWYgKDAgIT0gKGMgPSBbKHAgPSBhW28gKyAxXSlbMF0gLSAobCA9IGFbb10pWzBdLCBwWzFdIC0gbFsxXV0pWzBdICogKGggPSBbKHUgPSBlKVswXSAtIChzID0gdClbMF0sIHVbMV0gLSBzWzFdXSlbMV0gLSBjWzFdICogaFswXSAmJiBDZShzLCB1LCBsLCBwKSAmJiBDZShsLCBwLCBzLCB1KSkgcmV0dXJuICEwO1xuICAgICAgdmFyIHMsIHUsIGwsIHAsIGMsIGg7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBlKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgaWYgKCFJZSh0W3JdLCBlKSkgcmV0dXJuICExO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aCAtIDE7ICsrbikgaWYgKEVlKHRbbl0sIHRbbiArIDFdLCBlKSkgcmV0dXJuICExO1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNZSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIGlmIChQZSh0LCBlW3JdKSkgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCZSh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBhID0gW10sIG8gPSAwOyBvIDwgdFtpXS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgIHZhciBzID0gU2UodFtpXVtvXSwgcik7XG4gICAgICAgICAgX2UoZSwgcyksIGEucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICBuLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVGUodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBCZSh0W2ldLCBlLCByKTtcbiAgICAgICAgbi5wdXNoKGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZlKHQsIGUsIHIsIG4pIHtcbiAgICAgIGlmICh0WzBdIDwgclswXSB8fCB0WzBdID4gclsyXSkge1xuICAgICAgICB2YXIgaSA9IC41ICogbixcbiAgICAgICAgICBhID0gdFswXSAtIHJbMF0gPiBpID8gLW4gOiByWzBdIC0gdFswXSA+IGkgPyBuIDogMDtcbiAgICAgICAgMCA9PT0gYSAmJiAoYSA9IHRbMF0gLSByWzJdID4gaSA/IC1uIDogclsyXSAtIHRbMF0gPiBpID8gbiA6IDApLCB0WzBdICs9IGE7XG4gICAgICB9XG4gICAgICBfZShlLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmUodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDgxOTIgKiBNYXRoLnBvdygyLCBuLnopLCBhID0gWzgxOTIgKiBuLngsIDgxOTIgKiBuLnldLCBvID0gW10sIHMgPSAwLCB1ID0gdDsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIGZvciAodmFyIGwgPSAwLCBwID0gdVtzXTsgbCA8IHAubGVuZ3RoOyBsICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBwW2xdLFxuICAgICAgICAgIGggPSBbYy54ICsgYVswXSwgYy55ICsgYVsxXV07XG4gICAgICAgIFZlKGgsIGUsIHIsIGkpLCBvLnB1c2goaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZnVuY3Rpb24gRGUodCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSwgYSA9IDgxOTIgKiBNYXRoLnBvdygyLCBuLnopLCBvID0gWzgxOTIgKiBuLngsIDgxOTIgKiBuLnldLCBzID0gW10sIHUgPSAwLCBsID0gdDsgdSA8IGwubGVuZ3RoOyB1ICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IFtdLCBjID0gMCwgaCA9IGxbdV07IGMgPCBoLmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgdmFyIGYgPSBoW2NdLFxuICAgICAgICAgICAgeSA9IFtmLnggKyBvWzBdLCBmLnkgKyBvWzFdXTtcbiAgICAgICAgICBfZShlLCB5KSwgcC5wdXNoKHkpO1xuICAgICAgICB9XG4gICAgICAgIHMucHVzaChwKTtcbiAgICAgIH1cbiAgICAgIGlmIChlWzJdIC0gZVswXSA8PSBhIC8gMikge1xuICAgICAgICAoaSA9IGUpWzBdID0gaVsxXSA9IDEgLyAwLCBpWzJdID0gaVszXSA9IC0xIC8gMDtcbiAgICAgICAgZm9yICh2YXIgZCA9IDAsIG0gPSBzOyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkgZm9yICh2YXIgdiA9IDAsIGcgPSBtW2RdOyB2IDwgZy5sZW5ndGg7IHYgKz0gMSkgVmUoZ1t2XSwgZSwgciwgYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgd2UucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDIgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgciA9IHRbMV07XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgciB8fCBBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gZS5lcnJvcihcIkNvbGxhdG9yIG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgdmFyIG4gPSBlLnBhcnNlKHZvaWQgMCAhPT0gcltcImNhc2Utc2Vuc2l0aXZlXCJdICYmIHJbXCJjYXNlLXNlbnNpdGl2ZVwiXSwgMSwganQpO1xuICAgICAgaWYgKCFuKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBpID0gZS5wYXJzZSh2b2lkIDAgIT09IHJbXCJkaWFjcml0aWMtc2Vuc2l0aXZlXCJdICYmIHJbXCJkaWFjcml0aWMtc2Vuc2l0aXZlXCJdLCAxLCBqdCk7XG4gICAgICBpZiAoIWkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGEgPSBudWxsO1xuICAgICAgcmV0dXJuIHIubG9jYWxlICYmICEoYSA9IGUucGFyc2Uoci5sb2NhbGUsIDEsIFV0KSkgPyBudWxsIDogbmV3IHdlKG4sIGksIGEpO1xuICAgIH0sIHdlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IHJlKHRoaXMuY2FzZVNlbnNpdGl2ZS5ldmFsdWF0ZSh0KSwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUuZXZhbHVhdGUodCksIHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUodCkgOiBudWxsKTtcbiAgICB9LCB3ZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5jYXNlU2Vuc2l0aXZlKSwgdCh0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSksIHRoaXMubG9jYWxlICYmIHQodGhpcy5sb2NhbGUpO1xuICAgIH0sIHdlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIHdlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgcmV0dXJuIHRbXCJjYXNlLXNlbnNpdGl2ZVwiXSA9IHRoaXMuY2FzZVNlbnNpdGl2ZS5zZXJpYWxpemUoKSwgdFtcImRpYWNyaXRpYy1zZW5zaXRpdmVcIl0gPSB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5zZXJpYWxpemUoKSwgdGhpcy5sb2NhbGUgJiYgKHQubG9jYWxlID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCkpLCBbXCJjb2xsYXRvclwiLCB0XTtcbiAgICB9O1xuICAgIHZhciBMZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSBqdCwgdGhpcy5nZW9qc29uID0gdCwgdGhpcy5nZW9tZXRyaWVzID0gZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIFJlKHQpIHtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgYmUpIHtcbiAgICAgICAgaWYgKFwiZ2V0XCIgPT09IHQubmFtZSAmJiAxID09PSB0LmFyZ3MubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImZlYXR1cmUtc3RhdGVcIiA9PT0gdC5uYW1lKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChcImhhc1wiID09PSB0Lm5hbWUgJiYgMSA9PT0gdC5hcmdzLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICBpZiAoXCJwcm9wZXJ0aWVzXCIgPT09IHQubmFtZSB8fCBcImdlb21ldHJ5LXR5cGVcIiA9PT0gdC5uYW1lIHx8IFwiaWRcIiA9PT0gdC5uYW1lKSByZXR1cm4gITE7XG4gICAgICAgIGlmICgvXmZpbHRlci0vLnRlc3QodC5uYW1lKSkgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBMZSkgcmV0dXJuICExO1xuICAgICAgdmFyIGUgPSAhMDtcbiAgICAgIHJldHVybiB0LmVhY2hDaGlsZChmdW5jdGlvbiAodCkge1xuICAgICAgICBlICYmICFSZSh0KSAmJiAoZSA9ICExKTtcbiAgICAgIH0pLCBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPZSh0KSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIGJlICYmIFwiZmVhdHVyZS1zdGF0ZVwiID09PSB0Lm5hbWUpIHJldHVybiAhMTtcbiAgICAgIHZhciBlID0gITA7XG4gICAgICByZXR1cm4gdC5lYWNoQ2hpbGQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZSAmJiAhT2UodCkgJiYgKGUgPSAhMSk7XG4gICAgICB9KSwgZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVWUodCwgZSkge1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBiZSAmJiBlLmluZGV4T2YodC5uYW1lKSA+PSAwKSByZXR1cm4gITE7XG4gICAgICB2YXIgciA9ICEwO1xuICAgICAgcmV0dXJuIHQuZWFjaENoaWxkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHIgJiYgIVVlKHQsIGUpICYmIChyID0gITEpO1xuICAgICAgfSksIHI7XG4gICAgfVxuICAgIExlLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCInd2l0aGluJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgaWYgKHNlKHRbMV0pKSB7XG4gICAgICAgIHZhciByID0gdFsxXTtcbiAgICAgICAgaWYgKFwiRmVhdHVyZUNvbGxlY3Rpb25cIiA9PT0gci50eXBlKSBmb3IgKHZhciBuID0gMDsgbiA8IHIuZmVhdHVyZXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICB2YXIgaSA9IHIuZmVhdHVyZXNbbl0uZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgICBpZiAoXCJQb2x5Z29uXCIgPT09IGkgfHwgXCJNdWx0aVBvbHlnb25cIiA9PT0gaSkgcmV0dXJuIG5ldyBMZShyLCByLmZlYXR1cmVzW25dLmdlb21ldHJ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChcIkZlYXR1cmVcIiA9PT0gci50eXBlKSB7XG4gICAgICAgICAgdmFyIGEgPSByLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgaWYgKFwiUG9seWdvblwiID09PSBhIHx8IFwiTXVsdGlQb2x5Z29uXCIgPT09IGEpIHJldHVybiBuZXcgTGUociwgci5nZW9tZXRyeSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJQb2x5Z29uXCIgPT09IHIudHlwZSB8fCBcIk11bHRpUG9seWdvblwiID09PSByLnR5cGUpIHJldHVybiBuZXcgTGUociwgcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5lcnJvcihcIid3aXRoaW4nIGV4cHJlc3Npb24gcmVxdWlyZXMgdmFsaWQgZ2VvanNvbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2x5Z29uIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH0sIExlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAobnVsbCAhPSB0Lmdlb21ldHJ5KCkgJiYgbnVsbCAhPSB0LmNhbm9uaWNhbElEKCkpIHtcbiAgICAgICAgaWYgKFwiUG9pbnRcIiA9PT0gdC5nZW9tZXRyeVR5cGUoKSkgcmV0dXJuIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sXG4gICAgICAgICAgICBuID0gWzEgLyAwLCAxIC8gMCwgLTEgLyAwLCAtMSAvIDBdLFxuICAgICAgICAgICAgaSA9IHQuY2Fub25pY2FsSUQoKTtcbiAgICAgICAgICBpZiAoXCJQb2x5Z29uXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdmFyIGEgPSBCZShlLmNvb3JkaW5hdGVzLCBuLCBpKSxcbiAgICAgICAgICAgICAgbyA9IEZlKHQuZ2VvbWV0cnkoKSwgciwgbiwgaSk7XG4gICAgICAgICAgICBpZiAoIUFlKHIsIG4pKSByZXR1cm4gITE7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgdSA9IG87IHMgPCB1Lmxlbmd0aDsgcyArPSAxKSBpZiAoIUllKHVbc10sIGEpKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcIk11bHRpUG9seWdvblwiID09PSBlLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciBsID0gVGUoZS5jb29yZGluYXRlcywgbiwgaSksXG4gICAgICAgICAgICAgIHAgPSBGZSh0Lmdlb21ldHJ5KCksIHIsIG4sIGkpO1xuICAgICAgICAgICAgaWYgKCFBZShyLCBuKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGggPSBwOyBjIDwgaC5sZW5ndGg7IGMgKz0gMSkgaWYgKCF6ZShoW2NdLCBsKSkgcmV0dXJuICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0odCwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgICAgaWYgKFwiTGluZVN0cmluZ1wiID09PSB0Lmdlb21ldHJ5VHlwZSgpKSByZXR1cm4gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSxcbiAgICAgICAgICAgIG4gPSBbMSAvIDAsIDEgLyAwLCAtMSAvIDAsIC0xIC8gMF0sXG4gICAgICAgICAgICBpID0gdC5jYW5vbmljYWxJRCgpO1xuICAgICAgICAgIGlmIChcIlBvbHlnb25cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IEJlKGUuY29vcmRpbmF0ZXMsIG4sIGkpLFxuICAgICAgICAgICAgICBvID0gRGUodC5nZW9tZXRyeSgpLCByLCBuLCBpKTtcbiAgICAgICAgICAgIGlmICghQWUociwgbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwLCB1ID0gbzsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIGlmICghUGUodVtzXSwgYSkpIHJldHVybiAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IGUudHlwZSkge1xuICAgICAgICAgICAgdmFyIGwgPSBUZShlLmNvb3JkaW5hdGVzLCBuLCBpKSxcbiAgICAgICAgICAgICAgcCA9IERlKHQuZ2VvbWV0cnkoKSwgciwgbiwgaSk7XG4gICAgICAgICAgICBpZiAoIUFlKHIsIG4pKSByZXR1cm4gITE7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgaCA9IHA7IGMgPCBoLmxlbmd0aDsgYyArPSAxKSBpZiAoIU1lKGhbY10sIGwpKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSh0LCB0aGlzLmdlb21ldHJpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIExlLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAoKSB7fSwgTGUucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgTGUucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXCJ3aXRoaW5cIiwgdGhpcy5nZW9qc29uXTtcbiAgICB9O1xuICAgIHZhciBqZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMubmFtZSA9IHQsIHRoaXMuYm91bmRFeHByZXNzaW9uID0gZTtcbiAgICB9O1xuICAgIGplLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiB0WzFdKSByZXR1cm4gZS5lcnJvcihcIid2YXInIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIgPSB0WzFdO1xuICAgICAgcmV0dXJuIGUuc2NvcGUuaGFzKHIpID8gbmV3IGplKHIsIGUuc2NvcGUuZ2V0KHIpKSA6IGUuZXJyb3IoJ1Vua25vd24gdmFyaWFibGUgXCInICsgciArICdcIi4gTWFrZSBzdXJlIFwiJyArIHIgKyAnXCIgaGFzIGJlZW4gYm91bmQgaW4gYW4gZW5jbG9zaW5nIFwibGV0XCIgZXhwcmVzc2lvbiBiZWZvcmUgdXNpbmcgaXQuJywgMSk7XG4gICAgfSwgamUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvdW5kRXhwcmVzc2lvbi5ldmFsdWF0ZSh0KTtcbiAgICB9LCBqZS5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKCkge30sIGplLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGplLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1widmFyXCIsIHRoaXMubmFtZV07XG4gICAgfTtcbiAgICB2YXIgcWUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gW10pLCB2b2lkIDAgPT09IG4gJiYgKG4gPSBuZXcgTHQoKSksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IFtdKSwgdGhpcy5yZWdpc3RyeSA9IHQsIHRoaXMucGF0aCA9IGUsIHRoaXMua2V5ID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgdCArIFwiXVwiO1xuICAgICAgfSkuam9pbihcIlwiKSwgdGhpcy5zY29wZSA9IG4sIHRoaXMuZXJyb3JzID0gaSwgdGhpcy5leHBlY3RlZFR5cGUgPSByO1xuICAgIH07XG4gICAgZnVuY3Rpb24gTmUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciwgbiA9IHQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBuLCBvID0gMDsgaSA8PSBhOykgaWYgKChyID0gdFtvID0gTWF0aC5mbG9vcigoaSArIGEpIC8gMildKSA8PSBlKSB7XG4gICAgICAgIGlmIChvID09PSBuIHx8IGUgPCB0W28gKyAxXSkgcmV0dXJuIG87XG4gICAgICAgIGkgPSBvICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHIgPiBlKSkgdGhyb3cgbmV3IGNlKFwiSW5wdXQgaXMgbm90IGEgbnVtYmVyLlwiKTtcbiAgICAgICAgYSA9IG8gLSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHFlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBpICYmIChpID0ge30pLCBlID8gdGhpcy5jb25jYXQoZSwgciwgbikuX3BhcnNlKHQsIGkpIDogdGhpcy5fcGFyc2UodCwgaSk7XG4gICAgfSwgcWUucHJvdG90eXBlLl9wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmdW5jdGlvbiByKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXNzZXJ0XCIgPT09IHIgPyBuZXcgZmUoZSwgW3RdKSA6IFwiY29lcmNlXCIgPT09IHIgPyBuZXcgdmUoZSwgW3RdKSA6IHQ7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gdCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmIFwiYm9vbGVhblwiICE9IHR5cGVvZiB0ICYmIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQgfHwgKHQgPSBbXCJsaXRlcmFsXCIsIHRdKSwgQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICBpZiAoMCA9PT0gdC5sZW5ndGgpIHJldHVybiB0aGlzLmVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcImxpdGVyYWxcIiwgW11dLicpO1xuICAgICAgICB2YXIgbiA9IHRbMF07XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBuKSByZXR1cm4gdGhpcy5lcnJvcihcIkV4cHJlc3Npb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZm91bmQgXCIgKyB0eXBlb2YgbiArICcgaW5zdGVhZC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXCJsaXRlcmFsXCIsIFsuLi5dXS4nLCAwKSwgbnVsbDtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnJlZ2lzdHJ5W25dO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHZhciBhID0gaS5wYXJzZSh0LCB0aGlzKTtcbiAgICAgICAgICBpZiAoIWEpIHJldHVybiBudWxsO1xuICAgICAgICAgIGlmICh0aGlzLmV4cGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmV4cGVjdGVkVHlwZSxcbiAgICAgICAgICAgICAgcyA9IGEudHlwZTtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9PSBvLmtpbmQgJiYgXCJudW1iZXJcIiAhPT0gby5raW5kICYmIFwiYm9vbGVhblwiICE9PSBvLmtpbmQgJiYgXCJvYmplY3RcIiAhPT0gby5raW5kICYmIFwiYXJyYXlcIiAhPT0gby5raW5kIHx8IFwidmFsdWVcIiAhPT0gcy5raW5kKSB7XG4gICAgICAgICAgICAgIGlmIChcImNvbG9yXCIgIT09IG8ua2luZCAmJiBcImZvcm1hdHRlZFwiICE9PSBvLmtpbmQgJiYgXCJyZXNvbHZlZEltYWdlXCIgIT09IG8ua2luZCB8fCBcInZhbHVlXCIgIT09IHMua2luZCAmJiBcInN0cmluZ1wiICE9PSBzLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1N1YnR5cGUobywgcykpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgYSA9IHIoYSwgbywgZS50eXBlQW5ub3RhdGlvbiB8fCBcImNvZXJjZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBhID0gcihhLCBvLCBlLnR5cGVBbm5vdGF0aW9uIHx8IFwiYXNzZXJ0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhIGluc3RhbmNlb2YgcGUpICYmIFwicmVzb2x2ZWRJbWFnZVwiICE9PSBhLnR5cGUua2luZCAmJiBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgamUpIHJldHVybiB0KGUuYm91bmRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYmUgJiYgXCJlcnJvclwiID09PSBlLm5hbWUpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2Ygd2UpIHJldHVybiAhMTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTGUpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHZhciByID0gZSBpbnN0YW5jZW9mIHZlIHx8IGUgaW5zdGFuY2VvZiBmZSxcbiAgICAgICAgICAgICAgbiA9ICEwO1xuICAgICAgICAgICAgcmV0dXJuIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG4gPSByID8gbiAmJiB0KGUpIDogbiAmJiBlIGluc3RhbmNlb2YgcGU7XG4gICAgICAgICAgICB9KSwgISFuICYmIFJlKGUpICYmIFVlKGUsIFtcInpvb21cIiwgXCJoZWF0bWFwLWRlbnNpdHlcIiwgXCJsaW5lLXByb2dyZXNzXCIsIFwiYWNjdW11bGF0ZWRcIiwgXCJpcy1zdXBwb3J0ZWQtc2NyaXB0XCJdKTtcbiAgICAgICAgICB9KGEpKSB7XG4gICAgICAgICAgICB2YXIgdSA9IG5ldyB4ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYSA9IG5ldyBwZShhLnR5cGUsIGEuZXZhbHVhdGUodSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcih0Lm1lc3NhZ2UpLCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW5rbm93biBleHByZXNzaW9uIFwiJyArIG4gKyAnXCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1wibGl0ZXJhbFwiLCBbLi4uXV0uJywgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcih2b2lkIDAgPT09IHQgPyBcIid1bmRlZmluZWQnIHZhbHVlIGludmFsaWQuIFVzZSBudWxsIGluc3RlYWQuXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiB0ID8gJ0JhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1wibGl0ZXJhbFwiLCB7Li4ufV0gaW5zdGVhZC4nIDogXCJFeHBlY3RlZCBhbiBhcnJheSwgYnV0IGZvdW5kIFwiICsgdHlwZW9mIHQgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICB9LCBxZS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgdCA/IHRoaXMucGF0aC5jb25jYXQodCkgOiB0aGlzLnBhdGgsXG4gICAgICAgIGkgPSByID8gdGhpcy5zY29wZS5jb25jYXQocikgOiB0aGlzLnNjb3BlO1xuICAgICAgcmV0dXJuIG5ldyBxZSh0aGlzLnJlZ2lzdHJ5LCBuLCBlIHx8IG51bGwsIGksIHRoaXMuZXJyb3JzKTtcbiAgICB9LCBxZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IFtdLCByID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IHItLSA+IDA7KSBlW3JdID0gYXJndW1lbnRzW3IgKyAxXTtcbiAgICAgIHZhciBuID0gXCJcIiArIHRoaXMua2V5ICsgZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgdCArIFwiXVwiO1xuICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IER0KG4sIHQpKTtcbiAgICB9LCBxZS5wcm90b3R5cGUuY2hlY2tTdWJ0eXBlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gJHQodCwgZSk7XG4gICAgICByZXR1cm4gciAmJiB0aGlzLmVycm9yKHIpLCByO1xuICAgIH07XG4gICAgdmFyIEtlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5wdXQgPSBlLCB0aGlzLmxhYmVscyA9IFtdLCB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gcjsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dLFxuICAgICAgICAgIG8gPSBhWzFdO1xuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGFbMF0pLCB0aGlzLm91dHB1dHMucHVzaChvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIEdlKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0ICogKDEgLSByKSArIGUgKiByO1xuICAgIH1cbiAgICBLZS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggLSAxIDwgNCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmICgodC5sZW5ndGggLSAxKSAlIDIgIT0gMCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIE90KTtcbiAgICAgIGlmICghcikgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbiA9IFtdLFxuICAgICAgICBpID0gbnVsbDtcbiAgICAgIGUuZXhwZWN0ZWRUeXBlICYmIFwidmFsdWVcIiAhPT0gZS5leHBlY3RlZFR5cGUua2luZCAmJiAoaSA9IGUuZXhwZWN0ZWRUeXBlKTtcbiAgICAgIGZvciAodmFyIGEgPSAxOyBhIDwgdC5sZW5ndGg7IGEgKz0gMikge1xuICAgICAgICB2YXIgbyA9IDEgPT09IGEgPyAtMSAvIDAgOiB0W2FdLFxuICAgICAgICAgIHMgPSB0W2EgKyAxXSxcbiAgICAgICAgICB1ID0gYSxcbiAgICAgICAgICBsID0gYSArIDE7XG4gICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBvKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCB1KTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoICYmIG5bbi5sZW5ndGggLSAxXVswXSA+PSBvKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCB1KTtcbiAgICAgICAgdmFyIHAgPSBlLnBhcnNlKHMsIGwsIGkpO1xuICAgICAgICBpZiAoIXApIHJldHVybiBudWxsO1xuICAgICAgICBpID0gaSB8fCBwLnR5cGUsIG4ucHVzaChbbywgcF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBLZShpLCByLCBuKTtcbiAgICB9LCBLZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgciA9IHRoaXMub3V0cHV0cztcbiAgICAgIGlmICgxID09PSBlLmxlbmd0aCkgcmV0dXJuIHJbMF0uZXZhbHVhdGUodCk7XG4gICAgICB2YXIgbiA9IHRoaXMuaW5wdXQuZXZhbHVhdGUodCk7XG4gICAgICBpZiAobiA8PSBlWzBdKSByZXR1cm4gclswXS5ldmFsdWF0ZSh0KTtcbiAgICAgIHZhciBpID0gZS5sZW5ndGg7XG4gICAgICByZXR1cm4gbiA+PSBlW2kgLSAxXSA/IHJbaSAtIDFdLmV2YWx1YXRlKHQpIDogcltOZShlLCBuKV0uZXZhbHVhdGUodCk7XG4gICAgfSwgS2UucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMuaW5wdXQpO1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0aGlzLm91dHB1dHM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB0KHJbZV0pO1xuICAgIH0sIEtlLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9LCBLZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IFtcInN0ZXBcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV0sIGUgPSAwOyBlIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyBlKyspIGUgPiAwICYmIHQucHVzaCh0aGlzLmxhYmVsc1tlXSksIHQucHVzaCh0aGlzLm91dHB1dHNbZV0uc2VyaWFsaXplKCkpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICB2YXIgWmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBudW1iZXI6IEdlLFxuICAgICAgICBjb2xvcjogZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGVlKEdlKHQuciwgZS5yLCByKSwgR2UodC5nLCBlLmcsIHIpLCBHZSh0LmIsIGUuYiwgciksIEdlKHQuYSwgZS5hLCByKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFycmF5OiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiB0Lm1hcChmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgcmV0dXJuIEdlKHQsIGVbbl0sIHIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFhlID0gNiAvIDI5ICogMyAqICg2IC8gMjkpLFxuICAgICAgSmUgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgSGUgPSAxODAgLyBNYXRoLlBJO1xuICAgIGZ1bmN0aW9uIFllKHQpIHtcbiAgICAgIHJldHVybiB0ID4gLjAwODg1NjQ1MTY3OTAzNTYzMSA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyBYZSArIDQgLyAyOTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJGUodCkge1xuICAgICAgcmV0dXJuIHQgPiA2IC8gMjkgPyB0ICogdCAqIHQgOiBYZSAqICh0IC0gNCAvIDI5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV2UodCkge1xuICAgICAgcmV0dXJuIDI1NSAqICh0IDw9IC4wMDMxMzA4ID8gMTIuOTIgKiB0IDogMS4wNTUgKiBNYXRoLnBvdyh0LCAxIC8gMi40KSAtIC4wNTUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRZSh0KSB7XG4gICAgICByZXR1cm4gKHQgLz0gMjU1KSA8PSAuMDQwNDUgPyB0IC8gMTIuOTIgOiBNYXRoLnBvdygodCArIC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyKHQpIHtcbiAgICAgIHZhciBlID0gUWUodC5yKSxcbiAgICAgICAgciA9IFFlKHQuZyksXG4gICAgICAgIG4gPSBRZSh0LmIpLFxuICAgICAgICBpID0gWWUoKC40MTI0NTY0ICogZSArIC4zNTc1NzYxICogciArIC4xODA0Mzc1ICogbikgLyAuOTUwNDcpLFxuICAgICAgICBhID0gWWUoKC4yMTI2NzI5ICogZSArIC43MTUxNTIyICogciArIC4wNzIxNzUgKiBuKSAvIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbDogMTE2ICogYSAtIDE2LFxuICAgICAgICBhOiA1MDAgKiAoaSAtIGEpLFxuICAgICAgICBiOiAyMDAgKiAoYSAtIFllKCguMDE5MzMzOSAqIGUgKyAuMTE5MTkyICogciArIC45NTAzMDQxICogbikgLyAxLjA4ODgzKSksXG4gICAgICAgIGFscGhhOiB0LmFcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVyKHQpIHtcbiAgICAgIHZhciBlID0gKHQubCArIDE2KSAvIDExNixcbiAgICAgICAgciA9IGlzTmFOKHQuYSkgPyBlIDogZSArIHQuYSAvIDUwMCxcbiAgICAgICAgbiA9IGlzTmFOKHQuYikgPyBlIDogZSAtIHQuYiAvIDIwMDtcbiAgICAgIHJldHVybiBlID0gMSAqICRlKGUpLCByID0gLjk1MDQ3ICogJGUociksIG4gPSAxLjA4ODgzICogJGUobiksIG5ldyBlZShXZSgzLjI0MDQ1NDIgKiByIC0gMS41MzcxMzg1ICogZSAtIC40OTg1MzE0ICogbiksIFdlKC0uOTY5MjY2ICogciArIDEuODc2MDEwOCAqIGUgKyAuMDQxNTU2ICogbiksIFdlKC4wNTU2NDM0ICogciAtIC4yMDQwMjU5ICogZSArIDEuMDU3MjI1MiAqIG4pLCB0LmFscGhhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnIodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlIC0gdDtcbiAgICAgIHJldHVybiB0ICsgciAqIChuID4gMTgwIHx8IG4gPCAtMTgwID8gbiAtIDM2MCAqIE1hdGgucm91bmQobiAvIDM2MCkgOiBuKTtcbiAgICB9XG4gICAgdmFyIG5yID0ge1xuICAgICAgICBmb3J3YXJkOiB0cixcbiAgICAgICAgcmV2ZXJzZTogZXIsXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsOiBHZSh0LmwsIGUubCwgciksXG4gICAgICAgICAgICBhOiBHZSh0LmEsIGUuYSwgciksXG4gICAgICAgICAgICBiOiBHZSh0LmIsIGUuYiwgciksXG4gICAgICAgICAgICBhbHBoYTogR2UodC5hbHBoYSwgZS5hbHBoYSwgcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXIgPSB7XG4gICAgICAgIGZvcndhcmQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0cih0KSxcbiAgICAgICAgICAgIHIgPSBlLmwsXG4gICAgICAgICAgICBuID0gZS5hLFxuICAgICAgICAgICAgaSA9IGUuYixcbiAgICAgICAgICAgIGEgPSBNYXRoLmF0YW4yKGksIG4pICogSGU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGg6IGEgPCAwID8gYSArIDM2MCA6IGEsXG4gICAgICAgICAgICBjOiBNYXRoLnNxcnQobiAqIG4gKyBpICogaSksXG4gICAgICAgICAgICBsOiByLFxuICAgICAgICAgICAgYWxwaGE6IHQuYVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0LmggKiBKZSxcbiAgICAgICAgICAgIHIgPSB0LmM7XG4gICAgICAgICAgcmV0dXJuIGVyKHtcbiAgICAgICAgICAgIGw6IHQubCxcbiAgICAgICAgICAgIGE6IE1hdGguY29zKGUpICogcixcbiAgICAgICAgICAgIGI6IE1hdGguc2luKGUpICogcixcbiAgICAgICAgICAgIGFscGhhOiB0LmFscGhhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoOiBycih0LmgsIGUuaCwgciksXG4gICAgICAgICAgICBjOiBHZSh0LmMsIGUuYywgciksXG4gICAgICAgICAgICBsOiBHZSh0LmwsIGUubCwgciksXG4gICAgICAgICAgICBhbHBoYTogR2UodC5hbHBoYSwgZS5hbHBoYSwgcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXIgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBsYWI6IG5yLFxuICAgICAgICBoY2w6IGlyXG4gICAgICB9KSxcbiAgICAgIG9yID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5vcGVyYXRvciA9IGUsIHRoaXMuaW50ZXJwb2xhdGlvbiA9IHIsIHRoaXMuaW5wdXQgPSBuLCB0aGlzLmxhYmVscyA9IFtdLCB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYSA9IDAsIG8gPSBpOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgIHZhciBzID0gb1thXSxcbiAgICAgICAgICAgIHUgPSBzWzFdO1xuICAgICAgICAgIHRoaXMubGFiZWxzLnB1c2goc1swXSksIHRoaXMub3V0cHV0cy5wdXNoKHUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIHNyKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gbiAtIHIsXG4gICAgICAgIGEgPSB0IC0gcjtcbiAgICAgIHJldHVybiAwID09PSBpID8gMCA6IDEgPT09IGUgPyBhIC8gaSA6IChNYXRoLnBvdyhlLCBhKSAtIDEpIC8gKE1hdGgucG93KGUsIGkpIC0gMSk7XG4gICAgfVxuICAgIG9yLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodCwgZSwgbiwgaSkge1xuICAgICAgdmFyIGEgPSAwO1xuICAgICAgaWYgKFwiZXhwb25lbnRpYWxcIiA9PT0gdC5uYW1lKSBhID0gc3IoZSwgdC5iYXNlLCBuLCBpKTtlbHNlIGlmIChcImxpbmVhclwiID09PSB0Lm5hbWUpIGEgPSBzcihlLCAxLCBuLCBpKTtlbHNlIGlmIChcImN1YmljLWJlemllclwiID09PSB0Lm5hbWUpIHtcbiAgICAgICAgdmFyIG8gPSB0LmNvbnRyb2xQb2ludHM7XG4gICAgICAgIGEgPSBuZXcgcihvWzBdLCBvWzFdLCBvWzJdLCBvWzNdKS5zb2x2ZShzcihlLCAxLCBuLCBpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBvci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRbMF0sXG4gICAgICAgIG4gPSB0WzFdLFxuICAgICAgICBpID0gdFsyXSxcbiAgICAgICAgYSA9IHQuc2xpY2UoMyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobikgfHwgMCA9PT0gbi5sZW5ndGgpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYW4gaW50ZXJwb2xhdGlvbiB0eXBlIGV4cHJlc3Npb24uXCIsIDEpO1xuICAgICAgaWYgKFwibGluZWFyXCIgPT09IG5bMF0pIG4gPSB7XG4gICAgICAgIG5hbWU6IFwibGluZWFyXCJcbiAgICAgIH07ZWxzZSBpZiAoXCJleHBvbmVudGlhbFwiID09PSBuWzBdKSB7XG4gICAgICAgIHZhciBvID0gblsxXTtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIG8pIHJldHVybiBlLmVycm9yKFwiRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS5cIiwgMSwgMSk7XG4gICAgICAgIG4gPSB7XG4gICAgICAgICAgbmFtZTogXCJleHBvbmVudGlhbFwiLFxuICAgICAgICAgIGJhc2U6IG9cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcImN1YmljLWJlemllclwiICE9PSBuWzBdKSByZXR1cm4gZS5lcnJvcihcIlVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlIFwiICsgU3RyaW5nKG5bMF0pLCAxLCAwKTtcbiAgICAgICAgdmFyIHMgPSBuLnNsaWNlKDEpO1xuICAgICAgICBpZiAoNCAhPT0gcy5sZW5ndGggfHwgcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQgfHwgdCA8IDAgfHwgdCA+IDE7XG4gICAgICAgIH0pKSByZXR1cm4gZS5lcnJvcihcIkN1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLlwiLCAxKTtcbiAgICAgICAgbiA9IHtcbiAgICAgICAgICBuYW1lOiBcImN1YmljLWJlemllclwiLFxuICAgICAgICAgIGNvbnRyb2xQb2ludHM6IHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0Lmxlbmd0aCAtIDEgPCA0KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIuXCIpO1xuICAgICAgaWYgKCh0Lmxlbmd0aCAtIDEpICUgMiAhPSAwKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICBpZiAoIShpID0gZS5wYXJzZShpLCAyLCBPdCkpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB1ID0gW10sXG4gICAgICAgIGwgPSBudWxsO1xuICAgICAgXCJpbnRlcnBvbGF0ZS1oY2xcIiA9PT0gciB8fCBcImludGVycG9sYXRlLWxhYlwiID09PSByID8gbCA9IHF0IDogZS5leHBlY3RlZFR5cGUgJiYgXCJ2YWx1ZVwiICE9PSBlLmV4cGVjdGVkVHlwZS5raW5kICYmIChsID0gZS5leHBlY3RlZFR5cGUpO1xuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBhLmxlbmd0aDsgcCArPSAyKSB7XG4gICAgICAgIHZhciBjID0gYVtwXSxcbiAgICAgICAgICBoID0gYVtwICsgMV0sXG4gICAgICAgICAgZiA9IHAgKyAzLFxuICAgICAgICAgIHkgPSBwICsgNDtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGMpIHJldHVybiBlLmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCBmKTtcbiAgICAgICAgaWYgKHUubGVuZ3RoICYmIHVbdS5sZW5ndGggLSAxXVswXSA+PSBjKSByZXR1cm4gZS5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBhcnJhbmdlZCB3aXRoIGlucHV0IHZhbHVlcyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuJywgZik7XG4gICAgICAgIHZhciBkID0gZS5wYXJzZShoLCB5LCBsKTtcbiAgICAgICAgaWYgKCFkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbCA9IGwgfHwgZC50eXBlLCB1LnB1c2goW2MsIGRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm51bWJlclwiID09PSBsLmtpbmQgfHwgXCJjb2xvclwiID09PSBsLmtpbmQgfHwgXCJhcnJheVwiID09PSBsLmtpbmQgJiYgXCJudW1iZXJcIiA9PT0gbC5pdGVtVHlwZS5raW5kICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGwuTiA/IG5ldyBvcihsLCByLCBuLCBpLCB1KSA6IGUuZXJyb3IoXCJUeXBlIFwiICsgSHQobCkgKyBcIiBpcyBub3QgaW50ZXJwb2xhdGFibGUuXCIpO1xuICAgIH0sIG9yLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubGFiZWxzLFxuICAgICAgICByID0gdGhpcy5vdXRwdXRzO1xuICAgICAgaWYgKDEgPT09IGUubGVuZ3RoKSByZXR1cm4gclswXS5ldmFsdWF0ZSh0KTtcbiAgICAgIHZhciBuID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmIChuIDw9IGVbMF0pIHJldHVybiByWzBdLmV2YWx1YXRlKHQpO1xuICAgICAgdmFyIGkgPSBlLmxlbmd0aDtcbiAgICAgIGlmIChuID49IGVbaSAtIDFdKSByZXR1cm4gcltpIC0gMV0uZXZhbHVhdGUodCk7XG4gICAgICB2YXIgYSA9IE5lKGUsIG4pLFxuICAgICAgICBvID0gb3IuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb24sIG4sIGVbYV0sIGVbYSArIDFdKSxcbiAgICAgICAgcyA9IHJbYV0uZXZhbHVhdGUodCksXG4gICAgICAgIHUgPSByW2EgKyAxXS5ldmFsdWF0ZSh0KTtcbiAgICAgIHJldHVybiBcImludGVycG9sYXRlXCIgPT09IHRoaXMub3BlcmF0b3IgPyBaZVt0aGlzLnR5cGUua2luZC50b0xvd2VyQ2FzZSgpXShzLCB1LCBvKSA6IFwiaW50ZXJwb2xhdGUtaGNsXCIgPT09IHRoaXMub3BlcmF0b3IgPyBpci5yZXZlcnNlKGlyLmludGVycG9sYXRlKGlyLmZvcndhcmQocyksIGlyLmZvcndhcmQodSksIG8pKSA6IG5yLnJldmVyc2UobnIuaW50ZXJwb2xhdGUobnIuZm9yd2FyZChzKSwgbnIuZm9yd2FyZCh1KSwgbykpO1xuICAgIH0sIG9yLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KTtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5vdXRwdXRzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkgdChyW2VdKTtcbiAgICB9LCBvci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSwgb3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0O1xuICAgICAgdCA9IFwibGluZWFyXCIgPT09IHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID8gW1wibGluZWFyXCJdIDogXCJleHBvbmVudGlhbFwiID09PSB0aGlzLmludGVycG9sYXRpb24ubmFtZSA/IDEgPT09IHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID8gW1wibGluZWFyXCJdIDogW1wiZXhwb25lbnRpYWxcIiwgdGhpcy5pbnRlcnBvbGF0aW9uLmJhc2VdIDogW1wiY3ViaWMtYmV6aWVyXCJdLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7XG4gICAgICBmb3IgKHZhciBlID0gW3RoaXMub3BlcmF0b3IsIHQsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldLCByID0gMDsgciA8IHRoaXMubGFiZWxzLmxlbmd0aDsgcisrKSBlLnB1c2godGhpcy5sYWJlbHNbcl0sIHRoaXMub3V0cHV0c1tyXS5zZXJpYWxpemUoKSk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHZhciB1ciA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLmFyZ3MgPSBlO1xuICAgIH07XG4gICAgdXIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgMikgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIHIgPSBudWxsLFxuICAgICAgICBuID0gZS5leHBlY3RlZFR5cGU7XG4gICAgICBuICYmIFwidmFsdWVcIiAhPT0gbi5raW5kICYmIChyID0gbik7XG4gICAgICBmb3IgKHZhciBpID0gW10sIGEgPSAwLCBvID0gdC5zbGljZSgxKTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgdmFyIHMgPSBlLnBhcnNlKG9bYV0sIDEgKyBpLmxlbmd0aCwgciwgdm9pZCAwLCB7XG4gICAgICAgICAgdHlwZUFubm90YXRpb246IFwib21pdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXMpIHJldHVybiBudWxsO1xuICAgICAgICByID0gciB8fCBzLnR5cGUsIGkucHVzaChzKTtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gbiAmJiBpLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuICR0KG4sIHQudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgdXIodSA/IEt0IDogciwgaSk7XG4gICAgfSwgdXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUsIHIgPSBudWxsLCBuID0gMCwgaSA9IDAsIGEgPSB0aGlzLmFyZ3M7IGkgPCBhLmxlbmd0aCAmJiAobisrLCAociA9IGFbaV0uZXZhbHVhdGUodCkpICYmIHIgaW5zdGFuY2VvZiBhZSAmJiAhci5hdmFpbGFibGUgJiYgKGUgfHwgKGUgPSByLm5hbWUpLCByID0gbnVsbCwgbiA9PT0gdGhpcy5hcmdzLmxlbmd0aCAmJiAociA9IGUpKSwgbnVsbCA9PT0gcik7IGkgKz0gMSk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCB1ci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKHQpO1xuICAgIH0sIHVyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9LCB1ci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBbXCJjb2FsZXNjZVwiXTtcbiAgICAgIHJldHVybiB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICB0LnB1c2goZS5zZXJpYWxpemUoKSk7XG4gICAgICB9KSwgdDtcbiAgICB9O1xuICAgIHZhciBsciA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMuYmluZGluZ3MgPSBbXS5jb25jYXQodCksIHRoaXMucmVzdWx0ID0gZTtcbiAgICB9O1xuICAgIGxyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHQuZXZhbHVhdGUodCk7XG4gICAgfSwgbHIucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHRoaXMuYmluZGluZ3M7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB0KHJbZV1bMV0pO1xuICAgICAgdCh0aGlzLnJlc3VsdCk7XG4gICAgfSwgbHIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgNCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCAzIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIGZvciAodmFyIHIgPSBbXSwgbiA9IDE7IG4gPCB0Lmxlbmd0aCAtIDE7IG4gKz0gMikge1xuICAgICAgICB2YXIgaSA9IHRbbl07XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBpKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kIFwiICsgdHlwZW9mIGkgKyBcIiBpbnN0ZWFkLlwiLCBuKTtcbiAgICAgICAgaWYgKC9bXmEtekEtWjAtOV9dLy50ZXN0KGkpKSByZXR1cm4gZS5lcnJvcihcIlZhcmlhYmxlIG5hbWVzIG11c3QgY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIG9yICdfJy5cIiwgbik7XG4gICAgICAgIHZhciBhID0gZS5wYXJzZSh0W24gKyAxXSwgbiArIDEpO1xuICAgICAgICBpZiAoIWEpIHJldHVybiBudWxsO1xuICAgICAgICByLnB1c2goW2ksIGFdKTtcbiAgICAgIH1cbiAgICAgIHZhciBvID0gZS5wYXJzZSh0W3QubGVuZ3RoIC0gMV0sIHQubGVuZ3RoIC0gMSwgZS5leHBlY3RlZFR5cGUsIHIpO1xuICAgICAgcmV0dXJuIG8gPyBuZXcgbHIociwgbykgOiBudWxsO1xuICAgIH0sIGxyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm91dHB1dERlZmluZWQoKTtcbiAgICB9LCBsci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IFtcImxldFwiXSwgZSA9IDAsIHIgPSB0aGlzLmJpbmRpbmdzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV07XG4gICAgICAgIHQucHVzaChuWzBdLCBuWzFdLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LnB1c2godGhpcy5yZXN1bHQuc2VyaWFsaXplKCkpLCB0O1xuICAgIH07XG4gICAgdmFyIHByID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5kZXggPSBlLCB0aGlzLmlucHV0ID0gcjtcbiAgICB9O1xuICAgIHByLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgzICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCAyIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBPdCksXG4gICAgICAgIG4gPSBlLnBhcnNlKHRbMl0sIDIsIEp0KGUuZXhwZWN0ZWRUeXBlIHx8IEt0KSk7XG4gICAgICByZXR1cm4gciAmJiBuID8gbmV3IHByKG4udHlwZS5pdGVtVHlwZSwgciwgbikgOiBudWxsO1xuICAgIH0sIHByLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaW5kZXguZXZhbHVhdGUodCksXG4gICAgICAgIHIgPSB0aGlzLmlucHV0LmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKGUgPCAwKSB0aHJvdyBuZXcgY2UoXCJBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiBcIiArIGUgKyBcIiA8IDAuXCIpO1xuICAgICAgaWYgKGUgPj0gci5sZW5ndGgpIHRocm93IG5ldyBjZShcIkFycmF5IGluZGV4IG91dCBvZiBib3VuZHM6IFwiICsgZSArIFwiID4gXCIgKyAoci5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmIChlICE9PSBNYXRoLmZsb29yKGUpKSB0aHJvdyBuZXcgY2UoXCJBcnJheSBpbmRleCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBmb3VuZCBcIiArIGUgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHJldHVybiByW2VdO1xuICAgIH0sIHByLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmluZGV4KSwgdCh0aGlzLmlucHV0KTtcbiAgICB9LCBwci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBwci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFtcImF0XCIsIHRoaXMuaW5kZXguc2VyaWFsaXplKCksIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuICAgIH07XG4gICAgdmFyIGNyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IGp0LCB0aGlzLm5lZWRsZSA9IHQsIHRoaXMuaGF5c3RhY2sgPSBlO1xuICAgIH07XG4gICAgY3IucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKDMgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEsIEt0KSxcbiAgICAgICAgbiA9IGUucGFyc2UodFsyXSwgMiwgS3QpO1xuICAgICAgcmV0dXJuIHIgJiYgbiA/IFd0KHIudHlwZSwgW2p0LCBVdCwgT3QsIFJ0LCBLdF0pID8gbmV3IGNyKHIsIG4pIDogZS5lcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiICsgSHQoci50eXBlKSArIFwiIGluc3RlYWRcIikgOiBudWxsO1xuICAgIH0sIGNyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMubmVlZGxlLmV2YWx1YXRlKHQpLFxuICAgICAgICByID0gdGhpcy5oYXlzdGFjay5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmICghcikgcmV0dXJuICExO1xuICAgICAgaWYgKCFRdChlLCBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwibnVsbFwiXSkpIHRocm93IG5ldyBjZShcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiICsgSHQodWUoZSkpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICBpZiAoIVF0KHIsIFtcInN0cmluZ1wiLCBcImFycmF5XCJdKSkgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIgKyBIdCh1ZShyKSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHJldHVybiByLmluZGV4T2YoZSkgPj0gMDtcbiAgICB9LCBjci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5uZWVkbGUpLCB0KHRoaXMuaGF5c3RhY2spO1xuICAgIH0sIGNyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGNyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW1wiaW5cIiwgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCldO1xuICAgIH07XG4gICAgdmFyIGhyID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudHlwZSA9IE90LCB0aGlzLm5lZWRsZSA9IHQsIHRoaXMuaGF5c3RhY2sgPSBlLCB0aGlzLmZyb21JbmRleCA9IHI7XG4gICAgfTtcbiAgICBoci5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPD0gMiB8fCB0Lmxlbmd0aCA+PSA1KSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIiArICh0Lmxlbmd0aCAtIDEpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICB2YXIgciA9IGUucGFyc2UodFsxXSwgMSwgS3QpLFxuICAgICAgICBuID0gZS5wYXJzZSh0WzJdLCAyLCBLdCk7XG4gICAgICBpZiAoIXIgfHwgIW4pIHJldHVybiBudWxsO1xuICAgICAgaWYgKCFXdChyLnR5cGUsIFtqdCwgVXQsIE90LCBSdCwgS3RdKSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIiArIEh0KHIudHlwZSkgKyBcIiBpbnN0ZWFkXCIpO1xuICAgICAgaWYgKDQgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpID0gZS5wYXJzZSh0WzNdLCAzLCBPdCk7XG4gICAgICAgIHJldHVybiBpID8gbmV3IGhyKHIsIG4sIGkpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgaHIociwgbik7XG4gICAgfSwgaHIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUodCksXG4gICAgICAgIHIgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKHQpO1xuICAgICAgaWYgKCFRdChlLCBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwibnVsbFwiXSkpIHRocm93IG5ldyBjZShcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiICsgSHQodWUoZSkpICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICBpZiAoIVF0KHIsIFtcInN0cmluZ1wiLCBcImFycmF5XCJdKSkgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIgKyBIdCh1ZShyKSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIGlmICh0aGlzLmZyb21JbmRleCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuZnJvbUluZGV4LmV2YWx1YXRlKHQpO1xuICAgICAgICByZXR1cm4gci5pbmRleE9mKGUsIG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIuaW5kZXhPZihlKTtcbiAgICB9LCBoci5wcm90b3R5cGUuZWFjaENoaWxkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy5uZWVkbGUpLCB0KHRoaXMuaGF5c3RhY2spLCB0aGlzLmZyb21JbmRleCAmJiB0KHRoaXMuZnJvbUluZGV4KTtcbiAgICB9LCBoci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBoci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG51bGwgIT0gdGhpcy5mcm9tSW5kZXggJiYgdm9pZCAwICE9PSB0aGlzLmZyb21JbmRleCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZnJvbUluZGV4LnNlcmlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gW1wiaW5kZXgtb2ZcIiwgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCksIHRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcImluZGV4LW9mXCIsIHRoaXMubmVlZGxlLnNlcmlhbGl6ZSgpLCB0aGlzLmhheXN0YWNrLnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuICAgIHZhciBmciA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB0aGlzLmlucHV0VHlwZSA9IHQsIHRoaXMudHlwZSA9IGUsIHRoaXMuaW5wdXQgPSByLCB0aGlzLmNhc2VzID0gbiwgdGhpcy5vdXRwdXRzID0gaSwgdGhpcy5vdGhlcndpc2UgPSBhO1xuICAgIH07XG4gICAgZnIucGFyc2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHQubGVuZ3RoIDwgNSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiLlwiKTtcbiAgICAgIGlmICh0Lmxlbmd0aCAlIDIgIT0gMSkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIHIsIG47XG4gICAgICBlLmV4cGVjdGVkVHlwZSAmJiBcInZhbHVlXCIgIT09IGUuZXhwZWN0ZWRUeXBlLmtpbmQgJiYgKG4gPSBlLmV4cGVjdGVkVHlwZSk7XG4gICAgICBmb3IgKHZhciBpID0ge30sIGEgPSBbXSwgbyA9IDI7IG8gPCB0Lmxlbmd0aCAtIDE7IG8gKz0gMikge1xuICAgICAgICB2YXIgcyA9IHRbb10sXG4gICAgICAgICAgdSA9IHRbbyArIDFdO1xuICAgICAgICBBcnJheS5pc0FycmF5KHMpIHx8IChzID0gW3NdKTtcbiAgICAgICAgdmFyIGwgPSBlLmNvbmNhdChvKTtcbiAgICAgICAgaWYgKDAgPT09IHMubGVuZ3RoKSByZXR1cm4gbC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBicmFuY2ggbGFiZWwuXCIpO1xuICAgICAgICBmb3IgKHZhciBwID0gMCwgYyA9IHM7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgdmFyIGggPSBjW3BdO1xuICAgICAgICAgIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiBoICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGgpIHJldHVybiBsLmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIG51bWJlcnMgb3Igc3RyaW5ncy5cIik7XG4gICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGggJiYgTWF0aC5hYnMoaCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgcmV0dXJuIGwuZXJyb3IoXCJCcmFuY2ggbGFiZWxzIG11c3QgYmUgaW50ZWdlcnMgbm8gbGFyZ2VyIHRoYW4gXCIgKyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiArIFwiLlwiKTtcbiAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgaCAmJiBNYXRoLmZsb29yKGgpICE9PSBoKSByZXR1cm4gbC5lcnJvcihcIk51bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLlwiKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgaWYgKGwuY2hlY2tTdWJ0eXBlKHIsIHVlKGgpKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHIgPSB1ZShoKTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBpW1N0cmluZyhoKV0pIHJldHVybiBsLmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIHVuaXF1ZS5cIik7XG4gICAgICAgICAgaVtTdHJpbmcoaCldID0gYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGYgPSBlLnBhcnNlKHUsIG8sIG4pO1xuICAgICAgICBpZiAoIWYpIHJldHVybiBudWxsO1xuICAgICAgICBuID0gbiB8fCBmLnR5cGUsIGEucHVzaChmKTtcbiAgICAgIH1cbiAgICAgIHZhciB5ID0gZS5wYXJzZSh0WzFdLCAxLCBLdCk7XG4gICAgICBpZiAoIXkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGQgPSBlLnBhcnNlKHRbdC5sZW5ndGggLSAxXSwgdC5sZW5ndGggLSAxLCBuKTtcbiAgICAgIHJldHVybiBkID8gXCJ2YWx1ZVwiICE9PSB5LnR5cGUua2luZCAmJiBlLmNvbmNhdCgxKS5jaGVja1N1YnR5cGUociwgeS50eXBlKSA/IG51bGwgOiBuZXcgZnIociwgbiwgeSwgaSwgYSwgZCkgOiBudWxsO1xuICAgIH0sIGZyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUodCk7XG4gICAgICByZXR1cm4gKHVlKGUpID09PSB0aGlzLmlucHV0VHlwZSAmJiB0aGlzLm91dHB1dHNbdGhpcy5jYXNlc1tlXV0gfHwgdGhpcy5vdGhlcndpc2UpLmV2YWx1YXRlKHQpO1xuICAgIH0sIGZyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KSwgdGhpcy5vdXRwdXRzLmZvckVhY2godCksIHQodGhpcy5vdGhlcndpc2UpO1xuICAgIH0sIGZyLnByb3RvdHlwZS5vdXRwdXREZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gICAgfSwgZnIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSB0aGlzLCBlID0gW1wibWF0Y2hcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV0sIHIgPSBbXSwgbiA9IHt9LCBpID0gMCwgYSA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICB2b2lkIDAgPT09IChjID0gblt0aGlzLmNhc2VzW29dXSkgPyAoblt0aGlzLmNhc2VzW29dXSA9IHIubGVuZ3RoLCByLnB1c2goW3RoaXMuY2FzZXNbb10sIFtvXV0pKSA6IHJbY11bMV0ucHVzaChvKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09PSB0LmlucHV0VHlwZS5raW5kID8gTnVtYmVyKGUpIDogZTtcbiAgICAgICAgfSwgdSA9IDAsIGwgPSByOyB1IDwgbC5sZW5ndGg7IHUgKz0gMSkge1xuICAgICAgICB2YXIgcCA9IGxbdV0sXG4gICAgICAgICAgYyA9IHBbMF0sXG4gICAgICAgICAgaCA9IHBbMV07XG4gICAgICAgIGUucHVzaCgxID09PSBoLmxlbmd0aCA/IHMoaFswXSkgOiBoLm1hcChzKSksIGUucHVzaCh0aGlzLm91dHB1dHNbb3V0cHV0SW5kZXgkMV0uc2VyaWFsaXplKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUucHVzaCh0aGlzLm90aGVyd2lzZS5zZXJpYWxpemUoKSksIGU7XG4gICAgfTtcbiAgICB2YXIgeXIgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy50eXBlID0gdCwgdGhpcy5icmFuY2hlcyA9IGUsIHRoaXMub3RoZXJ3aXNlID0gcjtcbiAgICB9O1xuICAgIHlyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8IDQpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5IFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIi5cIik7XG4gICAgICBpZiAodC5sZW5ndGggJSAyICE9IDApIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIHI7XG4gICAgICBlLmV4cGVjdGVkVHlwZSAmJiBcInZhbHVlXCIgIT09IGUuZXhwZWN0ZWRUeXBlLmtpbmQgJiYgKHIgPSBlLmV4cGVjdGVkVHlwZSk7XG4gICAgICBmb3IgKHZhciBuID0gW10sIGkgPSAxOyBpIDwgdC5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGEgPSBlLnBhcnNlKHRbaV0sIGksIGp0KTtcbiAgICAgICAgaWYgKCFhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG8gPSBlLnBhcnNlKHRbaSArIDFdLCBpICsgMSwgcik7XG4gICAgICAgIGlmICghbykgcmV0dXJuIG51bGw7XG4gICAgICAgIG4ucHVzaChbYSwgb10pLCByID0gciB8fCBvLnR5cGU7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IGUucGFyc2UodFt0Lmxlbmd0aCAtIDFdLCB0Lmxlbmd0aCAtIDEsIHIpO1xuICAgICAgcmV0dXJuIHMgPyBuZXcgeXIociwgbiwgcykgOiBudWxsO1xuICAgIH0sIHlyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgciA9IHRoaXMuYnJhbmNoZXM7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXSxcbiAgICAgICAgICBpID0gblsxXTtcbiAgICAgICAgaWYgKG5bMF0uZXZhbHVhdGUodCkpIHJldHVybiBpLmV2YWx1YXRlKHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMub3RoZXJ3aXNlLmV2YWx1YXRlKHQpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0aGlzLmJyYW5jaGVzOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV0sXG4gICAgICAgICAgaSA9IG5bMV07XG4gICAgICAgIHQoblswXSksIHQoaSk7XG4gICAgICB9XG4gICAgICB0KHRoaXMub3RoZXJ3aXNlKTtcbiAgICB9LCB5ci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJyYW5jaGVzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0WzFdLm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pICYmIHRoaXMub3RoZXJ3aXNlLm91dHB1dERlZmluZWQoKTtcbiAgICB9LCB5ci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBbXCJjYXNlXCJdO1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHQucHVzaChlLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH0pLCB0O1xuICAgIH07XG4gICAgdmFyIGRyID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMudHlwZSA9IHQsIHRoaXMuaW5wdXQgPSBlLCB0aGlzLmJlZ2luSW5kZXggPSByLCB0aGlzLmVuZEluZGV4ID0gbjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1yKHQsIGUpIHtcbiAgICAgIHJldHVybiBcIj09XCIgPT09IHQgfHwgXCIhPVwiID09PSB0ID8gXCJib29sZWFuXCIgPT09IGUua2luZCB8fCBcInN0cmluZ1wiID09PSBlLmtpbmQgfHwgXCJudW1iZXJcIiA9PT0gZS5raW5kIHx8IFwibnVsbFwiID09PSBlLmtpbmQgfHwgXCJ2YWx1ZVwiID09PSBlLmtpbmQgOiBcInN0cmluZ1wiID09PSBlLmtpbmQgfHwgXCJudW1iZXJcIiA9PT0gZS5raW5kIHx8IFwidmFsdWVcIiA9PT0gZS5raW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2cih0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gMCA9PT0gbi5jb21wYXJlKGUsIHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBncih0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IFwiPT1cIiAhPT0gdCAmJiBcIiE9XCIgIT09IHQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBpKHQsIGUsIHIpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBqdCwgdGhpcy5saHMgPSB0LCB0aGlzLnJocyA9IGUsIHRoaXMuY29sbGF0b3IgPSByLCB0aGlzLmhhc1VudHlwZWRBcmd1bWVudCA9IFwidmFsdWVcIiA9PT0gdC50eXBlLmtpbmQgfHwgXCJ2YWx1ZVwiID09PSBlLnR5cGUua2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaS5wYXJzZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKDMgIT09IHQubGVuZ3RoICYmIDQgIT09IHQubGVuZ3RoKSByZXR1cm4gZS5lcnJvcihcIkV4cGVjdGVkIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXCIpO1xuICAgICAgICAgIHZhciByID0gdFswXSxcbiAgICAgICAgICAgIGEgPSBlLnBhcnNlKHRbMV0sIDEsIEt0KTtcbiAgICAgICAgICBpZiAoIWEpIHJldHVybiBudWxsO1xuICAgICAgICAgIGlmICghbXIociwgYS50eXBlKSkgcmV0dXJuIGUuY29uY2F0KDEpLmVycm9yKCdcIicgKyByICsgXCJcXFwiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICdcIiArIEh0KGEudHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgIHZhciBvID0gZS5wYXJzZSh0WzJdLCAyLCBLdCk7XG4gICAgICAgICAgaWYgKCFvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoIW1yKHIsIG8udHlwZSkpIHJldHVybiBlLmNvbmNhdCgyKS5lcnJvcignXCInICsgciArIFwiXFxcIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAnXCIgKyBIdChvLnR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICBpZiAoYS50eXBlLmtpbmQgIT09IG8udHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gYS50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiICE9PSBvLnR5cGUua2luZCkgcmV0dXJuIGUuZXJyb3IoXCJDYW5ub3QgY29tcGFyZSB0eXBlcyAnXCIgKyBIdChhLnR5cGUpICsgXCInIGFuZCAnXCIgKyBIdChvLnR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICBuICYmIChcInZhbHVlXCIgPT09IGEudHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gby50eXBlLmtpbmQgPyBhID0gbmV3IGZlKG8udHlwZSwgW2FdKSA6IFwidmFsdWVcIiAhPT0gYS50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiID09PSBvLnR5cGUua2luZCAmJiAobyA9IG5ldyBmZShhLnR5cGUsIFtvXSkpKTtcbiAgICAgICAgICB2YXIgcyA9IG51bGw7XG4gICAgICAgICAgaWYgKDQgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gYS50eXBlLmtpbmQgJiYgXCJzdHJpbmdcIiAhPT0gby50eXBlLmtpbmQgJiYgXCJ2YWx1ZVwiICE9PSBhLnR5cGUua2luZCAmJiBcInZhbHVlXCIgIT09IG8udHlwZS5raW5kKSByZXR1cm4gZS5lcnJvcihcIkNhbm5vdCB1c2UgY29sbGF0b3IgdG8gY29tcGFyZSBub24tc3RyaW5nIHR5cGVzLlwiKTtcbiAgICAgICAgICAgIGlmICghKHMgPSBlLnBhcnNlKHRbM10sIDMsIEd0KSkpIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IGkoYSwgbywgcyk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMubGhzLmV2YWx1YXRlKGkpLFxuICAgICAgICAgICAgbyA9IHRoaXMucmhzLmV2YWx1YXRlKGkpO1xuICAgICAgICAgIGlmIChuICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgcyA9IHVlKGEpLFxuICAgICAgICAgICAgICB1ID0gdWUobyk7XG4gICAgICAgICAgICBpZiAocy5raW5kICE9PSB1LmtpbmQgfHwgXCJzdHJpbmdcIiAhPT0gcy5raW5kICYmIFwibnVtYmVyXCIgIT09IHMua2luZCkgdGhyb3cgbmV3IGNlKCdFeHBlY3RlZCBhcmd1bWVudHMgZm9yIFwiJyArIHQgKyAnXCIgdG8gYmUgKHN0cmluZywgc3RyaW5nKSBvciAobnVtYmVyLCBudW1iZXIpLCBidXQgZm91bmQgKCcgKyBzLmtpbmQgKyBcIiwgXCIgKyB1LmtpbmQgKyBcIikgaW5zdGVhZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmNvbGxhdG9yICYmICFuICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgbCA9IHVlKGEpLFxuICAgICAgICAgICAgICBwID0gdWUobyk7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPT0gbC5raW5kIHx8IFwic3RyaW5nXCIgIT09IHAua2luZCkgcmV0dXJuIGUoaSwgYSwgbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yID8gcihpLCBhLCBvLCB0aGlzLmNvbGxhdG9yLmV2YWx1YXRlKGkpKSA6IGUoaSwgYSwgbyk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdCh0aGlzLmxocyksIHQodGhpcy5yaHMpLCB0aGlzLmNvbGxhdG9yICYmIHQodGhpcy5jb2xsYXRvcik7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSBbdF07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBlLnB1c2godC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgfSksIGU7XG4gICAgICAgIH0sIGk7XG4gICAgICB9KCk7XG4gICAgfVxuICAgIGRyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA8PSAyIHx8IHQubGVuZ3RoID49IDUpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiICsgKHQubGVuZ3RoIC0gMSkgKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBLdCksXG4gICAgICAgIG4gPSBlLnBhcnNlKHRbMl0sIDIsIE90KTtcbiAgICAgIGlmICghciB8fCAhbikgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoIVd0KHIudHlwZSwgW0p0KEt0KSwgVXQsIEt0XSkpIHJldHVybiBlLmVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIEh0KHIudHlwZSkgKyBcIiBpbnN0ZWFkXCIpO1xuICAgICAgaWYgKDQgPT09IHQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpID0gZS5wYXJzZSh0WzNdLCAzLCBPdCk7XG4gICAgICAgIHJldHVybiBpID8gbmV3IGRyKHIudHlwZSwgciwgbiwgaSkgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBkcihyLnR5cGUsIHIsIG4pO1xuICAgIH0sIGRyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUodCksXG4gICAgICAgIHIgPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUodCk7XG4gICAgICBpZiAoIVF0KGUsIFtcInN0cmluZ1wiLCBcImFycmF5XCJdKSkgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIiArIEh0KHVlKGUpKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmVuZEluZGV4LmV2YWx1YXRlKHQpO1xuICAgICAgICByZXR1cm4gZS5zbGljZShyLCBuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLnNsaWNlKHIpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KSwgdCh0aGlzLmJlZ2luSW5kZXgpLCB0aGlzLmVuZEluZGV4ICYmIHQodGhpcy5lbmRJbmRleCk7XG4gICAgfSwgZHIucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZHIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChudWxsICE9IHRoaXMuZW5kSW5kZXggJiYgdm9pZCAwICE9PSB0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5lbmRJbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFtcInNsaWNlXCIsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKSwgdF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW1wic2xpY2VcIiwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpXTtcbiAgICB9O1xuICAgIHZhciB4ciA9IGdyKFwiPT1cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIGUgPT09IHI7XG4gICAgICB9LCB2ciksXG4gICAgICBiciA9IGdyKFwiIT1cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIGUgIT09IHI7XG4gICAgICB9LCBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICByZXR1cm4gIXZyKDAsIGUsIHIsIG4pO1xuICAgICAgfSksXG4gICAgICB3ciA9IGdyKFwiPFwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICByZXR1cm4gZSA8IHI7XG4gICAgICB9LCBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICByZXR1cm4gbi5jb21wYXJlKGUsIHIpIDwgMDtcbiAgICAgIH0pLFxuICAgICAgX3IgPSBncihcIj5cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIGUgPiByO1xuICAgICAgfSwgZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgcmV0dXJuIG4uY29tcGFyZShlLCByKSA+IDA7XG4gICAgICB9KSxcbiAgICAgIEFyID0gZ3IoXCI8PVwiLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICByZXR1cm4gZSA8PSByO1xuICAgICAgfSwgZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgcmV0dXJuIG4uY29tcGFyZShlLCByKSA8PSAwO1xuICAgICAgfSksXG4gICAgICBTciA9IGdyKFwiPj1cIiwgZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgcmV0dXJuIGUgPj0gcjtcbiAgICAgIH0sIGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHJldHVybiBuLmNvbXBhcmUoZSwgcikgPj0gMDtcbiAgICAgIH0pLFxuICAgICAga3IgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB0aGlzLnR5cGUgPSBVdCwgdGhpcy5udW1iZXIgPSB0LCB0aGlzLmxvY2FsZSA9IGUsIHRoaXMuY3VycmVuY3kgPSByLCB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID0gbiwgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA9IGk7XG4gICAgICB9O1xuICAgIGtyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgzICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciByID0gZS5wYXJzZSh0WzFdLCAxLCBPdCk7XG4gICAgICBpZiAoIXIpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG4gPSB0WzJdO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIG4gfHwgQXJyYXkuaXNBcnJheShuKSkgcmV0dXJuIGUuZXJyb3IoXCJOdW1iZXJGb3JtYXQgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB2YXIgaSA9IG51bGw7XG4gICAgICBpZiAobi5sb2NhbGUgJiYgIShpID0gZS5wYXJzZShuLmxvY2FsZSwgMSwgVXQpKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgYSA9IG51bGw7XG4gICAgICBpZiAobi5jdXJyZW5jeSAmJiAhKGEgPSBlLnBhcnNlKG4uY3VycmVuY3ksIDEsIFV0KSkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG8gPSBudWxsO1xuICAgICAgaWYgKG5bXCJtaW4tZnJhY3Rpb24tZGlnaXRzXCJdICYmICEobyA9IGUucGFyc2UobltcIm1pbi1mcmFjdGlvbi1kaWdpdHNcIl0sIDEsIE90KSkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgcmV0dXJuIG5bXCJtYXgtZnJhY3Rpb24tZGlnaXRzXCJdICYmICEocyA9IGUucGFyc2UobltcIm1heC1mcmFjdGlvbi1kaWdpdHNcIl0sIDEsIE90KSkgPyBudWxsIDogbmV3IGtyKHIsIGksIGEsIG8sIHMpO1xuICAgIH0sIGtyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUodCkgOiBbXSwge1xuICAgICAgICBzdHlsZTogdGhpcy5jdXJyZW5jeSA/IFwiY3VycmVuY3lcIiA6IFwiZGVjaW1hbFwiLFxuICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUodCkgOiB2b2lkIDAsXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUodCkgOiB2b2lkIDAsXG4gICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUodCkgOiB2b2lkIDBcbiAgICAgIH0pLmZvcm1hdCh0aGlzLm51bWJlci5ldmFsdWF0ZSh0KSk7XG4gICAgfSwga3IucHJvdG90eXBlLmVhY2hDaGlsZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0KHRoaXMubnVtYmVyKSwgdGhpcy5sb2NhbGUgJiYgdCh0aGlzLmxvY2FsZSksIHRoaXMuY3VycmVuY3kgJiYgdCh0aGlzLmN1cnJlbmN5KSwgdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyAmJiB0KHRoaXMubWluRnJhY3Rpb25EaWdpdHMpLCB0aGlzLm1heEZyYWN0aW9uRGlnaXRzICYmIHQodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyk7XG4gICAgfSwga3IucHJvdG90eXBlLm91dHB1dERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwga3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0ge307XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbGUgJiYgKHQubG9jYWxlID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCkpLCB0aGlzLmN1cnJlbmN5ICYmICh0LmN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jeS5zZXJpYWxpemUoKSksIHRoaXMubWluRnJhY3Rpb25EaWdpdHMgJiYgKHRbXCJtaW4tZnJhY3Rpb24tZGlnaXRzXCJdID0gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5zZXJpYWxpemUoKSksIHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgJiYgKHRbXCJtYXgtZnJhY3Rpb24tZGlnaXRzXCJdID0gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5zZXJpYWxpemUoKSksIFtcIm51bWJlci1mb3JtYXRcIiwgdGhpcy5udW1iZXIuc2VyaWFsaXplKCksIHRdO1xuICAgIH07XG4gICAgdmFyIElyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudHlwZSA9IE90LCB0aGlzLmlucHV0ID0gdDtcbiAgICB9O1xuICAgIElyLnBhcnNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICgyICE9PSB0Lmxlbmd0aCkgcmV0dXJuIGUuZXJyb3IoXCJFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgXCIgKyAodC5sZW5ndGggLSAxKSArIFwiIGluc3RlYWQuXCIpO1xuICAgICAgdmFyIHIgPSBlLnBhcnNlKHRbMV0sIDEpO1xuICAgICAgcmV0dXJuIHIgPyBcImFycmF5XCIgIT09IHIudHlwZS5raW5kICYmIFwic3RyaW5nXCIgIT09IHIudHlwZS5raW5kICYmIFwidmFsdWVcIiAhPT0gci50eXBlLmtpbmQgPyBlLmVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCBcIiArIEh0KHIudHlwZSkgKyBcIiBpbnN0ZWFkLlwiKSA6IG5ldyBJcihyKSA6IG51bGw7XG4gICAgfSwgSXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5pbnB1dC5ldmFsdWF0ZSh0KTtcbiAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSByZXR1cm4gZS5sZW5ndGg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkgcmV0dXJuIGUubGVuZ3RoO1xuICAgICAgdGhyb3cgbmV3IGNlKFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgb2YgdHlwZSBzdHJpbmcgb3IgYXJyYXksIGJ1dCBmb3VuZCBcIiArIEh0KHVlKGUpKSArIFwiIGluc3RlYWQuXCIpO1xuICAgIH0sIElyLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdCh0aGlzLmlucHV0KTtcbiAgICB9LCBJci5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBJci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBbXCJsZW5ndGhcIl07XG4gICAgICByZXR1cm4gdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdC5wdXNoKGUuc2VyaWFsaXplKCkpO1xuICAgICAgfSksIHQ7XG4gICAgfTtcbiAgICB2YXIgenIgPSB7XG4gICAgICBcIj09XCI6IHhyLFxuICAgICAgXCIhPVwiOiBicixcbiAgICAgIFwiPlwiOiBfcixcbiAgICAgIFwiPFwiOiB3cixcbiAgICAgIFwiPj1cIjogU3IsXG4gICAgICBcIjw9XCI6IEFyLFxuICAgICAgYXJyYXk6IGZlLFxuICAgICAgYXQ6IHByLFxuICAgICAgYm9vbGVhbjogZmUsXG4gICAgICBjYXNlOiB5cixcbiAgICAgIGNvYWxlc2NlOiB1cixcbiAgICAgIGNvbGxhdG9yOiB3ZSxcbiAgICAgIGZvcm1hdDogeWUsXG4gICAgICBpbWFnZTogZGUsXG4gICAgICBpbjogY3IsXG4gICAgICBcImluZGV4LW9mXCI6IGhyLFxuICAgICAgaW50ZXJwb2xhdGU6IG9yLFxuICAgICAgXCJpbnRlcnBvbGF0ZS1oY2xcIjogb3IsXG4gICAgICBcImludGVycG9sYXRlLWxhYlwiOiBvcixcbiAgICAgIGxlbmd0aDogSXIsXG4gICAgICBsZXQ6IGxyLFxuICAgICAgbGl0ZXJhbDogcGUsXG4gICAgICBtYXRjaDogZnIsXG4gICAgICBudW1iZXI6IGZlLFxuICAgICAgXCJudW1iZXItZm9ybWF0XCI6IGtyLFxuICAgICAgb2JqZWN0OiBmZSxcbiAgICAgIHNsaWNlOiBkcixcbiAgICAgIHN0ZXA6IEtlLFxuICAgICAgc3RyaW5nOiBmZSxcbiAgICAgIFwidG8tYm9vbGVhblwiOiB2ZSxcbiAgICAgIFwidG8tY29sb3JcIjogdmUsXG4gICAgICBcInRvLW51bWJlclwiOiB2ZSxcbiAgICAgIFwidG8tc3RyaW5nXCI6IHZlLFxuICAgICAgdmFyOiBqZSxcbiAgICAgIHdpdGhpbjogTGVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENyKHQsIGUpIHtcbiAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgIGkgPSBlWzJdLFxuICAgICAgICBhID0gZVszXTtcbiAgICAgIHIgPSByLmV2YWx1YXRlKHQpLCBuID0gbi5ldmFsdWF0ZSh0KSwgaSA9IGkuZXZhbHVhdGUodCk7XG4gICAgICB2YXIgbyA9IGEgPyBhLmV2YWx1YXRlKHQpIDogMSxcbiAgICAgICAgcyA9IG9lKHIsIG4sIGksIG8pO1xuICAgICAgaWYgKHMpIHRocm93IG5ldyBjZShzKTtcbiAgICAgIHJldHVybiBuZXcgZWUociAvIDI1NSAqIG8sIG4gLyAyNTUgKiBvLCBpIC8gMjU1ICogbywgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVyKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IGluIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFByKHQsIGUpIHtcbiAgICAgIHZhciByID0gZVt0XTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IHIgPyBudWxsIDogcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gTXIodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQnIodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBcInN1Y2Nlc3NcIixcbiAgICAgICAgdmFsdWU6IHRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogXCJlcnJvclwiLFxuICAgICAgICB2YWx1ZTogdFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVnIodCkge1xuICAgICAgcmV0dXJuIFwiZGF0YS1kcml2ZW5cIiA9PT0gdFtcInByb3BlcnR5LXR5cGVcIl0gfHwgXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiID09PSB0W1wicHJvcGVydHktdHlwZVwiXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRnIodCkge1xuICAgICAgcmV0dXJuICEhdC5leHByZXNzaW9uICYmIHQuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoXCJ6b29tXCIpID4gLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIERyKHQpIHtcbiAgICAgIHJldHVybiAhIXQuZXhwcmVzc2lvbiAmJiB0LmV4cHJlc3Npb24uaW50ZXJwb2xhdGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMcih0KSB7XG4gICAgICByZXR1cm4gdCBpbnN0YW5jZW9mIE51bWJlciA/IFwibnVtYmVyXCIgOiB0IGluc3RhbmNlb2YgU3RyaW5nID8gXCJzdHJpbmdcIiA6IHQgaW5zdGFuY2VvZiBCb29sZWFuID8gXCJib29sZWFuXCIgOiBBcnJheS5pc0FycmF5KHQpID8gXCJhcnJheVwiIDogbnVsbCA9PT0gdCA/IFwibnVsbFwiIDogdHlwZW9mIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJyKHQpIHtcbiAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIG51bGwgIT09IHQgJiYgIUFycmF5LmlzQXJyYXkodCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9yKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBVcih0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSB0ID8gdCA6IHZvaWQgMCAhPT0gZSA/IGUgOiB2b2lkIDAgIT09IHIgPyByIDogdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqcih0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4gVXIodHlwZW9mIHIgPT09IGkgPyBuW3JdIDogdm9pZCAwLCB0LmRlZmF1bHQsIGUuZGVmYXVsdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHFyKHQsIGUsIHIpIHtcbiAgICAgIGlmIChcIm51bWJlclwiICE9PSBMcihyKSkgcmV0dXJuIFVyKHQuZGVmYXVsdCwgZS5kZWZhdWx0KTtcbiAgICAgIHZhciBuID0gdC5zdG9wcy5sZW5ndGg7XG4gICAgICBpZiAoMSA9PT0gbikgcmV0dXJuIHQuc3RvcHNbMF1bMV07XG4gICAgICBpZiAociA8PSB0LnN0b3BzWzBdWzBdKSByZXR1cm4gdC5zdG9wc1swXVsxXTtcbiAgICAgIGlmIChyID49IHQuc3RvcHNbbiAtIDFdWzBdKSByZXR1cm4gdC5zdG9wc1tuIC0gMV1bMV07XG4gICAgICB2YXIgaSA9IE5lKHQuc3RvcHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0WzBdO1xuICAgICAgfSksIHIpO1xuICAgICAgcmV0dXJuIHQuc3RvcHNbaV1bMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5yKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdm9pZCAwICE9PSB0LmJhc2UgPyB0LmJhc2UgOiAxO1xuICAgICAgaWYgKFwibnVtYmVyXCIgIT09IExyKHIpKSByZXR1cm4gVXIodC5kZWZhdWx0LCBlLmRlZmF1bHQpO1xuICAgICAgdmFyIGkgPSB0LnN0b3BzLmxlbmd0aDtcbiAgICAgIGlmICgxID09PSBpKSByZXR1cm4gdC5zdG9wc1swXVsxXTtcbiAgICAgIGlmIChyIDw9IHQuc3RvcHNbMF1bMF0pIHJldHVybiB0LnN0b3BzWzBdWzFdO1xuICAgICAgaWYgKHIgPj0gdC5zdG9wc1tpIC0gMV1bMF0pIHJldHVybiB0LnN0b3BzW2kgLSAxXVsxXTtcbiAgICAgIHZhciBhID0gTmUodC5zdG9wcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdFswXTtcbiAgICAgICAgfSksIHIpLFxuICAgICAgICBvID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICB2YXIgaSA9IG4gLSByLFxuICAgICAgICAgICAgYSA9IHQgLSByO1xuICAgICAgICAgIHJldHVybiAwID09PSBpID8gMCA6IDEgPT09IGUgPyBhIC8gaSA6IChNYXRoLnBvdyhlLCBhKSAtIDEpIC8gKE1hdGgucG93KGUsIGkpIC0gMSk7XG4gICAgICAgIH0ociwgbiwgdC5zdG9wc1thXVswXSwgdC5zdG9wc1thICsgMV1bMF0pLFxuICAgICAgICBzID0gdC5zdG9wc1thXVsxXSxcbiAgICAgICAgdSA9IHQuc3RvcHNbYSArIDFdWzFdLFxuICAgICAgICBsID0gWmVbZS50eXBlXSB8fCBPcjtcbiAgICAgIGlmICh0LmNvbG9yU3BhY2UgJiYgXCJyZ2JcIiAhPT0gdC5jb2xvclNwYWNlKSB7XG4gICAgICAgIHZhciBwID0gYXJbdC5jb2xvclNwYWNlXTtcbiAgICAgICAgbCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHAucmV2ZXJzZShwLmludGVycG9sYXRlKHAuZm9yd2FyZCh0KSwgcC5mb3J3YXJkKGUpLCBvKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBzLmV2YWx1YXRlID8ge1xuICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIHQgPSBbXSwgZSA9IGFyZ3VtZW50cy5sZW5ndGg7IGUtLTspIHRbZV0gPSBhcmd1bWVudHNbZV07XG4gICAgICAgICAgdmFyIHIgPSBzLmV2YWx1YXRlLmFwcGx5KHZvaWQgMCwgdCksXG4gICAgICAgICAgICBuID0gdS5ldmFsdWF0ZS5hcHBseSh2b2lkIDAsIHQpO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIgJiYgdm9pZCAwICE9PSBuKSByZXR1cm4gbChyLCBuLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSA6IGwocywgdSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEtyKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBcImNvbG9yXCIgPT09IGUudHlwZSA/IHIgPSBlZS5wYXJzZShyKSA6IFwiZm9ybWF0dGVkXCIgPT09IGUudHlwZSA/IHIgPSBpZS5mcm9tU3RyaW5nKHIudG9TdHJpbmcoKSkgOiBcInJlc29sdmVkSW1hZ2VcIiA9PT0gZS50eXBlID8gciA9IGFlLmZyb21TdHJpbmcoci50b1N0cmluZygpKSA6IExyKHIpID09PSBlLnR5cGUgfHwgXCJlbnVtXCIgPT09IGUudHlwZSAmJiBlLnZhbHVlc1tyXSB8fCAociA9IHZvaWQgMCksIFVyKHIsIHQuZGVmYXVsdCwgZS5kZWZhdWx0KTtcbiAgICB9XG4gICAgYmUucmVnaXN0ZXIoenIsIHtcbiAgICAgIGVycm9yOiBbe1xuICAgICAgICBraW5kOiBcImVycm9yXCJcbiAgICAgIH0sIFtVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRocm93IG5ldyBjZShlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgdHlwZW9mOiBbVXQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBIdCh1ZShlWzBdLmV2YWx1YXRlKHQpKSk7XG4gICAgICB9XSxcbiAgICAgIFwidG8tcmdiYVwiOiBbSnQoT3QsIDQpLCBbcXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS50b0FycmF5KCk7XG4gICAgICB9XSxcbiAgICAgIHJnYjogW3F0LCBbT3QsIE90LCBPdF0sIENyXSxcbiAgICAgIHJnYmE6IFtxdCwgW090LCBPdCwgT3QsIE90XSwgQ3JdLFxuICAgICAgaGFzOiB7XG4gICAgICAgIHR5cGU6IGp0LFxuICAgICAgICBvdmVybG9hZHM6IFtbW1V0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gRXIoZVswXS5ldmFsdWF0ZSh0KSwgdC5wcm9wZXJ0aWVzKCkpO1xuICAgICAgICB9XSwgW1tVdCwgTnRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gZVsxXTtcbiAgICAgICAgICByZXR1cm4gRXIoZVswXS5ldmFsdWF0ZSh0KSwgci5ldmFsdWF0ZSh0KSk7XG4gICAgICAgIH1dXVxuICAgICAgfSxcbiAgICAgIGdldDoge1xuICAgICAgICB0eXBlOiBLdCxcbiAgICAgICAgb3ZlcmxvYWRzOiBbW1tVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIFByKGVbMF0uZXZhbHVhdGUodCksIHQucHJvcGVydGllcygpKTtcbiAgICAgICAgfV0sIFtbVXQsIE50XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgICAgcmV0dXJuIFByKGVbMF0uZXZhbHVhdGUodCksIHIuZXZhbHVhdGUodCkpO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBcImZlYXR1cmUtc3RhdGVcIjogW0t0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gUHIoZVswXS5ldmFsdWF0ZSh0KSwgdC5mZWF0dXJlU3RhdGUgfHwge30pO1xuICAgICAgfV0sXG4gICAgICBwcm9wZXJ0aWVzOiBbTnQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5wcm9wZXJ0aWVzKCk7XG4gICAgICB9XSxcbiAgICAgIFwiZ2VvbWV0cnktdHlwZVwiOiBbVXQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5nZW9tZXRyeVR5cGUoKTtcbiAgICAgIH1dLFxuICAgICAgaWQ6IFtLdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkKCk7XG4gICAgICB9XSxcbiAgICAgIHpvb206IFtPdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0Lmdsb2JhbHMuem9vbTtcbiAgICAgIH1dLFxuICAgICAgXCJoZWF0bWFwLWRlbnNpdHlcIjogW090LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwO1xuICAgICAgfV0sXG4gICAgICBcImxpbmUtcHJvZ3Jlc3NcIjogW090LCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMDtcbiAgICAgIH1dLFxuICAgICAgYWNjdW11bGF0ZWQ6IFtLdCwgW10sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IHQuZ2xvYmFscy5hY2N1bXVsYXRlZCA/IG51bGwgOiB0Lmdsb2JhbHMuYWNjdW11bGF0ZWQ7XG4gICAgICB9XSxcbiAgICAgIFwiK1wiOiBbT3QsIE1yKE90KSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDAsIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHIgKz0gaVtuXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XSxcbiAgICAgIFwiKlwiOiBbT3QsIE1yKE90KSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDEsIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHIgKj0gaVtuXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XSxcbiAgICAgIFwiLVwiOiB7XG4gICAgICAgIHR5cGU6IE90LFxuICAgICAgICBvdmVybG9hZHM6IFtbW090LCBPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpIC0gci5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfV0sIFtbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiAtZVswXS5ldmFsdWF0ZSh0KTtcbiAgICAgICAgfV1dXG4gICAgICB9LFxuICAgICAgXCIvXCI6IFtPdCwgW090LCBPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVsxXTtcbiAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkgLyByLmV2YWx1YXRlKHQpO1xuICAgICAgfV0sXG4gICAgICBcIiVcIjogW090LCBbT3QsIE90XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KSAlIHIuZXZhbHVhdGUodCk7XG4gICAgICB9XSxcbiAgICAgIGxuMjogW090LCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5MTjI7XG4gICAgICB9XSxcbiAgICAgIHBpOiBbT3QsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgfV0sXG4gICAgICBlOiBbT3QsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLkU7XG4gICAgICB9XSxcbiAgICAgIFwiXlwiOiBbT3QsIFtPdCwgT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMV07XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhlWzBdLmV2YWx1YXRlKHQpLCByLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgc3FydDogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBsb2cxMDogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coZVswXS5ldmFsdWF0ZSh0KSkgLyBNYXRoLkxOMTA7XG4gICAgICB9XSxcbiAgICAgIGxuOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyhlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgbG9nMjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coZVswXS5ldmFsdWF0ZSh0KSkgLyBNYXRoLkxOMjtcbiAgICAgIH1dLFxuICAgICAgc2luOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbihlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgY29zOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNvcyhlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgdGFuOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRhbihlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgYXNpbjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hc2luKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBhY29zOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIGF0YW46IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbihlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgbWluOiBbT3QsIE1yKE90KSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGUubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZXZhbHVhdGUodCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1dLFxuICAgICAgbWF4OiBbT3QsIE1yKE90KSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIGUubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZXZhbHVhdGUodCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1dLFxuICAgICAgYWJzOiBbT3QsIFtPdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgcm91bmQ6IFtPdCwgW090XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLmV2YWx1YXRlKHQpO1xuICAgICAgICByZXR1cm4gciA8IDAgPyAtTWF0aC5yb3VuZCgtcikgOiBNYXRoLnJvdW5kKHIpO1xuICAgICAgfV0sXG4gICAgICBmbG9vcjogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihlWzBdLmV2YWx1YXRlKHQpKTtcbiAgICAgIH1dLFxuICAgICAgY2VpbDogW090LCBbT3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGVbMF0uZXZhbHVhdGUodCkpO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci09PVwiOiBbanQsIFtVdCwgS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IGVbMV07XG4gICAgICAgIHJldHVybiB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSA9PT0gbi52YWx1ZTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPT1cIjogW2p0LCBbS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF07XG4gICAgICAgIHJldHVybiB0LmlkKCkgPT09IHIudmFsdWU7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLXR5cGUtPT1cIjogW2p0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF07XG4gICAgICAgIHJldHVybiB0Lmdlb21ldHJ5VHlwZSgpID09PSByLnZhbHVlO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci08XCI6IFtqdCwgW1V0LCBLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICBuID0gZVsxXSxcbiAgICAgICAgICBpID0gdC5wcm9wZXJ0aWVzKClbci52YWx1ZV0sXG4gICAgICAgICAgYSA9IG4udmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaSA9PSB0eXBlb2YgYSAmJiBpIDwgYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPFwiOiBbanQsIFtLdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgICBuID0gdC5pZCgpLFxuICAgICAgICAgIGkgPSByLnZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT0gdHlwZW9mIGkgJiYgbiA8IGk7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLT5cIjogW2p0LCBbVXQsIEt0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgIGkgPSB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSxcbiAgICAgICAgICBhID0gbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpID09IHR5cGVvZiBhICYmIGkgPiBhO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci1pZC0+XCI6IFtqdCwgW0t0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgIG4gPSB0LmlkKCksXG4gICAgICAgICAgaSA9IHIudmFsdWU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PSB0eXBlb2YgaSAmJiBuID4gaTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPD1cIjogW2p0LCBbVXQsIEt0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgIGkgPSB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSxcbiAgICAgICAgICBhID0gbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpID09IHR5cGVvZiBhICYmIGkgPD0gYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPD1cIjogW2p0LCBbS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IHQuaWQoKSxcbiAgICAgICAgICBpID0gci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBpICYmIG4gPD0gaTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItPj1cIjogW2p0LCBbVXQsIEt0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSBlWzBdLFxuICAgICAgICAgIG4gPSBlWzFdLFxuICAgICAgICAgIGkgPSB0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSxcbiAgICAgICAgICBhID0gbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpID09IHR5cGVvZiBhICYmIGkgPj0gYTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtPj1cIjogW2p0LCBbS3RdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IHQuaWQoKSxcbiAgICAgICAgICBpID0gci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09IHR5cGVvZiBpICYmIG4gPj0gaTtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaGFzXCI6IFtqdCwgW0t0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMF0udmFsdWUgaW4gdC5wcm9wZXJ0aWVzKCk7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWhhcy1pZFwiOiBbanQsIFtdLCBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdC5pZCgpICYmIHZvaWQgMCAhPT0gdC5pZCgpO1xuICAgICAgfV0sXG4gICAgICBcImZpbHRlci10eXBlLWluXCI6IFtqdCwgW0p0KFV0KV0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlWzBdLnZhbHVlLmluZGV4T2YodC5nZW9tZXRyeVR5cGUoKSkgPj0gMDtcbiAgICAgIH1dLFxuICAgICAgXCJmaWx0ZXItaWQtaW5cIjogW2p0LCBbSnQoS3QpXSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMF0udmFsdWUuaW5kZXhPZih0LmlkKCkpID49IDA7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWluLXNtYWxsXCI6IFtqdCwgW1V0LCBKdChLdCldLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF07XG4gICAgICAgIHJldHVybiBlWzFdLnZhbHVlLmluZGV4T2YodC5wcm9wZXJ0aWVzKClbci52YWx1ZV0pID49IDA7XG4gICAgICB9XSxcbiAgICAgIFwiZmlsdGVyLWluLWxhcmdlXCI6IFtqdCwgW1V0LCBKdChLdCldLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgICAgbiA9IGVbMV07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIGZvciAoOyByIDw9IG47KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHIgKyBuID4+IDE7XG4gICAgICAgICAgICBpZiAoZVtpXSA9PT0gdCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgZVtpXSA+IHQgPyBuID0gaSAtIDEgOiByID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSh0LnByb3BlcnRpZXMoKVtyLnZhbHVlXSwgbi52YWx1ZSwgMCwgbi52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgIH1dLFxuICAgICAgYWxsOiB7XG4gICAgICAgIHR5cGU6IGp0LFxuICAgICAgICBvdmVybG9hZHM6IFtbW2p0LCBqdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpICYmIHIuZXZhbHVhdGUodCk7XG4gICAgICAgIH1dLCBbTXIoanQpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gZTsgciA8IG4ubGVuZ3RoOyByICs9IDEpIGlmICghbltyXS5ldmFsdWF0ZSh0KSkgcmV0dXJuICExO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfV1dXG4gICAgICB9LFxuICAgICAgYW55OiB7XG4gICAgICAgIHR5cGU6IGp0LFxuICAgICAgICBvdmVybG9hZHM6IFtbW2p0LCBqdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIgPSBlWzFdO1xuICAgICAgICAgIHJldHVybiBlWzBdLmV2YWx1YXRlKHQpIHx8IHIuZXZhbHVhdGUodCk7XG4gICAgICAgIH1dLCBbTXIoanQpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gZTsgciA8IG4ubGVuZ3RoOyByICs9IDEpIGlmIChuW3JdLmV2YWx1YXRlKHQpKSByZXR1cm4gITA7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XV1cbiAgICAgIH0sXG4gICAgICBcIiFcIjogW2p0LCBbanRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gIWVbMF0uZXZhbHVhdGUodCk7XG4gICAgICB9XSxcbiAgICAgIFwiaXMtc3VwcG9ydGVkLXNjcmlwdFwiOiBbanQsIFtVdF0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gdC5nbG9iYWxzICYmIHQuZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcbiAgICAgICAgcmV0dXJuICFyIHx8IHIoZVswXS5ldmFsdWF0ZSh0KSk7XG4gICAgICB9XSxcbiAgICAgIHVwY2FzZTogW1V0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfV0sXG4gICAgICBkb3duY2FzZTogW1V0LCBbVXRdLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZVswXS5ldmFsdWF0ZSh0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfV0sXG4gICAgICBjb25jYXQ6IFtVdCwgTXIoS3QpLCBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gbGUoZS5ldmFsdWF0ZSh0KSk7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9XSxcbiAgICAgIFwicmVzb2x2ZWQtbG9jYWxlXCI6IFtVdCwgW0d0XSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMF0uZXZhbHVhdGUodCkucmVzb2x2ZWRMb2NhbGUoKTtcbiAgICAgIH1dXG4gICAgfSk7XG4gICAgdmFyIEdyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHQsIHRoaXMuX3dhcm5pbmdIaXN0b3J5ID0ge30sIHRoaXMuX2V2YWx1YXRvciA9IG5ldyB4ZSgpLCB0aGlzLl9kZWZhdWx0VmFsdWUgPSBlID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFwiY29sb3JcIiA9PT0gdC50eXBlICYmIFJyKHQuZGVmYXVsdCkgPyBuZXcgZWUoMCwgMCwgMCwgMCkgOiBcImNvbG9yXCIgPT09IHQudHlwZSA/IGVlLnBhcnNlKHQuZGVmYXVsdCkgfHwgbnVsbCA6IHZvaWQgMCA9PT0gdC5kZWZhdWx0ID8gbnVsbCA6IHQuZGVmYXVsdDtcbiAgICAgIH0oZSkgOiBudWxsLCB0aGlzLl9lbnVtVmFsdWVzID0gZSAmJiBcImVudW1cIiA9PT0gZS50eXBlID8gZS52YWx1ZXMgOiBudWxsO1xuICAgIH07XG4gICAgZnVuY3Rpb24gWnIodCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgJiYgdC5sZW5ndGggPiAwICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRbMF0gJiYgdFswXSBpbiB6cjtcbiAgICB9XG4gICAgZnVuY3Rpb24gWHIodCwgZSkge1xuICAgICAgdmFyIHIgPSBuZXcgcWUoenIsIFtdLCBlID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBxdCxcbiAgICAgICAgICAgIHN0cmluZzogVXQsXG4gICAgICAgICAgICBudW1iZXI6IE90LFxuICAgICAgICAgICAgZW51bTogVXQsXG4gICAgICAgICAgICBib29sZWFuOiBqdCxcbiAgICAgICAgICAgIGZvcm1hdHRlZDogWnQsXG4gICAgICAgICAgICByZXNvbHZlZEltYWdlOiBYdFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIiA9PT0gdC50eXBlID8gSnQoZVt0LnZhbHVlXSB8fCBLdCwgdC5sZW5ndGgpIDogZVt0LnR5cGVdO1xuICAgICAgICB9KGUpIDogdm9pZCAwKSxcbiAgICAgICAgbiA9IHIucGFyc2UodCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZSAmJiBcInN0cmluZ1wiID09PSBlLnR5cGUgPyB7XG4gICAgICAgICAgdHlwZUFubm90YXRpb246IFwiY29lcmNlXCJcbiAgICAgICAgfSA6IHZvaWQgMCk7XG4gICAgICByZXR1cm4gbiA/IEJyKG5ldyBHcihuLCBlKSkgOiBUcihyLmVycm9ycyk7XG4gICAgfVxuICAgIEdyLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IHQsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZSwgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IHIsIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBuLCB0aGlzLl9ldmFsdWF0b3IuYXZhaWxhYmxlSW1hZ2VzID0gaSB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGEsIHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xuICAgIH0sIEdyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IHQsIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZSB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gciB8fCBudWxsLCB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gbiwgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGkgfHwgbnVsbCwgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBhIHx8IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbyA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZSh0aGlzLl9ldmFsdWF0b3IpO1xuICAgICAgICBpZiAobnVsbCA9PSBvIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIG8gJiYgbyAhPSBvKSByZXR1cm4gdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fZW51bVZhbHVlcyAmJiAhKG8gaW4gdGhpcy5fZW51bVZhbHVlcykpIHRocm93IG5ldyBjZShcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9uZSBvZiBcIiArIE9iamVjdC5rZXlzKHRoaXMuX2VudW1WYWx1ZXMpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0KTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpICsgXCIsIGJ1dCBmb3VuZCBcIiArIEpTT04uc3RyaW5naWZ5KG8pICsgXCIgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FybmluZ0hpc3RvcnlbdC5tZXNzYWdlXSB8fCAodGhpcy5fd2FybmluZ0hpc3RvcnlbdC5tZXNzYWdlXSA9ICEwLCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBjb25zb2xlICYmIGNvbnNvbGUud2Fybih0Lm1lc3NhZ2UpKSwgdGhpcy5fZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIEpyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMua2luZCA9IHQsIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGUsIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IFwiY29uc3RhbnRcIiAhPT0gdCAmJiAhT2UoZS5leHByZXNzaW9uKTtcbiAgICB9O1xuICAgIEpyLnByb3RvdHlwZS5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyh0LCBlLCByLCBuLCBpLCBhKTtcbiAgICB9LCBKci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZSh0LCBlLCByLCBuLCBpLCBhKTtcbiAgICB9O1xuICAgIHZhciBIciA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB0aGlzLmtpbmQgPSB0LCB0aGlzLnpvb21TdG9wcyA9IHIsIHRoaXMuX3N0eWxlRXhwcmVzc2lvbiA9IGUsIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IFwiY2FtZXJhXCIgIT09IHQgJiYgIU9lKGUuZXhwcmVzc2lvbiksIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBuO1xuICAgIH07XG4gICAgZnVuY3Rpb24gWXIodCwgZSkge1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gKHQgPSBYcih0LCBlKSkucmVzdWx0KSByZXR1cm4gdDtcbiAgICAgIHZhciByID0gdC52YWx1ZS5leHByZXNzaW9uLFxuICAgICAgICBuID0gUmUocik7XG4gICAgICBpZiAoIW4gJiYgIVZyKGUpKSByZXR1cm4gVHIoW25ldyBEdChcIlwiLCBcImRhdGEgZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZFwiKV0pO1xuICAgICAgdmFyIGkgPSBVZShyLCBbXCJ6b29tXCJdKTtcbiAgICAgIGlmICghaSAmJiAhRnIoZSkpIHJldHVybiBUcihbbmV3IER0KFwiXCIsIFwiem9vbSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkXCIpXSk7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICB2YXIgciA9IG51bGw7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgbHIpIHIgPSB0KGUucmVzdWx0KTtlbHNlIGlmIChlIGluc3RhbmNlb2YgdXIpIGZvciAodmFyIG4gPSAwLCBpID0gZS5hcmdzOyBuIDwgaS5sZW5ndGggJiYgIShyID0gdChpW25dKSk7IG4gKz0gMSk7ZWxzZSAoZSBpbnN0YW5jZW9mIEtlIHx8IGUgaW5zdGFuY2VvZiBvcikgJiYgZS5pbnB1dCBpbnN0YW5jZW9mIGJlICYmIFwiem9vbVwiID09PSBlLmlucHV0Lm5hbWUgJiYgKHIgPSBlKTtcbiAgICAgICAgcmV0dXJuIHIgaW5zdGFuY2VvZiBEdCB8fCBlLmVhY2hDaGlsZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBuID0gdChlKTtcbiAgICAgICAgICBuIGluc3RhbmNlb2YgRHQgPyByID0gbiA6ICFyICYmIG4gPyByID0gbmV3IER0KFwiXCIsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJykgOiByICYmIG4gJiYgciAhPT0gbiAmJiAociA9IG5ldyBEdChcIlwiLCAnT25seSBvbmUgem9vbS1iYXNlZCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpKTtcbiAgICAgICAgfSksIHI7XG4gICAgICB9KHIpO1xuICAgICAgcmV0dXJuIGEgfHwgaSA/IGEgaW5zdGFuY2VvZiBEdCA/IFRyKFthXSkgOiBhIGluc3RhbmNlb2Ygb3IgJiYgIURyKGUpID8gVHIoW25ldyBEdChcIlwiLCAnXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIGNhbm5vdCBiZSB1c2VkIHdpdGggdGhpcyBwcm9wZXJ0eScpXSkgOiBCcihhID8gbmV3IEhyKG4gPyBcImNhbWVyYVwiIDogXCJjb21wb3NpdGVcIiwgdC52YWx1ZSwgYS5sYWJlbHMsIGEgaW5zdGFuY2VvZiBvciA/IGEuaW50ZXJwb2xhdGlvbiA6IHZvaWQgMCkgOiBuZXcgSnIobiA/IFwiY29uc3RhbnRcIiA6IFwic291cmNlXCIsIHQudmFsdWUpKSA6IFRyKFtuZXcgRHQoXCJcIiwgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKV0pO1xuICAgIH1cbiAgICBIci5wcm90b3R5cGUuZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcodCwgZSwgciwgbiwgaSwgYSk7XG4gICAgfSwgSHIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGUodCwgZSwgciwgbiwgaSwgYSk7XG4gICAgfSwgSHIucHJvdG90eXBlLmludGVycG9sYXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPyBvci5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvblR5cGUsIHQsIGUsIHIpIDogMDtcbiAgICB9O1xuICAgIHZhciAkciA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLl9wYXJhbWV0ZXJzID0gdCwgdGhpcy5fc3BlY2lmaWNhdGlvbiA9IGUsIFR0KHRoaXMsIGZ1bmN0aW9uIHQoZSwgcikge1xuICAgICAgICB2YXIgbixcbiAgICAgICAgICBpLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbyA9IFwiY29sb3JcIiA9PT0gci50eXBlLFxuICAgICAgICAgIHMgPSBlLnN0b3BzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUuc3RvcHNbMF1bMF0sXG4gICAgICAgICAgdSA9IHMgfHwgIShzIHx8IHZvaWQgMCAhPT0gZS5wcm9wZXJ0eSksXG4gICAgICAgICAgbCA9IGUudHlwZSB8fCAoRHIocikgPyBcImV4cG9uZW50aWFsXCIgOiBcImludGVydmFsXCIpO1xuICAgICAgICBpZiAobyAmJiAoKGUgPSBUdCh7fSwgZSkpLnN0b3BzICYmIChlLnN0b3BzID0gZS5zdG9wcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gW3RbMF0sIGVlLnBhcnNlKHRbMV0pXTtcbiAgICAgICAgfSkpLCBlLmRlZmF1bHQgPSBlZS5wYXJzZShlLmRlZmF1bHQgPyBlLmRlZmF1bHQgOiByLmRlZmF1bHQpKSwgZS5jb2xvclNwYWNlICYmIFwicmdiXCIgIT09IGUuY29sb3JTcGFjZSAmJiAhYXJbZS5jb2xvclNwYWNlXSkgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBzcGFjZTogXCIgKyBlLmNvbG9yU3BhY2UpO1xuICAgICAgICBpZiAoXCJleHBvbmVudGlhbFwiID09PSBsKSBuID0gTnI7ZWxzZSBpZiAoXCJpbnRlcnZhbFwiID09PSBsKSBuID0gcXI7ZWxzZSBpZiAoXCJjYXRlZ29yaWNhbFwiID09PSBsKSB7XG4gICAgICAgICAgbiA9IGpyLCBpID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBmb3IgKHZhciBwID0gMCwgYyA9IGUuc3RvcHM7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaCA9IGNbcF07XG4gICAgICAgICAgICBpW2hbMF1dID0gaFsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYSA9IHR5cGVvZiBlLnN0b3BzWzBdWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChcImlkZW50aXR5XCIgIT09IGwpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmdW5jdGlvbiB0eXBlIFwiJyArIGwgKyAnXCInKTtcbiAgICAgICAgICBuID0gS3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBmID0ge30sIHkgPSBbXSwgZCA9IDA7IGQgPCBlLnN0b3BzLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGUuc3RvcHNbZF0sXG4gICAgICAgICAgICAgIHYgPSBtWzBdLnpvb207XG4gICAgICAgICAgICB2b2lkIDAgPT09IGZbdl0gJiYgKGZbdl0gPSB7XG4gICAgICAgICAgICAgIHpvb206IHYsXG4gICAgICAgICAgICAgIHR5cGU6IGUudHlwZSxcbiAgICAgICAgICAgICAgcHJvcGVydHk6IGUucHJvcGVydHksXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGUuZGVmYXVsdCxcbiAgICAgICAgICAgICAgc3RvcHM6IFtdXG4gICAgICAgICAgICB9LCB5LnB1c2godikpLCBmW3ZdLnN0b3BzLnB1c2goW21bMF0udmFsdWUsIG1bMV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgZyA9IFtdLCB4ID0gMCwgYiA9IHk7IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGJbeF07XG4gICAgICAgICAgICBnLnB1c2goW2Zbd10uem9vbSwgdChmW3ddLCByKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgXyA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwibGluZWFyXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiBcImNvbXBvc2l0ZVwiLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IF8sXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uRmFjdG9yOiBvci5pbnRlcnBvbGF0aW9uRmFjdG9yLmJpbmQodm9pZCAwLCBfKSxcbiAgICAgICAgICAgIHpvb21TdG9wczogZy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRbMF07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgICB2YXIgaSA9IHQuem9vbTtcbiAgICAgICAgICAgICAgcmV0dXJuIE5yKHtcbiAgICAgICAgICAgICAgICBzdG9wczogZyxcbiAgICAgICAgICAgICAgICBiYXNlOiBlLmJhc2VcbiAgICAgICAgICAgICAgfSwgciwgaSkuZXZhbHVhdGUoaSwgbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciBBID0gXCJleHBvbmVudGlhbFwiID09PSBsID8ge1xuICAgICAgICAgICAgbmFtZTogXCJleHBvbmVudGlhbFwiLFxuICAgICAgICAgICAgYmFzZTogdm9pZCAwICE9PSBlLmJhc2UgPyBlLmJhc2UgOiAxXG4gICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IFwiY2FtZXJhXCIsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogQSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb25GYWN0b3I6IG9yLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh2b2lkIDAsIEEpLFxuICAgICAgICAgICAgem9vbVN0b3BzOiBlLnN0b3BzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdFswXTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuKGUsIHIsIHQuem9vbSwgaSwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtpbmQ6IFwic291cmNlXCIsXG4gICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICh0LCBvKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG8gJiYgby5wcm9wZXJ0aWVzID8gby5wcm9wZXJ0aWVzW2UucHJvcGVydHldIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gcyA/IFVyKGUuZGVmYXVsdCwgci5kZWZhdWx0KSA6IG4oZSwgciwgcywgaSwgYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSh0aGlzLl9wYXJhbWV0ZXJzLCB0aGlzLl9zcGVjaWZpY2F0aW9uKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBXcih0KSB7XG4gICAgICB2YXIgZSA9IHQua2V5LFxuICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgbiA9IHQudmFsdWVTcGVjIHx8IHt9LFxuICAgICAgICBpID0gdC5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fSxcbiAgICAgICAgYSA9IHQuc3R5bGUsXG4gICAgICAgIG8gPSB0LnN0eWxlU3BlYyxcbiAgICAgICAgcyA9IFtdLFxuICAgICAgICB1ID0gTHIocik7XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdSkgcmV0dXJuIFtuZXcgTXQoZSwgciwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgdSArIFwiIGZvdW5kXCIpXTtcbiAgICAgIGZvciAodmFyIGwgaW4gcikge1xuICAgICAgICB2YXIgcCA9IGwuc3BsaXQoXCIuXCIpWzBdLFxuICAgICAgICAgIGMgPSBuW3BdIHx8IG5bXCIqXCJdLFxuICAgICAgICAgIGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChpW3BdKSBoID0gaVtwXTtlbHNlIGlmIChuW3BdKSBoID0gU247ZWxzZSBpZiAoaVtcIipcIl0pIGggPSBpW1wiKlwiXTtlbHNlIHtcbiAgICAgICAgICBpZiAoIW5bXCIqXCJdKSB7XG4gICAgICAgICAgICBzLnB1c2gobmV3IE10KGUsIHJbbF0sICd1bmtub3duIHByb3BlcnR5IFwiJyArIGwgKyAnXCInKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaCA9IFNuO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzLmNvbmNhdChoKHtcbiAgICAgICAgICBrZXk6IChlID8gZSArIFwiLlwiIDogZSkgKyBsLFxuICAgICAgICAgIHZhbHVlOiByW2xdLFxuICAgICAgICAgIHZhbHVlU3BlYzogYyxcbiAgICAgICAgICBzdHlsZTogYSxcbiAgICAgICAgICBzdHlsZVNwZWM6IG8sXG4gICAgICAgICAgb2JqZWN0OiByLFxuICAgICAgICAgIG9iamVjdEtleTogbFxuICAgICAgICB9LCByKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBmIGluIG4pIGlbZl0gfHwgbltmXS5yZXF1aXJlZCAmJiB2b2lkIDAgPT09IG5bZl0uZGVmYXVsdCAmJiB2b2lkIDAgPT09IHJbZl0gJiYgcy5wdXNoKG5ldyBNdChlLCByLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIicgKyBmICsgJ1wiJykpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFyKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgciA9IHQudmFsdWVTcGVjLFxuICAgICAgICBuID0gdC5zdHlsZSxcbiAgICAgICAgaSA9IHQuc3R5bGVTcGVjLFxuICAgICAgICBhID0gdC5rZXksXG4gICAgICAgIG8gPSB0LmFycmF5RWxlbWVudFZhbGlkYXRvciB8fCBTbjtcbiAgICAgIGlmIChcImFycmF5XCIgIT09IExyKGUpKSByZXR1cm4gW25ldyBNdChhLCBlLCBcImFycmF5IGV4cGVjdGVkLCBcIiArIExyKGUpICsgXCIgZm91bmRcIildO1xuICAgICAgaWYgKHIubGVuZ3RoICYmIGUubGVuZ3RoICE9PSByLmxlbmd0aCkgcmV0dXJuIFtuZXcgTXQoYSwgZSwgXCJhcnJheSBsZW5ndGggXCIgKyByLmxlbmd0aCArIFwiIGV4cGVjdGVkLCBsZW5ndGggXCIgKyBlLmxlbmd0aCArIFwiIGZvdW5kXCIpXTtcbiAgICAgIGlmIChyW1wibWluLWxlbmd0aFwiXSAmJiBlLmxlbmd0aCA8IHJbXCJtaW4tbGVuZ3RoXCJdKSByZXR1cm4gW25ldyBNdChhLCBlLCBcImFycmF5IGxlbmd0aCBhdCBsZWFzdCBcIiArIHJbXCJtaW4tbGVuZ3RoXCJdICsgXCIgZXhwZWN0ZWQsIGxlbmd0aCBcIiArIGUubGVuZ3RoICsgXCIgZm91bmRcIildO1xuICAgICAgdmFyIHMgPSB7XG4gICAgICAgIHR5cGU6IHIudmFsdWUsXG4gICAgICAgIHZhbHVlczogci52YWx1ZXNcbiAgICAgIH07XG4gICAgICBpLiR2ZXJzaW9uIDwgNyAmJiAocy5mdW5jdGlvbiA9IHIuZnVuY3Rpb24pLCBcIm9iamVjdFwiID09PSBMcihyLnZhbHVlKSAmJiAocyA9IHIudmFsdWUpO1xuICAgICAgZm9yICh2YXIgdSA9IFtdLCBsID0gMDsgbCA8IGUubGVuZ3RoOyBsKyspIHUgPSB1LmNvbmNhdChvKHtcbiAgICAgICAgYXJyYXk6IGUsXG4gICAgICAgIGFycmF5SW5kZXg6IGwsXG4gICAgICAgIHZhbHVlOiBlW2xdLFxuICAgICAgICB2YWx1ZVNwZWM6IHMsXG4gICAgICAgIHN0eWxlOiBuLFxuICAgICAgICBzdHlsZVNwZWM6IGksXG4gICAgICAgIGtleTogYSArIFwiW1wiICsgbCArIFwiXVwiXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG4odCkge1xuICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgciA9IHQudmFsdWUsXG4gICAgICAgIG4gPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgaSA9IExyKHIpO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT09IGkgJiYgciAhPSByICYmIChpID0gXCJOYU5cIiksIFwibnVtYmVyXCIgIT09IGkgPyBbbmV3IE10KGUsIHIsIFwibnVtYmVyIGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKV0gOiBcIm1pbmltdW1cIiBpbiBuICYmIHIgPCBuLm1pbmltdW0gPyBbbmV3IE10KGUsIHIsIHIgKyBcIiBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUgXCIgKyBuLm1pbmltdW0pXSA6IFwibWF4aW11bVwiIGluIG4gJiYgciA+IG4ubWF4aW11bSA/IFtuZXcgTXQoZSwgciwgciArIFwiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSBcIiArIG4ubWF4aW11bSldIDogW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuKHQpIHtcbiAgICAgIHZhciBlLFxuICAgICAgICByLFxuICAgICAgICBuLFxuICAgICAgICBpID0gdC52YWx1ZVNwZWMsXG4gICAgICAgIGEgPSBWdCh0LnZhbHVlLnR5cGUpLFxuICAgICAgICBvID0ge30sXG4gICAgICAgIHMgPSBcImNhdGVnb3JpY2FsXCIgIT09IGEgJiYgdm9pZCAwID09PSB0LnZhbHVlLnByb3BlcnR5LFxuICAgICAgICB1ID0gIXMsXG4gICAgICAgIGwgPSBcImFycmF5XCIgPT09IExyKHQudmFsdWUuc3RvcHMpICYmIFwiYXJyYXlcIiA9PT0gTHIodC52YWx1ZS5zdG9wc1swXSkgJiYgXCJvYmplY3RcIiA9PT0gTHIodC52YWx1ZS5zdG9wc1swXVswXSksXG4gICAgICAgIHAgPSBXcih7XG4gICAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgICB2YWx1ZTogdC52YWx1ZSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IHQuc3R5bGVTcGVjLmZ1bmN0aW9uLFxuICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIHN0b3BzOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICBpZiAoXCJpZGVudGl0eVwiID09PSBhKSByZXR1cm4gW25ldyBNdCh0LmtleSwgdC52YWx1ZSwgJ2lkZW50aXR5IGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBhIFwic3RvcHNcIiBwcm9wZXJ0eScpXTtcbiAgICAgICAgICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICAgICAgICByID0gdC52YWx1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGUgPSBlLmNvbmNhdChRcih7XG4gICAgICAgICAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHQudmFsdWVTcGVjLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgYXJyYXlFbGVtZW50VmFsaWRhdG9yOiBjXG4gICAgICAgICAgICAgIH0pKSwgXCJhcnJheVwiID09PSBMcihyKSAmJiAwID09PSByLmxlbmd0aCAmJiBlLnB1c2gobmV3IE10KHQua2V5LCByLCBcImFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcFwiKSksIGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNuKHtcbiAgICAgICAgICAgICAgICBrZXk6IHQua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogaSxcbiAgICAgICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gXCJpZGVudGl0eVwiID09PSBhICYmIHMgJiYgcC5wdXNoKG5ldyBNdCh0LmtleSwgdC52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJwcm9wZXJ0eVwiJykpLCBcImlkZW50aXR5XCIgPT09IGEgfHwgdC52YWx1ZS5zdG9wcyB8fCBwLnB1c2gobmV3IE10KHQua2V5LCB0LnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInN0b3BzXCInKSksIFwiZXhwb25lbnRpYWxcIiA9PT0gYSAmJiB0LnZhbHVlU3BlYy5leHByZXNzaW9uICYmICFEcih0LnZhbHVlU3BlYykgJiYgcC5wdXNoKG5ldyBNdCh0LmtleSwgdC52YWx1ZSwgXCJleHBvbmVudGlhbCBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZFwiKSksIHQuc3R5bGVTcGVjLiR2ZXJzaW9uID49IDggJiYgKHUgJiYgIVZyKHQudmFsdWVTcGVjKSA/IHAucHVzaChuZXcgTXQodC5rZXksIHQudmFsdWUsIFwicHJvcGVydHkgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIikpIDogcyAmJiAhRnIodC52YWx1ZVNwZWMpICYmIHAucHVzaChuZXcgTXQodC5rZXksIHQudmFsdWUsIFwiem9vbSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZFwiKSkpLCBcImNhdGVnb3JpY2FsXCIgIT09IGEgJiYgIWwgfHwgdm9pZCAwICE9PSB0LnZhbHVlLnByb3BlcnR5IHx8IHAucHVzaChuZXcgTXQodC5rZXksIHQudmFsdWUsICdcInByb3BlcnR5XCIgcHJvcGVydHkgaXMgcmVxdWlyZWQnKSksIHA7XG4gICAgICBmdW5jdGlvbiBjKHQpIHtcbiAgICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICBhID0gdC52YWx1ZSxcbiAgICAgICAgICBzID0gdC5rZXk7XG4gICAgICAgIGlmIChcImFycmF5XCIgIT09IExyKGEpKSByZXR1cm4gW25ldyBNdChzLCBhLCBcImFycmF5IGV4cGVjdGVkLCBcIiArIExyKGEpICsgXCIgZm91bmRcIildO1xuICAgICAgICBpZiAoMiAhPT0gYS5sZW5ndGgpIHJldHVybiBbbmV3IE10KHMsIGEsIFwiYXJyYXkgbGVuZ3RoIDIgZXhwZWN0ZWQsIGxlbmd0aCBcIiArIGEubGVuZ3RoICsgXCIgZm91bmRcIildO1xuICAgICAgICBpZiAobCkge1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSBMcihhWzBdKSkgcmV0dXJuIFtuZXcgTXQocywgYSwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgTHIoYVswXSkgKyBcIiBmb3VuZFwiKV07XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYVswXS56b29tKSByZXR1cm4gW25ldyBNdChzLCBhLCBcIm9iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgem9vbVwiKV07XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYVswXS52YWx1ZSkgcmV0dXJuIFtuZXcgTXQocywgYSwgXCJvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHZhbHVlXCIpXTtcbiAgICAgICAgICBpZiAobiAmJiBuID4gVnQoYVswXS56b29tKSkgcmV0dXJuIFtuZXcgTXQocywgYVswXS56b29tLCBcInN0b3Agem9vbSB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyXCIpXTtcbiAgICAgICAgICBWdChhWzBdLnpvb20pICE9PSBuICYmIChuID0gVnQoYVswXS56b29tKSwgciA9IHZvaWQgMCwgbyA9IHt9KSwgZSA9IGUuY29uY2F0KFdyKHtcbiAgICAgICAgICAgIGtleTogcyArIFwiWzBdXCIsXG4gICAgICAgICAgICB2YWx1ZTogYVswXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzoge1xuICAgICAgICAgICAgICB6b29tOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlYyxcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAgIHpvb206IHRuLFxuICAgICAgICAgICAgICB2YWx1ZTogaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGUgPSBlLmNvbmNhdChoKHtcbiAgICAgICAgICBrZXk6IHMgKyBcIlswXVwiLFxuICAgICAgICAgIHZhbHVlOiBhWzBdLFxuICAgICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlY1xuICAgICAgICB9LCBhKSk7XG4gICAgICAgIHJldHVybiBacihGdChhWzFdKSkgPyBlLmNvbmNhdChbbmV3IE10KHMgKyBcIlsxXVwiLCBhWzFdLCBcImV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiBzdG9wcy5cIildKSA6IGUuY29uY2F0KFNuKHtcbiAgICAgICAgICBrZXk6IHMgKyBcIlsxXVwiLFxuICAgICAgICAgIHZhbHVlOiBhWzFdLFxuICAgICAgICAgIHZhbHVlU3BlYzogaSxcbiAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGgodCwgbikge1xuICAgICAgICB2YXIgcyA9IExyKHQudmFsdWUpLFxuICAgICAgICAgIHUgPSBWdCh0LnZhbHVlKSxcbiAgICAgICAgICBsID0gbnVsbCAhPT0gdC52YWx1ZSA/IHQudmFsdWUgOiBuO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGlmIChzICE9PSBlKSByZXR1cm4gW25ldyBNdCh0LmtleSwgbCwgcyArIFwiIHN0b3AgZG9tYWluIHR5cGUgbXVzdCBtYXRjaCBwcmV2aW91cyBzdG9wIGRvbWFpbiB0eXBlIFwiICsgZSldO1xuICAgICAgICB9IGVsc2UgZSA9IHM7XG4gICAgICAgIGlmIChcIm51bWJlclwiICE9PSBzICYmIFwic3RyaW5nXCIgIT09IHMgJiYgXCJib29sZWFuXCIgIT09IHMpIHJldHVybiBbbmV3IE10KHQua2V5LCBsLCBcInN0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhblwiKV07XG4gICAgICAgIGlmIChcIm51bWJlclwiICE9PSBzICYmIFwiY2F0ZWdvcmljYWxcIiAhPT0gYSkge1xuICAgICAgICAgIHZhciBwID0gXCJudW1iZXIgZXhwZWN0ZWQsIFwiICsgcyArIFwiIGZvdW5kXCI7XG4gICAgICAgICAgcmV0dXJuIFZyKGkpICYmIHZvaWQgMCA9PT0gYSAmJiAocCArPSAnXFxuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGBcInR5cGVcIjogXCJjYXRlZ29yaWNhbFwiYC4nKSwgW25ldyBNdCh0LmtleSwgbCwgcCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImNhdGVnb3JpY2FsXCIgIT09IGEgfHwgXCJudW1iZXJcIiAhPT0gcyB8fCBpc0Zpbml0ZSh1KSAmJiBNYXRoLmZsb29yKHUpID09PSB1ID8gXCJjYXRlZ29yaWNhbFwiICE9PSBhICYmIFwibnVtYmVyXCIgPT09IHMgJiYgdm9pZCAwICE9PSByICYmIHUgPCByID8gW25ldyBNdCh0LmtleSwgbCwgXCJzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyXCIpXSA6IChyID0gdSwgXCJjYXRlZ29yaWNhbFwiID09PSBhICYmIHUgaW4gbyA/IFtuZXcgTXQodC5rZXksIGwsIFwic3RvcCBkb21haW4gdmFsdWVzIG11c3QgYmUgdW5pcXVlXCIpXSA6IChvW3VdID0gITAsIFtdKSkgOiBbbmV3IE10KHQua2V5LCBsLCBcImludGVnZXIgZXhwZWN0ZWQsIGZvdW5kIFwiICsgdSldO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBybih0KSB7XG4gICAgICB2YXIgZSA9IChcInByb3BlcnR5XCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgPyBZciA6IFhyKShGdCh0LnZhbHVlKSwgdC52YWx1ZVNwZWMpO1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gZS5yZXN1bHQpIHJldHVybiBlLnZhbHVlLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbmV3IE10KFwiXCIgKyB0LmtleSArIGUua2V5LCB0LnZhbHVlLCBlLm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgciA9IGUudmFsdWUuZXhwcmVzc2lvbiB8fCBlLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgICAgIGlmIChcInByb3BlcnR5XCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgXCJ0ZXh0LWZvbnRcIiA9PT0gdC5wcm9wZXJ0eUtleSAmJiAhci5vdXRwdXREZWZpbmVkKCkpIHJldHVybiBbbmV3IE10KHQua2V5LCB0LnZhbHVlLCAnSW52YWxpZCBkYXRhIGV4cHJlc3Npb24gZm9yIFwiJyArIHQucHJvcGVydHlLZXkgKyAnXCIuIE91dHB1dCB2YWx1ZXMgbXVzdCBiZSBjb250YWluZWQgYXMgbGl0ZXJhbHMgd2l0aGluIHRoZSBleHByZXNzaW9uLicpXTtcbiAgICAgIGlmIChcInByb3BlcnR5XCIgPT09IHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgXCJsYXlvdXRcIiA9PT0gdC5wcm9wZXJ0eVR5cGUgJiYgIU9lKHIpKSByZXR1cm4gW25ldyBNdCh0LmtleSwgdC52YWx1ZSwgJ1wiZmVhdHVyZS1zdGF0ZVwiIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBsYXlvdXQgcHJvcGVydGllcy4nKV07XG4gICAgICBpZiAoXCJmaWx0ZXJcIiA9PT0gdC5leHByZXNzaW9uQ29udGV4dCAmJiAhT2UocikpIHJldHVybiBbbmV3IE10KHQua2V5LCB0LnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGZpbHRlcnMuJyldO1xuICAgICAgaWYgKHQuZXhwcmVzc2lvbkNvbnRleHQgJiYgMCA9PT0gdC5leHByZXNzaW9uQ29udGV4dC5pbmRleE9mKFwiY2x1c3RlclwiKSkge1xuICAgICAgICBpZiAoIVVlKHIsIFtcInpvb21cIiwgXCJmZWF0dXJlLXN0YXRlXCJdKSkgcmV0dXJuIFtuZXcgTXQodC5rZXksIHQudmFsdWUsICdcInpvb21cIiBhbmQgXCJmZWF0dXJlLXN0YXRlXCIgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBjbHVzdGVyIHByb3BlcnRpZXMuJyldO1xuICAgICAgICBpZiAoXCJjbHVzdGVyLWluaXRpYWxcIiA9PT0gdC5leHByZXNzaW9uQ29udGV4dCAmJiAhUmUocikpIHJldHVybiBbbmV3IE10KHQua2V5LCB0LnZhbHVlLCBcIkZlYXR1cmUgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGluaXRpYWwgZXhwcmVzc2lvbiBwYXJ0IG9mIGNsdXN0ZXIgcHJvcGVydGllcy5cIildO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBubih0KSB7XG4gICAgICB2YXIgZSA9IHQua2V5LFxuICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgbiA9IHQudmFsdWVTcGVjLFxuICAgICAgICBpID0gW107XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuLnZhbHVlcykgPyAtMSA9PT0gbi52YWx1ZXMuaW5kZXhPZihWdChyKSkgJiYgaS5wdXNoKG5ldyBNdChlLCByLCBcImV4cGVjdGVkIG9uZSBvZiBbXCIgKyBuLnZhbHVlcy5qb2luKFwiLCBcIikgKyBcIl0sIFwiICsgSlNPTi5zdHJpbmdpZnkocikgKyBcIiBmb3VuZFwiKSkgOiAtMSA9PT0gT2JqZWN0LmtleXMobi52YWx1ZXMpLmluZGV4T2YoVnQocikpICYmIGkucHVzaChuZXcgTXQoZSwgciwgXCJleHBlY3RlZCBvbmUgb2YgW1wiICsgT2JqZWN0LmtleXMobi52YWx1ZXMpLmpvaW4oXCIsIFwiKSArIFwiXSwgXCIgKyBKU09OLnN0cmluZ2lmeShyKSArIFwiIGZvdW5kXCIpKSwgaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW4odCkge1xuICAgICAgaWYgKCEwID09PSB0IHx8ICExID09PSB0KSByZXR1cm4gITA7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodCkgfHwgMCA9PT0gdC5sZW5ndGgpIHJldHVybiAhMTtcbiAgICAgIHN3aXRjaCAodFswXSkge1xuICAgICAgICBjYXNlIFwiaGFzXCI6XG4gICAgICAgICAgcmV0dXJuIHQubGVuZ3RoID49IDIgJiYgXCIkaWRcIiAhPT0gdFsxXSAmJiBcIiR0eXBlXCIgIT09IHRbMV07XG4gICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgIHJldHVybiB0Lmxlbmd0aCA+PSAzICYmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0WzFdIHx8IEFycmF5LmlzQXJyYXkodFsyXSkpO1xuICAgICAgICBjYXNlIFwiIWluXCI6XG4gICAgICAgIGNhc2UgXCIhaGFzXCI6XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgICByZXR1cm4gMyAhPT0gdC5sZW5ndGggfHwgQXJyYXkuaXNBcnJheSh0WzFdKSB8fCBBcnJheS5pc0FycmF5KHRbMl0pO1xuICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQuc2xpY2UoMSk7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJbZV07XG4gICAgICAgICAgICBpZiAoIWFuKG4pICYmIFwiYm9vbGVhblwiICE9IHR5cGVvZiBuKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgICRyLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBuZXcgJHIodC5fcGFyYW1ldGVycywgdC5fc3BlY2lmaWNhdGlvbik7XG4gICAgfSwgJHIuc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9wYXJhbWV0ZXJzOiB0Ll9wYXJhbWV0ZXJzLFxuICAgICAgICBfc3BlY2lmaWNhdGlvbjogdC5fc3BlY2lmaWNhdGlvblxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBvbiA9IHtcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogITEsXG4gICAgICB0cmFuc2l0aW9uOiAhMSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogITEsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzbih0KSB7XG4gICAgICBpZiAobnVsbCA9PSB0KSByZXR1cm4ge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0sXG4gICAgICAgIG5lZWRHZW9tZXRyeTogITFcbiAgICAgIH07XG4gICAgICBhbih0KSB8fCAodCA9IGxuKHQpKTtcbiAgICAgIHZhciBlID0gWHIodCwgb24pO1xuICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gZS5yZXN1bHQpIHRocm93IG5ldyBFcnJvcihlLnZhbHVlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5rZXkgKyBcIjogXCIgKyB0Lm1lc3NhZ2U7XG4gICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAodCwgciwgbikge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlLmV2YWx1YXRlKHQsIHIsIHt9LCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgbmVlZEdlb21ldHJ5OiBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkpIHJldHVybiAhMTtcbiAgICAgICAgICBpZiAoXCJ3aXRoaW5cIiA9PT0gZVswXSkgcmV0dXJuICEwO1xuICAgICAgICAgIGZvciAodmFyIHIgPSAxOyByIDwgZS5sZW5ndGg7IHIrKykgaWYgKHQoZVtyXSkpIHJldHVybiAhMDtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0odClcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IDwgZSA/IC0xIDogdCA+IGUgPyAxIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG4odCkge1xuICAgICAgaWYgKCF0KSByZXR1cm4gITA7XG4gICAgICB2YXIgZSxcbiAgICAgICAgciA9IHRbMF07XG4gICAgICByZXR1cm4gdC5sZW5ndGggPD0gMSA/IFwiYW55XCIgIT09IHIgOiBcIj09XCIgPT09IHIgPyBwbih0WzFdLCB0WzJdLCBcIj09XCIpIDogXCIhPVwiID09PSByID8gZm4ocG4odFsxXSwgdFsyXSwgXCI9PVwiKSkgOiBcIjxcIiA9PT0gciB8fCBcIj5cIiA9PT0gciB8fCBcIjw9XCIgPT09IHIgfHwgXCI+PVwiID09PSByID8gcG4odFsxXSwgdFsyXSwgcikgOiBcImFueVwiID09PSByID8gKGUgPSB0LnNsaWNlKDEpLCBbXCJhbnlcIl0uY29uY2F0KGUubWFwKGxuKSkpIDogXCJhbGxcIiA9PT0gciA/IFtcImFsbFwiXS5jb25jYXQodC5zbGljZSgxKS5tYXAobG4pKSA6IFwibm9uZVwiID09PSByID8gW1wiYWxsXCJdLmNvbmNhdCh0LnNsaWNlKDEpLm1hcChsbikubWFwKGZuKSkgOiBcImluXCIgPT09IHIgPyBjbih0WzFdLCB0LnNsaWNlKDIpKSA6IFwiIWluXCIgPT09IHIgPyBmbihjbih0WzFdLCB0LnNsaWNlKDIpKSkgOiBcImhhc1wiID09PSByID8gaG4odFsxXSkgOiBcIiFoYXNcIiA9PT0gciA/IGZuKGhuKHRbMV0pKSA6IFwid2l0aGluXCIgIT09IHIgfHwgdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG4odCwgZSwgcikge1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCIkdHlwZVwiOlxuICAgICAgICAgIHJldHVybiBbXCJmaWx0ZXItdHlwZS1cIiArIHIsIGVdO1xuICAgICAgICBjYXNlIFwiJGlkXCI6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1pZC1cIiArIHIsIGVdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBbXCJmaWx0ZXItXCIgKyByLCB0LCBlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY24odCwgZSkge1xuICAgICAgaWYgKDAgPT09IGUubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcIiR0eXBlXCI6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci10eXBlLWluXCIsIFtcImxpdGVyYWxcIiwgZV1dO1xuICAgICAgICBjYXNlIFwiJGlkXCI6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1pZC1pblwiLCBbXCJsaXRlcmFsXCIsIGVdXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZS5sZW5ndGggPiAyMDAgJiYgIWUuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ICE9IHR5cGVvZiBlWzBdO1xuICAgICAgICAgIH0pID8gW1wiZmlsdGVyLWluLWxhcmdlXCIsIHQsIFtcImxpdGVyYWxcIiwgZS5zb3J0KHVuKV1dIDogW1wiZmlsdGVyLWluLXNtYWxsXCIsIHQsIFtcImxpdGVyYWxcIiwgZV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBobih0KSB7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcIiR0eXBlXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjYXNlIFwiJGlkXCI6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1oYXMtaWRcIl07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFtcImZpbHRlci1oYXNcIiwgdF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZuKHQpIHtcbiAgICAgIHJldHVybiBbXCIhXCIsIHRdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB5bih0KSB7XG4gICAgICByZXR1cm4gYW4oRnQodC52YWx1ZSkpID8gcm4oVHQoe30sIHQsIHtcbiAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwiZmlsdGVyXCIsXG4gICAgICAgIHZhbHVlU3BlYzoge1xuICAgICAgICAgIHZhbHVlOiBcImJvb2xlYW5cIlxuICAgICAgICB9XG4gICAgICB9KSkgOiBmdW5jdGlvbiB0KGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLnZhbHVlLFxuICAgICAgICAgIG4gPSBlLmtleTtcbiAgICAgICAgaWYgKFwiYXJyYXlcIiAhPT0gTHIocikpIHJldHVybiBbbmV3IE10KG4sIHIsIFwiYXJyYXkgZXhwZWN0ZWQsIFwiICsgTHIocikgKyBcIiBmb3VuZFwiKV07XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIGEgPSBlLnN0eWxlU3BlYyxcbiAgICAgICAgICBvID0gW107XG4gICAgICAgIGlmIChyLmxlbmd0aCA8IDEpIHJldHVybiBbbmV3IE10KG4sIHIsIFwiZmlsdGVyIGFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnRcIildO1xuICAgICAgICBzd2l0Y2ggKG8gPSBvLmNvbmNhdChubih7XG4gICAgICAgICAga2V5OiBuICsgXCJbMF1cIixcbiAgICAgICAgICB2YWx1ZTogclswXSxcbiAgICAgICAgICB2YWx1ZVNwZWM6IGEuZmlsdGVyX29wZXJhdG9yLFxuICAgICAgICAgIHN0eWxlOiBlLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogZS5zdHlsZVNwZWNcbiAgICAgICAgfSkpLCBWdChyWzBdKSkge1xuICAgICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICAgIHIubGVuZ3RoID49IDIgJiYgXCIkdHlwZVwiID09PSBWdChyWzFdKSAmJiBvLnB1c2gobmV3IE10KG4sIHIsICdcIiR0eXBlXCIgY2Fubm90IGJlIHVzZSB3aXRoIG9wZXJhdG9yIFwiJyArIHJbMF0gKyAnXCInKSk7XG4gICAgICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgICAgICAzICE9PSByLmxlbmd0aCAmJiBvLnB1c2gobmV3IE10KG4sIHIsICdmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFwiJyArIHJbMF0gKyAnXCIgbXVzdCBoYXZlIDMgZWxlbWVudHMnKSk7XG4gICAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgY2FzZSBcIiFpblwiOlxuICAgICAgICAgICAgci5sZW5ndGggPj0gMiAmJiBcInN0cmluZ1wiICE9PSAoaSA9IExyKHJbMV0pKSAmJiBvLnB1c2gobmV3IE10KG4gKyBcIlsxXVwiLCByWzFdLCBcInN0cmluZyBleHBlY3RlZCwgXCIgKyBpICsgXCIgZm91bmRcIikpO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDI7IHMgPCByLmxlbmd0aDsgcysrKSBpID0gTHIocltzXSksIFwiJHR5cGVcIiA9PT0gVnQoclsxXSkgPyBvID0gby5jb25jYXQobm4oe1xuICAgICAgICAgICAgICBrZXk6IG4gKyBcIltcIiArIHMgKyBcIl1cIixcbiAgICAgICAgICAgICAgdmFsdWU6IHJbc10sXG4gICAgICAgICAgICAgIHZhbHVlU3BlYzogYS5nZW9tZXRyeV90eXBlLFxuICAgICAgICAgICAgICBzdHlsZTogZS5zdHlsZSxcbiAgICAgICAgICAgICAgc3R5bGVTcGVjOiBlLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpIDogXCJzdHJpbmdcIiAhPT0gaSAmJiBcIm51bWJlclwiICE9PSBpICYmIFwiYm9vbGVhblwiICE9PSBpICYmIG8ucHVzaChuZXcgTXQobiArIFwiW1wiICsgcyArIFwiXVwiLCByW3NdLCBcInN0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCBcIiArIGkgKyBcIiBmb3VuZFwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgICAgY2FzZSBcImFsbFwiOlxuICAgICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gMTsgdSA8IHIubGVuZ3RoOyB1KyspIG8gPSBvLmNvbmNhdCh0KHtcbiAgICAgICAgICAgICAga2V5OiBuICsgXCJbXCIgKyB1ICsgXCJdXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiByW3VdLFxuICAgICAgICAgICAgICBzdHlsZTogZS5zdHlsZSxcbiAgICAgICAgICAgICAgc3R5bGVTcGVjOiBlLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImhhc1wiOlxuICAgICAgICAgIGNhc2UgXCIhaGFzXCI6XG4gICAgICAgICAgICBpID0gTHIoclsxXSksIDIgIT09IHIubGVuZ3RoID8gby5wdXNoKG5ldyBNdChuLCByLCAnZmlsdGVyIGFycmF5IGZvciBcIicgKyByWzBdICsgJ1wiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzJykpIDogXCJzdHJpbmdcIiAhPT0gaSAmJiBvLnB1c2gobmV3IE10KG4gKyBcIlsxXVwiLCByWzFdLCBcInN0cmluZyBleHBlY3RlZCwgXCIgKyBpICsgXCIgZm91bmRcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIndpdGhpblwiOlxuICAgICAgICAgICAgaSA9IExyKHJbMV0pLCAyICE9PSByLmxlbmd0aCA/IG8ucHVzaChuZXcgTXQobiwgciwgJ2ZpbHRlciBhcnJheSBmb3IgXCInICsgclswXSArICdcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50cycpKSA6IFwib2JqZWN0XCIgIT09IGkgJiYgby5wdXNoKG5ldyBNdChuICsgXCJbMV1cIiwgclsxXSwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiICsgaSArIFwiIGZvdW5kXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH0odCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRuKHQsIGUpIHtcbiAgICAgIHZhciByID0gdC5rZXksXG4gICAgICAgIG4gPSB0LnN0eWxlLFxuICAgICAgICBpID0gdC5zdHlsZVNwZWMsXG4gICAgICAgIGEgPSB0LnZhbHVlLFxuICAgICAgICBvID0gdC5vYmplY3RLZXksXG4gICAgICAgIHMgPSBpW2UgKyBcIl9cIiArIHQubGF5ZXJUeXBlXTtcbiAgICAgIGlmICghcykgcmV0dXJuIFtdO1xuICAgICAgdmFyIHUgPSBvLm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuICAgICAgaWYgKFwicGFpbnRcIiA9PT0gZSAmJiB1ICYmIHNbdVsxXV0gJiYgc1t1WzFdXS50cmFuc2l0aW9uKSByZXR1cm4gU24oe1xuICAgICAgICBrZXk6IHIsXG4gICAgICAgIHZhbHVlOiBhLFxuICAgICAgICB2YWx1ZVNwZWM6IGkudHJhbnNpdGlvbixcbiAgICAgICAgc3R5bGU6IG4sXG4gICAgICAgIHN0eWxlU3BlYzogaVxuICAgICAgfSk7XG4gICAgICB2YXIgbCxcbiAgICAgICAgcCA9IHQudmFsdWVTcGVjIHx8IHNbb107XG4gICAgICBpZiAoIXApIHJldHVybiBbbmV3IE10KHIsIGEsICd1bmtub3duIHByb3BlcnR5IFwiJyArIG8gKyAnXCInKV07XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gTHIoYSkgJiYgVnIocCkgJiYgIXAudG9rZW5zICYmIChsID0gL157KFtefV0rKX0kLy5leGVjKGEpKSkgcmV0dXJuIFtuZXcgTXQociwgYSwgJ1wiJyArIG8gKyAnXCIgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW9uIHN5bnRheFxcblVzZSBhbiBpZGVudGl0eSBwcm9wZXJ0eSBmdW5jdGlvbiBpbnN0ZWFkOiBgeyBcInR5cGVcIjogXCJpZGVudGl0eVwiLCBcInByb3BlcnR5XCI6ICcgKyBKU09OLnN0cmluZ2lmeShsWzFdKSArIFwiIH1gLlwiKV07XG4gICAgICB2YXIgYyA9IFtdO1xuICAgICAgcmV0dXJuIFwic3ltYm9sXCIgPT09IHQubGF5ZXJUeXBlICYmIChcInRleHQtZmllbGRcIiA9PT0gbyAmJiBuICYmICFuLmdseXBocyAmJiBjLnB1c2gobmV3IE10KHIsIGEsICd1c2Ugb2YgXCJ0ZXh0LWZpZWxkXCIgcmVxdWlyZXMgYSBzdHlsZSBcImdseXBoc1wiIHByb3BlcnR5JykpLCBcInRleHQtZm9udFwiID09PSBvICYmIFJyKEZ0KGEpKSAmJiBcImlkZW50aXR5XCIgPT09IFZ0KGEudHlwZSkgJiYgYy5wdXNoKG5ldyBNdChyLCBhLCAnXCJ0ZXh0LWZvbnRcIiBkb2VzIG5vdCBzdXBwb3J0IGlkZW50aXR5IGZ1bmN0aW9ucycpKSksIGMuY29uY2F0KFNuKHtcbiAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgIHZhbHVlU3BlYzogcCxcbiAgICAgICAgc3R5bGU6IG4sXG4gICAgICAgIHN0eWxlU3BlYzogaSxcbiAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwicHJvcGVydHlcIixcbiAgICAgICAgcHJvcGVydHlUeXBlOiBlLFxuICAgICAgICBwcm9wZXJ0eUtleTogb1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtbih0KSB7XG4gICAgICByZXR1cm4gZG4odCwgXCJwYWludFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdm4odCkge1xuICAgICAgcmV0dXJuIGRuKHQsIFwibGF5b3V0XCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbih0KSB7XG4gICAgICB2YXIgZSA9IFtdLFxuICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgbiA9IHQua2V5LFxuICAgICAgICBpID0gdC5zdHlsZSxcbiAgICAgICAgYSA9IHQuc3R5bGVTcGVjO1xuICAgICAgci50eXBlIHx8IHIucmVmIHx8IGUucHVzaChuZXcgTXQobiwgciwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICAgICAgdmFyIG8sXG4gICAgICAgIHMgPSBWdChyLnR5cGUpLFxuICAgICAgICB1ID0gVnQoci5yZWYpO1xuICAgICAgaWYgKHIuaWQpIGZvciAodmFyIGwgPSBWdChyLmlkKSwgcCA9IDA7IHAgPCB0LmFycmF5SW5kZXg7IHArKykge1xuICAgICAgICB2YXIgYyA9IGkubGF5ZXJzW3BdO1xuICAgICAgICBWdChjLmlkKSA9PT0gbCAmJiBlLnB1c2gobmV3IE10KG4sIHIuaWQsICdkdXBsaWNhdGUgbGF5ZXIgaWQgXCInICsgci5pZCArICdcIiwgcHJldmlvdXNseSB1c2VkIGF0IGxpbmUgJyArIGMuaWQuX19saW5lX18pKTtcbiAgICAgIH1cbiAgICAgIGlmIChcInJlZlwiIGluIHIpIFtcInR5cGVcIiwgXCJzb3VyY2VcIiwgXCJzb3VyY2UtbGF5ZXJcIiwgXCJmaWx0ZXJcIiwgXCJsYXlvdXRcIl0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0IGluIHIgJiYgZS5wdXNoKG5ldyBNdChuLCByW3RdLCAnXCInICsgdCArICdcIiBpcyBwcm9oaWJpdGVkIGZvciByZWYgbGF5ZXJzJykpO1xuICAgICAgfSksIGkubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgVnQodC5pZCkgPT09IHUgJiYgKG8gPSB0KTtcbiAgICAgIH0pLCBvID8gby5yZWYgPyBlLnB1c2gobmV3IE10KG4sIHIucmVmLCBcInJlZiBjYW5ub3QgcmVmZXJlbmNlIGFub3RoZXIgcmVmIGxheWVyXCIpKSA6IHMgPSBWdChvLnR5cGUpIDogZS5wdXNoKG5ldyBNdChuLCByLnJlZiwgJ3JlZiBsYXllciBcIicgKyB1ICsgJ1wiIG5vdCBmb3VuZCcpKTtlbHNlIGlmIChcImJhY2tncm91bmRcIiAhPT0gcykgaWYgKHIuc291cmNlKSB7XG4gICAgICAgIHZhciBoID0gaS5zb3VyY2VzICYmIGkuc291cmNlc1tyLnNvdXJjZV0sXG4gICAgICAgICAgZiA9IGggJiYgVnQoaC50eXBlKTtcbiAgICAgICAgaCA/IFwidmVjdG9yXCIgPT09IGYgJiYgXCJyYXN0ZXJcIiA9PT0gcyA/IGUucHVzaChuZXcgTXQobiwgci5zb3VyY2UsICdsYXllciBcIicgKyByLmlkICsgJ1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScpKSA6IFwicmFzdGVyXCIgPT09IGYgJiYgXCJyYXN0ZXJcIiAhPT0gcyA/IGUucHVzaChuZXcgTXQobiwgci5zb3VyY2UsICdsYXllciBcIicgKyByLmlkICsgJ1wiIHJlcXVpcmVzIGEgdmVjdG9yIHNvdXJjZScpKSA6IFwidmVjdG9yXCIgIT09IGYgfHwgcltcInNvdXJjZS1sYXllclwiXSA/IFwicmFzdGVyLWRlbVwiID09PSBmICYmIFwiaGlsbHNoYWRlXCIgIT09IHMgPyBlLnB1c2gobmV3IE10KG4sIHIuc291cmNlLCBcInJhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlICdoaWxsc2hhZGUnLlwiKSkgOiBcImxpbmVcIiAhPT0gcyB8fCAhci5wYWludCB8fCAhci5wYWludFtcImxpbmUtZ3JhZGllbnRcIl0gfHwgXCJnZW9qc29uXCIgPT09IGYgJiYgaC5saW5lTWV0cmljcyB8fCBlLnB1c2gobmV3IE10KG4sIHIsICdsYXllciBcIicgKyByLmlkICsgJ1wiIHNwZWNpZmllcyBhIGxpbmUtZ3JhZGllbnQsIHdoaWNoIHJlcXVpcmVzIGEgR2VvSlNPTiBzb3VyY2Ugd2l0aCBgbGluZU1ldHJpY3NgIGVuYWJsZWQuJykpIDogZS5wdXNoKG5ldyBNdChuLCByLCAnbGF5ZXIgXCInICsgci5pZCArICdcIiBtdXN0IHNwZWNpZnkgYSBcInNvdXJjZS1sYXllclwiJykpIDogZS5wdXNoKG5ldyBNdChuLCByLnNvdXJjZSwgJ3NvdXJjZSBcIicgKyByLnNvdXJjZSArICdcIiBub3QgZm91bmQnKSk7XG4gICAgICB9IGVsc2UgZS5wdXNoKG5ldyBNdChuLCByLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgICAgcmV0dXJuIGUgPSBlLmNvbmNhdChXcih7XG4gICAgICAgIGtleTogbixcbiAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgIHZhbHVlU3BlYzogYS5sYXllcixcbiAgICAgICAgc3R5bGU6IHQuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBTbih7XG4gICAgICAgICAgICAgIGtleTogbiArIFwiLnR5cGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHIudHlwZSxcbiAgICAgICAgICAgICAgdmFsdWVTcGVjOiBhLmxheWVyLnR5cGUsXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICBvYmplY3Q6IHIsXG4gICAgICAgICAgICAgIG9iamVjdEtleTogXCJ0eXBlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZmlsdGVyOiB5bixcbiAgICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gV3Ioe1xuICAgICAgICAgICAgICBsYXllcjogcixcbiAgICAgICAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHQudmFsdWUsXG4gICAgICAgICAgICAgIHN0eWxlOiB0LnN0eWxlLFxuICAgICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgICAgIFwiKlwiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZuKFR0KHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJUeXBlOiBzXG4gICAgICAgICAgICAgICAgICB9LCB0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhaW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIFdyKHtcbiAgICAgICAgICAgICAgbGF5ZXI6IHIsXG4gICAgICAgICAgICAgIGtleTogdC5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB0LnZhbHVlLFxuICAgICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgICAgc3R5bGVTcGVjOiB0LnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICBcIipcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtbihUdCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyVHlwZTogc1xuICAgICAgICAgICAgICAgICAgfSwgdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhuKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgciA9IHQua2V5LFxuICAgICAgICBuID0gTHIoZSk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPT0gbiA/IFtuZXcgTXQociwgZSwgXCJzdHJpbmcgZXhwZWN0ZWQsIFwiICsgbiArIFwiIGZvdW5kXCIpXSA6IFtdO1xuICAgIH1cbiAgICB2YXIgYm4gPSB7XG4gICAgICBwcm9tb3RlSWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdC5rZXksXG4gICAgICAgICAgciA9IHQudmFsdWU7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSBMcihyKSkgcmV0dXJuIHhuKHtcbiAgICAgICAgICBrZXk6IGUsXG4gICAgICAgICAgdmFsdWU6IHJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gcikgbi5wdXNoLmFwcGx5KG4sIHhuKHtcbiAgICAgICAgICBrZXk6IGUgKyBcIi5cIiArIGksXG4gICAgICAgICAgdmFsdWU6IHJbaV1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHduKHQpIHtcbiAgICAgIHZhciBlID0gdC52YWx1ZSxcbiAgICAgICAgciA9IHQua2V5LFxuICAgICAgICBuID0gdC5zdHlsZVNwZWMsXG4gICAgICAgIGkgPSB0LnN0eWxlO1xuICAgICAgaWYgKCFlLnR5cGUpIHJldHVybiBbbmV3IE10KHIsIGUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgICAgIHZhciBhLFxuICAgICAgICBvID0gVnQoZS50eXBlKTtcbiAgICAgIHN3aXRjaCAobykge1xuICAgICAgICBjYXNlIFwidmVjdG9yXCI6XG4gICAgICAgIGNhc2UgXCJyYXN0ZXJcIjpcbiAgICAgICAgY2FzZSBcInJhc3Rlci1kZW1cIjpcbiAgICAgICAgICByZXR1cm4gV3Ioe1xuICAgICAgICAgICAga2V5OiByLFxuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG5bXCJzb3VyY2VfXCIgKyBvLnJlcGxhY2UoXCItXCIsIFwiX1wiKV0sXG4gICAgICAgICAgICBzdHlsZTogdC5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogbixcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBiblxuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFwiZ2VvanNvblwiOlxuICAgICAgICAgIGlmIChhID0gV3Ioe1xuICAgICAgICAgICAga2V5OiByLFxuICAgICAgICAgICAgdmFsdWU6IGUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG4uc291cmNlX2dlb2pzb24sXG4gICAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogbixcbiAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBiblxuICAgICAgICAgIH0pLCBlLmNsdXN0ZXIpIGZvciAodmFyIHMgaW4gZS5jbHVzdGVyUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIHUgPSBlLmNsdXN0ZXJQcm9wZXJ0aWVzW3NdLFxuICAgICAgICAgICAgICBsID0gdVswXSxcbiAgICAgICAgICAgICAgcCA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGwgPyBbbCwgW1wiYWNjdW11bGF0ZWRcIl0sIFtcImdldFwiLCBzXV0gOiBsO1xuICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIHJuKHtcbiAgICAgICAgICAgICAga2V5OiByICsgXCIuXCIgKyBzICsgXCIubWFwXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiB1WzFdLFxuICAgICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogXCJjbHVzdGVyLW1hcFwiXG4gICAgICAgICAgICB9KSksIGEucHVzaC5hcHBseShhLCBybih7XG4gICAgICAgICAgICAgIGtleTogciArIFwiLlwiICsgcyArIFwiLnJlZHVjZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogcCxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6IFwiY2x1c3Rlci1yZWR1Y2VcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgY2FzZSBcInZpZGVvXCI6XG4gICAgICAgICAgcmV0dXJuIFdyKHtcbiAgICAgICAgICAgIGtleTogcixcbiAgICAgICAgICAgIHZhbHVlOiBlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBuLnNvdXJjZV92aWRlbyxcbiAgICAgICAgICAgIHN0eWxlOiBpLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBuXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIHJldHVybiBXcih7XG4gICAgICAgICAgICBrZXk6IHIsXG4gICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogbi5zb3VyY2VfaW1hZ2UsXG4gICAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogblxuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFwiY2FudmFzXCI6XG4gICAgICAgICAgcmV0dXJuIFtuZXcgTXQociwgbnVsbCwgXCJQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLlwiLCBcInNvdXJjZS5jYW52YXNcIildO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBubih7XG4gICAgICAgICAgICBrZXk6IHIgKyBcIi50eXBlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZS50eXBlLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiB7XG4gICAgICAgICAgICAgIHZhbHVlczogW1widmVjdG9yXCIsIFwicmFzdGVyXCIsIFwicmFzdGVyLWRlbVwiLCBcImdlb2pzb25cIiwgXCJ2aWRlb1wiLCBcImltYWdlXCJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IGksXG4gICAgICAgICAgICBzdHlsZVNwZWM6IG5cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX24odCkge1xuICAgICAgdmFyIGUgPSB0LnZhbHVlLFxuICAgICAgICByID0gdC5zdHlsZVNwZWMsXG4gICAgICAgIG4gPSByLmxpZ2h0LFxuICAgICAgICBpID0gdC5zdHlsZSxcbiAgICAgICAgYSA9IFtdLFxuICAgICAgICBvID0gTHIoZSk7XG4gICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gYTtcbiAgICAgIGlmIChcIm9iamVjdFwiICE9PSBvKSByZXR1cm4gYS5jb25jYXQoW25ldyBNdChcImxpZ2h0XCIsIGUsIFwib2JqZWN0IGV4cGVjdGVkLCBcIiArIG8gKyBcIiBmb3VuZFwiKV0pO1xuICAgICAgZm9yICh2YXIgcyBpbiBlKSB7XG4gICAgICAgIHZhciB1ID0gcy5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcbiAgICAgICAgYSA9IGEuY29uY2F0KHUgJiYgblt1WzFdXSAmJiBuW3VbMV1dLnRyYW5zaXRpb24gPyBTbih7XG4gICAgICAgICAga2V5OiBzLFxuICAgICAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgICAgIHZhbHVlU3BlYzogci50cmFuc2l0aW9uLFxuICAgICAgICAgIHN0eWxlOiBpLFxuICAgICAgICAgIHN0eWxlU3BlYzogclxuICAgICAgICB9KSA6IG5bc10gPyBTbih7XG4gICAgICAgICAga2V5OiBzLFxuICAgICAgICAgIHZhbHVlOiBlW3NdLFxuICAgICAgICAgIHZhbHVlU3BlYzogbltzXSxcbiAgICAgICAgICBzdHlsZTogaSxcbiAgICAgICAgICBzdHlsZVNwZWM6IHJcbiAgICAgICAgfSkgOiBbbmV3IE10KHMsIGVbc10sICd1bmtub3duIHByb3BlcnR5IFwiJyArIHMgKyAnXCInKV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBBbiA9IHtcbiAgICAgIFwiKlwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICBhcnJheTogUXIsXG4gICAgICBib29sZWFuOiBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQudmFsdWUsXG4gICAgICAgICAgciA9IHQua2V5LFxuICAgICAgICAgIG4gPSBMcihlKTtcbiAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiICE9PSBuID8gW25ldyBNdChyLCBlLCBcImJvb2xlYW4gZXhwZWN0ZWQsIFwiICsgbiArIFwiIGZvdW5kXCIpXSA6IFtdO1xuICAgICAgfSxcbiAgICAgIG51bWJlcjogdG4sXG4gICAgICBjb2xvcjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LmtleSxcbiAgICAgICAgICByID0gdC52YWx1ZSxcbiAgICAgICAgICBuID0gTHIocik7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiICE9PSBuID8gW25ldyBNdChlLCByLCBcImNvbG9yIGV4cGVjdGVkLCBcIiArIG4gKyBcIiBmb3VuZFwiKV0gOiBudWxsID09PSB0ZShyKSA/IFtuZXcgTXQoZSwgciwgJ2NvbG9yIGV4cGVjdGVkLCBcIicgKyByICsgJ1wiIGZvdW5kJyldIDogW107XG4gICAgICB9LFxuICAgICAgY29uc3RhbnRzOiBCdCxcbiAgICAgIGVudW06IG5uLFxuICAgICAgZmlsdGVyOiB5bixcbiAgICAgIGZ1bmN0aW9uOiBlbixcbiAgICAgIGxheWVyOiBnbixcbiAgICAgIG9iamVjdDogV3IsXG4gICAgICBzb3VyY2U6IHduLFxuICAgICAgbGlnaHQ6IF9uLFxuICAgICAgc3RyaW5nOiB4bixcbiAgICAgIGZvcm1hdHRlZDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IHhuKHQpLmxlbmd0aCA/IFtdIDogcm4odCk7XG4gICAgICB9LFxuICAgICAgcmVzb2x2ZWRJbWFnZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IHhuKHQpLmxlbmd0aCA/IFtdIDogcm4odCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBTbih0KSB7XG4gICAgICB2YXIgZSA9IHQudmFsdWUsXG4gICAgICAgIHIgPSB0LnZhbHVlU3BlYyxcbiAgICAgICAgbiA9IHQuc3R5bGVTcGVjO1xuICAgICAgcmV0dXJuIHIuZXhwcmVzc2lvbiAmJiBScihWdChlKSkgPyBlbih0KSA6IHIuZXhwcmVzc2lvbiAmJiBacihGdChlKSkgPyBybih0KSA6IHIudHlwZSAmJiBBbltyLnR5cGVdID8gQW5bci50eXBlXSh0KSA6IFdyKFR0KHt9LCB0LCB7XG4gICAgICAgIHZhbHVlU3BlYzogci50eXBlID8gbltyLnR5cGVdIDogclxuICAgICAgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbih0KSB7XG4gICAgICB2YXIgZSA9IHQudmFsdWUsXG4gICAgICAgIHIgPSB0LmtleSxcbiAgICAgICAgbiA9IHhuKHQpO1xuICAgICAgcmV0dXJuIG4ubGVuZ3RoIHx8ICgtMSA9PT0gZS5pbmRleE9mKFwie2ZvbnRzdGFja31cIikgJiYgbi5wdXNoKG5ldyBNdChyLCBlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7Zm9udHN0YWNrfVwiIHRva2VuJykpLCAtMSA9PT0gZS5pbmRleE9mKFwie3JhbmdlfVwiKSAmJiBuLnB1c2gobmV3IE10KHIsIGUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntyYW5nZX1cIiB0b2tlbicpKSksIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluKHQsIGUpIHtcbiAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IFB0KTtcbiAgICAgIHZhciByID0gW107XG4gICAgICByZXR1cm4gciA9IHIuY29uY2F0KFNuKHtcbiAgICAgICAga2V5OiBcIlwiLFxuICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgdmFsdWVTcGVjOiBlLiRyb290LFxuICAgICAgICBzdHlsZVNwZWM6IGUsXG4gICAgICAgIHN0eWxlOiB0LFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgIGdseXBoczoga24sXG4gICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKSwgdC5jb25zdGFudHMgJiYgKHIgPSByLmNvbmNhdChCdCh7XG4gICAgICAgIGtleTogXCJjb25zdGFudHNcIixcbiAgICAgICAgdmFsdWU6IHQuY29uc3RhbnRzLFxuICAgICAgICBzdHlsZTogdCxcbiAgICAgICAgc3R5bGVTcGVjOiBlXG4gICAgICB9KSkpLCB6bihyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gem4odCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0KS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LmxpbmUgLSBlLmxpbmU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ24odCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IFtdLCByID0gYXJndW1lbnRzLmxlbmd0aDsgci0tOykgZVtyXSA9IGFyZ3VtZW50c1tyXTtcbiAgICAgICAgcmV0dXJuIHpuKHQuYXBwbHkodGhpcywgZSkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgSW4uc291cmNlID0gQ24od24pLCBJbi5saWdodCA9IENuKF9uKSwgSW4ubGF5ZXIgPSBDbihnbiksIEluLmZpbHRlciA9IENuKHluKSwgSW4ucGFpbnRQcm9wZXJ0eSA9IENuKG1uKSwgSW4ubGF5b3V0UHJvcGVydHkgPSBDbih2bik7XG4gICAgdmFyIEVuID0gSW4sXG4gICAgICBQbiA9IEVuLmxpZ2h0LFxuICAgICAgTW4gPSBFbi5wYWludFByb3BlcnR5LFxuICAgICAgQm4gPSBFbi5sYXlvdXRQcm9wZXJ0eTtcbiAgICBmdW5jdGlvbiBUbih0LCBlKSB7XG4gICAgICB2YXIgciA9ICExO1xuICAgICAgaWYgKGUgJiYgZS5sZW5ndGgpIGZvciAodmFyIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHQuZmlyZShuZXcgQ3QobmV3IEVycm9yKGlbbl0ubWVzc2FnZSkpKSwgciA9ICEwO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHZhciBWbiA9IEZuO1xuICAgIGZ1bmN0aW9uIEZuKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5jZWxscyA9IFtdO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gdDtcbiAgICAgICAgdmFyIGkgPSBuZXcgSW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgICAgdCA9IGlbMF0sIHRoaXMuZCA9IChlID0gaVsxXSkgKyAyICogKHIgPSBpWzJdKTtcbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLmQgKiB0aGlzLmQ7IGErKykge1xuICAgICAgICAgIHZhciBvID0gaVszICsgYV0sXG4gICAgICAgICAgICBzID0gaVszICsgYSArIDFdO1xuICAgICAgICAgIG4ucHVzaChvID09PSBzID8gbnVsbCA6IGkuc3ViYXJyYXkobywgcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1ID0gaVszICsgbi5sZW5ndGggKyAxXTtcbiAgICAgICAgdGhpcy5rZXlzID0gaS5zdWJhcnJheShpWzMgKyBuLmxlbmd0aF0sIHUpLCB0aGlzLmJib3hlcyA9IGkuc3ViYXJyYXkodSksIHRoaXMuaW5zZXJ0ID0gdGhpcy5faW5zZXJ0UmVhZG9ubHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmQgPSBlICsgMiAqIHI7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5kICogdGhpcy5kOyBsKyspIG4ucHVzaChbXSk7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdLCB0aGlzLmJib3hlcyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5uID0gZSwgdGhpcy5leHRlbnQgPSB0LCB0aGlzLnBhZGRpbmcgPSByLCB0aGlzLnNjYWxlID0gZSAvIHQsIHRoaXMudWlkID0gMDtcbiAgICAgIHZhciBwID0gciAvIGUgKiB0O1xuICAgICAgdGhpcy5taW4gPSAtcCwgdGhpcy5tYXggPSB0ICsgcDtcbiAgICB9XG4gICAgRm4ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLl9mb3JFYWNoQ2VsbChlLCByLCBuLCBpLCB0aGlzLl9pbnNlcnRDZWxsLCB0aGlzLnVpZCsrKSwgdGhpcy5rZXlzLnB1c2godCksIHRoaXMuYmJveGVzLnB1c2goZSksIHRoaXMuYmJveGVzLnB1c2gociksIHRoaXMuYmJveGVzLnB1c2gobiksIHRoaXMuYmJveGVzLnB1c2goaSk7XG4gICAgfSwgRm4ucHJvdG90eXBlLl9pbnNlcnRSZWFkb25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IGluc2VydCBpbnRvIGEgR3JpZEluZGV4IGNyZWF0ZWQgZnJvbSBhbiBBcnJheUJ1ZmZlci5cIjtcbiAgICB9LCBGbi5wcm90b3R5cGUuX2luc2VydENlbGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdGhpcy5jZWxsc1tpXS5wdXNoKGEpO1xuICAgIH0sIEZuLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB2YXIgYSA9IHRoaXMubWluLFxuICAgICAgICBvID0gdGhpcy5tYXg7XG4gICAgICBpZiAodCA8PSBhICYmIGUgPD0gYSAmJiBvIDw9IHIgJiYgbyA8PSBuICYmICFpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5rZXlzKTtcbiAgICAgIHZhciBzID0gW107XG4gICAgICByZXR1cm4gdGhpcy5fZm9yRWFjaENlbGwodCwgZSwgciwgbiwgdGhpcy5fcXVlcnlDZWxsLCBzLCB7fSwgaSksIHM7XG4gICAgfSwgRm4ucHJvdG90eXBlLl9xdWVyeUNlbGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcykge1xuICAgICAgdmFyIHUgPSB0aGlzLmNlbGxzW2ldO1xuICAgICAgaWYgKG51bGwgIT09IHUpIGZvciAodmFyIGwgPSB0aGlzLmtleXMsIHAgPSB0aGlzLmJib3hlcywgYyA9IDA7IGMgPCB1Lmxlbmd0aDsgYysrKSB7XG4gICAgICAgIHZhciBoID0gdVtjXTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gb1toXSkge1xuICAgICAgICAgIHZhciBmID0gNCAqIGg7XG4gICAgICAgICAgKHMgPyBzKHBbZiArIDBdLCBwW2YgKyAxXSwgcFtmICsgMl0sIHBbZiArIDNdKSA6IHQgPD0gcFtmICsgMl0gJiYgZSA8PSBwW2YgKyAzXSAmJiByID49IHBbZiArIDBdICYmIG4gPj0gcFtmICsgMV0pID8gKG9baF0gPSAhMCwgYS5wdXNoKGxbaF0pKSA6IG9baF0gPSAhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEZuLnByb3RvdHlwZS5fZm9yRWFjaENlbGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcykge1xuICAgICAgZm9yICh2YXIgdSA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZCh0KSwgbCA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZChlKSwgcCA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZChyKSwgYyA9IHRoaXMuX2NvbnZlcnRUb0NlbGxDb29yZChuKSwgaCA9IHU7IGggPD0gcDsgaCsrKSBmb3IgKHZhciBmID0gbDsgZiA8PSBjOyBmKyspIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmQgKiBmICsgaDtcbiAgICAgICAgaWYgKCghcyB8fCBzKHRoaXMuX2NvbnZlcnRGcm9tQ2VsbENvb3JkKGgpLCB0aGlzLl9jb252ZXJ0RnJvbUNlbGxDb29yZChmKSwgdGhpcy5fY29udmVydEZyb21DZWxsQ29vcmQoaCArIDEpLCB0aGlzLl9jb252ZXJ0RnJvbUNlbGxDb29yZChmICsgMSkpKSAmJiBpLmNhbGwodGhpcywgdCwgZSwgciwgbiwgeSwgYSwgbywgcykpIHJldHVybjtcbiAgICAgIH1cbiAgICB9LCBGbi5wcm90b3R5cGUuX2NvbnZlcnRGcm9tQ2VsbENvb3JkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAodCAtIHRoaXMucGFkZGluZykgLyB0aGlzLnNjYWxlO1xuICAgIH0sIEZuLnByb3RvdHlwZS5fY29udmVydFRvQ2VsbENvb3JkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmQgLSAxLCBNYXRoLmZsb29yKHQgKiB0aGlzLnNjYWxlKSArIHRoaXMucGFkZGluZykpO1xuICAgIH0sIEZuLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuYXJyYXlCdWZmZXIpIHJldHVybiB0aGlzLmFycmF5QnVmZmVyO1xuICAgICAgZm9yICh2YXIgdCA9IHRoaXMuY2VsbHMsIGUgPSAzICsgdGhpcy5jZWxscy5sZW5ndGggKyAxICsgMSwgciA9IDAsIG4gPSAwOyBuIDwgdGhpcy5jZWxscy5sZW5ndGg7IG4rKykgciArPSB0aGlzLmNlbGxzW25dLmxlbmd0aDtcbiAgICAgIHZhciBpID0gbmV3IEludDMyQXJyYXkoZSArIHIgKyB0aGlzLmtleXMubGVuZ3RoICsgdGhpcy5iYm94ZXMubGVuZ3RoKTtcbiAgICAgIGlbMF0gPSB0aGlzLmV4dGVudCwgaVsxXSA9IHRoaXMubiwgaVsyXSA9IHRoaXMucGFkZGluZztcbiAgICAgIGZvciAodmFyIGEgPSBlLCBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgdmFyIHMgPSB0W29dO1xuICAgICAgICBpWzMgKyBvXSA9IGEsIGkuc2V0KHMsIGEpLCBhICs9IHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlbMyArIHQubGVuZ3RoXSA9IGEsIGkuc2V0KHRoaXMua2V5cywgYSksIGlbMyArIHQubGVuZ3RoICsgMV0gPSBhICs9IHRoaXMua2V5cy5sZW5ndGgsIGkuc2V0KHRoaXMuYmJveGVzLCBhKSwgYSArPSB0aGlzLmJib3hlcy5sZW5ndGgsIGkuYnVmZmVyO1xuICAgIH07XG4gICAgdmFyIERuID0gby5JbWFnZURhdGEsXG4gICAgICBMbiA9IG8uSW1hZ2VCaXRtYXAsXG4gICAgICBSbiA9IHt9O1xuICAgIGZ1bmN0aW9uIE9uKHQsIGUsIHIpIHtcbiAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX2NsYXNzUmVnaXN0cnlLZXlcIiwge1xuICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgd3JpdGVhYmxlOiAhMVxuICAgICAgfSksIFJuW3RdID0ge1xuICAgICAgICBrbGFzczogZSxcbiAgICAgICAgb21pdDogci5vbWl0IHx8IFtdLFxuICAgICAgICBzaGFsbG93OiByLnNoYWxsb3cgfHwgW11cbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAodmFyIFVuIGluIE9uKFwiT2JqZWN0XCIsIE9iamVjdCksIFZuLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHQudG9BcnJheUJ1ZmZlcigpO1xuICAgICAgcmV0dXJuIGUgJiYgZS5wdXNoKHIpLCB7XG4gICAgICAgIGJ1ZmZlcjogclxuICAgICAgfTtcbiAgICB9LCBWbi5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IFZuKHQuYnVmZmVyKTtcbiAgICB9LCBPbihcIkdyaWRcIiwgVm4pLCBPbihcIkNvbG9yXCIsIGVlKSwgT24oXCJFcnJvclwiLCBFcnJvciksIE9uKFwiUmVzb2x2ZWRJbWFnZVwiLCBhZSksIE9uKFwiU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uXCIsICRyKSwgT24oXCJTdHlsZUV4cHJlc3Npb25cIiwgR3IsIHtcbiAgICAgIG9taXQ6IFtcIl9ldmFsdWF0b3JcIl1cbiAgICB9KSwgT24oXCJab29tRGVwZW5kZW50RXhwcmVzc2lvblwiLCBIciksIE9uKFwiWm9vbUNvbnN0YW50RXhwcmVzc2lvblwiLCBKciksIE9uKFwiQ29tcG91bmRFeHByZXNzaW9uXCIsIGJlLCB7XG4gICAgICBvbWl0OiBbXCJfZXZhbHVhdGVcIl1cbiAgICB9KSwgenIpIHpyW1VuXS5fY2xhc3NSZWdpc3RyeUtleSB8fCBPbihcIkV4cHJlc3Npb25fXCIgKyBVbiwgenJbVW5dKTtcbiAgICBmdW5jdGlvbiBqbih0KSB7XG4gICAgICByZXR1cm4gdCAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBBcnJheUJ1ZmZlciAmJiAodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IHQuY29uc3RydWN0b3IgJiYgXCJBcnJheUJ1ZmZlclwiID09PSB0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxbih0KSB7XG4gICAgICByZXR1cm4gTG4gJiYgdCBpbnN0YW5jZW9mIExuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBObih0LCBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0IHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiB0IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQgfHwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCB8fCB0IGluc3RhbmNlb2YgQm9vbGVhbiB8fCB0IGluc3RhbmNlb2YgTnVtYmVyIHx8IHQgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdCBpbnN0YW5jZW9mIERhdGUgfHwgdCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHQ7XG4gICAgICBpZiAoam4odCkgfHwgcW4odCkpIHJldHVybiBlICYmIGUucHVzaCh0KSwgdDtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodCkpIHtcbiAgICAgICAgdmFyIHIgPSB0O1xuICAgICAgICByZXR1cm4gZSAmJiBlLnB1c2goci5idWZmZXIpLCByO1xuICAgICAgfVxuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBEbikgcmV0dXJuIGUgJiYgZS5wdXNoKHQuZGF0YS5idWZmZXIpLCB0O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSBuLnB1c2goTm4oYVtpXSwgZSkpO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgIHZhciBvID0gdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBzID0gby5fY2xhc3NSZWdpc3RyeUtleTtcbiAgICAgICAgaWYgKCFzKSB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBzZXJpYWxpemUgb2JqZWN0IG9mIHVucmVnaXN0ZXJlZCBjbGFzc1wiKTtcbiAgICAgICAgdmFyIHUgPSBvLnNlcmlhbGl6ZSA/IG8uc2VyaWFsaXplKHQsIGUpIDoge307XG4gICAgICAgIGlmICghby5zZXJpYWxpemUpIHtcbiAgICAgICAgICBmb3IgKHZhciBsIGluIHQpIGlmICh0Lmhhc093blByb3BlcnR5KGwpICYmICEoUm5bc10ub21pdC5pbmRleE9mKGwpID49IDApKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRbbF07XG4gICAgICAgICAgICB1W2xdID0gUm5bc10uc2hhbGxvdy5pbmRleE9mKGwpID49IDAgPyBwIDogTm4ocCwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHQgaW5zdGFuY2VvZiBFcnJvciAmJiAodS5tZXNzYWdlID0gdC5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodS4kbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiJG5hbWUgcHJvcGVydHkgaXMgcmVzZXJ2ZWQgZm9yIHdvcmtlciBzZXJpYWxpemF0aW9uIGxvZ2ljLlwiKTtcbiAgICAgICAgcmV0dXJuIFwiT2JqZWN0XCIgIT09IHMgJiYgKHUuJG5hbWUgPSBzKSwgdTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBvYmplY3Qgb2YgdHlwZSBcIiArIHR5cGVvZiB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gS24odCkge1xuICAgICAgaWYgKG51bGwgPT0gdCB8fCBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCB8fCBcIm51bWJlclwiID09IHR5cGVvZiB0IHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgfHwgdCBpbnN0YW5jZW9mIEJvb2xlYW4gfHwgdCBpbnN0YW5jZW9mIE51bWJlciB8fCB0IGluc3RhbmNlb2YgU3RyaW5nIHx8IHQgaW5zdGFuY2VvZiBEYXRlIHx8IHQgaW5zdGFuY2VvZiBSZWdFeHAgfHwgam4odCkgfHwgcW4odCkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHQpIHx8IHQgaW5zdGFuY2VvZiBEbikgcmV0dXJuIHQ7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkgcmV0dXJuIHQubWFwKEtuKTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0KSB7XG4gICAgICAgIHZhciBlID0gdC4kbmFtZSB8fCBcIk9iamVjdFwiLFxuICAgICAgICAgIHIgPSBSbltlXS5rbGFzcztcbiAgICAgICAgaWYgKCFyKSB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBkZXNlcmlhbGl6ZSB1bnJlZ2lzdGVyZWQgY2xhc3MgXCIgKyBlKTtcbiAgICAgICAgaWYgKHIuZGVzZXJpYWxpemUpIHJldHVybiByLmRlc2VyaWFsaXplKHQpO1xuICAgICAgICBmb3IgKHZhciBuID0gT2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksIGkgPSAwLCBhID0gT2JqZWN0LmtleXModCk7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIG8gPSBhW2ldO1xuICAgICAgICAgIGlmIChcIiRuYW1lXCIgIT09IG8pIHtcbiAgICAgICAgICAgIHZhciBzID0gdFtvXTtcbiAgICAgICAgICAgIG5bb10gPSBSbltlXS5zaGFsbG93LmluZGV4T2YobykgPj0gMCA/IHMgOiBLbihzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBkZXNlcmlhbGl6ZSBvYmplY3Qgb2YgdHlwZSBcIiArIHR5cGVvZiB0KTtcbiAgICB9XG4gICAgdmFyIEduID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5maXJzdCA9ICEwO1xuICAgIH07XG4gICAgR24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IE1hdGguZmxvb3IodCk7XG4gICAgICByZXR1cm4gdGhpcy5maXJzdCA/ICh0aGlzLmZpcnN0ID0gITEsIHRoaXMubGFzdEludGVnZXJab29tID0gciwgdGhpcy5sYXN0SW50ZWdlclpvb21UaW1lID0gMCwgdGhpcy5sYXN0Wm9vbSA9IHQsIHRoaXMubGFzdEZsb29yWm9vbSA9IHIsICEwKSA6ICh0aGlzLmxhc3RGbG9vclpvb20gPiByID8gKHRoaXMubGFzdEludGVnZXJab29tID0gciArIDEsIHRoaXMubGFzdEludGVnZXJab29tVGltZSA9IGUpIDogdGhpcy5sYXN0Rmxvb3Jab29tIDwgciAmJiAodGhpcy5sYXN0SW50ZWdlclpvb20gPSByLCB0aGlzLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBlKSwgdCAhPT0gdGhpcy5sYXN0Wm9vbSAmJiAodGhpcy5sYXN0Wm9vbSA9IHQsIHRoaXMubGFzdEZsb29yWm9vbSA9IHIsICEwKSk7XG4gICAgfTtcbiAgICB2YXIgWm4gPSB7XG4gICAgICBcIkxhdGluLTEgU3VwcGxlbWVudFwiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjggJiYgdCA8PSAyNTU7XG4gICAgICB9LFxuICAgICAgQXJhYmljOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxNTM2ICYmIHQgPD0gMTc5MTtcbiAgICAgIH0sXG4gICAgICBcIkFyYWJpYyBTdXBwbGVtZW50XCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDE4NzIgJiYgdCA8PSAxOTE5O1xuICAgICAgfSxcbiAgICAgIFwiQXJhYmljIEV4dGVuZGVkLUFcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMjIwOCAmJiB0IDw9IDIzMDM7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgSmFtb1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA0MzUyICYmIHQgPD0gNDYwNztcbiAgICAgIH0sXG4gICAgICBcIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNTEyMCAmJiB0IDw9IDU3NTk7XG4gICAgICB9LFxuICAgICAgS2htZXI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDYwMTYgJiYgdCA8PSA2MTQzO1xuICAgICAgfSxcbiAgICAgIFwiVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljcyBFeHRlbmRlZFwiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2MzIwICYmIHQgPD0gNjM5OTtcbiAgICAgIH0sXG4gICAgICBcIkdlbmVyYWwgUHVuY3R1YXRpb25cIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gODE5MiAmJiB0IDw9IDgzMDM7XG4gICAgICB9LFxuICAgICAgXCJMZXR0ZXJsaWtlIFN5bWJvbHNcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gODQ0OCAmJiB0IDw9IDg1Mjc7XG4gICAgICB9LFxuICAgICAgXCJOdW1iZXIgRm9ybXNcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gODUyOCAmJiB0IDw9IDg1OTE7XG4gICAgICB9LFxuICAgICAgXCJNaXNjZWxsYW5lb3VzIFRlY2huaWNhbFwiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA4OTYwICYmIHQgPD0gOTIxNTtcbiAgICAgIH0sXG4gICAgICBcIkNvbnRyb2wgUGljdHVyZXNcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gOTIxNiAmJiB0IDw9IDkyNzk7XG4gICAgICB9LFxuICAgICAgXCJPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblwiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA5MjgwICYmIHQgPD0gOTMxMTtcbiAgICAgIH0sXG4gICAgICBcIkVuY2xvc2VkIEFscGhhbnVtZXJpY3NcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gOTMxMiAmJiB0IDw9IDk0NzE7XG4gICAgICB9LFxuICAgICAgXCJHZW9tZXRyaWMgU2hhcGVzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDk2MzIgJiYgdCA8PSA5NzI3O1xuICAgICAgfSxcbiAgICAgIFwiTWlzY2VsbGFuZW91cyBTeW1ib2xzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDk3MjggJiYgdCA8PSA5OTgzO1xuICAgICAgfSxcbiAgICAgIFwiTWlzY2VsbGFuZW91cyBTeW1ib2xzIGFuZCBBcnJvd3NcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTEwMDggJiYgdCA8PSAxMTI2MztcbiAgICAgIH0sXG4gICAgICBcIkNKSyBSYWRpY2FscyBTdXBwbGVtZW50XCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDExOTA0ICYmIHQgPD0gMTIwMzE7XG4gICAgICB9LFxuICAgICAgXCJLYW5neGkgUmFkaWNhbHNcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTIwMzIgJiYgdCA8PSAxMjI1NTtcbiAgICAgIH0sXG4gICAgICBcIklkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTIyNzIgJiYgdCA8PSAxMjI4NztcbiAgICAgIH0sXG4gICAgICBcIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjI4OCAmJiB0IDw9IDEyMzUxO1xuICAgICAgfSxcbiAgICAgIEhpcmFnYW5hOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjM1MiAmJiB0IDw9IDEyNDQ3O1xuICAgICAgfSxcbiAgICAgIEthdGFrYW5hOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjQ0OCAmJiB0IDw9IDEyNTQzO1xuICAgICAgfSxcbiAgICAgIEJvcG9tb2ZvOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjU0NCAmJiB0IDw9IDEyNTkxO1xuICAgICAgfSxcbiAgICAgIFwiSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjU5MiAmJiB0IDw9IDEyNjg3O1xuICAgICAgfSxcbiAgICAgIEthbmJ1bjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTI2ODggJiYgdCA8PSAxMjcwMztcbiAgICAgIH0sXG4gICAgICBcIkJvcG9tb2ZvIEV4dGVuZGVkXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDEyNzA0ICYmIHQgPD0gMTI3MzU7XG4gICAgICB9LFxuICAgICAgXCJDSksgU3Ryb2tlc1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjczNiAmJiB0IDw9IDEyNzgzO1xuICAgICAgfSxcbiAgICAgIFwiS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjc4NCAmJiB0IDw9IDEyNzk5O1xuICAgICAgfSxcbiAgICAgIFwiRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSAxMjgwMCAmJiB0IDw9IDEzMDU1O1xuICAgICAgfSxcbiAgICAgIFwiQ0pLIENvbXBhdGliaWxpdHlcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTMwNTYgJiYgdCA8PSAxMzMxMTtcbiAgICAgIH0sXG4gICAgICBcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gMTMzMTIgJiYgdCA8PSAxOTkwMztcbiAgICAgIH0sXG4gICAgICBcIllpamluZyBIZXhhZ3JhbSBTeW1ib2xzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDE5OTA0ICYmIHQgPD0gMTk5Njc7XG4gICAgICB9LFxuICAgICAgXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDE5OTY4ICYmIHQgPD0gNDA5NTk7XG4gICAgICB9LFxuICAgICAgXCJZaSBTeWxsYWJsZXNcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNDA5NjAgJiYgdCA8PSA0MjEyNztcbiAgICAgIH0sXG4gICAgICBcIllpIFJhZGljYWxzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDQyMTI4ICYmIHQgPD0gNDIxOTE7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDQzMzYwICYmIHQgPD0gNDMzOTE7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgU3lsbGFibGVzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDQ0MDMyICYmIHQgPD0gNTUyMTU7XG4gICAgICB9LFxuICAgICAgXCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1CXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDU1MjE2ICYmIHQgPD0gNTUyOTU7XG4gICAgICB9LFxuICAgICAgXCJQcml2YXRlIFVzZSBBcmVhXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDU3MzQ0ICYmIHQgPD0gNjM3NDM7XG4gICAgICB9LFxuICAgICAgXCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDYzNzQ0ICYmIHQgPD0gNjQyNTU7XG4gICAgICB9LFxuICAgICAgXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcIjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPj0gNjQzMzYgJiYgdCA8PSA2NTAyMztcbiAgICAgIH0sXG4gICAgICBcIlZlcnRpY2FsIEZvcm1zXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDY1MDQwICYmIHQgPD0gNjUwNTU7XG4gICAgICB9LFxuICAgICAgXCJDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NTA3MiAmJiB0IDw9IDY1MTAzO1xuICAgICAgfSxcbiAgICAgIFwiU21hbGwgRm9ybSBWYXJpYW50c1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NTEwNCAmJiB0IDw9IDY1MTM1O1xuICAgICAgfSxcbiAgICAgIFwiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1CXCI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID49IDY1MTM2ICYmIHQgPD0gNjUyNzk7XG4gICAgICB9LFxuICAgICAgXCJIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1wiOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA+PSA2NTI4MCAmJiB0IDw9IDY1NTE5O1xuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gWG4odCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkgaWYgKEpuKHJbZV0uY2hhckNvZGVBdCgwKSkpIHJldHVybiAhMDtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSm4odCkge1xuICAgICAgcmV0dXJuICEoNzQ2ICE9PSB0ICYmIDc0NyAhPT0gdCAmJiAodCA8IDQzNTIgfHwgIShabltcIkJvcG9tb2ZvIEV4dGVuZGVkXCJdKHQpIHx8IFpuLkJvcG9tb2ZvKHQpIHx8IFpuW1wiQ0pLIENvbXBhdGliaWxpdHkgRm9ybXNcIl0odCkgJiYgISh0ID49IDY1MDk3ICYmIHQgPD0gNjUxMDMpIHx8IFpuW1wiQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1wiXSh0KSB8fCBabltcIkNKSyBDb21wYXRpYmlsaXR5XCJdKHQpIHx8IFpuW1wiQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcIl0odCkgfHwgWm5bXCJDSksgU3Ryb2tlc1wiXSh0KSB8fCAhKCFabltcIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvblwiXSh0KSB8fCB0ID49IDEyMjk2ICYmIHQgPD0gMTIzMDUgfHwgdCA+PSAxMjMwOCAmJiB0IDw9IDEyMzE5IHx8IDEyMzM2ID09PSB0KSB8fCBabltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcIl0odCkgfHwgWm5bXCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzXCJdKHQpIHx8IFpuW1wiRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1wiXSh0KSB8fCBabltcIkhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cIl0odCkgfHwgWm5bXCJIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXCJdKHQpIHx8IFpuW1wiSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQlwiXSh0KSB8fCBabltcIkhhbmd1bCBKYW1vXCJdKHQpIHx8IFpuW1wiSGFuZ3VsIFN5bGxhYmxlc1wiXSh0KSB8fCBabi5IaXJhZ2FuYSh0KSB8fCBabltcIklkZW9ncmFwaGljIERlc2NyaXB0aW9uIENoYXJhY3RlcnNcIl0odCkgfHwgWm4uS2FuYnVuKHQpIHx8IFpuW1wiS2FuZ3hpIFJhZGljYWxzXCJdKHQpIHx8IFpuW1wiS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1wiXSh0KSB8fCBabi5LYXRha2FuYSh0KSAmJiAxMjU0MCAhPT0gdCB8fCAhKCFabltcIkhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXCJdKHQpIHx8IDY1Mjg4ID09PSB0IHx8IDY1Mjg5ID09PSB0IHx8IDY1MjkzID09PSB0IHx8IHQgPj0gNjUzMDYgJiYgdCA8PSA2NTMxMCB8fCA2NTMzOSA9PT0gdCB8fCA2NTM0MSA9PT0gdCB8fCA2NTM0MyA9PT0gdCB8fCB0ID49IDY1MzcxICYmIHQgPD0gNjU1MDMgfHwgNjU1MDcgPT09IHQgfHwgdCA+PSA2NTUxMiAmJiB0IDw9IDY1NTE5KSB8fCAhKCFabltcIlNtYWxsIEZvcm0gVmFyaWFudHNcIl0odCkgfHwgdCA+PSA2NTExMiAmJiB0IDw9IDY1MTE4IHx8IHQgPj0gNjUxMjMgJiYgdCA8PSA2NTEyNikgfHwgWm5bXCJVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXCJdKHQpIHx8IFpuW1wiVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljcyBFeHRlbmRlZFwiXSh0KSB8fCBabltcIlZlcnRpY2FsIEZvcm1zXCJdKHQpIHx8IFpuW1wiWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcIl0odCkgfHwgWm5bXCJZaSBTeWxsYWJsZXNcIl0odCkgfHwgWm5bXCJZaSBSYWRpY2Fsc1wiXSh0KSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSG4odCkge1xuICAgICAgcmV0dXJuICEoSm4odCkgfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuICEhKFpuW1wiTGF0aW4tMSBTdXBwbGVtZW50XCJdKHQpICYmICgxNjcgPT09IHQgfHwgMTY5ID09PSB0IHx8IDE3NCA9PT0gdCB8fCAxNzcgPT09IHQgfHwgMTg4ID09PSB0IHx8IDE4OSA9PT0gdCB8fCAxOTAgPT09IHQgfHwgMjE1ID09PSB0IHx8IDI0NyA9PT0gdCkgfHwgWm5bXCJHZW5lcmFsIFB1bmN0dWF0aW9uXCJdKHQpICYmICg4MjE0ID09PSB0IHx8IDgyMjQgPT09IHQgfHwgODIyNSA9PT0gdCB8fCA4MjQwID09PSB0IHx8IDgyNDEgPT09IHQgfHwgODI1MSA9PT0gdCB8fCA4MjUyID09PSB0IHx8IDgyNTggPT09IHQgfHwgODI2MyA9PT0gdCB8fCA4MjY0ID09PSB0IHx8IDgyNjUgPT09IHQgfHwgODI3MyA9PT0gdCkgfHwgWm5bXCJMZXR0ZXJsaWtlIFN5bWJvbHNcIl0odCkgfHwgWm5bXCJOdW1iZXIgRm9ybXNcIl0odCkgfHwgWm5bXCJNaXNjZWxsYW5lb3VzIFRlY2huaWNhbFwiXSh0KSAmJiAodCA+PSA4OTYwICYmIHQgPD0gODk2NyB8fCB0ID49IDg5NzIgJiYgdCA8PSA4OTkxIHx8IHQgPj0gODk5NiAmJiB0IDw9IDllMyB8fCA5MDAzID09PSB0IHx8IHQgPj0gOTA4NSAmJiB0IDw9IDkxMTQgfHwgdCA+PSA5MTUwICYmIHQgPD0gOTE2NSB8fCA5MTY3ID09PSB0IHx8IHQgPj0gOTE2OSAmJiB0IDw9IDkxNzkgfHwgdCA+PSA5MTg2ICYmIHQgPD0gOTIxNSkgfHwgWm5bXCJDb250cm9sIFBpY3R1cmVzXCJdKHQpICYmIDkyNTEgIT09IHQgfHwgWm5bXCJPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblwiXSh0KSB8fCBabltcIkVuY2xvc2VkIEFscGhhbnVtZXJpY3NcIl0odCkgfHwgWm5bXCJHZW9tZXRyaWMgU2hhcGVzXCJdKHQpIHx8IFpuW1wiTWlzY2VsbGFuZW91cyBTeW1ib2xzXCJdKHQpICYmICEodCA+PSA5NzU0ICYmIHQgPD0gOTc1OSkgfHwgWm5bXCJNaXNjZWxsYW5lb3VzIFN5bWJvbHMgYW5kIEFycm93c1wiXSh0KSAmJiAodCA+PSAxMTAyNiAmJiB0IDw9IDExMDU1IHx8IHQgPj0gMTEwODggJiYgdCA8PSAxMTA5NyB8fCB0ID49IDExMTkyICYmIHQgPD0gMTEyNDMpIHx8IFpuW1wiQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXCJdKHQpIHx8IFpuLkthdGFrYW5hKHQpIHx8IFpuW1wiUHJpdmF0ZSBVc2UgQXJlYVwiXSh0KSB8fCBabltcIkNKSyBDb21wYXRpYmlsaXR5IEZvcm1zXCJdKHQpIHx8IFpuW1wiU21hbGwgRm9ybSBWYXJpYW50c1wiXSh0KSB8fCBabltcIkhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXCJdKHQpIHx8IDg3MzQgPT09IHQgfHwgODc1NiA9PT0gdCB8fCA4NzU3ID09PSB0IHx8IHQgPj0gOTk4NCAmJiB0IDw9IDEwMDg3IHx8IHQgPj0gMTAxMDIgJiYgdCA8PSAxMDEzMSB8fCA2NTUzMiA9PT0gdCB8fCA2NTUzMyA9PT0gdCk7XG4gICAgICB9KHQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWW4odCkge1xuICAgICAgcmV0dXJuIHQgPj0gMTQyNCAmJiB0IDw9IDIzMDMgfHwgWm5bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcIl0odCkgfHwgWm5bXCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcIl0odCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uICRuKHQsIGUpIHtcbiAgICAgIHJldHVybiAhKCFlICYmIFluKHQpIHx8IHQgPj0gMjMwNCAmJiB0IDw9IDM1ODMgfHwgdCA+PSAzODQwICYmIHQgPD0gNDI1NSB8fCBabi5LaG1lcih0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFduKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIGlmIChZbihyW2VdLmNoYXJDb2RlQXQoMCkpKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHZhciBRbiA9IG51bGwsXG4gICAgICB0aSA9IFwidW5hdmFpbGFibGVcIixcbiAgICAgIGVpID0gbnVsbCxcbiAgICAgIHJpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIHQuaW5kZXhPZihcIk5ldHdvcmtFcnJvclwiKSA+IC0xICYmICh0aSA9IFwiZXJyb3JcIiksIFFuICYmIFFuKHQpO1xuICAgICAgfTtcbiAgICBmdW5jdGlvbiBuaSgpIHtcbiAgICAgIGlpLmZpcmUobmV3IHp0KFwicGx1Z2luU3RhdGVDaGFuZ2VcIiwge1xuICAgICAgICBwbHVnaW5TdGF0dXM6IHRpLFxuICAgICAgICBwbHVnaW5VUkw6IGVpXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHZhciBpaSA9IG5ldyBFdCgpLFxuICAgICAgYWkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aTtcbiAgICAgIH0sXG4gICAgICBvaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFwiZGVmZXJyZWRcIiAhPT0gdGkgfHwgIWVpKSB0aHJvdyBuZXcgRXJyb3IoXCJydGwtdGV4dC1wbHVnaW4gY2Fubm90IGJlIGRvd25sb2FkZWQgdW5sZXNzIGEgcGx1Z2luVVJMIGlzIHNwZWNpZmllZFwiKTtcbiAgICAgICAgdGkgPSBcImxvYWRpbmdcIiwgbmkoKSwgZWkgJiYgd3Qoe1xuICAgICAgICAgIHVybDogZWlcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0ID8gcmkodCkgOiAodGkgPSBcImxvYWRlZFwiLCBuaSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2kgPSB7XG4gICAgICAgIGFwcGx5QXJhYmljU2hhcGluZzogbnVsbCxcbiAgICAgICAgcHJvY2Vzc0JpZGlyZWN0aW9uYWxUZXh0OiBudWxsLFxuICAgICAgICBwcm9jZXNzU3R5bGVkQmlkaXJlY3Rpb25hbFRleHQ6IG51bGwsXG4gICAgICAgIGlzTG9hZGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFwibG9hZGVkXCIgPT09IHRpIHx8IG51bGwgIT0gc2kuYXBwbHlBcmFiaWNTaGFwaW5nO1xuICAgICAgICB9LFxuICAgICAgICBpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gXCJsb2FkaW5nXCIgPT09IHRpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTdGF0ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aSA9IHQucGx1Z2luU3RhdHVzLCBlaSA9IHQucGx1Z2luVVJMO1xuICAgICAgICB9LFxuICAgICAgICBpc1BhcnNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsICE9IHNpLmFwcGx5QXJhYmljU2hhcGluZyAmJiBudWxsICE9IHNpLnByb2Nlc3NCaWRpcmVjdGlvbmFsVGV4dCAmJiBudWxsICE9IHNpLnByb2Nlc3NTdHlsZWRCaWRpcmVjdGlvbmFsVGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGx1Z2luVVJMOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGVpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdWkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLnpvb20gPSB0LCBlID8gKHRoaXMubm93ID0gZS5ub3csIHRoaXMuZmFkZUR1cmF0aW9uID0gZS5mYWRlRHVyYXRpb24sIHRoaXMuem9vbUhpc3RvcnkgPSBlLnpvb21IaXN0b3J5LCB0aGlzLnRyYW5zaXRpb24gPSBlLnRyYW5zaXRpb24pIDogKHRoaXMubm93ID0gMCwgdGhpcy5mYWRlRHVyYXRpb24gPSAwLCB0aGlzLnpvb21IaXN0b3J5ID0gbmV3IEduKCksIHRoaXMudHJhbnNpdGlvbiA9IHt9KTtcbiAgICAgIH07XG4gICAgdWkucHJvdG90eXBlLmlzU3VwcG9ydGVkU2NyaXB0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gMCwgbiA9IHQ7IHIgPCBuLmxlbmd0aDsgciArPSAxKSBpZiAoISRuKG5bcl0uY2hhckNvZGVBdCgwKSwgZSkpIHJldHVybiAhMTtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSh0LCBzaS5pc0xvYWRlZCgpKTtcbiAgICB9LCB1aS5wcm90b3R5cGUuY3Jvc3NGYWRpbmdGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5mYWRlRHVyYXRpb24gPyAxIDogTWF0aC5taW4oKHRoaXMubm93IC0gdGhpcy56b29tSGlzdG9yeS5sYXN0SW50ZWdlclpvb21UaW1lKSAvIHRoaXMuZmFkZUR1cmF0aW9uLCAxKTtcbiAgICB9LCB1aS5wcm90b3R5cGUuZ2V0Q3Jvc3NmYWRlUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy56b29tLFxuICAgICAgICBlID0gdCAtIE1hdGguZmxvb3IodCksXG4gICAgICAgIHIgPSB0aGlzLmNyb3NzRmFkaW5nRmFjdG9yKCk7XG4gICAgICByZXR1cm4gdCA+IHRoaXMuem9vbUhpc3RvcnkubGFzdEludGVnZXJab29tID8ge1xuICAgICAgICBmcm9tU2NhbGU6IDIsXG4gICAgICAgIHRvU2NhbGU6IDEsXG4gICAgICAgIHQ6IGUgKyAoMSAtIGUpICogclxuICAgICAgfSA6IHtcbiAgICAgICAgZnJvbVNjYWxlOiAuNSxcbiAgICAgICAgdG9TY2FsZTogMSxcbiAgICAgICAgdDogMSAtICgxIC0gcikgKiBlXG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGxpID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSB0LCB0aGlzLnZhbHVlID0gZSwgdGhpcy5leHByZXNzaW9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKFJyKHQpKSByZXR1cm4gbmV3ICRyKHQsIGUpO1xuICAgICAgICBpZiAoWnIodCkpIHtcbiAgICAgICAgICB2YXIgciA9IFlyKHQsIGUpO1xuICAgICAgICAgIGlmIChcImVycm9yXCIgPT09IHIucmVzdWx0KSB0aHJvdyBuZXcgRXJyb3Ioci52YWx1ZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmtleSArIFwiOiBcIiArIHQubWVzc2FnZTtcbiAgICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgIHJldHVybiByLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gdDtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgXCJjb2xvclwiID09PSBlLnR5cGUgJiYgKG4gPSBlZS5wYXJzZSh0KSksIHtcbiAgICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0odm9pZCAwID09PSBlID8gdC5zcGVjaWZpY2F0aW9uLmRlZmF1bHQgOiBlLCB0LnNwZWNpZmljYXRpb24pO1xuICAgIH07XG4gICAgbGkucHJvdG90eXBlLmlzRGF0YURyaXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcInNvdXJjZVwiID09PSB0aGlzLmV4cHJlc3Npb24ua2luZCB8fCBcImNvbXBvc2l0ZVwiID09PSB0aGlzLmV4cHJlc3Npb24ua2luZDtcbiAgICB9LCBsaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5wb3NzaWJseUV2YWx1YXRlKHRoaXMsIHQsIGUsIHIpO1xuICAgIH07XG4gICAgdmFyIHBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMucHJvcGVydHkgPSB0LCB0aGlzLnZhbHVlID0gbmV3IGxpKHQsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwaS5wcm90b3R5cGUudHJhbnNpdGlvbmVkID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiBuZXcgaGkodGhpcy5wcm9wZXJ0eSwgdGhpcy52YWx1ZSwgZSwgaCh7fSwgdC50cmFuc2l0aW9uLCB0aGlzLnRyYW5zaXRpb24pLCB0Lm5vdyk7XG4gICAgfSwgcGkucHJvdG90eXBlLnVudHJhbnNpdGlvbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBoaSh0aGlzLnByb3BlcnR5LCB0aGlzLnZhbHVlLCBudWxsLCB7fSwgMCk7XG4gICAgfTtcbiAgICB2YXIgY2kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHQsIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUodC5kZWZhdWx0VHJhbnNpdGlvbmFibGVQcm9wZXJ0eVZhbHVlcyk7XG4gICAgfTtcbiAgICBjaS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHcodGhpcy5fdmFsdWVzW3RdLnZhbHVlLnZhbHVlKTtcbiAgICB9LCBjaS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5fdmFsdWVzLmhhc093blByb3BlcnR5KHQpIHx8ICh0aGlzLl92YWx1ZXNbdF0gPSBuZXcgcGkodGhpcy5fdmFsdWVzW3RdLnByb3BlcnR5KSksIHRoaXMuX3ZhbHVlc1t0XS52YWx1ZSA9IG5ldyBsaSh0aGlzLl92YWx1ZXNbdF0ucHJvcGVydHksIG51bGwgPT09IGUgPyB2b2lkIDAgOiB3KGUpKTtcbiAgICB9LCBjaS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdyh0aGlzLl92YWx1ZXNbdF0udHJhbnNpdGlvbik7XG4gICAgfSwgY2kucHJvdG90eXBlLnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5fdmFsdWVzLmhhc093blByb3BlcnR5KHQpIHx8ICh0aGlzLl92YWx1ZXNbdF0gPSBuZXcgcGkodGhpcy5fdmFsdWVzW3RdLnByb3BlcnR5KSksIHRoaXMuX3ZhbHVlc1t0XS50cmFuc2l0aW9uID0gdyhlKSB8fCB2b2lkIDA7XG4gICAgfSwgY2kucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSB7fSwgZSA9IDAsIHIgPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZXMpOyBlIDwgci5sZW5ndGg7IGUgKz0gMSkge1xuICAgICAgICB2YXIgbiA9IHJbZV0sXG4gICAgICAgICAgaSA9IHRoaXMuZ2V0VmFsdWUobik7XG4gICAgICAgIHZvaWQgMCAhPT0gaSAmJiAodFtuXSA9IGkpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0VHJhbnNpdGlvbihuKTtcbiAgICAgICAgdm9pZCAwICE9PSBhICYmICh0W24gKyBcIi10cmFuc2l0aW9uXCJdID0gYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBjaS5wcm90b3R5cGUudHJhbnNpdGlvbmVkID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSBuZXcgZmkodGhpcy5fcHJvcGVydGllcyksIG4gPSAwLCBpID0gT2JqZWN0LmtleXModGhpcy5fdmFsdWVzKTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBpW25dO1xuICAgICAgICByLl92YWx1ZXNbYV0gPSB0aGlzLl92YWx1ZXNbYV0udHJhbnNpdGlvbmVkKHQsIGUuX3ZhbHVlc1thXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBjaS5wcm90b3R5cGUudW50cmFuc2l0aW9uZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gbmV3IGZpKHRoaXMuX3Byb3BlcnRpZXMpLCBlID0gMCwgciA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXTtcbiAgICAgICAgdC5fdmFsdWVzW25dID0gdGhpcy5fdmFsdWVzW25dLnVudHJhbnNpdGlvbmVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHZhciBoaSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0aGlzLnByb3BlcnR5ID0gdCwgdGhpcy52YWx1ZSA9IGUsIHRoaXMuYmVnaW4gPSBpICsgbi5kZWxheSB8fCAwLCB0aGlzLmVuZCA9IHRoaXMuYmVnaW4gKyBuLmR1cmF0aW9uIHx8IDAsIHQuc3BlY2lmaWNhdGlvbi50cmFuc2l0aW9uICYmIChuLmRlbGF5IHx8IG4uZHVyYXRpb24pICYmICh0aGlzLnByaW9yID0gcik7XG4gICAgfTtcbiAgICBoaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHQubm93IHx8IDAsXG4gICAgICAgIGkgPSB0aGlzLnZhbHVlLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgciksXG4gICAgICAgIGEgPSB0aGlzLnByaW9yO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKG4gPiB0aGlzLmVuZCkgcmV0dXJuIHRoaXMucHJpb3IgPSBudWxsLCBpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5pc0RhdGFEcml2ZW4oKSkgcmV0dXJuIHRoaXMucHJpb3IgPSBudWxsLCBpO1xuICAgICAgICBpZiAobiA8IHRoaXMuYmVnaW4pIHJldHVybiBhLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgcik7XG4gICAgICAgIHZhciBvID0gKG4gLSB0aGlzLmJlZ2luKSAvICh0aGlzLmVuZCAtIHRoaXMuYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5pbnRlcnBvbGF0ZShhLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgciksIGksIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgICAgICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgICAgICAgdmFyIGUgPSB0ICogdCxcbiAgICAgICAgICAgIHIgPSBlICogdDtcbiAgICAgICAgICByZXR1cm4gNCAqICh0IDwgLjUgPyByIDogMyAqICh0IC0gZSkgKyByIC0gLjc1KTtcbiAgICAgICAgfShvKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuICAgIHZhciBmaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdCwgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0LmRlZmF1bHRUcmFuc2l0aW9uaW5nUHJvcGVydHlWYWx1ZXMpO1xuICAgIH07XG4gICAgZmkucHJvdG90eXBlLnBvc3NpYmx5RXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IG5ldyBtaSh0aGlzLl9wcm9wZXJ0aWVzKSwgaSA9IDAsIGEgPSBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZXMpOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IGFbaV07XG4gICAgICAgIG4uX3ZhbHVlc1tvXSA9IHRoaXMuX3ZhbHVlc1tvXS5wb3NzaWJseUV2YWx1YXRlKHQsIGUsIHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgZmkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMCwgZSA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBpZiAodGhpcy5fdmFsdWVzW2VbdF1dLnByaW9yKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcbiAgICB2YXIgeWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fcHJvcGVydGllcyA9IHQsIHRoaXMuX3ZhbHVlcyA9IE9iamVjdC5jcmVhdGUodC5kZWZhdWx0UHJvcGVydHlWYWx1ZXMpO1xuICAgIH07XG4gICAgeWkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB3KHRoaXMuX3ZhbHVlc1t0XS52YWx1ZSk7XG4gICAgfSwgeWkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlc1t0XSA9IG5ldyBsaSh0aGlzLl92YWx1ZXNbdF0ucHJvcGVydHksIG51bGwgPT09IGUgPyB2b2lkIDAgOiB3KGUpKTtcbiAgICB9LCB5aS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IHt9LCBlID0gMCwgciA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IGUgPCByLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gcltlXSxcbiAgICAgICAgICBpID0gdGhpcy5nZXRWYWx1ZShuKTtcbiAgICAgICAgdm9pZCAwICE9PSBpICYmICh0W25dID0gaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCB5aS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gbmV3IG1pKHRoaXMuX3Byb3BlcnRpZXMpLCBpID0gMCwgYSA9IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlcyk7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgbi5fdmFsdWVzW29dID0gdGhpcy5fdmFsdWVzW29dLnBvc3NpYmx5RXZhbHVhdGUodCwgZSwgcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9O1xuICAgIHZhciBkaSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnByb3BlcnR5ID0gdCwgdGhpcy52YWx1ZSA9IGUsIHRoaXMucGFyYW1ldGVycyA9IHI7XG4gICAgfTtcbiAgICBkaS5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImNvbnN0YW50XCIgPT09IHRoaXMudmFsdWUua2luZDtcbiAgICB9LCBkaS5wcm90b3R5cGUuY29uc3RhbnRPciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gXCJjb25zdGFudFwiID09PSB0aGlzLnZhbHVlLmtpbmQgPyB0aGlzLnZhbHVlLnZhbHVlIDogdDtcbiAgICB9LCBkaS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuZXZhbHVhdGUodGhpcy52YWx1ZSwgdGhpcy5wYXJhbWV0ZXJzLCB0LCBlLCByLCBuKTtcbiAgICB9O1xuICAgIHZhciBtaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdCwgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0LmRlZmF1bHRQb3NzaWJseUV2YWx1YXRlZFZhbHVlcyk7XG4gICAgfTtcbiAgICBtaS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNbdF07XG4gICAgfTtcbiAgICB2YXIgdmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5zcGVjaWZpY2F0aW9uID0gdDtcbiAgICB9O1xuICAgIHZpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LmV4cHJlc3Npb24uZXZhbHVhdGUoZSk7XG4gICAgfSwgdmkucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gWmVbdGhpcy5zcGVjaWZpY2F0aW9uLnR5cGVdO1xuICAgICAgcmV0dXJuIG4gPyBuKHQsIGUsIHIpIDogdDtcbiAgICB9O1xuICAgIHZhciBnaSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnNwZWNpZmljYXRpb24gPSB0LCB0aGlzLm92ZXJyaWRlcyA9IGU7XG4gICAgfTtcbiAgICBnaS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gbmV3IGRpKHRoaXMsIFwiY29uc3RhbnRcIiA9PT0gdC5leHByZXNzaW9uLmtpbmQgfHwgXCJjYW1lcmFcIiA9PT0gdC5leHByZXNzaW9uLmtpbmQgPyB7XG4gICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgdmFsdWU6IHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlLCBudWxsLCB7fSwgciwgbilcbiAgICAgIH0gOiB0LmV4cHJlc3Npb24sIGUpO1xuICAgIH0sIGdpLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBpZiAoXCJjb25zdGFudFwiICE9PSB0LnZhbHVlLmtpbmQgfHwgXCJjb25zdGFudFwiICE9PSBlLnZhbHVlLmtpbmQpIHJldHVybiB0O1xuICAgICAgaWYgKHZvaWQgMCA9PT0gdC52YWx1ZS52YWx1ZSB8fCB2b2lkIDAgPT09IGUudmFsdWUudmFsdWUpIHJldHVybiBuZXcgZGkodGhpcywge1xuICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgIH0sIHQucGFyYW1ldGVycyk7XG4gICAgICB2YXIgbiA9IFplW3RoaXMuc3BlY2lmaWNhdGlvbi50eXBlXTtcbiAgICAgIHJldHVybiBuID8gbmV3IGRpKHRoaXMsIHtcbiAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICB2YWx1ZTogbih0LnZhbHVlLnZhbHVlLCBlLnZhbHVlLnZhbHVlLCByKVxuICAgICAgfSwgdC5wYXJhbWV0ZXJzKSA6IHQ7XG4gICAgfSwgZ2kucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiBcImNvbnN0YW50XCIgPT09IHQua2luZCA/IHQudmFsdWUgOiB0LmV2YWx1YXRlKGUsIHIsIG4sIGksIGEpO1xuICAgIH07XG4gICAgdmFyIHhpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gdC52YWx1ZSkgcmV0dXJuIG5ldyBkaSh0aGlzLCB7XG4gICAgICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgaWYgKFwiY29uc3RhbnRcIiA9PT0gdC5leHByZXNzaW9uLmtpbmQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdC5leHByZXNzaW9uLmV2YWx1YXRlKGUsIG51bGwsIHt9LCByLCBuKSxcbiAgICAgICAgICAgICAgYSA9IFwicmVzb2x2ZWRJbWFnZVwiID09PSB0LnByb3BlcnR5LnNwZWNpZmljYXRpb24udHlwZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBpID8gaS5uYW1lIDogaSxcbiAgICAgICAgICAgICAgbyA9IHRoaXMuX2NhbGN1bGF0ZShhLCBhLCBhLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGkodGhpcywge1xuICAgICAgICAgICAgICBraW5kOiBcImNvbnN0YW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBvXG4gICAgICAgICAgICB9LCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiY2FtZXJhXCIgPT09IHQuZXhwcmVzc2lvbi5raW5kKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuX2NhbGN1bGF0ZSh0LmV4cHJlc3Npb24uZXZhbHVhdGUoe1xuICAgICAgICAgICAgICB6b29tOiBlLnpvb20gLSAxXG4gICAgICAgICAgICB9KSwgdC5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgICAgICAgem9vbTogZS56b29tXG4gICAgICAgICAgICB9KSwgdC5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgICAgICAgem9vbTogZS56b29tICsgMVxuICAgICAgICAgICAgfSksIGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBkaSh0aGlzLCB7XG4gICAgICAgICAgICAgIGtpbmQ6IFwiY29uc3RhbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHNcbiAgICAgICAgICAgIH0sIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IGRpKHRoaXMsIHQuZXhwcmVzc2lvbiwgZSk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgICAgICBpZiAoXCJzb3VyY2VcIiA9PT0gdC5raW5kKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHQuZXZhbHVhdGUoZSwgciwgbiwgaSwgYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlKG8sIG8sIG8sIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJjb21wb3NpdGVcIiA9PT0gdC5raW5kID8gdGhpcy5fY2FsY3VsYXRlKHQuZXZhbHVhdGUoe1xuICAgICAgICAgICAgem9vbTogTWF0aC5mbG9vcihlLnpvb20pIC0gMVxuICAgICAgICAgIH0sIHIsIG4pLCB0LmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IE1hdGguZmxvb3IoZS56b29tKVxuICAgICAgICAgIH0sIHIsIG4pLCB0LmV2YWx1YXRlKHtcbiAgICAgICAgICAgIHpvb206IE1hdGguZmxvb3IoZS56b29tKSArIDFcbiAgICAgICAgICB9LCByLCBuKSwgZSkgOiB0LnZhbHVlO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5fY2FsY3VsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICByZXR1cm4gbi56b29tID4gbi56b29tSGlzdG9yeS5sYXN0SW50ZWdlclpvb20gPyB7XG4gICAgICAgICAgICBmcm9tOiB0LFxuICAgICAgICAgICAgdG86IGVcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgZnJvbTogcixcbiAgICAgICAgICAgIHRvOiBlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9LCBlO1xuICAgICAgfShnaSksXG4gICAgICBiaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQ7XG4gICAgICB9O1xuICAgIGJpLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIGlmICh2b2lkIDAgIT09IHQudmFsdWUpIHtcbiAgICAgICAgaWYgKFwiY29uc3RhbnRcIiA9PT0gdC5leHByZXNzaW9uLmtpbmQpIHtcbiAgICAgICAgICB2YXIgaSA9IHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlLCBudWxsLCB7fSwgciwgbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZShpLCBpLCBpLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlKHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgdWkoTWF0aC5mbG9vcihlLnpvb20gLSAxKSwgZSkpLCB0LmV4cHJlc3Npb24uZXZhbHVhdGUobmV3IHVpKE1hdGguZmxvb3IoZS56b29tKSwgZSkpLCB0LmV4cHJlc3Npb24uZXZhbHVhdGUobmV3IHVpKE1hdGguZmxvb3IoZS56b29tICsgMSksIGUpKSwgZSk7XG4gICAgICB9XG4gICAgfSwgYmkucHJvdG90eXBlLl9jYWxjdWxhdGUgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIG4uem9vbSA+IG4uem9vbUhpc3RvcnkubGFzdEludGVnZXJab29tID8ge1xuICAgICAgICBmcm9tOiB0LFxuICAgICAgICB0bzogZVxuICAgICAgfSA6IHtcbiAgICAgICAgZnJvbTogcixcbiAgICAgICAgdG86IGVcbiAgICAgIH07XG4gICAgfSwgYmkucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgdmFyIHdpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQ7XG4gICAgfTtcbiAgICB3aS5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICByZXR1cm4gISF0LmV4cHJlc3Npb24uZXZhbHVhdGUoZSwgbnVsbCwge30sIHIsIG4pO1xuICAgIH0sIHdpLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuICAgIHZhciBfaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMucHJvcGVydGllcyA9IHQsIHRoaXMuZGVmYXVsdFByb3BlcnR5VmFsdWVzID0ge30sIHRoaXMuZGVmYXVsdFRyYW5zaXRpb25hYmxlUHJvcGVydHlWYWx1ZXMgPSB7fSwgdGhpcy5kZWZhdWx0VHJhbnNpdGlvbmluZ1Byb3BlcnR5VmFsdWVzID0ge30sIHRoaXMuZGVmYXVsdFBvc3NpYmx5RXZhbHVhdGVkVmFsdWVzID0ge30sIHRoaXMub3ZlcnJpZGFibGVQcm9wZXJ0aWVzID0gW10sIHQpIHtcbiAgICAgICAgdmFyIHIgPSB0W2VdO1xuICAgICAgICByLnNwZWNpZmljYXRpb24ub3ZlcnJpZGFibGUgJiYgdGhpcy5vdmVycmlkYWJsZVByb3BlcnRpZXMucHVzaChlKTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmRlZmF1bHRQcm9wZXJ0eVZhbHVlc1tlXSA9IG5ldyBsaShyLCB2b2lkIDApLFxuICAgICAgICAgIGkgPSB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uYWJsZVByb3BlcnR5VmFsdWVzW2VdID0gbmV3IHBpKHIpO1xuICAgICAgICB0aGlzLmRlZmF1bHRUcmFuc2l0aW9uaW5nUHJvcGVydHlWYWx1ZXNbZV0gPSBpLnVudHJhbnNpdGlvbmVkKCksIHRoaXMuZGVmYXVsdFBvc3NpYmx5RXZhbHVhdGVkVmFsdWVzW2VdID0gbi5wb3NzaWJseUV2YWx1YXRlKHt9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE9uKFwiRGF0YURyaXZlblByb3BlcnR5XCIsIGdpKSwgT24oXCJEYXRhQ29uc3RhbnRQcm9wZXJ0eVwiLCB2aSksIE9uKFwiQ3Jvc3NGYWRlZERhdGFEcml2ZW5Qcm9wZXJ0eVwiLCB4aSksIE9uKFwiQ3Jvc3NGYWRlZFByb3BlcnR5XCIsIGJpKSwgT24oXCJDb2xvclJhbXBQcm9wZXJ0eVwiLCB3aSk7XG4gICAgdmFyIEFpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgICAgaWYgKHQuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGUuaWQsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5fZmVhdHVyZUZpbHRlciA9IHtcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmVlZEdlb21ldHJ5OiAhMVxuICAgICAgICAgIH0sIFwiY3VzdG9tXCIgIT09IGUudHlwZSAmJiAodGhpcy5tZXRhZGF0YSA9IChlID0gZSkubWV0YWRhdGEsIHRoaXMubWluem9vbSA9IGUubWluem9vbSwgdGhpcy5tYXh6b29tID0gZS5tYXh6b29tLCBcImJhY2tncm91bmRcIiAhPT0gZS50eXBlICYmICh0aGlzLnNvdXJjZSA9IGUuc291cmNlLCB0aGlzLnNvdXJjZUxheWVyID0gZVtcInNvdXJjZS1sYXllclwiXSwgdGhpcy5maWx0ZXIgPSBlLmZpbHRlciksIHIubGF5b3V0ICYmICh0aGlzLl91bmV2YWx1YXRlZExheW91dCA9IG5ldyB5aShyLmxheW91dCkpLCByLnBhaW50KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50ID0gbmV3IGNpKHIucGFpbnQpLCBlLnBhaW50KSB0aGlzLnNldFBhaW50UHJvcGVydHkobiwgZS5wYWludFtuXSwge1xuICAgICAgICAgICAgICB2YWxpZGF0ZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBlLmxheW91dCkgdGhpcy5zZXRMYXlvdXRQcm9wZXJ0eShpLCBlLmxheW91dFtpXSwge1xuICAgICAgICAgICAgICB2YWxpZGF0ZTogITFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50ID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC51bnRyYW5zaXRpb25lZCgpLCB0aGlzLnBhaW50ID0gbmV3IG1pKHIucGFpbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXRDcm9zc2ZhZGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jcm9zc2ZhZGVQYXJhbWV0ZXJzO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5nZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwidmlzaWJpbGl0eVwiID09PSB0ID8gdGhpcy52aXNpYmlsaXR5IDogdGhpcy5fdW5ldmFsdWF0ZWRMYXlvdXQuZ2V0VmFsdWUodCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldExheW91dFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIG51bGwgIT0gZSAmJiB0aGlzLl92YWxpZGF0ZShCbiwgXCJsYXllcnMuXCIgKyB0aGlzLmlkICsgXCIubGF5b3V0LlwiICsgdCwgdCwgZSwgcikgfHwgKFwidmlzaWJpbGl0eVwiICE9PSB0ID8gdGhpcy5fdW5ldmFsdWF0ZWRMYXlvdXQuc2V0VmFsdWUodCwgZSkgOiB0aGlzLnZpc2liaWxpdHkgPSBlKTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuZ2V0UGFpbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIGcodCwgXCItdHJhbnNpdGlvblwiKSA/IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuZ2V0VHJhbnNpdGlvbih0LnNsaWNlKDAsIC1cIi10cmFuc2l0aW9uXCIubGVuZ3RoKSkgOiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50LmdldFZhbHVlKHQpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXRQYWludFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSByICYmIChyID0ge30pLCBudWxsICE9IGUgJiYgdGhpcy5fdmFsaWRhdGUoTW4sIFwibGF5ZXJzLlwiICsgdGhpcy5pZCArIFwiLnBhaW50LlwiICsgdCwgdCwgZSwgcikpIHJldHVybiAhMTtcbiAgICAgICAgICBpZiAoZyh0LCBcIi10cmFuc2l0aW9uXCIpKSByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5zZXRUcmFuc2l0aW9uKHQuc2xpY2UoMCwgLVwiLXRyYW5zaXRpb25cIi5sZW5ndGgpLCBlIHx8IHZvaWQgMCksICExO1xuICAgICAgICAgIHZhciBuID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW3RdLFxuICAgICAgICAgICAgaSA9IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIiA9PT0gbi5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uW1wicHJvcGVydHktdHlwZVwiXSxcbiAgICAgICAgICAgIGEgPSBuLnZhbHVlLmlzRGF0YURyaXZlbigpLFxuICAgICAgICAgICAgbyA9IG4udmFsdWU7XG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5zZXRWYWx1ZSh0LCBlKSwgdGhpcy5faGFuZGxlU3BlY2lhbFBhaW50UHJvcGVydHlVcGRhdGUodCk7XG4gICAgICAgICAgdmFyIHMgPSB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50Ll92YWx1ZXNbdF0udmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHMuaXNEYXRhRHJpdmVuKCkgfHwgYSB8fCBpIHx8IHRoaXMuX2hhbmRsZU92ZXJyaWRhYmxlUGFpbnRQcm9wZXJ0eVVwZGF0ZSh0LCBvLCBzKTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX2hhbmRsZVNwZWNpYWxQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQpIHt9LCBlLnByb3RvdHlwZS5faGFuZGxlT3ZlcnJpZGFibGVQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gISEodGhpcy5taW56b29tICYmIHQgPCB0aGlzLm1pbnpvb20pIHx8ICEhKHRoaXMubWF4em9vbSAmJiB0ID49IHRoaXMubWF4em9vbSkgfHwgXCJub25lXCIgPT09IHRoaXMudmlzaWJpbGl0eTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUudXBkYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25pbmdQYWludCA9IHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQudHJhbnNpdGlvbmVkKHQsIHRoaXMuX3RyYW5zaXRpb25pbmdQYWludCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25pbmdQYWludC5oYXNUcmFuc2l0aW9uKCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB0LmdldENyb3NzZmFkZVBhcmFtZXRlcnMgJiYgKHRoaXMuX2Nyb3NzZmFkZVBhcmFtZXRlcnMgPSB0LmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSksIHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0ICYmICh0aGlzLmxheW91dCA9IHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0LnBvc3NpYmx5RXZhbHVhdGUodCwgdm9pZCAwLCBlKSksIHRoaXMucGFpbnQgPSB0aGlzLl90cmFuc2l0aW9uaW5nUGFpbnQucG9zc2libHlFdmFsdWF0ZSh0LCB2b2lkIDAsIGUpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICBcInNvdXJjZS1sYXllclwiOiB0aGlzLnNvdXJjZUxheWVyLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBtaW56b29tOiB0aGlzLm1pbnpvb20sXG4gICAgICAgICAgICBtYXh6b29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLl91bmV2YWx1YXRlZExheW91dCAmJiB0aGlzLl91bmV2YWx1YXRlZExheW91dC5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50ICYmIHRoaXMuX3RyYW5zaXRpb25hYmxlUGFpbnQuc2VyaWFsaXplKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2liaWxpdHkgJiYgKHQubGF5b3V0ID0gdC5sYXlvdXQgfHwge30sIHQubGF5b3V0LnZpc2liaWxpdHkgPSB0aGlzLnZpc2liaWxpdHkpLCBiKHQsIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICByZXR1cm4gISh2b2lkIDAgPT09IHQgfHwgXCJsYXlvdXRcIiA9PT0gZSAmJiAhT2JqZWN0LmtleXModCkubGVuZ3RoIHx8IFwicGFpbnRcIiA9PT0gZSAmJiAhT2JqZWN0LmtleXModCkubGVuZ3RoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBpICYmIChpID0ge30pLCAoIWkgfHwgITEgIT09IGkudmFsaWRhdGUpICYmIFRuKHRoaXMsIHQuY2FsbChFbiwge1xuICAgICAgICAgICAga2V5OiBlLFxuICAgICAgICAgICAgbGF5ZXJUeXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBvYmplY3RLZXk6IHIsXG4gICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgIHN0eWxlU3BlYzogUHQsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBnbHlwaHM6ICEwLFxuICAgICAgICAgICAgICBzcHJpdGU6ICEwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5pczNEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuaXNUaWxlQ2xpcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmhhc09mZnNjcmVlblBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUuaXNTdGF0ZURlcGVuZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMucGFpbnQuX3ZhbHVlcykge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnBhaW50LmdldCh0KTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZGkgJiYgVnIoZS5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uKSAmJiAoXCJzb3VyY2VcIiA9PT0gZS52YWx1ZS5raW5kIHx8IFwiY29tcG9zaXRlXCIgPT09IGUudmFsdWUua2luZCkgJiYgZS52YWx1ZS5pc1N0YXRlRGVwZW5kZW50KSByZXR1cm4gITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oRXQpLFxuICAgICAgU2kgPSB7XG4gICAgICAgIEludDg6IEludDhBcnJheSxcbiAgICAgICAgVWludDg6IFVpbnQ4QXJyYXksXG4gICAgICAgIEludDE2OiBJbnQxNkFycmF5LFxuICAgICAgICBVaW50MTY6IFVpbnQxNkFycmF5LFxuICAgICAgICBJbnQzMjogSW50MzJBcnJheSxcbiAgICAgICAgVWludDMyOiBVaW50MzJBcnJheSxcbiAgICAgICAgRmxvYXQzMjogRmxvYXQzMkFycmF5XG4gICAgICB9LFxuICAgICAga2kgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLl9zdHJ1Y3RBcnJheSA9IHQsIHRoaXMuX3BvczEgPSBlICogdGhpcy5zaXplLCB0aGlzLl9wb3MyID0gdGhpcy5fcG9zMSAvIDIsIHRoaXMuX3BvczQgPSB0aGlzLl9wb3MxIC8gNCwgdGhpcy5fcG9zOCA9IHRoaXMuX3BvczEgLyA4O1xuICAgICAgfSxcbiAgICAgIElpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVHJhbnNmZXJyZWQgPSAhMSwgdGhpcy5jYXBhY2l0eSA9IC0xLCB0aGlzLnJlc2l6ZSgwKTtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gemkodCwgZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMSk7XG4gICAgICB2YXIgciA9IDAsXG4gICAgICAgIG4gPSAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVtYmVyczogdC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgaSA9IFNpW3QudHlwZV0uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgICBhID0gciA9IENpKHIsIE1hdGgubWF4KGUsIGkpKSxcbiAgICAgICAgICAgIG8gPSB0LmNvbXBvbmVudHMgfHwgMTtcbiAgICAgICAgICByZXR1cm4gbiA9IE1hdGgubWF4KG4sIGkpLCByICs9IGkgKiBvLCB7XG4gICAgICAgICAgICBuYW1lOiB0Lm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0LnR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBvLFxuICAgICAgICAgICAgb2Zmc2V0OiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHNpemU6IENpKHIsIE1hdGgubWF4KG4sIGUpKSxcbiAgICAgICAgYWxpZ25tZW50OiBlXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBDaSh0LCBlKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHQgLyBlKSAqIGU7XG4gICAgfVxuICAgIElpLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdC5fdHJpbSgpLCBlICYmICh0LmlzVHJhbnNmZXJyZWQgPSAhMCwgZS5wdXNoKHQuYXJyYXlCdWZmZXIpKSwge1xuICAgICAgICBsZW5ndGg6IHQubGVuZ3RoLFxuICAgICAgICBhcnJheUJ1ZmZlcjogdC5hcnJheUJ1ZmZlclxuICAgICAgfTtcbiAgICB9LCBJaS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGUuYXJyYXlCdWZmZXIgPSB0LmFycmF5QnVmZmVyLCBlLmxlbmd0aCA9IHQubGVuZ3RoLCBlLmNhcGFjaXR5ID0gdC5hcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC8gZS5ieXRlc1BlckVsZW1lbnQsIGUuX3JlZnJlc2hWaWV3cygpLCBlO1xuICAgIH0sIElpLnByb3RvdHlwZS5fdHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGVuZ3RoICE9PSB0aGlzLmNhcGFjaXR5ICYmICh0aGlzLmNhcGFjaXR5ID0gdGhpcy5sZW5ndGgsIHRoaXMuYXJyYXlCdWZmZXIgPSB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKDAsIHRoaXMubGVuZ3RoICogdGhpcy5ieXRlc1BlckVsZW1lbnQpLCB0aGlzLl9yZWZyZXNoVmlld3MoKSk7XG4gICAgfSwgSWkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH0sIElpLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5yZXNlcnZlKHQpLCB0aGlzLmxlbmd0aCA9IHQ7XG4gICAgfSwgSWkucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQgPiB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heCh0LCBNYXRoLmZsb29yKDUgKiB0aGlzLmNhcGFjaXR5KSwgMTI4KSwgdGhpcy5hcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmNhcGFjaXR5ICogdGhpcy5ieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICB2YXIgZSA9IHRoaXMudWludDg7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpLCBlICYmIHRoaXMudWludDguc2V0KGUpO1xuICAgICAgfVxuICAgIH0sIElpLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3JlZnJlc2hWaWV3cygpIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCBjb25jcmV0ZSBTdHJ1Y3RBcnJheSBsYXlvdXRcIik7XG4gICAgfTtcbiAgICB2YXIgRWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShyICsgMSksIHRoaXMuZW1wbGFjZShyLCB0LCBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgbiA9IDIgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltuICsgMF0gPSBlLCB0aGlzLmludDE2W24gKyAxXSA9IHIsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIEVpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA0LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0Mmk0XCIsIEVpKTtcbiAgICB2YXIgUGkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShpICsgMSksIHRoaXMuZW1wbGFjZShpLCB0LCBlLCByLCBuKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB2YXIgYSA9IDQgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNlthICsgMF0gPSBlLCB0aGlzLmludDE2W2EgKyAxXSA9IHIsIHRoaXMuaW50MTZbYSArIDJdID0gbiwgdGhpcy5pbnQxNlthICsgM10gPSBpLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBQaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gOCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDRpOFwiLCBQaSk7XG4gICAgdmFyIE1pID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobyArIDEpLCB0aGlzLmVtcGxhY2UobywgdCwgZSwgciwgbiwgaSwgYSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8pIHtcbiAgICAgICAgdmFyIHMgPSA2ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbcyArIDBdID0gZSwgdGhpcy5pbnQxNltzICsgMV0gPSByLCB0aGlzLmludDE2W3MgKyAyXSA9IG4sIHRoaXMuaW50MTZbcyArIDNdID0gaSwgdGhpcy5pbnQxNltzICsgNF0gPSBhLCB0aGlzLmludDE2W3MgKyA1XSA9IG8sIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIE1pLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAxMiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJpNGkxMlwiLCBNaSk7XG4gICAgdmFyIEJpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobyArIDEpLCB0aGlzLmVtcGxhY2UobywgdCwgZSwgciwgbiwgaSwgYSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8pIHtcbiAgICAgICAgdmFyIHMgPSA0ICogdCxcbiAgICAgICAgICB1ID0gOCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W3MgKyAwXSA9IGUsIHRoaXMuaW50MTZbcyArIDFdID0gciwgdGhpcy51aW50OFt1ICsgNF0gPSBuLCB0aGlzLnVpbnQ4W3UgKyA1XSA9IGksIHRoaXMudWludDhbdSArIDZdID0gYSwgdGhpcy51aW50OFt1ICsgN10gPSBvLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBCaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gOCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJpNHViOFwiLCBCaSk7XG4gICAgdmFyIFRpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHIgKyAxKSwgdGhpcy5lbXBsYWNlKHIsIHQsIGUpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gMiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbbiArIDBdID0gZSwgdGhpcy5mbG9hdDMyW24gKyAxXSA9IHIsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIFRpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA4LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MmY4XCIsIFRpKTtcbiAgICB2YXIgVmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHAgKyAxKSwgdGhpcy5lbXBsYWNlKHAsIHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwKSB7XG4gICAgICAgIHZhciBjID0gMTAgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MTZbYyArIDBdID0gZSwgdGhpcy51aW50MTZbYyArIDFdID0gciwgdGhpcy51aW50MTZbYyArIDJdID0gbiwgdGhpcy51aW50MTZbYyArIDNdID0gaSwgdGhpcy51aW50MTZbYyArIDRdID0gYSwgdGhpcy51aW50MTZbYyArIDVdID0gbywgdGhpcy51aW50MTZbYyArIDZdID0gcywgdGhpcy51aW50MTZbYyArIDddID0gdSwgdGhpcy51aW50MTZbYyArIDhdID0gbCwgdGhpcy51aW50MTZbYyArIDldID0gcCwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgVmkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDIwLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MTB1aTIwXCIsIFZpKTtcbiAgICB2YXIgRmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYykge1xuICAgICAgICB2YXIgaCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoaCArIDEpLCB0aGlzLmVtcGxhY2UoaCwgdCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYyk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgpIHtcbiAgICAgICAgdmFyIGYgPSAxMiAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W2YgKyAwXSA9IGUsIHRoaXMuaW50MTZbZiArIDFdID0gciwgdGhpcy5pbnQxNltmICsgMl0gPSBuLCB0aGlzLmludDE2W2YgKyAzXSA9IGksIHRoaXMudWludDE2W2YgKyA0XSA9IGEsIHRoaXMudWludDE2W2YgKyA1XSA9IG8sIHRoaXMudWludDE2W2YgKyA2XSA9IHMsIHRoaXMudWludDE2W2YgKyA3XSA9IHUsIHRoaXMuaW50MTZbZiArIDhdID0gbCwgdGhpcy5pbnQxNltmICsgOV0gPSBwLCB0aGlzLmludDE2W2YgKyAxMF0gPSBjLCB0aGlzLmludDE2W2YgKyAxMV0gPSBoLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBGaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMjQsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ0aTR1aTRpMjRcIiwgRmkpO1xuICAgIHZhciBEaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShuICsgMSksIHRoaXMuZW1wbGFjZShuLCB0LCBlLCByKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdDMyW2kgKyAwXSA9IGUsIHRoaXMuZmxvYXQzMltpICsgMV0gPSByLCB0aGlzLmZsb2F0MzJbaSArIDJdID0gbiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgRGkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDEyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0M2YxMlwiLCBEaSk7XG4gICAgdmFyIExpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShlICsgMSksIHRoaXMuZW1wbGFjZShlLCB0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MzJbMSAqIHQgKyAwXSA9IGUsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIExpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA0LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MXVsNFwiLCBMaSk7XG4gICAgdmFyIFJpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1KSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShsICsgMSksIHRoaXMuZW1wbGFjZShsLCB0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCkge1xuICAgICAgICB2YXIgcCA9IDEwICogdCxcbiAgICAgICAgICBjID0gNSAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W3AgKyAwXSA9IGUsIHRoaXMuaW50MTZbcCArIDFdID0gciwgdGhpcy5pbnQxNltwICsgMl0gPSBuLCB0aGlzLmludDE2W3AgKyAzXSA9IGksIHRoaXMuaW50MTZbcCArIDRdID0gYSwgdGhpcy5pbnQxNltwICsgNV0gPSBvLCB0aGlzLnVpbnQzMltjICsgM10gPSBzLCB0aGlzLnVpbnQxNltwICsgOF0gPSB1LCB0aGlzLnVpbnQxNltwICsgOV0gPSBsLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBSaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gMjAsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ2aTF1bDJ1aTIwXCIsIFJpKTtcbiAgICB2YXIgT2kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShvICsgMSksIHRoaXMuZW1wbGFjZShvLCB0LCBlLCByLCBuLCBpLCBhKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgICB2YXIgcyA9IDYgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltzICsgMF0gPSBlLCB0aGlzLmludDE2W3MgKyAxXSA9IHIsIHRoaXMuaW50MTZbcyArIDJdID0gbiwgdGhpcy5pbnQxNltzICsgM10gPSBpLCB0aGlzLmludDE2W3MgKyA0XSA9IGEsIHRoaXMuaW50MTZbcyArIDVdID0gbywgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgT2kucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDEyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MmkyaTJpMTJcIiwgT2kpO1xuICAgIHZhciBVaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGEgKyAxKSwgdGhpcy5lbXBsYWNlKGEsIHQsIGUsIHIsIG4sIGkpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgIHZhciBvID0gNCAqIHQsXG4gICAgICAgICAgcyA9IDggKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5mbG9hdDMyW28gKyAwXSA9IGUsIHRoaXMuZmxvYXQzMltvICsgMV0gPSByLCB0aGlzLmZsb2F0MzJbbyArIDJdID0gbiwgdGhpcy5pbnQxNltzICsgNl0gPSBpLCB0aGlzLmludDE2W3MgKyA3XSA9IGEsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIFVpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAxNiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDJmMWYyaTE2XCIsIFVpKTtcbiAgICB2YXIgamkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoaSArIDEpLCB0aGlzLmVtcGxhY2UoaSwgdCwgZSwgciwgbik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdmFyIGEgPSAxMiAqIHQsXG4gICAgICAgICAgbyA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy51aW50OFthICsgMF0gPSBlLCB0aGlzLnVpbnQ4W2EgKyAxXSA9IHIsIHRoaXMuZmxvYXQzMltvICsgMV0gPSBuLCB0aGlzLmZsb2F0MzJbbyArIDJdID0gaSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgamkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDEyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MnViMmYxMlwiLCBqaSk7XG4gICAgdmFyIHFpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShuICsgMSksIHRoaXMuZW1wbGFjZShuLCB0LCBlLCByKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICB2YXIgaSA9IDMgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MTZbaSArIDBdID0gZSwgdGhpcy51aW50MTZbaSArIDFdID0gciwgdGhpcy51aW50MTZbaSArIDJdID0gbiwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgcWkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDYsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQzdWk2XCIsIHFpKTtcbiAgICB2YXIgTmkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmludDE2ID0gbmV3IEludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHYgKyAxKSwgdGhpcy5lbXBsYWNlKHYsIHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtLCB2KSB7XG4gICAgICAgIHZhciBnID0gMjQgKiB0LFxuICAgICAgICAgIHggPSAxMiAqIHQsXG4gICAgICAgICAgYiA9IDQ4ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbZyArIDBdID0gZSwgdGhpcy5pbnQxNltnICsgMV0gPSByLCB0aGlzLnVpbnQxNltnICsgMl0gPSBuLCB0aGlzLnVpbnQxNltnICsgM10gPSBpLCB0aGlzLnVpbnQzMlt4ICsgMl0gPSBhLCB0aGlzLnVpbnQzMlt4ICsgM10gPSBvLCB0aGlzLnVpbnQzMlt4ICsgNF0gPSBzLCB0aGlzLnVpbnQxNltnICsgMTBdID0gdSwgdGhpcy51aW50MTZbZyArIDExXSA9IGwsIHRoaXMudWludDE2W2cgKyAxMl0gPSBwLCB0aGlzLmZsb2F0MzJbeCArIDddID0gYywgdGhpcy5mbG9hdDMyW3ggKyA4XSA9IGgsIHRoaXMudWludDhbYiArIDM2XSA9IGYsIHRoaXMudWludDhbYiArIDM3XSA9IHksIHRoaXMudWludDhbYiArIDM4XSA9IGQsIHRoaXMudWludDMyW3ggKyAxMF0gPSBtLCB0aGlzLmludDE2W2cgKyAyMl0gPSB2LCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBOaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNDgsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQyaTJ1aTN1bDN1aTJmM3ViMXVsMWk0OFwiLCBOaSk7XG4gICAgdmFyIEtpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5pbnQxNiA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtLCB2LCBnLCB4LCBiLCB3LCBfLCBBLCBTLCBrLCBJLCB6KSB7XG4gICAgICAgIHZhciBDID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShDICsgMSksIHRoaXMuZW1wbGFjZShDLCB0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkLCBtLCB2LCBnLCB4LCBiLCB3LCBfLCBBLCBTLCBrLCBJLCB6KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCwgbSwgdiwgZywgeCwgYiwgdywgXywgQSwgUywgaywgSSwgeiwgQykge1xuICAgICAgICB2YXIgRSA9IDM0ICogdCxcbiAgICAgICAgICBQID0gMTcgKiB0O1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQxNltFICsgMF0gPSBlLCB0aGlzLmludDE2W0UgKyAxXSA9IHIsIHRoaXMuaW50MTZbRSArIDJdID0gbiwgdGhpcy5pbnQxNltFICsgM10gPSBpLCB0aGlzLmludDE2W0UgKyA0XSA9IGEsIHRoaXMuaW50MTZbRSArIDVdID0gbywgdGhpcy5pbnQxNltFICsgNl0gPSBzLCB0aGlzLmludDE2W0UgKyA3XSA9IHUsIHRoaXMudWludDE2W0UgKyA4XSA9IGwsIHRoaXMudWludDE2W0UgKyA5XSA9IHAsIHRoaXMudWludDE2W0UgKyAxMF0gPSBjLCB0aGlzLnVpbnQxNltFICsgMTFdID0gaCwgdGhpcy51aW50MTZbRSArIDEyXSA9IGYsIHRoaXMudWludDE2W0UgKyAxM10gPSB5LCB0aGlzLnVpbnQxNltFICsgMTRdID0gZCwgdGhpcy51aW50MTZbRSArIDE1XSA9IG0sIHRoaXMudWludDE2W0UgKyAxNl0gPSB2LCB0aGlzLnVpbnQxNltFICsgMTddID0gZywgdGhpcy51aW50MTZbRSArIDE4XSA9IHgsIHRoaXMudWludDE2W0UgKyAxOV0gPSBiLCB0aGlzLnVpbnQxNltFICsgMjBdID0gdywgdGhpcy51aW50MTZbRSArIDIxXSA9IF8sIHRoaXMudWludDE2W0UgKyAyMl0gPSBBLCB0aGlzLnVpbnQzMltQICsgMTJdID0gUywgdGhpcy5mbG9hdDMyW1AgKyAxM10gPSBrLCB0aGlzLmZsb2F0MzJbUCArIDE0XSA9IEksIHRoaXMuZmxvYXQzMltQICsgMTVdID0geiwgdGhpcy5mbG9hdDMyW1AgKyAxNl0gPSBDLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBLaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNjgsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQ4aTE1dWkxdWw0ZjY4XCIsIEtpKTtcbiAgICB2YXIgR2kgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX3JlZnJlc2hWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51aW50OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXlCdWZmZXIpLCB0aGlzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoZSArIDEpLCB0aGlzLmVtcGxhY2UoZSwgdCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvYXQzMlsxICogdCArIDBdID0gZSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgR2kucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDQsIE9uKFwiU3RydWN0QXJyYXlMYXlvdXQxZjRcIiwgR2kpO1xuICAgIHZhciBaaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMuaW50MTYgPSBuZXcgSW50MTZBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKG4gKyAxKSwgdGhpcy5lbXBsYWNlKG4sIHQsIGUsIHIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpID0gMyAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2W2kgKyAwXSA9IGUsIHRoaXMuaW50MTZbaSArIDFdID0gciwgdGhpcy5pbnQxNltpICsgMl0gPSBuLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBaaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gNiwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDNpNlwiLCBaaSk7XG4gICAgdmFyIFhpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICB2YXIgbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUobiArIDEpLCB0aGlzLmVtcGxhY2UobiwgdCwgZSwgcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSA0ICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyWzIgKiB0ICsgMF0gPSBlLCB0aGlzLnVpbnQxNltpICsgMl0gPSByLCB0aGlzLnVpbnQxNltpICsgM10gPSBuLCB0O1xuICAgICAgfSwgZTtcbiAgICB9KElpKTtcbiAgICBYaS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gOCwgT24oXCJTdHJ1Y3RBcnJheUxheW91dDF1bDJ1aThcIiwgWGkpO1xuICAgIHZhciBKaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5fcmVmcmVzaFZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hcnJheUJ1ZmZlciksIHRoaXMudWludDE2ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXlCdWZmZXIpO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZUJhY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUociArIDEpLCB0aGlzLmVtcGxhY2UociwgdCwgZSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgdmFyIG4gPSAyICogdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDE2W24gKyAwXSA9IGUsIHRoaXMudWludDE2W24gKyAxXSA9IHIsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIEppLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSA0LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MnVpNFwiLCBKaSk7XG4gICAgdmFyIEhpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy51aW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICB9LCBlLnByb3RvdHlwZS5lbXBsYWNlQmFjayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZShlICsgMSksIHRoaXMuZW1wbGFjZShlLCB0KTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50MTZbMSAqIHQgKyAwXSA9IGUsIHQ7XG4gICAgICB9LCBlO1xuICAgIH0oSWkpO1xuICAgIEhpLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnQgPSAyLCBPbihcIlN0cnVjdEFycmF5TGF5b3V0MXVpMlwiLCBIaSk7XG4gICAgdmFyIFlpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudWludDggPSBuZXcgVWludDhBcnJheSh0aGlzLmFycmF5QnVmZmVyKSwgdGhpcy5mbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmFycmF5QnVmZmVyKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKGkgKyAxKSwgdGhpcy5lbXBsYWNlKGksIHQsIGUsIHIsIG4pO1xuICAgICAgfSwgZS5wcm90b3R5cGUuZW1wbGFjZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICAgIHZhciBhID0gNCAqIHQ7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbYSArIDBdID0gZSwgdGhpcy5mbG9hdDMyW2EgKyAxXSA9IHIsIHRoaXMuZmxvYXQzMlthICsgMl0gPSBuLCB0aGlzLmZsb2F0MzJbYSArIDNdID0gaSwgdDtcbiAgICAgIH0sIGU7XG4gICAgfShJaSk7XG4gICAgWWkucHJvdG90eXBlLmJ5dGVzUGVyRWxlbWVudCA9IDE2LCBPbihcIlN0cnVjdEFycmF5TGF5b3V0NGYxNlwiLCBZaSk7XG4gICAgdmFyICRpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZTtcbiAgICAgIHZhciByID0ge1xuICAgICAgICBhbmNob3JQb2ludFg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclBvaW50WToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgeDE6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHkxOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB4Mjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgeTI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGZlYXR1cmVJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlTGF5ZXJJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYnVja2V0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclBvaW50OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHIuYW5jaG9yUG9pbnRYLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAwXTtcbiAgICAgIH0sIHIuYW5jaG9yUG9pbnRZLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAxXTtcbiAgICAgIH0sIHIueDEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDJdO1xuICAgICAgfSwgci55MS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgM107XG4gICAgICB9LCByLngyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA0XTtcbiAgICAgIH0sIHIueTIuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDVdO1xuICAgICAgfSwgci5mZWF0dXJlSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAzXTtcbiAgICAgIH0sIHIuc291cmNlTGF5ZXJJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDhdO1xuICAgICAgfSwgci5idWNrZXRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDldO1xuICAgICAgfSwgci5hbmNob3JQb2ludC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgaSh0aGlzLmFuY2hvclBvaW50WCwgdGhpcy5hbmNob3JQb2ludFkpO1xuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBlO1xuICAgIH0oa2kpO1xuICAgICRpLnByb3RvdHlwZS5zaXplID0gMjA7XG4gICAgdmFyIFdpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgJGkodGhpcywgdCk7XG4gICAgICB9LCBlO1xuICAgIH0oUmkpO1xuICAgIE9uKFwiQ29sbGlzaW9uQm94QXJyYXlcIiwgV2kpO1xuICAgIHZhciBRaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGU7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgYW5jaG9yWDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYW5jaG9yWToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgZ2x5cGhTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBudW1HbHlwaHM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRleFN0YXJ0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsaW5lTGVuZ3RoOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBzZWdtZW50OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsb3dlclNpemU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyU2l6ZToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbGluZU9mZnNldFg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVPZmZzZXRZOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB3cml0aW5nTW9kZToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VkT3JpZW50YXRpb246IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGRlbjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvc3NUaWxlSUQ6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGFzc29jaWF0ZWRJY29uSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5hbmNob3JYLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAwXTtcbiAgICAgIH0sIHIuYW5jaG9yWS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMV07XG4gICAgICB9LCByLmdseXBoU3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDJdO1xuICAgICAgfSwgci5udW1HbHlwaHMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAzXTtcbiAgICAgIH0sIHIudmVydGV4U3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDJdO1xuICAgICAgfSwgci5saW5lU3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDNdO1xuICAgICAgfSwgci5saW5lTGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQzMlt0aGlzLl9wb3M0ICsgNF07XG4gICAgICB9LCByLnNlZ21lbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxMF07XG4gICAgICB9LCByLmxvd2VyU2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDExXTtcbiAgICAgIH0sIHIudXBwZXJTaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTJdO1xuICAgICAgfSwgci5saW5lT2Zmc2V0WC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyA3XTtcbiAgICAgIH0sIHIubGluZU9mZnNldFkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgOF07XG4gICAgICB9LCByLndyaXRpbmdNb2RlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzNl07XG4gICAgICB9LCByLnBsYWNlZE9yaWVudGF0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzN107XG4gICAgICB9LCByLnBsYWNlZE9yaWVudGF0aW9uLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzN10gPSB0O1xuICAgICAgfSwgci5oaWRkZW4uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDhbdGhpcy5fcG9zMSArIDM4XTtcbiAgICAgIH0sIHIuaGlkZGVuLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQ4W3RoaXMuX3BvczEgKyAzOF0gPSB0O1xuICAgICAgfSwgci5jcm9zc1RpbGVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDEwXTtcbiAgICAgIH0sIHIuY3Jvc3NUaWxlSUQuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc3RydWN0QXJyYXkudWludDMyW3RoaXMuX3BvczQgKyAxMF0gPSB0O1xuICAgICAgfSwgci5hc3NvY2lhdGVkSWNvbkluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAyMl07XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIGU7XG4gICAgfShraSk7XG4gICAgUWkucHJvdG90eXBlLnNpemUgPSA0ODtcbiAgICB2YXIgdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRaSh0aGlzLCB0KTtcbiAgICAgIH0sIGU7XG4gICAgfShOaSk7XG4gICAgT24oXCJQbGFjZWRTeW1ib2xBcnJheVwiLCB0YSk7XG4gICAgdmFyIGVhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZTtcbiAgICAgIHZhciByID0ge1xuICAgICAgICBhbmNob3JYOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JZOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICByaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBsZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VkSWNvblN5bWJvbEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFBsYWNlZEljb25TeW1ib2xJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAga2V5OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Qm94U3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dEJveEVuZEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFRleHRCb3hTdGFydEluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbFRleHRCb3hFbmRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgaWNvbkJveFN0YXJ0SW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGljb25Cb3hFbmRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxJY29uQm94U3RhcnRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxJY29uQm94RW5kSW5kZXg6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGZlYXR1cmVJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIG51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbnVtSWNvblZlcnRpY2VzOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBudW1WZXJ0aWNhbEljb25WZXJ0aWNlczoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXM6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzVGlsZUlEOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Qm94U2NhbGU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRPZmZzZXQwOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0T2Zmc2V0MToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGlzaW9uQ2lyY2xlRGlhbWV0ZXI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gci5hbmNob3JYLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAwXTtcbiAgICAgIH0sIHIuYW5jaG9yWS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgMV07XG4gICAgICB9LCByLnJpZ2h0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAyXTtcbiAgICAgIH0sIHIuY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyAzXTtcbiAgICAgIH0sIHIubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5pbnQxNlt0aGlzLl9wb3MyICsgNF07XG4gICAgICB9LCByLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA1XTtcbiAgICAgIH0sIHIucGxhY2VkSWNvblN5bWJvbEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmludDE2W3RoaXMuX3BvczIgKyA2XTtcbiAgICAgIH0sIHIudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuaW50MTZbdGhpcy5fcG9zMiArIDddO1xuICAgICAgfSwgci5rZXkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyA4XTtcbiAgICAgIH0sIHIudGV4dEJveFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyA5XTtcbiAgICAgIH0sIHIudGV4dEJveEVuZEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTBdO1xuICAgICAgfSwgci52ZXJ0aWNhbFRleHRCb3hTdGFydEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMTFdO1xuICAgICAgfSwgci52ZXJ0aWNhbFRleHRCb3hFbmRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDEyXTtcbiAgICAgIH0sIHIuaWNvbkJveFN0YXJ0SW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxM107XG4gICAgICB9LCByLmljb25Cb3hFbmRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE0XTtcbiAgICAgIH0sIHIudmVydGljYWxJY29uQm94U3RhcnRJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE1XTtcbiAgICAgIH0sIHIudmVydGljYWxJY29uQm94RW5kSW5kZXguZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxNl07XG4gICAgICB9LCByLmZlYXR1cmVJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE3XTtcbiAgICAgIH0sIHIubnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAxOF07XG4gICAgICB9LCByLm51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDE5XTtcbiAgICAgIH0sIHIubnVtSWNvblZlcnRpY2VzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMjBdO1xuICAgICAgfSwgci5udW1WZXJ0aWNhbEljb25WZXJ0aWNlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MTZbdGhpcy5fcG9zMiArIDIxXTtcbiAgICAgIH0sIHIudXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkudWludDE2W3RoaXMuX3BvczIgKyAyMl07XG4gICAgICB9LCByLmNyb3NzVGlsZUlELmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQzMlt0aGlzLl9wb3M0ICsgMTJdO1xuICAgICAgfSwgci5jcm9zc1RpbGVJRC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDEyXSA9IHQ7XG4gICAgICB9LCByLnRleHRCb3hTY2FsZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyAxM107XG4gICAgICB9LCByLnRleHRPZmZzZXQwLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LmZsb2F0MzJbdGhpcy5fcG9zNCArIDE0XTtcbiAgICAgIH0sIHIudGV4dE9mZnNldDEuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RydWN0QXJyYXkuZmxvYXQzMlt0aGlzLl9wb3M0ICsgMTVdO1xuICAgICAgfSwgci5jb2xsaXNpb25DaXJjbGVEaWFtZXRlci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS5mbG9hdDMyW3RoaXMuX3BvczQgKyAxNl07XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIGU7XG4gICAgfShraSk7XG4gICAgZWEucHJvdG90eXBlLnNpemUgPSA2ODtcbiAgICB2YXIgcmEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlYSh0aGlzLCB0KTtcbiAgICAgIH0sIGU7XG4gICAgfShLaSk7XG4gICAgT24oXCJTeW1ib2xJbnN0YW5jZUFycmF5XCIsIHJhKTtcbiAgICB2YXIgbmEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0b2Zmc2V0WCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb2F0MzJbMSAqIHQgKyAwXTtcbiAgICAgIH0sIGU7XG4gICAgfShHaSk7XG4gICAgT24oXCJHbHlwaE9mZnNldEFycmF5XCIsIG5hKTtcbiAgICB2YXIgaWEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0eCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludDE2WzMgKiB0ICsgMF07XG4gICAgICB9LCBlLnByb3RvdHlwZS5nZXR5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbMyAqIHQgKyAxXTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmdldHRpbGVVbml0RGlzdGFuY2VGcm9tQW5jaG9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50MTZbMyAqIHQgKyAyXTtcbiAgICAgIH0sIGU7XG4gICAgfShaaSk7XG4gICAgT24oXCJTeW1ib2xMaW5lVmVydGV4QXJyYXlcIiwgaWEpO1xuICAgIHZhciBhYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGU7XG4gICAgICB2YXIgciA9IHtcbiAgICAgICAgZmVhdHVyZUluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VMYXllckluZGV4OiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBidWNrZXRJbmRleDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLmZlYXR1cmVJbmRleC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RBcnJheS51aW50MzJbdGhpcy5fcG9zNCArIDBdO1xuICAgICAgfSwgci5zb3VyY2VMYXllckluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgMl07XG4gICAgICB9LCByLmJ1Y2tldEluZGV4LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdEFycmF5LnVpbnQxNlt0aGlzLl9wb3MyICsgM107XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIGU7XG4gICAgfShraSk7XG4gICAgYWEucHJvdG90eXBlLnNpemUgPSA4O1xuICAgIHZhciBvYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IGFhKHRoaXMsIHQpO1xuICAgICAgfSwgZTtcbiAgICB9KFhpKTtcbiAgICBPbihcIkZlYXR1cmVJbmRleEFycmF5XCIsIG9hKTtcbiAgICB2YXIgc2EgPSB6aShbe1xuICAgICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgICAgfV0sIDQpLm1lbWJlcnMsXG4gICAgICB1YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IFtdKSwgdGhpcy5zZWdtZW50cyA9IHQ7XG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIGxhKHQsIGUpIHtcbiAgICAgIHJldHVybiAyNTYgKiAodCA9IHAoTWF0aC5mbG9vcih0KSwgMCwgMjU1KSkgKyBwKE1hdGguZmxvb3IoZSksIDAsIDI1NSk7XG4gICAgfVxuICAgIHVhLnByb3RvdHlwZS5wcmVwYXJlU2VnbWVudCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiB0ID4gdWEuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgQShcIk1heCB2ZXJ0aWNlcyBwZXIgc2VnbWVudCBpcyBcIiArIHVhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIICsgXCI6IGJ1Y2tldCByZXF1ZXN0ZWQgXCIgKyB0KSwgKCFpIHx8IGkudmVydGV4TGVuZ3RoICsgdCA+IHVhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIIHx8IGkuc29ydEtleSAhPT0gbikgJiYgKGkgPSB7XG4gICAgICAgIHZlcnRleE9mZnNldDogZS5sZW5ndGgsXG4gICAgICAgIHByaW1pdGl2ZU9mZnNldDogci5sZW5ndGgsXG4gICAgICAgIHZlcnRleExlbmd0aDogMCxcbiAgICAgICAgcHJpbWl0aXZlTGVuZ3RoOiAwXG4gICAgICB9LCB2b2lkIDAgIT09IG4gJiYgKGkuc29ydEtleSA9IG4pLCB0aGlzLnNlZ21lbnRzLnB1c2goaSkpLCBpO1xuICAgIH0sIHVhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWdtZW50cztcbiAgICB9LCB1YS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gdGhpcy5zZWdtZW50czsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIHtcbiAgICAgICAgdmFyIHIgPSBlW3RdO1xuICAgICAgICBmb3IgKHZhciBuIGluIHIudmFvcykgci52YW9zW25dLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9LCB1YS5zaW1wbGVTZWdtZW50ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBuZXcgdWEoW3tcbiAgICAgICAgdmVydGV4T2Zmc2V0OiB0LFxuICAgICAgICBwcmltaXRpdmVPZmZzZXQ6IGUsXG4gICAgICAgIHZlcnRleExlbmd0aDogcixcbiAgICAgICAgcHJpbWl0aXZlTGVuZ3RoOiBuLFxuICAgICAgICB2YW9zOiB7fSxcbiAgICAgICAgc29ydEtleTogMFxuICAgICAgfV0pO1xuICAgIH0sIHVhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIID0gTWF0aC5wb3coMiwgMTYpIC0gMSwgT24oXCJTZWdtZW50VmVjdG9yXCIsIHVhKTtcbiAgICB2YXIgcGEgPSB6aShbe1xuICAgICAgICBuYW1lOiBcImFfcGF0dGVybl9mcm9tXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICAgIHR5cGU6IFwiVWludDE2XCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhX3BhdHRlcm5fdG9cIixcbiAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgdHlwZTogXCJVaW50MTZcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImFfcGl4ZWxfcmF0aW9fZnJvbVwiLFxuICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICB0eXBlOiBcIlVpbnQxNlwiXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYV9waXhlbF9yYXRpb190b1wiLFxuICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICB0eXBlOiBcIlVpbnQxNlwiXG4gICAgICB9XSksXG4gICAgICBjYSA9IGUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB2YXIgciwgbiwgaSwgYSwgbywgcywgdSwgbDtcbiAgICAgICAgICBmb3IgKG4gPSB0Lmxlbmd0aCAtIChyID0gMyAmIHQubGVuZ3RoKSwgaSA9IGUsIG8gPSAzNDMyOTE4MzUzLCBzID0gNDYxODQ1OTA3LCBsID0gMDsgbCA8IG47KSB1ID0gMjU1ICYgdC5jaGFyQ29kZUF0KGwpIHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2wpKSA8PCA4IHwgKDI1NSAmIHQuY2hhckNvZGVBdCgrK2wpKSA8PCAxNiB8ICgyNTUgJiB0LmNoYXJDb2RlQXQoKytsKSkgPDwgMjQsICsrbCwgaSA9IDI3NDkyICsgKDY1NTM1ICYgKGEgPSA1ICogKDY1NTM1ICYgKGkgPSAoaSBePSB1ID0gKDY1NTM1ICYgKHUgPSAodSA9ICg2NTUzNSAmIHUpICogbyArICgoKHUgPj4+IDE2KSAqIG8gJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSkgPDwgMTUgfCB1ID4+PiAxNykpICogcyArICgoKHUgPj4+IDE2KSAqIHMgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSkgPDwgMTMgfCBpID4+PiAxOSkpICsgKCg1ICogKGkgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1KSkgKyAoKDU4OTY0ICsgKGEgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNik7XG4gICAgICAgICAgc3dpdGNoICh1ID0gMCwgcikge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB1IF49ICgyNTUgJiB0LmNoYXJDb2RlQXQobCArIDIpKSA8PCAxNjtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdSBePSAoMjU1ICYgdC5jaGFyQ29kZUF0KGwgKyAxKSkgPDwgODtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaSBePSB1ID0gKDY1NTM1ICYgKHUgPSAodSA9ICg2NTUzNSAmICh1IF49IDI1NSAmIHQuY2hhckNvZGVBdChsKSkpICogbyArICgoKHUgPj4+IDE2KSAqIG8gJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSkgPDwgMTUgfCB1ID4+PiAxNykpICogcyArICgoKHUgPj4+IDE2KSAqIHMgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGkgXj0gdC5sZW5ndGgsIGkgPSAyMjQ2ODIyNTA3ICogKDY1NTM1ICYgKGkgXj0gaSA+Pj4gMTYpKSArICgoMjI0NjgyMjUwNyAqIChpID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpICYgNDI5NDk2NzI5NSwgaSA9IDMyNjY0ODk5MDkgKiAoNjU1MzUgJiAoaSBePSBpID4+PiAxMykpICsgKCgzMjY2NDg5OTA5ICogKGkgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgJiA0Mjk0OTY3Mjk1LCAoaSBePSBpID4+PiAxNikgPj4+IDA7XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIGhhID0gZShmdW5jdGlvbiAodCkge1xuICAgICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIGZvciAodmFyIHIsIG4gPSB0Lmxlbmd0aCwgaSA9IGUgXiBuLCBhID0gMDsgbiA+PSA0OykgciA9IDE1NDA0ODM0NzcgKiAoNjU1MzUgJiAociA9IDI1NSAmIHQuY2hhckNvZGVBdChhKSB8ICgyNTUgJiB0LmNoYXJDb2RlQXQoKythKSkgPDwgOCB8ICgyNTUgJiB0LmNoYXJDb2RlQXQoKythKSkgPDwgMTYgfCAoMjU1ICYgdC5jaGFyQ29kZUF0KCsrYSkpIDw8IDI0KSkgKyAoKDE1NDA0ODM0NzcgKiAociA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSwgaSA9IDE1NDA0ODM0NzcgKiAoNjU1MzUgJiBpKSArICgoMTU0MDQ4MzQ3NyAqIChpID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpIF4gKHIgPSAxNTQwNDgzNDc3ICogKDY1NTM1ICYgKHIgXj0gciA+Pj4gMjQpKSArICgoMTU0MDQ4MzQ3NyAqIChyID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpKSwgbiAtPSA0LCArK2E7XG4gICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGkgXj0gKDI1NSAmIHQuY2hhckNvZGVBdChhICsgMikpIDw8IDE2O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpIF49ICgyNTUgJiB0LmNoYXJDb2RlQXQoYSArIDEpKSA8PCA4O1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpID0gMTU0MDQ4MzQ3NyAqICg2NTUzNSAmIChpIF49IDI1NSAmIHQuY2hhckNvZGVBdChhKSkpICsgKCgxNTQwNDgzNDc3ICogKGkgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpID0gMTU0MDQ4MzQ3NyAqICg2NTUzNSAmIChpIF49IGkgPj4+IDEzKSkgKyAoKDE1NDA0ODM0NzcgKiAoaSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSwgKGkgXj0gaSA+Pj4gMTUpID4+PiAwO1xuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBmYSA9IGNhLFxuICAgICAgeWEgPSBoYTtcbiAgICBmYS5tdXJtdXIzID0gY2EsIGZhLm11cm11cjIgPSB5YTtcbiAgICB2YXIgZGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmlkcyA9IFtdLCB0aGlzLnBvc2l0aW9ucyA9IFtdLCB0aGlzLmluZGV4ZWQgPSAhMTtcbiAgICB9O1xuICAgIGRhLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5pZHMucHVzaCh2YSh0KSksIHRoaXMucG9zaXRpb25zLnB1c2goZSwgciwgbik7XG4gICAgfSwgZGEucHJvdG90eXBlLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdmEodCksIHIgPSAwLCBuID0gdGhpcy5pZHMubGVuZ3RoIC0gMTsgciA8IG47KSB7XG4gICAgICAgIHZhciBpID0gciArIG4gPj4gMTtcbiAgICAgICAgdGhpcy5pZHNbaV0gPj0gZSA/IG4gPSBpIDogciA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgYSA9IFtdOyB0aGlzLmlkc1tyXSA9PT0gZTspIGEucHVzaCh7XG4gICAgICAgIGluZGV4OiB0aGlzLnBvc2l0aW9uc1szICogcl0sXG4gICAgICAgIHN0YXJ0OiB0aGlzLnBvc2l0aW9uc1szICogciArIDFdLFxuICAgICAgICBlbmQ6IHRoaXMucG9zaXRpb25zWzMgKiByICsgMl1cbiAgICAgIH0pLCByKys7XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBkYS5zZXJpYWxpemUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBuZXcgRmxvYXQ2NEFycmF5KHQuaWRzKSxcbiAgICAgICAgbiA9IG5ldyBVaW50MzJBcnJheSh0LnBvc2l0aW9ucyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdChlLCByLCBuLCBpKSB7XG4gICAgICAgIGZvciAoOyBuIDwgaTspIHtcbiAgICAgICAgICBmb3IgKHZhciBhID0gZVtuICsgaSA+PiAxXSwgbyA9IG4gLSAxLCBzID0gaSArIDE7Oykge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBvKys7XG4gICAgICAgICAgICB9IHdoaWxlIChlW29dIDwgYSk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGVbc10gPiBhKTtcbiAgICAgICAgICAgIGlmIChvID49IHMpIGJyZWFrO1xuICAgICAgICAgICAgZ2EoZSwgbywgcyksIGdhKHIsIDMgKiBvLCAzICogcyksIGdhKHIsIDMgKiBvICsgMSwgMyAqIHMgKyAxKSwgZ2EociwgMyAqIG8gKyAyLCAzICogcyArIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzIC0gbiA8IGkgLSBzID8gKHQoZSwgciwgbiwgcyksIG4gPSBzICsgMSkgOiAodChlLCByLCBzICsgMSwgaSksIGkgPSBzKTtcbiAgICAgICAgfVxuICAgICAgfShyLCBuLCAwLCByLmxlbmd0aCAtIDEpLCBlICYmIGUucHVzaChyLmJ1ZmZlciwgbi5idWZmZXIpLCB7XG4gICAgICAgIGlkczogcixcbiAgICAgICAgcG9zaXRpb25zOiBuXG4gICAgICB9O1xuICAgIH0sIGRhLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gbmV3IGRhKCk7XG4gICAgICByZXR1cm4gZS5pZHMgPSB0LmlkcywgZS5wb3NpdGlvbnMgPSB0LnBvc2l0aW9ucywgZS5pbmRleGVkID0gITAsIGU7XG4gICAgfTtcbiAgICB2YXIgbWEgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICAgIGZ1bmN0aW9uIHZhKHQpIHtcbiAgICAgIHZhciBlID0gK3Q7XG4gICAgICByZXR1cm4gIWlzTmFOKGUpICYmIGUgPD0gbWEgPyBlIDogZmEoU3RyaW5nKHQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2EodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0W2VdO1xuICAgICAgdFtlXSA9IHRbcl0sIHRbcl0gPSBuO1xuICAgIH1cbiAgICBPbihcIkZlYXR1cmVQb3NpdGlvbk1hcFwiLCBkYSk7XG4gICAgdmFyIHhhID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy5nbCA9IHQuZ2wsIHRoaXMubG9jYXRpb24gPSBlO1xuICAgICAgfSxcbiAgICAgIGJhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50ICE9PSB0ICYmICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm0xaSh0aGlzLmxvY2F0aW9uLCB0KSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KHhhKSxcbiAgICAgIHdhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50ICE9PSB0ICYmICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLmxvY2F0aW9uLCB0KSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KHhhKSxcbiAgICAgIF9hID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0WzBdID09PSB0aGlzLmN1cnJlbnRbMF0gJiYgdFsxXSA9PT0gdGhpcy5jdXJyZW50WzFdIHx8ICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm0yZih0aGlzLmxvY2F0aW9uLCB0WzBdLCB0WzFdKSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KHhhKSxcbiAgICAgIEFhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSBbMCwgMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0WzBdID09PSB0aGlzLmN1cnJlbnRbMF0gJiYgdFsxXSA9PT0gdGhpcy5jdXJyZW50WzFdICYmIHRbMl0gPT09IHRoaXMuY3VycmVudFsyXSB8fCAodGhpcy5jdXJyZW50ID0gdCwgdGhpcy5nbC51bmlmb3JtM2YodGhpcy5sb2NhdGlvbiwgdFswXSwgdFsxXSwgdFsyXSkpO1xuICAgICAgICB9LCBlO1xuICAgICAgfSh4YSksXG4gICAgICBTYSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSwgcikge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlLCByKSwgdGhpcy5jdXJyZW50ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdFswXSA9PT0gdGhpcy5jdXJyZW50WzBdICYmIHRbMV0gPT09IHRoaXMuY3VycmVudFsxXSAmJiB0WzJdID09PSB0aGlzLmN1cnJlbnRbMl0gJiYgdFszXSA9PT0gdGhpcy5jdXJyZW50WzNdIHx8ICh0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmdsLnVuaWZvcm00Zih0aGlzLmxvY2F0aW9uLCB0WzBdLCB0WzFdLCB0WzJdLCB0WzNdKSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KHhhKSxcbiAgICAgIGthID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlLCByKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIpLCB0aGlzLmN1cnJlbnQgPSBlZS50cmFuc3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHQuciA9PT0gdGhpcy5jdXJyZW50LnIgJiYgdC5nID09PSB0aGlzLmN1cnJlbnQuZyAmJiB0LmIgPT09IHRoaXMuY3VycmVudC5iICYmIHQuYSA9PT0gdGhpcy5jdXJyZW50LmEgfHwgKHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybTRmKHRoaXMubG9jYXRpb24sIHQuciwgdC5nLCB0LmIsIHQuYSkpO1xuICAgICAgICB9LCBlO1xuICAgICAgfSh4YSksXG4gICAgICBJYSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpLFxuICAgICAgemEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKGUsIHIpIHtcbiAgICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuY3VycmVudCA9IElhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHRbMTJdICE9PSB0aGlzLmN1cnJlbnRbMTJdIHx8IHRbMF0gIT09IHRoaXMuY3VycmVudFswXSkgcmV0dXJuIHRoaXMuY3VycmVudCA9IHQsIHZvaWQgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMubG9jYXRpb24sICExLCB0KTtcbiAgICAgICAgICBmb3IgKHZhciBlID0gMTsgZSA8IDE2OyBlKyspIGlmICh0W2VdICE9PSB0aGlzLmN1cnJlbnRbZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmxvY2F0aW9uLCAhMSwgdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KHhhKTtcbiAgICBmdW5jdGlvbiBDYSh0KSB7XG4gICAgICByZXR1cm4gW2xhKDI1NSAqIHQuciwgMjU1ICogdC5nKSwgbGEoMjU1ICogdC5iLCAyNTUgKiB0LmEpXTtcbiAgICB9XG4gICAgdmFyIEVhID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0LCB0aGlzLnVuaWZvcm1OYW1lcyA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBcInVfXCIgKyB0O1xuICAgICAgfSksIHRoaXMudHlwZSA9IHI7XG4gICAgfTtcbiAgICBFYS5wcm90b3R5cGUuc2V0VW5pZm9ybSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0LnNldChyLmNvbnN0YW50T3IodGhpcy52YWx1ZSkpO1xuICAgIH0sIEVhLnByb3RvdHlwZS5nZXRCaW5kaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBcImNvbG9yXCIgPT09IHRoaXMudHlwZSA/IG5ldyBrYSh0LCBlKSA6IG5ldyB3YSh0LCBlKTtcbiAgICB9O1xuICAgIHZhciBQYSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnVuaWZvcm1OYW1lcyA9IGUubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBcInVfXCIgKyB0O1xuICAgICAgfSksIHRoaXMucGF0dGVybkZyb20gPSBudWxsLCB0aGlzLnBhdHRlcm5UbyA9IG51bGwsIHRoaXMucGl4ZWxSYXRpb0Zyb20gPSAxLCB0aGlzLnBpeGVsUmF0aW9UbyA9IDE7XG4gICAgfTtcbiAgICBQYS5wcm90b3R5cGUuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucGl4ZWxSYXRpb0Zyb20gPSBlLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpb1RvID0gdC5waXhlbFJhdGlvLCB0aGlzLnBhdHRlcm5Gcm9tID0gZS50bGJyLCB0aGlzLnBhdHRlcm5UbyA9IHQudGxicjtcbiAgICB9LCBQYS5wcm90b3R5cGUuc2V0VW5pZm9ybSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IFwidV9wYXR0ZXJuX3RvXCIgPT09IG4gPyB0aGlzLnBhdHRlcm5UbyA6IFwidV9wYXR0ZXJuX2Zyb21cIiA9PT0gbiA/IHRoaXMucGF0dGVybkZyb20gOiBcInVfcGl4ZWxfcmF0aW9fdG9cIiA9PT0gbiA/IHRoaXMucGl4ZWxSYXRpb1RvIDogXCJ1X3BpeGVsX3JhdGlvX2Zyb21cIiA9PT0gbiA/IHRoaXMucGl4ZWxSYXRpb0Zyb20gOiBudWxsO1xuICAgICAgaSAmJiB0LnNldChpKTtcbiAgICB9LCBQYS5wcm90b3R5cGUuZ2V0QmluZGluZyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gXCJ1X3BhdHRlcm5cIiA9PT0gci5zdWJzdHIoMCwgOSkgPyBuZXcgU2EodCwgZSkgOiBuZXcgd2EodCwgZSk7XG4gICAgfTtcbiAgICB2YXIgTWEgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gdCwgdGhpcy50eXBlID0gciwgdGhpcy5tYXhWYWx1ZSA9IDAsIHRoaXMucGFpbnRWZXJ0ZXhBdHRyaWJ1dGVzID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBcImFfXCIgKyB0LFxuICAgICAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgICAgIGNvbXBvbmVudHM6IFwiY29sb3JcIiA9PT0gciA/IDIgOiAxLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9O1xuICAgICAgfSksIHRoaXMucGFpbnRWZXJ0ZXhBcnJheSA9IG5ldyBuKCk7XG4gICAgfTtcbiAgICBNYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5wYWludFZlcnRleEFycmF5Lmxlbmd0aCxcbiAgICAgICAgbyA9IHRoaXMuZXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgdWkoMCksIGUsIHt9LCBuLCBbXSwgaSk7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkucmVzaXplKHQpLCB0aGlzLl9zZXRQYWludFZhbHVlKGEsIHQsIG8pO1xuICAgIH0sIE1hLnByb3RvdHlwZS51cGRhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgem9vbTogMFxuICAgICAgfSwgciwgbik7XG4gICAgICB0aGlzLl9zZXRQYWludFZhbHVlKHQsIGUsIGkpO1xuICAgIH0sIE1hLnByb3RvdHlwZS5fc2V0UGFpbnRWYWx1ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBpZiAoXCJjb2xvclwiID09PSB0aGlzLnR5cGUpIGZvciAodmFyIG4gPSBDYShyKSwgaSA9IHQ7IGkgPCBlOyBpKyspIHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5lbXBsYWNlKGksIG5bMF0sIG5bMV0pO2Vsc2Uge1xuICAgICAgICBmb3IgKHZhciBhID0gdDsgYSA8IGU7IGErKykgdGhpcy5wYWludFZlcnRleEFycmF5LmVtcGxhY2UoYSwgcik7XG4gICAgICAgIHRoaXMubWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLm1heFZhbHVlLCBNYXRoLmFicyhyKSk7XG4gICAgICB9XG4gICAgfSwgTWEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy5wYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmICh0aGlzLnBhaW50VmVydGV4QnVmZmVyICYmIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIuYnVmZmVyID8gdGhpcy5wYWludFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHRoaXMucGFpbnRWZXJ0ZXhBcnJheSkgOiB0aGlzLnBhaW50VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5wYWludFZlcnRleEFycmF5LCB0aGlzLnBhaW50VmVydGV4QXR0cmlidXRlcywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpKTtcbiAgICB9LCBNYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy5wYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICB2YXIgQmEgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gdCwgdGhpcy51bmlmb3JtTmFtZXMgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gXCJ1X1wiICsgdCArIFwiX3RcIjtcbiAgICAgIH0pLCB0aGlzLnR5cGUgPSByLCB0aGlzLnVzZUludGVnZXJab29tID0gbiwgdGhpcy56b29tID0gaSwgdGhpcy5tYXhWYWx1ZSA9IDAsIHRoaXMucGFpbnRWZXJ0ZXhBdHRyaWJ1dGVzID0gZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBcImFfXCIgKyB0LFxuICAgICAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgICAgIGNvbXBvbmVudHM6IFwiY29sb3JcIiA9PT0gciA/IDQgOiAyLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9O1xuICAgICAgfSksIHRoaXMucGFpbnRWZXJ0ZXhBcnJheSA9IG5ldyBhKCk7XG4gICAgfTtcbiAgICBCYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKG5ldyB1aSh0aGlzLnpvb20pLCBlLCB7fSwgbiwgW10sIGkpLFxuICAgICAgICBvID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKG5ldyB1aSh0aGlzLnpvb20gKyAxKSwgZSwge30sIG4sIFtdLCBpKSxcbiAgICAgICAgcyA9IHRoaXMucGFpbnRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkucmVzaXplKHQpLCB0aGlzLl9zZXRQYWludFZhbHVlKHMsIHQsIGEsIG8pO1xuICAgIH0sIEJhLnByb3RvdHlwZS51cGRhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHtcbiAgICAgICAgICB6b29tOiB0aGlzLnpvb21cbiAgICAgICAgfSwgciwgbiksXG4gICAgICAgIGEgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUoe1xuICAgICAgICAgIHpvb206IHRoaXMuem9vbSArIDFcbiAgICAgICAgfSwgciwgbik7XG4gICAgICB0aGlzLl9zZXRQYWludFZhbHVlKHQsIGUsIGksIGEpO1xuICAgIH0sIEJhLnByb3RvdHlwZS5fc2V0UGFpbnRWYWx1ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBpZiAoXCJjb2xvclwiID09PSB0aGlzLnR5cGUpIGZvciAodmFyIGkgPSBDYShyKSwgYSA9IENhKG4pLCBvID0gdDsgbyA8IGU7IG8rKykgdGhpcy5wYWludFZlcnRleEFycmF5LmVtcGxhY2UobywgaVswXSwgaVsxXSwgYVswXSwgYVsxXSk7ZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHMgPSB0OyBzIDwgZTsgcysrKSB0aGlzLnBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShzLCByLCBuKTtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMubWF4VmFsdWUsIE1hdGguYWJzKHIpLCBNYXRoLmFicyhuKSk7XG4gICAgICB9XG4gICAgfSwgQmEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy5wYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmICh0aGlzLnBhaW50VmVydGV4QnVmZmVyICYmIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIuYnVmZmVyID8gdGhpcy5wYWludFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHRoaXMucGFpbnRWZXJ0ZXhBcnJheSkgOiB0aGlzLnBhaW50VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5wYWludFZlcnRleEFycmF5LCB0aGlzLnBhaW50VmVydGV4QXR0cmlidXRlcywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpKTtcbiAgICB9LCBCYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy5wYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfSwgQmEucHJvdG90eXBlLnNldFVuaWZvcm0gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzLnVzZUludGVnZXJab29tID8gTWF0aC5mbG9vcihlLnpvb20pIDogZS56b29tLFxuICAgICAgICBuID0gcCh0aGlzLmV4cHJlc3Npb24uaW50ZXJwb2xhdGlvbkZhY3RvcihyLCB0aGlzLnpvb20sIHRoaXMuem9vbSArIDEpLCAwLCAxKTtcbiAgICAgIHQuc2V0KG4pO1xuICAgIH0sIEJhLnByb3RvdHlwZS5nZXRCaW5kaW5nID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBuZXcgd2EodCwgZSk7XG4gICAgfTtcbiAgICB2YXIgVGEgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gdCwgdGhpcy50eXBlID0gZSwgdGhpcy51c2VJbnRlZ2VyWm9vbSA9IHIsIHRoaXMuem9vbSA9IG4sIHRoaXMubGF5ZXJJZCA9IGEsIHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheSA9IG5ldyBpKCksIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkgPSBuZXcgaSgpO1xuICAgIH07XG4gICAgVGEucHJvdG90eXBlLnBvcHVsYXRlUGFpbnRBcnJheSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgICB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkucmVzaXplKHQpLCB0aGlzLnpvb21PdXRQYWludFZlcnRleEFycmF5LnJlc2l6ZSh0KSwgdGhpcy5fc2V0UGFpbnRWYWx1ZXMobiwgdCwgZS5wYXR0ZXJucyAmJiBlLnBhdHRlcm5zW3RoaXMubGF5ZXJJZF0sIHIpO1xuICAgIH0sIFRhLnByb3RvdHlwZS51cGRhdGVQYWludEFycmF5ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHRoaXMuX3NldFBhaW50VmFsdWVzKHQsIGUsIHIucGF0dGVybnMgJiYgci5wYXR0ZXJuc1t0aGlzLmxheWVySWRdLCBpKTtcbiAgICB9LCBUYS5wcm90b3R5cGUuX3NldFBhaW50VmFsdWVzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIGlmIChuICYmIHIpIHtcbiAgICAgICAgdmFyIGkgPSBuW3IubWluXSxcbiAgICAgICAgICBhID0gbltyLm1pZF0sXG4gICAgICAgICAgbyA9IG5bci5tYXhdO1xuICAgICAgICBpZiAoaSAmJiBhICYmIG8pIGZvciAodmFyIHMgPSB0OyBzIDwgZTsgcysrKSB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShzLCBhLnRsWzBdLCBhLnRsWzFdLCBhLmJyWzBdLCBhLmJyWzFdLCBpLnRsWzBdLCBpLnRsWzFdLCBpLmJyWzBdLCBpLmJyWzFdLCBhLnBpeGVsUmF0aW8sIGkucGl4ZWxSYXRpbyksIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkuZW1wbGFjZShzLCBhLnRsWzBdLCBhLnRsWzFdLCBhLmJyWzBdLCBhLmJyWzFdLCBvLnRsWzBdLCBvLnRsWzFdLCBvLmJyWzBdLCBvLmJyWzFdLCBhLnBpeGVsUmF0aW8sIG8ucGl4ZWxSYXRpbyk7XG4gICAgICB9XG4gICAgfSwgVGEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnpvb21JblBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy56b29tSW5QYWludFZlcnRleEFycmF5LmFycmF5QnVmZmVyICYmIHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXkgJiYgdGhpcy56b29tT3V0UGFpbnRWZXJ0ZXhBcnJheS5hcnJheUJ1ZmZlciAmJiAodGhpcy56b29tSW5QYWludFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhBcnJheSwgcGEubWVtYmVycywgdGhpcy5leHByZXNzaW9uLmlzU3RhdGVEZXBlbmRlbnQpLCB0aGlzLnpvb21PdXRQYWludFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuem9vbU91dFBhaW50VmVydGV4QXJyYXksIHBhLm1lbWJlcnMsIHRoaXMuZXhwcmVzc2lvbi5pc1N0YXRlRGVwZW5kZW50KSk7XG4gICAgfSwgVGEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnpvb21PdXRQYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLnpvb21PdXRQYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuem9vbUluUGFpbnRWZXJ0ZXhCdWZmZXIgJiYgdGhpcy56b29tSW5QYWludFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICB2YXIgVmEgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5iaW5kZXJzID0ge30sIHRoaXMuX2J1ZmZlcnMgPSBbXTtcbiAgICAgIHZhciBuID0gW107XG4gICAgICBmb3IgKHZhciBpIGluIHQucGFpbnQuX3ZhbHVlcykgaWYgKHIoaSkpIHtcbiAgICAgICAgdmFyIGEgPSB0LnBhaW50LmdldChpKTtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBkaSAmJiBWcihhLnByb3BlcnR5LnNwZWNpZmljYXRpb24pKSB7XG4gICAgICAgICAgdmFyIG8gPSBEYShpLCB0LnR5cGUpLFxuICAgICAgICAgICAgcyA9IGEudmFsdWUsXG4gICAgICAgICAgICB1ID0gYS5wcm9wZXJ0eS5zcGVjaWZpY2F0aW9uLnR5cGUsXG4gICAgICAgICAgICBsID0gYS5wcm9wZXJ0eS51c2VJbnRlZ2VyWm9vbSxcbiAgICAgICAgICAgIHAgPSBhLnByb3BlcnR5LnNwZWNpZmljYXRpb25bXCJwcm9wZXJ0eS10eXBlXCJdLFxuICAgICAgICAgICAgYyA9IFwiY3Jvc3MtZmFkZWRcIiA9PT0gcCB8fCBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCIgPT09IHA7XG4gICAgICAgICAgaWYgKFwiY29uc3RhbnRcIiA9PT0gcy5raW5kKSB0aGlzLmJpbmRlcnNbaV0gPSBjID8gbmV3IFBhKHMudmFsdWUsIG8pIDogbmV3IEVhKHMudmFsdWUsIG8sIHUpLCBuLnB1c2goXCIvdV9cIiArIGkpO2Vsc2UgaWYgKFwic291cmNlXCIgPT09IHMua2luZCB8fCBjKSB7XG4gICAgICAgICAgICB2YXIgaCA9IExhKGksIHUsIFwic291cmNlXCIpO1xuICAgICAgICAgICAgdGhpcy5iaW5kZXJzW2ldID0gYyA/IG5ldyBUYShzLCB1LCBsLCBlLCBoLCB0LmlkKSA6IG5ldyBNYShzLCBvLCB1LCBoKSwgbi5wdXNoKFwiL2FfXCIgKyBpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSBMYShpLCB1LCBcImNvbXBvc2l0ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuYmluZGVyc1tpXSA9IG5ldyBCYShzLCBvLCB1LCBsLCBlLCBmKSwgbi5wdXNoKFwiL3pfXCIgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVLZXkgPSBuLnNvcnQoKS5qb2luKFwiXCIpO1xuICAgIH07XG4gICAgVmEucHJvdG90eXBlLmdldE1heFZhbHVlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5iaW5kZXJzW3RdO1xuICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBNYSB8fCBlIGluc3RhbmNlb2YgQmEgPyBlLm1heFZhbHVlIDogMDtcbiAgICB9LCBWYS5wcm90b3R5cGUucG9wdWxhdGVQYWludEFycmF5cyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICBmb3IgKHZhciBhIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgbyA9IHRoaXMuYmluZGVyc1thXTtcbiAgICAgICAgKG8gaW5zdGFuY2VvZiBNYSB8fCBvIGluc3RhbmNlb2YgQmEgfHwgbyBpbnN0YW5jZW9mIFRhKSAmJiBvLnBvcHVsYXRlUGFpbnRBcnJheSh0LCBlLCByLCBuLCBpKTtcbiAgICAgIH1cbiAgICB9LCBWYS5wcm90b3R5cGUuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5iaW5kZXJzW3JdO1xuICAgICAgICBuIGluc3RhbmNlb2YgUGEgJiYgbi5zZXRDb25zdGFudFBhdHRlcm5Qb3NpdGlvbnModCwgZSk7XG4gICAgICB9XG4gICAgfSwgVmEucHJvdG90eXBlLnVwZGF0ZVBhaW50QXJyYXlzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gITE7XG4gICAgICBmb3IgKHZhciBvIGluIHQpIGZvciAodmFyIHMgPSAwLCB1ID0gZS5nZXRQb3NpdGlvbnMobyk7IHMgPCB1Lmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgIHZhciBsID0gdVtzXSxcbiAgICAgICAgICBwID0gci5mZWF0dXJlKGwuaW5kZXgpO1xuICAgICAgICBmb3IgKHZhciBjIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICAgIHZhciBoID0gdGhpcy5iaW5kZXJzW2NdO1xuICAgICAgICAgIGlmICgoaCBpbnN0YW5jZW9mIE1hIHx8IGggaW5zdGFuY2VvZiBCYSB8fCBoIGluc3RhbmNlb2YgVGEpICYmICEwID09PSBoLmV4cHJlc3Npb24uaXNTdGF0ZURlcGVuZGVudCkge1xuICAgICAgICAgICAgdmFyIGYgPSBuLnBhaW50LmdldChjKTtcbiAgICAgICAgICAgIGguZXhwcmVzc2lvbiA9IGYudmFsdWUsIGgudXBkYXRlUGFpbnRBcnJheShsLnN0YXJ0LCBsLmVuZCwgcCwgdFtvXSwgaSksIGEgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFZhLnByb3RvdHlwZS5kZWZpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5iaW5kZXJzW2VdO1xuICAgICAgICAociBpbnN0YW5jZW9mIEVhIHx8IHIgaW5zdGFuY2VvZiBQYSkgJiYgdC5wdXNoLmFwcGx5KHQsIHIudW5pZm9ybU5hbWVzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBcIiNkZWZpbmUgSEFTX1VOSUZPUk1fXCIgKyB0O1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBWYS5wcm90b3R5cGUuZ2V0QmluZGVyQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gW107XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBNYSB8fCByIGluc3RhbmNlb2YgQmEpIGZvciAodmFyIG4gPSAwOyBuIDwgci5wYWludFZlcnRleEF0dHJpYnV0ZXMubGVuZ3RoOyBuKyspIHQucHVzaChyLnBhaW50VmVydGV4QXR0cmlidXRlc1tuXS5uYW1lKTtlbHNlIGlmIChyIGluc3RhbmNlb2YgVGEpIGZvciAodmFyIGkgPSAwOyBpIDwgcGEubWVtYmVycy5sZW5ndGg7IGkrKykgdC5wdXNoKHBhLm1lbWJlcnNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBWYS5wcm90b3R5cGUuZ2V0QmluZGVyVW5pZm9ybXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IFtdO1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLmJpbmRlcnMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmJpbmRlcnNbZV07XG4gICAgICAgIGlmIChyIGluc3RhbmNlb2YgRWEgfHwgciBpbnN0YW5jZW9mIFBhIHx8IHIgaW5zdGFuY2VvZiBCYSkgZm9yICh2YXIgbiA9IDAsIGkgPSByLnVuaWZvcm1OYW1lczsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHQucHVzaChpW25dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICAgIH0sIFZhLnByb3RvdHlwZS5nZXRQYWludFZlcnRleEJ1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVycztcbiAgICB9LCBWYS5wcm90b3R5cGUuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBbXTtcbiAgICAgIGZvciAodmFyIG4gaW4gdGhpcy5iaW5kZXJzKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5iaW5kZXJzW25dO1xuICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIEVhIHx8IGkgaW5zdGFuY2VvZiBQYSB8fCBpIGluc3RhbmNlb2YgQmEpIGZvciAodmFyIGEgPSAwLCBvID0gaS51bmlmb3JtTmFtZXM7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgdmFyIHMgPSBvW2FdO1xuICAgICAgICAgIGlmIChlW3NdKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGkuZ2V0QmluZGluZyh0LCBlW3NdLCBzKTtcbiAgICAgICAgICAgIHIucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IHMsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBuLFxuICAgICAgICAgICAgICBiaW5kaW5nOiB1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIFZhLnByb3RvdHlwZS5zZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYSA9IGU7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXSxcbiAgICAgICAgICBzID0gby5uYW1lLFxuICAgICAgICAgIHUgPSBvLnByb3BlcnR5O1xuICAgICAgICB0aGlzLmJpbmRlcnNbdV0uc2V0VW5pZm9ybShvLmJpbmRpbmcsIG4sIHIuZ2V0KHUpLCBzKTtcbiAgICAgIH1cbiAgICB9LCBWYS5wcm90b3R5cGUudXBkYXRlUGFpbnRCdWZmZXJzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5fYnVmZmVycyA9IFtdLCB0aGlzLmJpbmRlcnMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmJpbmRlcnNbZV07XG4gICAgICAgIGlmICh0ICYmIHIgaW5zdGFuY2VvZiBUYSkge1xuICAgICAgICAgIHZhciBuID0gMiA9PT0gdC5mcm9tU2NhbGUgPyByLnpvb21JblBhaW50VmVydGV4QnVmZmVyIDogci56b29tT3V0UGFpbnRWZXJ0ZXhCdWZmZXI7XG4gICAgICAgICAgbiAmJiB0aGlzLl9idWZmZXJzLnB1c2gobik7XG4gICAgICAgIH0gZWxzZSAociBpbnN0YW5jZW9mIE1hIHx8IHIgaW5zdGFuY2VvZiBCYSkgJiYgci5wYWludFZlcnRleEJ1ZmZlciAmJiB0aGlzLl9idWZmZXJzLnB1c2goci5wYWludFZlcnRleEJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSwgVmEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgciA9IHRoaXMuYmluZGVyc1tlXTtcbiAgICAgICAgKHIgaW5zdGFuY2VvZiBNYSB8fCByIGluc3RhbmNlb2YgQmEgfHwgciBpbnN0YW5jZW9mIFRhKSAmJiByLnVwbG9hZCh0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlUGFpbnRCdWZmZXJzKCk7XG4gICAgfSwgVmEucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0IGluIHRoaXMuYmluZGVycykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuYmluZGVyc1t0XTtcbiAgICAgICAgKGUgaW5zdGFuY2VvZiBNYSB8fCBlIGluc3RhbmNlb2YgQmEgfHwgZSBpbnN0YW5jZW9mIFRhKSAmJiBlLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBGYSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0pLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IHt9O1xuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSB0OyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl07XG4gICAgICAgIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW2EuaWRdID0gbmV3IFZhKGEsIGUsIHIpO1xuICAgICAgfVxuICAgICAgdGhpcy5uZWVkc1VwbG9hZCA9ICExLCB0aGlzLl9mZWF0dXJlTWFwID0gbmV3IGRhKCksIHRoaXMuX2J1ZmZlck9mZnNldCA9IDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBEYSh0LCBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBcInRleHQtb3BhY2l0eVwiOiBbXCJvcGFjaXR5XCJdLFxuICAgICAgICBcImljb24tb3BhY2l0eVwiOiBbXCJvcGFjaXR5XCJdLFxuICAgICAgICBcInRleHQtY29sb3JcIjogW1wiZmlsbF9jb2xvclwiXSxcbiAgICAgICAgXCJpY29uLWNvbG9yXCI6IFtcImZpbGxfY29sb3JcIl0sXG4gICAgICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IFtcImhhbG9fY29sb3JcIl0sXG4gICAgICAgIFwiaWNvbi1oYWxvLWNvbG9yXCI6IFtcImhhbG9fY29sb3JcIl0sXG4gICAgICAgIFwidGV4dC1oYWxvLWJsdXJcIjogW1wiaGFsb19ibHVyXCJdLFxuICAgICAgICBcImljb24taGFsby1ibHVyXCI6IFtcImhhbG9fYmx1clwiXSxcbiAgICAgICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjogW1wiaGFsb193aWR0aFwiXSxcbiAgICAgICAgXCJpY29uLWhhbG8td2lkdGhcIjogW1wiaGFsb193aWR0aFwiXSxcbiAgICAgICAgXCJsaW5lLWdhcC13aWR0aFwiOiBbXCJnYXB3aWR0aFwiXSxcbiAgICAgICAgXCJsaW5lLXBhdHRlcm5cIjogW1wicGF0dGVybl90b1wiLCBcInBhdHRlcm5fZnJvbVwiLCBcInBpeGVsX3JhdGlvX3RvXCIsIFwicGl4ZWxfcmF0aW9fZnJvbVwiXSxcbiAgICAgICAgXCJmaWxsLXBhdHRlcm5cIjogW1wicGF0dGVybl90b1wiLCBcInBhdHRlcm5fZnJvbVwiLCBcInBpeGVsX3JhdGlvX3RvXCIsIFwicGl4ZWxfcmF0aW9fZnJvbVwiXSxcbiAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IFtcInBhdHRlcm5fdG9cIiwgXCJwYXR0ZXJuX2Zyb21cIiwgXCJwaXhlbF9yYXRpb190b1wiLCBcInBpeGVsX3JhdGlvX2Zyb21cIl1cbiAgICAgIH1bdF0gfHwgW3QucmVwbGFjZShlICsgXCItXCIsIFwiXCIpLnJlcGxhY2UoLy0vZywgXCJfXCIpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTGEodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIHNvdXJjZTogVGksXG4gICAgICAgICAgICBjb21wb3NpdGU6IFlpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIHNvdXJjZTogR2ksXG4gICAgICAgICAgICBjb21wb3NpdGU6IFRpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJsaW5lLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgICBzb3VyY2U6IFZpLFxuICAgICAgICAgICAgICBjb21wb3NpdGU6IFZpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLXBhdHRlcm5cIjoge1xuICAgICAgICAgICAgICBzb3VyY2U6IFZpLFxuICAgICAgICAgICAgICBjb21wb3NpdGU6IFZpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IHtcbiAgICAgICAgICAgICAgc291cmNlOiBWaSxcbiAgICAgICAgICAgICAgY29tcG9zaXRlOiBWaVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1bdF07XG4gICAgICAgIH0odCk7XG4gICAgICByZXR1cm4gaSAmJiBpW3JdIHx8IG5bZV1bcl07XG4gICAgfVxuICAgIEZhLnByb3RvdHlwZS5wb3B1bGF0ZVBhaW50QXJyYXlzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMpIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW29dLnBvcHVsYXRlUGFpbnRBcnJheXModCwgZSwgbiwgaSwgYSk7XG4gICAgICB2b2lkIDAgIT09IGUuaWQgJiYgdGhpcy5fZmVhdHVyZU1hcC5hZGQoZS5pZCwgciwgdGhpcy5fYnVmZmVyT2Zmc2V0LCB0KSwgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gdCwgdGhpcy5uZWVkc1VwbG9hZCA9ICEwO1xuICAgIH0sIEZhLnByb3RvdHlwZS51cGRhdGVQYWludEFycmF5cyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgYSA9IHI7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgdGhpcy5uZWVkc1VwbG9hZCA9IHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW28uaWRdLnVwZGF0ZVBhaW50QXJyYXlzKHQsIHRoaXMuX2ZlYXR1cmVNYXAsIGUsIG8sIG4pIHx8IHRoaXMubmVlZHNVcGxvYWQ7XG4gICAgICB9XG4gICAgfSwgRmEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnNbdF07XG4gICAgfSwgRmEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1VwbG9hZCkge1xuICAgICAgICBmb3IgKHZhciBlIGluIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zKSB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9uc1tlXS51cGxvYWQodCk7XG4gICAgICAgIHRoaXMubmVlZHNVcGxvYWQgPSAhMTtcbiAgICAgIH1cbiAgICB9LCBGYS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMpIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zW3RdLmRlc3Ryb3koKTtcbiAgICB9LCBPbihcIkNvbnN0YW50QmluZGVyXCIsIEVhKSwgT24oXCJDcm9zc0ZhZGVkQ29uc3RhbnRCaW5kZXJcIiwgUGEpLCBPbihcIlNvdXJjZUV4cHJlc3Npb25CaW5kZXJcIiwgTWEpLCBPbihcIkNyb3NzRmFkZWRDb21wb3NpdGVCaW5kZXJcIiwgVGEpLCBPbihcIkNvbXBvc2l0ZUV4cHJlc3Npb25CaW5kZXJcIiwgQmEpLCBPbihcIlByb2dyYW1Db25maWd1cmF0aW9uXCIsIFZhLCB7XG4gICAgICBvbWl0OiBbXCJfYnVmZmVyc1wiXVxuICAgIH0pLCBPbihcIlByb2dyYW1Db25maWd1cmF0aW9uU2V0XCIsIEZhKTtcbiAgICB2YXIgUmEgPSBNYXRoLnBvdygyLCAxNCkgLSAxLFxuICAgICAgT2EgPSAtUmEgLSAxO1xuICAgIGZ1bmN0aW9uIFVhKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSA4MTkyIC8gdC5leHRlbnQsIHIgPSB0LmxvYWRHZW9tZXRyeSgpLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIGZvciAodmFyIGkgPSByW25dLCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIG8gPSBpW2FdLFxuICAgICAgICAgIHMgPSBNYXRoLnJvdW5kKG8ueCAqIGUpLFxuICAgICAgICAgIHUgPSBNYXRoLnJvdW5kKG8ueSAqIGUpO1xuICAgICAgICBvLnggPSBwKHMsIE9hLCBSYSksIG8ueSA9IHAodSwgT2EsIFJhKSwgKHMgPCBvLnggfHwgcyA+IG8ueCArIDEgfHwgdSA8IG8ueSB8fCB1ID4gby55ICsgMSkgJiYgQShcIkdlb21ldHJ5IGV4Y2VlZHMgYWxsb3dlZCBleHRlbnQsIHJlZHVjZSB5b3VyIHZlY3RvciB0aWxlIGJ1ZmZlciBzaXplXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGphKHQsIGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHQudHlwZSxcbiAgICAgICAgaWQ6IHQuaWQsXG4gICAgICAgIHByb3BlcnRpZXM6IHQucHJvcGVydGllcyxcbiAgICAgICAgZ2VvbWV0cnk6IGUgPyBVYSh0KSA6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBxYSh0LCBlLCByLCBuLCBpKSB7XG4gICAgICB0LmVtcGxhY2VCYWNrKDIgKiBlICsgKG4gKyAxKSAvIDIsIDIgKiByICsgKGkgKyAxKSAvIDIpO1xuICAgIH1cbiAgICB2YXIgTmEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy56b29tID0gdC56b29tLCB0aGlzLm92ZXJzY2FsaW5nID0gdC5vdmVyc2NhbGluZywgdGhpcy5sYXllcnMgPSB0LmxheWVycywgdGhpcy5sYXllcklkcyA9IHRoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pLCB0aGlzLmluZGV4ID0gdC5pbmRleCwgdGhpcy5oYXNQYXR0ZXJuID0gITEsIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgRWkoKSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IHFpKCksIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgRmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc3RhdGVEZXBlbmRlbnRMYXllcklkcyA9IHRoaXMubGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1N0YXRlRGVwZW5kZW50KCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEthKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykgaWYgKFFhKGUsIHRbcl0pKSByZXR1cm4gITA7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIGlmIChRYSh0LCBlW25dKSkgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICEhSmEodCwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdhKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiAhIVFhKHQsIGUpIHx8ICEhWWEoZSwgdCwgcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFphKHQsIGUpIHtcbiAgICAgIGlmICgxID09PSB0Lmxlbmd0aCkgcmV0dXJuIFdhKGUsIHRbMF0pO1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSBmb3IgKHZhciBuID0gZVtyXSwgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSBpZiAoUWEodCwgbltpXSkpIHJldHVybiAhMDtcbiAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykgaWYgKFdhKGUsIHRbYV0pKSByZXR1cm4gITA7XG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIGlmIChKYSh0LCBlW29dKSkgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBYYSh0LCBlLCByKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChKYSh0LCBlKSkgcmV0dXJuICEwO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIGlmIChZYShlW25dLCB0LCByKSkgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSBpZiAoWWEodFtpXSwgZSwgcikpIHJldHVybiAhMDtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSmEodCwgZSkge1xuICAgICAgaWYgKDAgPT09IHQubGVuZ3RoIHx8IDAgPT09IGUubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoIC0gMTsgcisrKSBmb3IgKHZhciBuID0gdFtyXSwgaSA9IHRbciArIDFdLCBhID0gMDsgYSA8IGUubGVuZ3RoIC0gMTsgYSsrKSBpZiAoSGEobiwgaSwgZVthXSwgZVthICsgMV0pKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhhKHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiBTKHQsIHIsIG4pICE9PSBTKGUsIHIsIG4pICYmIFModCwgZSwgcikgIT09IFModCwgZSwgbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFlhKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gciAqIHI7XG4gICAgICBpZiAoMSA9PT0gZS5sZW5ndGgpIHJldHVybiB0LmRpc3RTcXIoZVswXSkgPCBuO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlLmxlbmd0aDsgaSsrKSBpZiAoJGEodCwgZVtpIC0gMV0sIGVbaV0pIDwgbikgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkYSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUuZGlzdFNxcihyKTtcbiAgICAgIGlmICgwID09PSBuKSByZXR1cm4gdC5kaXN0U3FyKGUpO1xuICAgICAgdmFyIGkgPSAoKHQueCAtIGUueCkgKiAoci54IC0gZS54KSArICh0LnkgLSBlLnkpICogKHIueSAtIGUueSkpIC8gbjtcbiAgICAgIHJldHVybiB0LmRpc3RTcXIoaSA8IDAgPyBlIDogaSA+IDEgPyByIDogci5zdWIoZSkuX211bHQoaSkuX2FkZChlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdhKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIsIG4sIGksIGEgPSAhMSwgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSBmb3IgKHZhciBzID0gMCwgdSA9IChyID0gdFtvXSkubGVuZ3RoIC0gMTsgcyA8IHIubGVuZ3RoOyB1ID0gcysrKSAobiA9IHJbc10pLnkgPiBlLnkgIT0gKGkgPSByW3VdKS55ID4gZS55ICYmIGUueCA8IChpLnggLSBuLngpICogKGUueSAtIG4ueSkgLyAoaS55IC0gbi55KSArIG4ueCAmJiAoYSA9ICFhKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRYSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gITEsIG4gPSAwLCBpID0gdC5sZW5ndGggLSAxOyBuIDwgdC5sZW5ndGg7IGkgPSBuKyspIHtcbiAgICAgICAgdmFyIGEgPSB0W25dLFxuICAgICAgICAgIG8gPSB0W2ldO1xuICAgICAgICBhLnkgPiBlLnkgIT0gby55ID4gZS55ICYmIGUueCA8IChvLnggLSBhLngpICogKGUueSAtIGEueSkgLyAoby55IC0gYS55KSArIGEueCAmJiAociA9ICFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0byh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHJbMF0sXG4gICAgICAgIGkgPSByWzJdO1xuICAgICAgaWYgKHQueCA8IG4ueCAmJiBlLnggPCBuLnggfHwgdC54ID4gaS54ICYmIGUueCA+IGkueCB8fCB0LnkgPCBuLnkgJiYgZS55IDwgbi55IHx8IHQueSA+IGkueSAmJiBlLnkgPiBpLnkpIHJldHVybiAhMTtcbiAgICAgIHZhciBhID0gUyh0LCBlLCByWzBdKTtcbiAgICAgIHJldHVybiBhICE9PSBTKHQsIGUsIHJbMV0pIHx8IGEgIT09IFModCwgZSwgclsyXSkgfHwgYSAhPT0gUyh0LCBlLCByWzNdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW8odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlLnBhaW50LmdldCh0KS52YWx1ZTtcbiAgICAgIHJldHVybiBcImNvbnN0YW50XCIgPT09IG4ua2luZCA/IG4udmFsdWUgOiByLnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoZS5pZCkuZ2V0TWF4VmFsdWUodCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodFswXSAqIHRbMF0gKyB0WzFdICogdFsxXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vKHQsIGUsIHIsIG4sIGEpIHtcbiAgICAgIGlmICghZVswXSAmJiAhZVsxXSkgcmV0dXJuIHQ7XG4gICAgICB2YXIgbyA9IGkuY29udmVydChlKS5fbXVsdChhKTtcbiAgICAgIFwidmlld3BvcnRcIiA9PT0gciAmJiBvLl9yb3RhdGUoLW4pO1xuICAgICAgZm9yICh2YXIgcyA9IFtdLCB1ID0gMDsgdSA8IHQubGVuZ3RoOyB1KyspIHMucHVzaCh0W3VdLnN1YihvKSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgTmEucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5sYXllcnNbMF0sXG4gICAgICAgIGkgPSBbXSxcbiAgICAgICAgYSA9IG51bGwsXG4gICAgICAgIG8gPSAhMTtcbiAgICAgIFwiY2lyY2xlXCIgPT09IG4udHlwZSAmJiAobyA9ICEoYSA9IG4ubGF5b3V0LmdldChcImNpcmNsZS1zb3J0LWtleVwiKSkuaXNDb25zdGFudCgpKTtcbiAgICAgIGZvciAodmFyIHMgPSAwLCB1ID0gdDsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgdmFyIGwgPSB1W3NdLFxuICAgICAgICAgIHAgPSBsLmZlYXR1cmUsXG4gICAgICAgICAgYyA9IGwuaWQsXG4gICAgICAgICAgaCA9IGwuaW5kZXgsXG4gICAgICAgICAgZiA9IGwuc291cmNlTGF5ZXJJbmRleCxcbiAgICAgICAgICB5ID0gdGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIubmVlZEdlb21ldHJ5LFxuICAgICAgICAgIGQgPSBqYShwLCB5KTtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLmZpbHRlcihuZXcgdWkodGhpcy56b29tKSwgZCwgcikpIHtcbiAgICAgICAgICB2YXIgbSA9IG8gPyBhLmV2YWx1YXRlKGQsIHt9LCByKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIHYgPSB7XG4gICAgICAgICAgICAgIGlkOiBjLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBwLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIHR5cGU6IHAudHlwZSxcbiAgICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogZixcbiAgICAgICAgICAgICAgaW5kZXg6IGgsXG4gICAgICAgICAgICAgIGdlb21ldHJ5OiB5ID8gZC5nZW9tZXRyeSA6IFVhKHApLFxuICAgICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgICAgICAgIHNvcnRLZXk6IG1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaS5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvICYmIGkuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5zb3J0S2V5IC0gZS5zb3J0S2V5O1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBnID0gMCwgeCA9IGk7IGcgPCB4Lmxlbmd0aDsgZyArPSAxKSB7XG4gICAgICAgIHZhciBiID0geFtnXSxcbiAgICAgICAgICB3ID0gYi5nZW9tZXRyeSxcbiAgICAgICAgICBfID0gYi5pbmRleCxcbiAgICAgICAgICBBID0gYi5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgIFMgPSB0W19dLmZlYXR1cmU7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZShiLCB3LCBfLCByKSwgZS5mZWF0dXJlSW5kZXguaW5zZXJ0KFMsIHcsIF8sIEEsIHRoaXMuaW5kZXgpO1xuICAgICAgfVxuICAgIH0sIE5hLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycywgcik7XG4gICAgfSwgTmEucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgfSwgTmEucHJvdG90eXBlLnVwbG9hZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudXBsb2FkZWQgfHwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwgTmEucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnVwbG9hZGVkIHx8ICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHNhKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5KSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSwgdGhpcy51cGxvYWRlZCA9ICEwO1xuICAgIH0sIE5hLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCkpO1xuICAgIH0sIE5hLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhID0gZTsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIGZvciAodmFyIG8gPSAwLCBzID0gYVtpXTsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgIGwgPSB1LngsXG4gICAgICAgICAgcCA9IHUueTtcbiAgICAgICAgaWYgKCEobCA8IDAgfHwgbCA+PSA4MTkyIHx8IHAgPCAwIHx8IHAgPj0gODE5MikpIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQoNCwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgdGhpcy5pbmRleEFycmF5LCB0LnNvcnRLZXkpLFxuICAgICAgICAgICAgaCA9IGMudmVydGV4TGVuZ3RoO1xuICAgICAgICAgIHFhKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGwsIHAsIC0xLCAtMSksIHFhKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGwsIHAsIDEsIC0xKSwgcWEodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgbCwgcCwgMSwgMSksIHFhKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGwsIHAsIC0xLCAxKSwgdGhpcy5pbmRleEFycmF5LmVtcGxhY2VCYWNrKGgsIGggKyAxLCBoICsgMiksIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhoLCBoICsgMywgaCArIDIpLCBjLnZlcnRleExlbmd0aCArPSA0LCBjLnByaW1pdGl2ZUxlbmd0aCArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5wb3B1bGF0ZVBhaW50QXJyYXlzKHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoLCB0LCByLCB7fSwgbik7XG4gICAgfSwgT24oXCJDaXJjbGVCdWNrZXRcIiwgTmEsIHtcbiAgICAgIG9taXQ6IFtcImxheWVyc1wiXVxuICAgIH0pO1xuICAgIHZhciBpbyA9IG5ldyBfaSh7XG4gICAgICAgIFwiY2lyY2xlLXNvcnQta2V5XCI6IG5ldyBnaShQdC5sYXlvdXRfY2lyY2xlW1wiY2lyY2xlLXNvcnQta2V5XCJdKVxuICAgICAgfSksXG4gICAgICBhbyA9IHtcbiAgICAgICAgcGFpbnQ6IG5ldyBfaSh7XG4gICAgICAgICAgXCJjaXJjbGUtcmFkaXVzXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtcmFkaXVzXCJdKSxcbiAgICAgICAgICBcImNpcmNsZS1jb2xvclwiOiBuZXcgZ2koUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLWNvbG9yXCJdKSxcbiAgICAgICAgICBcImNpcmNsZS1ibHVyXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtYmx1clwiXSksXG4gICAgICAgICAgXCJjaXJjbGUtb3BhY2l0eVwiOiBuZXcgZ2koUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLW9wYWNpdHlcIl0pLFxuICAgICAgICAgIFwiY2lyY2xlLXRyYW5zbGF0ZVwiOiBuZXcgdmkoUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXRyYW5zbGF0ZVwiXSksXG4gICAgICAgICAgXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIl0pLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IG5ldyB2aShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIl0pLFxuICAgICAgICAgIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiBuZXcgdmkoUHQucGFpbnRfY2lyY2xlW1wiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiXSksXG4gICAgICAgICAgXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCJdKSxcbiAgICAgICAgICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X2NpcmNsZVtcImNpcmNsZS1zdHJva2UtY29sb3JcIl0pLFxuICAgICAgICAgIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IG5ldyBnaShQdC5wYWludF9jaXJjbGVbXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIl0pXG4gICAgICAgIH0pLFxuICAgICAgICBsYXlvdXQ6IGlvXG4gICAgICB9LFxuICAgICAgb28gPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbiAgICBmdW5jdGlvbiBzbyh0KSB7XG4gICAgICByZXR1cm4gdFswXSA9IDEsIHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDAsIHRbNF0gPSAwLCB0WzVdID0gMSwgdFs2XSA9IDAsIHRbN10gPSAwLCB0WzhdID0gMCwgdFs5XSA9IDAsIHRbMTBdID0gMSwgdFsxMV0gPSAwLCB0WzEyXSA9IDAsIHRbMTNdID0gMCwgdFsxNF0gPSAwLCB0WzE1XSA9IDEsIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZVswXSxcbiAgICAgICAgaSA9IGVbMV0sXG4gICAgICAgIGEgPSBlWzJdLFxuICAgICAgICBvID0gZVszXSxcbiAgICAgICAgcyA9IGVbNF0sXG4gICAgICAgIHUgPSBlWzVdLFxuICAgICAgICBsID0gZVs2XSxcbiAgICAgICAgcCA9IGVbN10sXG4gICAgICAgIGMgPSBlWzhdLFxuICAgICAgICBoID0gZVs5XSxcbiAgICAgICAgZiA9IGVbMTBdLFxuICAgICAgICB5ID0gZVsxMV0sXG4gICAgICAgIGQgPSBlWzEyXSxcbiAgICAgICAgbSA9IGVbMTNdLFxuICAgICAgICB2ID0gZVsxNF0sXG4gICAgICAgIGcgPSBlWzE1XSxcbiAgICAgICAgeCA9IHJbMF0sXG4gICAgICAgIGIgPSByWzFdLFxuICAgICAgICB3ID0gclsyXSxcbiAgICAgICAgXyA9IHJbM107XG4gICAgICByZXR1cm4gdFswXSA9IHggKiBuICsgYiAqIHMgKyB3ICogYyArIF8gKiBkLCB0WzFdID0geCAqIGkgKyBiICogdSArIHcgKiBoICsgXyAqIG0sIHRbMl0gPSB4ICogYSArIGIgKiBsICsgdyAqIGYgKyBfICogdiwgdFszXSA9IHggKiBvICsgYiAqIHAgKyB3ICogeSArIF8gKiBnLCB0WzRdID0gKHggPSByWzRdKSAqIG4gKyAoYiA9IHJbNV0pICogcyArICh3ID0gcls2XSkgKiBjICsgKF8gPSByWzddKSAqIGQsIHRbNV0gPSB4ICogaSArIGIgKiB1ICsgdyAqIGggKyBfICogbSwgdFs2XSA9IHggKiBhICsgYiAqIGwgKyB3ICogZiArIF8gKiB2LCB0WzddID0geCAqIG8gKyBiICogcCArIHcgKiB5ICsgXyAqIGcsIHRbOF0gPSAoeCA9IHJbOF0pICogbiArIChiID0gcls5XSkgKiBzICsgKHcgPSByWzEwXSkgKiBjICsgKF8gPSByWzExXSkgKiBkLCB0WzldID0geCAqIGkgKyBiICogdSArIHcgKiBoICsgXyAqIG0sIHRbMTBdID0geCAqIGEgKyBiICogbCArIHcgKiBmICsgXyAqIHYsIHRbMTFdID0geCAqIG8gKyBiICogcCArIHcgKiB5ICsgXyAqIGcsIHRbMTJdID0gKHggPSByWzEyXSkgKiBuICsgKGIgPSByWzEzXSkgKiBzICsgKHcgPSByWzE0XSkgKiBjICsgKF8gPSByWzE1XSkgKiBkLCB0WzEzXSA9IHggKiBpICsgYiAqIHUgKyB3ICogaCArIF8gKiBtLCB0WzE0XSA9IHggKiBhICsgYiAqIGwgKyB3ICogZiArIF8gKiB2LCB0WzE1XSA9IHggKiBvICsgYiAqIHAgKyB3ICogeSArIF8gKiBnLCB0O1xuICAgIH1cbiAgICBNYXRoLmh5cG90IHx8IChNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cywgZSA9IDAsIHIgPSBhcmd1bWVudHMubGVuZ3RoOyByLS07KSBlICs9IHRbcl0gKiB0W3JdO1xuICAgICAgcmV0dXJuIE1hdGguc3FydChlKTtcbiAgICB9KTtcbiAgICB2YXIgbG8sXG4gICAgICBwbyA9IHVvO1xuICAgIGZ1bmN0aW9uIGNvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZVswXSxcbiAgICAgICAgaSA9IGVbMV0sXG4gICAgICAgIGEgPSBlWzJdLFxuICAgICAgICBvID0gZVszXTtcbiAgICAgIHJldHVybiB0WzBdID0gclswXSAqIG4gKyByWzRdICogaSArIHJbOF0gKiBhICsgclsxMl0gKiBvLCB0WzFdID0gclsxXSAqIG4gKyByWzVdICogaSArIHJbOV0gKiBhICsgclsxM10gKiBvLCB0WzJdID0gclsyXSAqIG4gKyByWzZdICogaSArIHJbMTBdICogYSArIHJbMTRdICogbywgdFszXSA9IHJbM10gKiBuICsgcls3XSAqIGkgKyByWzExXSAqIGEgKyByWzE1XSAqIG8sIHQ7XG4gICAgfVxuICAgIGxvID0gbmV3IG9vKDMpLCBvbyAhPSBGbG9hdDMyQXJyYXkgJiYgKGxvWzBdID0gMCwgbG9bMV0gPSAwLCBsb1syXSA9IDApLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IG5ldyBvbyg0KTtcbiAgICAgIG9vICE9IEZsb2F0MzJBcnJheSAmJiAodFswXSA9IDAsIHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDApO1xuICAgIH0oKTtcbiAgICB2YXIgaG8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgb28oMik7XG4gICAgICBvbyAhPSBGbG9hdDMyQXJyYXkgJiYgKHRbMF0gPSAwLCB0WzFdID0gMCk7XG4gICAgfSgpLCBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgIHQuY2FsbCh0aGlzLCBlLCBhbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hKHQpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHQ7XG4gICAgICAgIHJldHVybiBlbyhcImNpcmNsZS1yYWRpdXNcIiwgdGhpcywgZSkgKyBlbyhcImNpcmNsZS1zdHJva2Utd2lkdGhcIiwgdGhpcywgZSkgKyBybyh0aGlzLnBhaW50LmdldChcImNpcmNsZS10cmFuc2xhdGVcIikpO1xuICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSBubyh0LCB0aGlzLnBhaW50LmdldChcImNpcmNsZS10cmFuc2xhdGVcIiksIHRoaXMucGFpbnQuZ2V0KFwiY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3JcIiksIGEuYW5nbGUsIG8pLCBsID0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcmFkaXVzXCIpLmV2YWx1YXRlKGUsIHIpICsgdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtc3Ryb2tlLXdpZHRoXCIpLmV2YWx1YXRlKGUsIHIpLCBwID0gXCJtYXBcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCIpLCBjID0gcCA/IHUgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIHQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmbyh0LCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0odSwgcyksIGggPSBwID8gbCAqIG8gOiBsLCBmID0gMCwgeSA9IG47IGYgPCB5Lmxlbmd0aDsgZiArPSAxKSBmb3IgKHZhciBkID0gMCwgbSA9IHlbZl07IGQgPCBtLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgICAgdmFyIHYgPSBtW2RdLFxuICAgICAgICAgICAgZyA9IHAgPyB2IDogZm8odiwgcyksXG4gICAgICAgICAgICB4ID0gaCxcbiAgICAgICAgICAgIGIgPSBjbyhbXSwgW3YueCwgdi55LCAwLCAxXSwgcyk7XG4gICAgICAgICAgaWYgKFwidmlld3BvcnRcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikgJiYgXCJtYXBcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCIpID8geCAqPSBiWzNdIC8gYS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIDogXCJtYXBcIiA9PT0gdGhpcy5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikgJiYgXCJ2aWV3cG9ydFwiID09PSB0aGlzLnBhaW50LmdldChcImNpcmNsZS1waXRjaC1hbGlnbm1lbnRcIikgJiYgKHggKj0gYS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIC8gYlszXSksIEdhKGMsIGcsIHgpKSByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSwgZTtcbiAgICB9KEFpKSk7XG4gICAgZnVuY3Rpb24gZm8odCwgZSkge1xuICAgICAgdmFyIHIgPSBjbyhbXSwgW3QueCwgdC55LCAwLCAxXSwgZSk7XG4gICAgICByZXR1cm4gbmV3IGkoclswXSAvIHJbM10sIHJbMV0gLyByWzNdKTtcbiAgICB9XG4gICAgdmFyIHlvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgfShOYSk7XG4gICAgZnVuY3Rpb24gbW8odCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBlLndpZHRoLFxuICAgICAgICBhID0gZS5oZWlnaHQ7XG4gICAgICBpZiAobikge1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSBuID0gbmV3IFVpbnQ4QXJyYXkobi5idWZmZXIpO2Vsc2UgaWYgKG4ubGVuZ3RoICE9PSBpICogYSAqIHIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWlzbWF0Y2hlZCBpbWFnZSBzaXplXCIpO1xuICAgICAgfSBlbHNlIG4gPSBuZXcgVWludDhBcnJheShpICogYSAqIHIpO1xuICAgICAgcmV0dXJuIHQud2lkdGggPSBpLCB0LmhlaWdodCA9IGEsIHQuZGF0YSA9IG4sIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZvKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZS53aWR0aCxcbiAgICAgICAgaSA9IGUuaGVpZ2h0O1xuICAgICAgaWYgKG4gIT09IHQud2lkdGggfHwgaSAhPT0gdC5oZWlnaHQpIHtcbiAgICAgICAgdmFyIGEgPSBtbyh7fSwge1xuICAgICAgICAgIHdpZHRoOiBuLFxuICAgICAgICAgIGhlaWdodDogaVxuICAgICAgICB9LCByKTtcbiAgICAgICAgZ28odCwgYSwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB3aWR0aDogTWF0aC5taW4odC53aWR0aCwgbiksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbih0LmhlaWdodCwgaSlcbiAgICAgICAgfSwgciksIHQud2lkdGggPSBuLCB0LmhlaWdodCA9IGksIHQuZGF0YSA9IGEuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ28odCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgaWYgKDAgPT09IGkud2lkdGggfHwgMCA9PT0gaS5oZWlnaHQpIHJldHVybiBlO1xuICAgICAgaWYgKGkud2lkdGggPiB0LndpZHRoIHx8IGkuaGVpZ2h0ID4gdC5oZWlnaHQgfHwgci54ID4gdC53aWR0aCAtIGkud2lkdGggfHwgci55ID4gdC5oZWlnaHQgLSBpLmhlaWdodCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2Ugc291cmNlIGNvb3JkaW5hdGVzIGZvciBpbWFnZSBjb3B5XCIpO1xuICAgICAgaWYgKGkud2lkdGggPiBlLndpZHRoIHx8IGkuaGVpZ2h0ID4gZS5oZWlnaHQgfHwgbi54ID4gZS53aWR0aCAtIGkud2lkdGggfHwgbi55ID4gZS5oZWlnaHQgLSBpLmhlaWdodCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgZGVzdGluYXRpb24gY29vcmRpbmF0ZXMgZm9yIGltYWdlIGNvcHlcIik7XG4gICAgICBmb3IgKHZhciBvID0gdC5kYXRhLCBzID0gZS5kYXRhLCB1ID0gMDsgdSA8IGkuaGVpZ2h0OyB1KyspIGZvciAodmFyIGwgPSAoKHIueSArIHUpICogdC53aWR0aCArIHIueCkgKiBhLCBwID0gKChuLnkgKyB1KSAqIGUud2lkdGggKyBuLngpICogYSwgYyA9IDA7IGMgPCBpLndpZHRoICogYTsgYysrKSBzW3AgKyBjXSA9IG9bbCArIGNdO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIE9uKFwiSGVhdG1hcEJ1Y2tldFwiLCB5bywge1xuICAgICAgb21pdDogW1wibGF5ZXJzXCJdXG4gICAgfSk7XG4gICAgdmFyIHhvID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIG1vKHRoaXMsIHQsIDEsIGUpO1xuICAgIH07XG4gICAgeG8ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2byh0aGlzLCB0LCAxKTtcbiAgICB9LCB4by5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IHhvKHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH0sIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSkpO1xuICAgIH0sIHhvLmNvcHkgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZ28odCwgZSwgciwgbiwgaSwgMSk7XG4gICAgfTtcbiAgICB2YXIgYm8gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgbW8odGhpcywgdCwgNCwgZSk7XG4gICAgfTtcbiAgICBiby5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvKHRoaXMsIHQsIDQpO1xuICAgIH0sIGJvLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGUgPyB0aGlzLmRhdGEuc2V0KHQpIDogdGhpcy5kYXRhID0gdCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID8gbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpIDogdDtcbiAgICB9LCBiby5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGJvKHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH0sIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSkpO1xuICAgIH0sIGJvLmNvcHkgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgZ28odCwgZSwgciwgbiwgaSwgNCk7XG4gICAgfSwgT24oXCJBbHBoYUltYWdlXCIsIHhvKSwgT24oXCJSR0JBSW1hZ2VcIiwgYm8pO1xuICAgIHZhciB3byA9IHtcbiAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICBcImhlYXRtYXAtcmFkaXVzXCI6IG5ldyBnaShQdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC1yYWRpdXNcIl0pLFxuICAgICAgICBcImhlYXRtYXAtd2VpZ2h0XCI6IG5ldyBnaShQdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC13ZWlnaHRcIl0pLFxuICAgICAgICBcImhlYXRtYXAtaW50ZW5zaXR5XCI6IG5ldyB2aShQdC5wYWludF9oZWF0bWFwW1wiaGVhdG1hcC1pbnRlbnNpdHlcIl0pLFxuICAgICAgICBcImhlYXRtYXAtY29sb3JcIjogbmV3IHdpKFB0LnBhaW50X2hlYXRtYXBbXCJoZWF0bWFwLWNvbG9yXCJdKSxcbiAgICAgICAgXCJoZWF0bWFwLW9wYWNpdHlcIjogbmV3IHZpKFB0LnBhaW50X2hlYXRtYXBbXCJoZWF0bWFwLW9wYWNpdHlcIl0pXG4gICAgICB9KVxuICAgIH07XG4gICAgZnVuY3Rpb24gX28odCkge1xuICAgICAgdmFyIGUgPSB7fSxcbiAgICAgICAgciA9IHQucmVzb2x1dGlvbiB8fCAyNTYsXG4gICAgICAgIG4gPSB0LmNsaXBzID8gdC5jbGlwcy5sZW5ndGggOiAxLFxuICAgICAgICBpID0gdC5pbWFnZSB8fCBuZXcgYm8oe1xuICAgICAgICAgIHdpZHRoOiByLFxuICAgICAgICAgIGhlaWdodDogblxuICAgICAgICB9KSxcbiAgICAgICAgYSA9IGZ1bmN0aW9uIChyLCBuLCBhKSB7XG4gICAgICAgICAgZVt0LmV2YWx1YXRpb25LZXldID0gYTtcbiAgICAgICAgICB2YXIgbyA9IHQuZXhwcmVzc2lvbi5ldmFsdWF0ZShlKTtcbiAgICAgICAgICBpLmRhdGFbciArIG4gKyAwXSA9IE1hdGguZmxvb3IoMjU1ICogby5yIC8gby5hKSwgaS5kYXRhW3IgKyBuICsgMV0gPSBNYXRoLmZsb29yKDI1NSAqIG8uZyAvIG8uYSksIGkuZGF0YVtyICsgbiArIDJdID0gTWF0aC5mbG9vcigyNTUgKiBvLmIgLyBvLmEpLCBpLmRhdGFbciArIG4gKyAzXSA9IE1hdGguZmxvb3IoMjU1ICogby5hKTtcbiAgICAgICAgfTtcbiAgICAgIGlmICh0LmNsaXBzKSBmb3IgKHZhciBvID0gMCwgcyA9IDA7IG8gPCBuOyArK28sIHMgKz0gNCAqIHIpIGZvciAodmFyIHUgPSAwLCBsID0gMDsgdSA8IHI7IHUrKywgbCArPSA0KSB7XG4gICAgICAgIHZhciBwID0gdSAvIChyIC0gMSksXG4gICAgICAgICAgYyA9IHQuY2xpcHNbb107XG4gICAgICAgIGEocywgbCwgYy5zdGFydCAqICgxIC0gcCkgKyBjLmVuZCAqIHApO1xuICAgICAgfSBlbHNlIGZvciAodmFyIGggPSAwLCBmID0gMDsgaCA8IHI7IGgrKywgZiArPSA0KSBhKDAsIGYsIGggLyAociAtIDEpKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB2YXIgQW8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgICB0LmNhbGwodGhpcywgZSwgd28pLCB0aGlzLl91cGRhdGVDb2xvclJhbXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBuZXcgeW8odCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9oYW5kbGVTcGVjaWFsUGFpbnRQcm9wZXJ0eVVwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgXCJoZWF0bWFwLWNvbG9yXCIgPT09IHQgJiYgdGhpcy5fdXBkYXRlQ29sb3JSYW1wKCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLl91cGRhdGVDb2xvclJhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5jb2xvclJhbXAgPSBfbyh7XG4gICAgICAgICAgICBleHByZXNzaW9uOiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50Ll92YWx1ZXNbXCJoZWF0bWFwLWNvbG9yXCJdLnZhbHVlLmV4cHJlc3Npb24sXG4gICAgICAgICAgICBldmFsdWF0aW9uS2V5OiBcImhlYXRtYXBEZW5zaXR5XCIsXG4gICAgICAgICAgICBpbWFnZTogdGhpcy5jb2xvclJhbXBcbiAgICAgICAgICB9KSwgdGhpcy5jb2xvclJhbXBUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuaGVhdG1hcEZibyAmJiAodGhpcy5oZWF0bWFwRmJvLmRlc3Ryb3koKSwgdGhpcy5oZWF0bWFwRmJvID0gbnVsbCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5UmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeUludGVyc2VjdHNGZWF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuaGFzT2Zmc2NyZWVuUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMCAhPT0gdGhpcy5wYWludC5nZXQoXCJoZWF0bWFwLW9wYWNpdHlcIikgJiYgXCJub25lXCIgIT09IHRoaXMudmlzaWJpbGl0eTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oQWkpLFxuICAgICAgU28gPSB7XG4gICAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICAgIFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1kaXJlY3Rpb25cIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCJdKSxcbiAgICAgICAgICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IG5ldyB2aShQdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiXSksXG4gICAgICAgICAgXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCI6IG5ldyB2aShQdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCJdKSxcbiAgICAgICAgICBcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIjogbmV3IHZpKFB0LnBhaW50X2hpbGxzaGFkZVtcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIl0pLFxuICAgICAgICAgIFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiOiBuZXcgdmkoUHQucGFpbnRfaGlsbHNoYWRlW1wiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiXSksXG4gICAgICAgICAgXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IG5ldyB2aShQdC5wYWludF9oaWxsc2hhZGVbXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCJdKVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGtvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIFNvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5oYXNPZmZzY3JlZW5QYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAwICE9PSB0aGlzLnBhaW50LmdldChcImhpbGxzaGFkZS1leGFnZ2VyYXRpb25cIikgJiYgXCJub25lXCIgIT09IHRoaXMudmlzaWJpbGl0eTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oQWkpLFxuICAgICAgSW8gPSB6aShbe1xuICAgICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgICAgfV0sIDQpLm1lbWJlcnMsXG4gICAgICB6byA9IEVvLFxuICAgICAgQ28gPSBFbztcbiAgICBmdW5jdGlvbiBFbyh0LCBlLCByKSB7XG4gICAgICByID0gciB8fCAyO1xuICAgICAgdmFyIG4sXG4gICAgICAgIGksXG4gICAgICAgIGEsXG4gICAgICAgIG8sXG4gICAgICAgIHMsXG4gICAgICAgIHUsXG4gICAgICAgIGwsXG4gICAgICAgIHAgPSBlICYmIGUubGVuZ3RoLFxuICAgICAgICBjID0gcCA/IGVbMF0gKiByIDogdC5sZW5ndGgsXG4gICAgICAgIGggPSBQbyh0LCAwLCBjLCByLCAhMCksXG4gICAgICAgIGYgPSBbXTtcbiAgICAgIGlmICghaCB8fCBoLm5leHQgPT09IGgucHJldikgcmV0dXJuIGY7XG4gICAgICBpZiAocCAmJiAoaCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbyxcbiAgICAgICAgICBzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGEgPSBlLmxlbmd0aDsgaSA8IGE7IGkrKykgKG8gPSBQbyh0LCBlW2ldICogbiwgaSA8IGEgLSAxID8gZVtpICsgMV0gKiBuIDogdC5sZW5ndGgsIG4sICExKSkgPT09IG8ubmV4dCAmJiAoby5zdGVpbmVyID0gITApLCBzLnB1c2goam8obykpO1xuICAgICAgICBmb3IgKHMuc29ydChMbyksIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgUm8oc1tpXSwgciksIHIgPSBNbyhyLCByLm5leHQpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0odCwgZSwgaCwgcikpLCB0Lmxlbmd0aCA+IDgwICogcikge1xuICAgICAgICBuID0gYSA9IHRbMF0sIGkgPSBvID0gdFsxXTtcbiAgICAgICAgZm9yICh2YXIgeSA9IHI7IHkgPCBjOyB5ICs9IHIpIChzID0gdFt5XSkgPCBuICYmIChuID0gcyksICh1ID0gdFt5ICsgMV0pIDwgaSAmJiAoaSA9IHUpLCBzID4gYSAmJiAoYSA9IHMpLCB1ID4gbyAmJiAobyA9IHUpO1xuICAgICAgICBsID0gMCAhPT0gKGwgPSBNYXRoLm1heChhIC0gbiwgbyAtIGkpKSA/IDEgLyBsIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCbyhoLCBmLCByLCBuLCBpLCBsKSwgZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUG8odCwgZSwgciwgbiwgaSkge1xuICAgICAgdmFyIGEsIG87XG4gICAgICBpZiAoaSA9PT0gdHModCwgZSwgciwgbikgPiAwKSBmb3IgKGEgPSBlOyBhIDwgcjsgYSArPSBuKSBvID0gJG8oYSwgdFthXSwgdFthICsgMV0sIG8pO2Vsc2UgZm9yIChhID0gciAtIG47IGEgPj0gZTsgYSAtPSBuKSBvID0gJG8oYSwgdFthXSwgdFthICsgMV0sIG8pO1xuICAgICAgcmV0dXJuIG8gJiYgR28obywgby5uZXh0KSAmJiAoV28obyksIG8gPSBvLm5leHQpLCBvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNbyh0LCBlKSB7XG4gICAgICBpZiAoIXQpIHJldHVybiB0O1xuICAgICAgZSB8fCAoZSA9IHQpO1xuICAgICAgdmFyIHIsXG4gICAgICAgIG4gPSB0O1xuICAgICAgZG8ge1xuICAgICAgICBpZiAociA9ICExLCBuLnN0ZWluZXIgfHwgIUdvKG4sIG4ubmV4dCkgJiYgMCAhPT0gS28obi5wcmV2LCBuLCBuLm5leHQpKSBuID0gbi5uZXh0O2Vsc2Uge1xuICAgICAgICAgIGlmIChXbyhuKSwgKG4gPSBlID0gbi5wcmV2KSA9PT0gbi5uZXh0KSBicmVhaztcbiAgICAgICAgICByID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHIgfHwgbiAhPT0gZSk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQm8odCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgIW8gJiYgYSAmJiBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgICAgIHZhciBpID0gdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBudWxsID09PSBpLnogJiYgKGkueiA9IFVvKGkueCwgaS55LCBlLCByLCBuKSksIGkucHJldlogPSBpLnByZXYsIGkubmV4dFogPSBpLm5leHQsIGkgPSBpLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAoaSAhPT0gdCk7XG4gICAgICAgICAgaS5wcmV2Wi5uZXh0WiA9IG51bGwsIGkucHJldlogPSBudWxsLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgIHUsXG4gICAgICAgICAgICAgIGwgPSAxO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBmb3IgKHIgPSB0LCB0ID0gbnVsbCwgYSA9IG51bGwsIG8gPSAwOyByOykge1xuICAgICAgICAgICAgICAgIGZvciAobysrLCBuID0gciwgcyA9IDAsIGUgPSAwOyBlIDwgbCAmJiAocysrLCBuID0gbi5uZXh0Wik7IGUrKyk7XG4gICAgICAgICAgICAgICAgZm9yICh1ID0gbDsgcyA+IDAgfHwgdSA+IDAgJiYgbjspIDAgIT09IHMgJiYgKDAgPT09IHUgfHwgIW4gfHwgci56IDw9IG4ueikgPyAoaSA9IHIsIHIgPSByLm5leHRaLCBzLS0pIDogKGkgPSBuLCBuID0gbi5uZXh0WiwgdS0tKSwgYSA/IGEubmV4dFogPSBpIDogdCA9IGksIGkucHJldlogPSBhLCBhID0gaTtcbiAgICAgICAgICAgICAgICByID0gbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhLm5leHRaID0gbnVsbCwgbCAqPSAyO1xuICAgICAgICAgICAgfSB3aGlsZSAobyA+IDEpO1xuICAgICAgICAgIH0oaSk7XG4gICAgICAgIH0odCwgbiwgaSwgYSk7XG4gICAgICAgIGZvciAodmFyIHMsIHUsIGwgPSB0OyB0LnByZXYgIT09IHQubmV4dDspIGlmIChzID0gdC5wcmV2LCB1ID0gdC5uZXh0LCBhID8gVm8odCwgbiwgaSwgYSkgOiBUbyh0KSkgZS5wdXNoKHMuaSAvIHIpLCBlLnB1c2godC5pIC8gciksIGUucHVzaCh1LmkgLyByKSwgV28odCksIHQgPSB1Lm5leHQsIGwgPSB1Lm5leHQ7ZWxzZSBpZiAoKHQgPSB1KSA9PT0gbCkge1xuICAgICAgICAgIG8gPyAxID09PSBvID8gQm8odCA9IEZvKE1vKHQpLCBlLCByKSwgZSwgciwgbiwgaSwgYSwgMikgOiAyID09PSBvICYmIERvKHQsIGUsIHIsIG4sIGksIGEpIDogQm8oTW8odCksIGUsIHIsIG4sIGksIGEsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRvKHQpIHtcbiAgICAgIHZhciBlID0gdC5wcmV2LFxuICAgICAgICByID0gdCxcbiAgICAgICAgbiA9IHQubmV4dDtcbiAgICAgIGlmIChLbyhlLCByLCBuKSA+PSAwKSByZXR1cm4gITE7XG4gICAgICBmb3IgKHZhciBpID0gdC5uZXh0Lm5leHQ7IGkgIT09IHQucHJldjspIHtcbiAgICAgICAgaWYgKHFvKGUueCwgZS55LCByLngsIHIueSwgbi54LCBuLnksIGkueCwgaS55KSAmJiBLbyhpLnByZXYsIGksIGkubmV4dCkgPj0gMCkgcmV0dXJuICExO1xuICAgICAgICBpID0gaS5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWbyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHQucHJldixcbiAgICAgICAgYSA9IHQsXG4gICAgICAgIG8gPSB0Lm5leHQ7XG4gICAgICBpZiAoS28oaSwgYSwgbykgPj0gMCkgcmV0dXJuICExO1xuICAgICAgZm9yICh2YXIgcyA9IGkueCA+IGEueCA/IGkueCA+IG8ueCA/IGkueCA6IG8ueCA6IGEueCA+IG8ueCA/IGEueCA6IG8ueCwgdSA9IGkueSA+IGEueSA/IGkueSA+IG8ueSA/IGkueSA6IG8ueSA6IGEueSA+IG8ueSA/IGEueSA6IG8ueSwgbCA9IFVvKGkueCA8IGEueCA/IGkueCA8IG8ueCA/IGkueCA6IG8ueCA6IGEueCA8IG8ueCA/IGEueCA6IG8ueCwgaS55IDwgYS55ID8gaS55IDwgby55ID8gaS55IDogby55IDogYS55IDwgby55ID8gYS55IDogby55LCBlLCByLCBuKSwgcCA9IFVvKHMsIHUsIGUsIHIsIG4pLCBjID0gdC5wcmV2WiwgaCA9IHQubmV4dFo7IGMgJiYgYy56ID49IGwgJiYgaCAmJiBoLnogPD0gcDspIHtcbiAgICAgICAgaWYgKGMgIT09IHQucHJldiAmJiBjICE9PSB0Lm5leHQgJiYgcW8oaS54LCBpLnksIGEueCwgYS55LCBvLngsIG8ueSwgYy54LCBjLnkpICYmIEtvKGMucHJldiwgYywgYy5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGlmIChjID0gYy5wcmV2WiwgaCAhPT0gdC5wcmV2ICYmIGggIT09IHQubmV4dCAmJiBxbyhpLngsIGkueSwgYS54LCBhLnksIG8ueCwgby55LCBoLngsIGgueSkgJiYgS28oaC5wcmV2LCBoLCBoLm5leHQpID49IDApIHJldHVybiAhMTtcbiAgICAgICAgaCA9IGgubmV4dFo7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYyAmJiBjLnogPj0gbDspIHtcbiAgICAgICAgaWYgKGMgIT09IHQucHJldiAmJiBjICE9PSB0Lm5leHQgJiYgcW8oaS54LCBpLnksIGEueCwgYS55LCBvLngsIG8ueSwgYy54LCBjLnkpICYmIEtvKGMucHJldiwgYywgYy5uZXh0KSA+PSAwKSByZXR1cm4gITE7XG4gICAgICAgIGMgPSBjLnByZXZaO1xuICAgICAgfVxuICAgICAgZm9yICg7IGggJiYgaC56IDw9IHA7KSB7XG4gICAgICAgIGlmIChoICE9PSB0LnByZXYgJiYgaCAhPT0gdC5uZXh0ICYmIHFvKGkueCwgaS55LCBhLngsIGEueSwgby54LCBvLnksIGgueCwgaC55KSAmJiBLbyhoLnByZXYsIGgsIGgubmV4dCkgPj0gMCkgcmV0dXJuICExO1xuICAgICAgICBoID0gaC5uZXh0WjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRm8odCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0O1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgaSA9IG4ucHJldixcbiAgICAgICAgICBhID0gbi5uZXh0Lm5leHQ7XG4gICAgICAgICFHbyhpLCBhKSAmJiBabyhpLCBuLCBuLm5leHQsIGEpICYmIEhvKGksIGEpICYmIEhvKGEsIGkpICYmIChlLnB1c2goaS5pIC8gciksIGUucHVzaChuLmkgLyByKSwgZS5wdXNoKGEuaSAvIHIpLCBXbyhuKSwgV28obi5uZXh0KSwgbiA9IHQgPSBhKSwgbiA9IG4ubmV4dDtcbiAgICAgIH0gd2hpbGUgKG4gIT09IHQpO1xuICAgICAgcmV0dXJuIE1vKG4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBEbyh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB2YXIgbyA9IHQ7XG4gICAgICBkbyB7XG4gICAgICAgIGZvciAodmFyIHMgPSBvLm5leHQubmV4dDsgcyAhPT0gby5wcmV2Oykge1xuICAgICAgICAgIGlmIChvLmkgIT09IHMuaSAmJiBObyhvLCBzKSkge1xuICAgICAgICAgICAgdmFyIHUgPSBZbyhvLCBzKTtcbiAgICAgICAgICAgIHJldHVybiBvID0gTW8obywgby5uZXh0KSwgdSA9IE1vKHUsIHUubmV4dCksIEJvKG8sIGUsIHIsIG4sIGksIGEpLCB2b2lkIEJvKHUsIGUsIHIsIG4sIGksIGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIG8gPSBvLm5leHQ7XG4gICAgICB9IHdoaWxlIChvICE9PSB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTG8odCwgZSkge1xuICAgICAgcmV0dXJuIHQueCAtIGUueDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUm8odCwgZSkge1xuICAgICAgaWYgKGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgcixcbiAgICAgICAgICBuID0gZSxcbiAgICAgICAgICBpID0gdC54LFxuICAgICAgICAgIGEgPSB0LnksXG4gICAgICAgICAgbyA9IC0xIC8gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChhIDw9IG4ueSAmJiBhID49IG4ubmV4dC55ICYmIG4ubmV4dC55ICE9PSBuLnkpIHtcbiAgICAgICAgICAgIHZhciBzID0gbi54ICsgKGEgLSBuLnkpICogKG4ubmV4dC54IC0gbi54KSAvIChuLm5leHQueSAtIG4ueSk7XG4gICAgICAgICAgICBpZiAocyA8PSBpICYmIHMgPiBvKSB7XG4gICAgICAgICAgICAgIGlmIChvID0gcywgcyA9PT0gaSkge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBuLnkpIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBuLm5leHQueSkgcmV0dXJuIG4ubmV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByID0gbi54IDwgbi5uZXh0LnggPyBuIDogbi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gbi5uZXh0O1xuICAgICAgICB9IHdoaWxlIChuICE9PSBlKTtcbiAgICAgICAgaWYgKCFyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGkgPT09IG8pIHJldHVybiByO1xuICAgICAgICB2YXIgdSxcbiAgICAgICAgICBsID0gcixcbiAgICAgICAgICBwID0gci54LFxuICAgICAgICAgIGMgPSByLnksXG4gICAgICAgICAgaCA9IDEgLyAwO1xuICAgICAgICBuID0gcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGkgPj0gbi54ICYmIG4ueCA+PSBwICYmIGkgIT09IG4ueCAmJiBxbyhhIDwgYyA/IGkgOiBvLCBhLCBwLCBjLCBhIDwgYyA/IG8gOiBpLCBhLCBuLngsIG4ueSkgJiYgKHUgPSBNYXRoLmFicyhhIC0gbi55KSAvIChpIC0gbi54KSwgSG8obiwgdCkgJiYgKHUgPCBoIHx8IHUgPT09IGggJiYgKG4ueCA+IHIueCB8fCBuLnggPT09IHIueCAmJiBPbyhyLCBuKSkpICYmIChyID0gbiwgaCA9IHUpKSwgbiA9IG4ubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobiAhPT0gbCk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSh0LCBlKSkge1xuICAgICAgICB2YXIgciA9IFlvKGUsIHQpO1xuICAgICAgICBNbyhlLCBlLm5leHQpLCBNbyhyLCByLm5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBPbyh0LCBlKSB7XG4gICAgICByZXR1cm4gS28odC5wcmV2LCB0LCBlLnByZXYpIDwgMCAmJiBLbyhlLm5leHQsIHQsIHQubmV4dCkgPCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbyh0LCBlLCByLCBuLCBpKSB7XG4gICAgICByZXR1cm4gKHQgPSAxNDMxNjU1NzY1ICYgKCh0ID0gODU4OTkzNDU5ICYgKCh0ID0gMjUyNjQ1MTM1ICYgKCh0ID0gMTY3MTE5MzUgJiAoKHQgPSAzMjc2NyAqICh0IC0gcikgKiBpKSB8IHQgPDwgOCkpIHwgdCA8PCA0KSkgfCB0IDw8IDIpKSB8IHQgPDwgMSkpIHwgKGUgPSAxNDMxNjU1NzY1ICYgKChlID0gODU4OTkzNDU5ICYgKChlID0gMjUyNjQ1MTM1ICYgKChlID0gMTY3MTE5MzUgJiAoKGUgPSAzMjc2NyAqIChlIC0gbikgKiBpKSB8IGUgPDwgOCkpIHwgZSA8PCA0KSkgfCBlIDw8IDIpKSB8IGUgPDwgMSkpIDw8IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpvKHQpIHtcbiAgICAgIHZhciBlID0gdCxcbiAgICAgICAgciA9IHQ7XG4gICAgICBkbyB7XG4gICAgICAgIChlLnggPCByLnggfHwgZS54ID09PSByLnggJiYgZS55IDwgci55KSAmJiAociA9IGUpLCBlID0gZS5uZXh0O1xuICAgICAgfSB3aGlsZSAoZSAhPT0gdCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcW8odCwgZSwgciwgbiwgaSwgYSwgbywgcykge1xuICAgICAgcmV0dXJuIChpIC0gbykgKiAoZSAtIHMpIC0gKHQgLSBvKSAqIChhIC0gcykgPj0gMCAmJiAodCAtIG8pICogKG4gLSBzKSAtIChyIC0gbykgKiAoZSAtIHMpID49IDAgJiYgKHIgLSBvKSAqIChhIC0gcykgLSAoaSAtIG8pICogKG4gLSBzKSA+PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBObyh0LCBlKSB7XG4gICAgICByZXR1cm4gdC5uZXh0LmkgIT09IGUuaSAmJiB0LnByZXYuaSAhPT0gZS5pICYmICFmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoci5pICE9PSB0LmkgJiYgci5uZXh0LmkgIT09IHQuaSAmJiByLmkgIT09IGUuaSAmJiByLm5leHQuaSAhPT0gZS5pICYmIFpvKHIsIHIubmV4dCwgdCwgZSkpIHJldHVybiAhMDtcbiAgICAgICAgICByID0gci5uZXh0O1xuICAgICAgICB9IHdoaWxlIChyICE9PSB0KTtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSh0LCBlKSAmJiAoSG8odCwgZSkgJiYgSG8oZSwgdCkgJiYgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIHIgPSB0LFxuICAgICAgICAgIG4gPSAhMSxcbiAgICAgICAgICBpID0gKHQueCArIGUueCkgLyAyLFxuICAgICAgICAgIGEgPSAodC55ICsgZS55KSAvIDI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICByLnkgPiBhICE9IHIubmV4dC55ID4gYSAmJiByLm5leHQueSAhPT0gci55ICYmIGkgPCAoci5uZXh0LnggLSByLngpICogKGEgLSByLnkpIC8gKHIubmV4dC55IC0gci55KSArIHIueCAmJiAobiA9ICFuKSwgciA9IHIubmV4dDtcbiAgICAgICAgfSB3aGlsZSAociAhPT0gdCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSh0LCBlKSAmJiAoS28odC5wcmV2LCB0LCBlLnByZXYpIHx8IEtvKHQsIGUucHJldiwgZSkpIHx8IEdvKHQsIGUpICYmIEtvKHQucHJldiwgdCwgdC5uZXh0KSA+IDAgJiYgS28oZS5wcmV2LCBlLCBlLm5leHQpID4gMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEtvKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiAoZS55IC0gdC55KSAqIChyLnggLSBlLngpIC0gKGUueCAtIHQueCkgKiAoci55IC0gZS55KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR28odCwgZSkge1xuICAgICAgcmV0dXJuIHQueCA9PT0gZS54ICYmIHQueSA9PT0gZS55O1xuICAgIH1cbiAgICBmdW5jdGlvbiBabyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IEpvKEtvKHQsIGUsIHIpKSxcbiAgICAgICAgYSA9IEpvKEtvKHQsIGUsIG4pKSxcbiAgICAgICAgbyA9IEpvKEtvKHIsIG4sIHQpKSxcbiAgICAgICAgcyA9IEpvKEtvKHIsIG4sIGUpKTtcbiAgICAgIHJldHVybiBpICE9PSBhICYmIG8gIT09IHMgfHwgISgwICE9PSBpIHx8ICFYbyh0LCByLCBlKSkgfHwgISgwICE9PSBhIHx8ICFYbyh0LCBuLCBlKSkgfHwgISgwICE9PSBvIHx8ICFYbyhyLCB0LCBuKSkgfHwgISgwICE9PSBzIHx8ICFYbyhyLCBlLCBuKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFhvKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiBlLnggPD0gTWF0aC5tYXgodC54LCByLngpICYmIGUueCA+PSBNYXRoLm1pbih0LngsIHIueCkgJiYgZS55IDw9IE1hdGgubWF4KHQueSwgci55KSAmJiBlLnkgPj0gTWF0aC5taW4odC55LCByLnkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBKbyh0KSB7XG4gICAgICByZXR1cm4gdCA+IDAgPyAxIDogdCA8IDAgPyAtMSA6IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhvKHQsIGUpIHtcbiAgICAgIHJldHVybiBLbyh0LnByZXYsIHQsIHQubmV4dCkgPCAwID8gS28odCwgZSwgdC5uZXh0KSA+PSAwICYmIEtvKHQsIHQucHJldiwgZSkgPj0gMCA6IEtvKHQsIGUsIHQucHJldikgPCAwIHx8IEtvKHQsIHQubmV4dCwgZSkgPCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBZbyh0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBRbyh0LmksIHQueCwgdC55KSxcbiAgICAgICAgbiA9IG5ldyBRbyhlLmksIGUueCwgZS55KSxcbiAgICAgICAgaSA9IHQubmV4dCxcbiAgICAgICAgYSA9IGUucHJldjtcbiAgICAgIHJldHVybiB0Lm5leHQgPSBlLCBlLnByZXYgPSB0LCByLm5leHQgPSBpLCBpLnByZXYgPSByLCBuLm5leHQgPSByLCByLnByZXYgPSBuLCBhLm5leHQgPSBuLCBuLnByZXYgPSBhLCBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkbyh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IG5ldyBRbyh0LCBlLCByKTtcbiAgICAgIHJldHVybiBuID8gKGkubmV4dCA9IG4ubmV4dCwgaS5wcmV2ID0gbiwgbi5uZXh0LnByZXYgPSBpLCBuLm5leHQgPSBpKSA6IChpLnByZXYgPSBpLCBpLm5leHQgPSBpKSwgaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV28odCkge1xuICAgICAgdC5uZXh0LnByZXYgPSB0LnByZXYsIHQucHJldi5uZXh0ID0gdC5uZXh0LCB0LnByZXZaICYmICh0LnByZXZaLm5leHRaID0gdC5uZXh0WiksIHQubmV4dFogJiYgKHQubmV4dFoucHJldlogPSB0LnByZXZaKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUW8odCwgZSwgcikge1xuICAgICAgdGhpcy5pID0gdCwgdGhpcy54ID0gZSwgdGhpcy55ID0gciwgdGhpcy5wcmV2ID0gbnVsbCwgdGhpcy5uZXh0ID0gbnVsbCwgdGhpcy56ID0gbnVsbCwgdGhpcy5wcmV2WiA9IG51bGwsIHRoaXMubmV4dFogPSBudWxsLCB0aGlzLnN0ZWluZXIgPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHModCwgZSwgciwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGEgPSBlLCBvID0gciAtIG47IGEgPCByOyBhICs9IG4pIGkgKz0gKHRbb10gLSB0W2FdKSAqICh0W2EgKyAxXSArIHRbbyArIDFdKSwgbyA9IGE7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXModCwgZSwgciwgbiwgaSkge1xuICAgICAgIWZ1bmN0aW9uIHQoZSwgciwgbiwgaSwgYSkge1xuICAgICAgICBmb3IgKDsgaSA+IG47KSB7XG4gICAgICAgICAgaWYgKGkgLSBuID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGkgLSBuICsgMSxcbiAgICAgICAgICAgICAgcyA9IHIgLSBuICsgMSxcbiAgICAgICAgICAgICAgdSA9IE1hdGgubG9nKG8pLFxuICAgICAgICAgICAgICBsID0gLjUgKiBNYXRoLmV4cCgyICogdSAvIDMpLFxuICAgICAgICAgICAgICBwID0gLjUgKiBNYXRoLnNxcnQodSAqIGwgKiAobyAtIGwpIC8gbykgKiAocyAtIG8gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB0KGUsIHIsIE1hdGgubWF4KG4sIE1hdGguZmxvb3IociAtIHMgKiBsIC8gbyArIHApKSwgTWF0aC5taW4oaSwgTWF0aC5mbG9vcihyICsgKG8gLSBzKSAqIGwgLyBvICsgcCkpLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGMgPSBlW3JdLFxuICAgICAgICAgICAgaCA9IG4sXG4gICAgICAgICAgICBmID0gaTtcbiAgICAgICAgICBmb3IgKHJzKGUsIG4sIHIpLCBhKGVbaV0sIGMpID4gMCAmJiBycyhlLCBuLCBpKTsgaCA8IGY7KSB7XG4gICAgICAgICAgICBmb3IgKHJzKGUsIGgsIGYpLCBoKyssIGYtLTsgYShlW2hdLCBjKSA8IDA7KSBoKys7XG4gICAgICAgICAgICBmb3IgKDsgYShlW2ZdLCBjKSA+IDA7KSBmLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIDAgPT09IGEoZVtuXSwgYykgPyBycyhlLCBuLCBmKSA6IHJzKGUsICsrZiwgaSksIGYgPD0gciAmJiAobiA9IGYgKyAxKSwgciA8PSBmICYmIChpID0gZiAtIDEpO1xuICAgICAgICB9XG4gICAgICB9KHQsIGUsIHIgfHwgMCwgbiB8fCB0Lmxlbmd0aCAtIDEsIGkgfHwgbnMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBycyh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRbZV07XG4gICAgICB0W2VdID0gdFtyXSwgdFtyXSA9IG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5zKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IDwgZSA/IC0xIDogdCA+IGUgPyAxIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXModCwgZSkge1xuICAgICAgdmFyIHIgPSB0Lmxlbmd0aDtcbiAgICAgIGlmIChyIDw9IDEpIHJldHVybiBbdF07XG4gICAgICBmb3IgKHZhciBuLCBpLCBhID0gW10sIG8gPSAwOyBvIDwgcjsgbysrKSB7XG4gICAgICAgIHZhciBzID0gayh0W29dKTtcbiAgICAgICAgMCAhPT0gcyAmJiAodFtvXS5hcmVhID0gTWF0aC5hYnMocyksIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHMgPCAwKSwgaSA9PT0gcyA8IDAgPyAobiAmJiBhLnB1c2gobiksIG4gPSBbdFtvXV0pIDogbi5wdXNoKHRbb10pKTtcbiAgICAgIH1cbiAgICAgIGlmIChuICYmIGEucHVzaChuKSwgZSA+IDEpIGZvciAodmFyIHUgPSAwOyB1IDwgYS5sZW5ndGg7IHUrKykgYVt1XS5sZW5ndGggPD0gZSB8fCAoZXMoYVt1XSwgZSwgMSwgYVt1XS5sZW5ndGggLSAxLCBhcyksIGFbdV0gPSBhW3VdLnNsaWNlKDAsIGUpKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcyh0LCBlKSB7XG4gICAgICByZXR1cm4gZS5hcmVhIC0gdC5hcmVhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcyh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gci5wYXR0ZXJuRGVwZW5kZW5jaWVzLCBpID0gITEsIGEgPSAwLCBvID0gZTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgdmFyIHMgPSBvW2FdLnBhaW50LmdldCh0ICsgXCItcGF0dGVyblwiKTtcbiAgICAgICAgcy5pc0NvbnN0YW50KCkgfHwgKGkgPSAhMCk7XG4gICAgICAgIHZhciB1ID0gcy5jb25zdGFudE9yKG51bGwpO1xuICAgICAgICB1ICYmIChpID0gITAsIG5bdS50b10gPSAhMCwgblt1LmZyb21dID0gITApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNzKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSBpLnBhdHRlcm5EZXBlbmRlbmNpZXMsIG8gPSAwLCBzID0gZTsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgIGwgPSB1LnBhaW50LmdldCh0ICsgXCItcGF0dGVyblwiKS52YWx1ZTtcbiAgICAgICAgaWYgKFwiY29uc3RhbnRcIiAhPT0gbC5raW5kKSB7XG4gICAgICAgICAgdmFyIHAgPSBsLmV2YWx1YXRlKHtcbiAgICAgICAgICAgICAgem9vbTogbiAtIDFcbiAgICAgICAgICAgIH0sIHIsIHt9LCBpLmF2YWlsYWJsZUltYWdlcyksXG4gICAgICAgICAgICBjID0gbC5ldmFsdWF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG5cbiAgICAgICAgICAgIH0sIHIsIHt9LCBpLmF2YWlsYWJsZUltYWdlcyksXG4gICAgICAgICAgICBoID0gbC5ldmFsdWF0ZSh7XG4gICAgICAgICAgICAgIHpvb206IG4gKyAxXG4gICAgICAgICAgICB9LCByLCB7fSwgaS5hdmFpbGFibGVJbWFnZXMpO1xuICAgICAgICAgIGMgPSBjICYmIGMubmFtZSA/IGMubmFtZSA6IGMsIGggPSBoICYmIGgubmFtZSA/IGgubmFtZSA6IGgsIGFbcCA9IHAgJiYgcC5uYW1lID8gcC5uYW1lIDogcF0gPSAhMCwgYVtjXSA9ICEwLCBhW2hdID0gITAsIHIucGF0dGVybnNbdS5pZF0gPSB7XG4gICAgICAgICAgICBtaW46IHAsXG4gICAgICAgICAgICBtaWQ6IGMsXG4gICAgICAgICAgICBtYXg6IGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgRW8uZGV2aWF0aW9uID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIHZhciBpID0gZSAmJiBlLmxlbmd0aCxcbiAgICAgICAgYSA9IE1hdGguYWJzKHRzKHQsIDAsIGkgPyBlWzBdICogciA6IHQubGVuZ3RoLCByKSk7XG4gICAgICBpZiAoaSkgZm9yICh2YXIgbyA9IDAsIHMgPSBlLmxlbmd0aDsgbyA8IHM7IG8rKykgYSAtPSBNYXRoLmFicyh0cyh0LCBlW29dICogciwgbyA8IHMgLSAxID8gZVtvICsgMV0gKiByIDogdC5sZW5ndGgsIHIpKTtcbiAgICAgIHZhciB1ID0gMDtcbiAgICAgIGZvciAobyA9IDA7IG8gPCBuLmxlbmd0aDsgbyArPSAzKSB7XG4gICAgICAgIHZhciBsID0gbltvXSAqIHIsXG4gICAgICAgICAgcCA9IG5bbyArIDFdICogcixcbiAgICAgICAgICBjID0gbltvICsgMl0gKiByO1xuICAgICAgICB1ICs9IE1hdGguYWJzKCh0W2xdIC0gdFtjXSkgKiAodFtwICsgMV0gLSB0W2wgKyAxXSkgLSAodFtsXSAtIHRbcF0pICogKHRbYyArIDFdIC0gdFtsICsgMV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwID09PSBhICYmIDAgPT09IHUgPyAwIDogTWF0aC5hYnMoKHUgLSBhKSAvIGEpO1xuICAgIH0sIEVvLmZsYXR0ZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRbMF1bMF0ubGVuZ3RoLCByID0ge1xuICAgICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgICBob2xlczogW10sXG4gICAgICAgICAgZGltZW5zaW9uczogZVxuICAgICAgICB9LCBuID0gMCwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdFtpXS5sZW5ndGg7IGErKykgZm9yICh2YXIgbyA9IDA7IG8gPCBlOyBvKyspIHIudmVydGljZXMucHVzaCh0W2ldW2FdW29dKTtcbiAgICAgICAgaSA+IDAgJiYgci5ob2xlcy5wdXNoKG4gKz0gdFtpIC0gMV0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHpvLmRlZmF1bHQgPSBDbztcbiAgICB2YXIgdXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy56b29tID0gdC56b29tLCB0aGlzLm92ZXJzY2FsaW5nID0gdC5vdmVyc2NhbGluZywgdGhpcy5sYXllcnMgPSB0LmxheWVycywgdGhpcy5sYXllcklkcyA9IHRoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pLCB0aGlzLmluZGV4ID0gdC5pbmRleCwgdGhpcy5oYXNQYXR0ZXJuID0gITEsIHRoaXMucGF0dGVybkZlYXR1cmVzID0gW10sIHRoaXMubGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgRWkoKSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IHFpKCksIHRoaXMuaW5kZXhBcnJheTIgPSBuZXcgSmkoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgRmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5zZWdtZW50czIgPSBuZXcgdWEoKSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzU3RhdGVEZXBlbmRlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdXMucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMuaGFzUGF0dGVybiA9IG9zKFwiZmlsbFwiLCB0aGlzLmxheWVycywgZSk7XG4gICAgICBmb3IgKHZhciBuID0gdGhpcy5sYXllcnNbMF0ubGF5b3V0LmdldChcImZpbGwtc29ydC1rZXlcIiksIGkgPSAhbi5pc0NvbnN0YW50KCksIGEgPSBbXSwgbyA9IDAsIHMgPSB0OyBvIDwgcy5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICB2YXIgdSA9IHNbb10sXG4gICAgICAgICAgbCA9IHUuZmVhdHVyZSxcbiAgICAgICAgICBwID0gdS5pZCxcbiAgICAgICAgICBjID0gdS5pbmRleCxcbiAgICAgICAgICBoID0gdS5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgIGYgPSB0aGlzLmxheWVyc1swXS5fZmVhdHVyZUZpbHRlci5uZWVkR2VvbWV0cnksXG4gICAgICAgICAgeSA9IGphKGwsIGYpO1xuICAgICAgICBpZiAodGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIuZmlsdGVyKG5ldyB1aSh0aGlzLnpvb20pLCB5LCByKSkge1xuICAgICAgICAgIHZhciBkID0gaSA/IG4uZXZhbHVhdGUoeSwge30sIHIsIGUuYXZhaWxhYmxlSW1hZ2VzKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICAgIGlkOiBwLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBsLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIHR5cGU6IGwudHlwZSxcbiAgICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogaCxcbiAgICAgICAgICAgICAgaW5kZXg6IGMsXG4gICAgICAgICAgICAgIGdlb21ldHJ5OiBmID8geS5nZW9tZXRyeSA6IFVhKGwpLFxuICAgICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgICAgICAgIHNvcnRLZXk6IGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgYS5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpICYmIGEuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5zb3J0S2V5IC0gZS5zb3J0S2V5O1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciB2ID0gMCwgZyA9IGE7IHYgPCBnLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgIHZhciB4ID0gZ1t2XSxcbiAgICAgICAgICBiID0geC5nZW9tZXRyeSxcbiAgICAgICAgICB3ID0geC5pbmRleCxcbiAgICAgICAgICBfID0geC5zb3VyY2VMYXllckluZGV4O1xuICAgICAgICBpZiAodGhpcy5oYXNQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIEEgPSBzcyhcImZpbGxcIiwgdGhpcy5sYXllcnMsIHgsIHRoaXMuem9vbSwgZSk7XG4gICAgICAgICAgdGhpcy5wYXR0ZXJuRmVhdHVyZXMucHVzaChBKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuYWRkRmVhdHVyZSh4LCBiLCB3LCByLCB7fSk7XG4gICAgICAgIGUuZmVhdHVyZUluZGV4Lmluc2VydCh0W3ddLmZlYXR1cmUsIGIsIHcsIF8sIHRoaXMuaW5kZXgpO1xuICAgICAgfVxuICAgIH0sIHVzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycywgcik7XG4gICAgfSwgdXMucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gdGhpcy5wYXR0ZXJuRmVhdHVyZXM7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGEsIGEuZ2VvbWV0cnksIGEuaW5kZXgsIGUsIHIpO1xuICAgICAgfVxuICAgIH0sIHVzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgIH0sIHVzLnByb3RvdHlwZS51cGxvYWRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnVwbG9hZGVkIHx8IHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkO1xuICAgIH0sIHVzLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy51cGxvYWRlZCB8fCAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmxheW91dFZlcnRleEFycmF5LCBJbyksIHRoaXMuaW5kZXhCdWZmZXIgPSB0LmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhBcnJheSksIHRoaXMuaW5kZXhCdWZmZXIyID0gdC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmluZGV4QXJyYXkyKSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSwgdGhpcy51cGxvYWRlZCA9ICEwO1xuICAgIH0sIHVzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIyLmRlc3Ryb3koKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZGVzdHJveSgpLCB0aGlzLnNlZ21lbnRzLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50czIuZGVzdHJveSgpKTtcbiAgICB9LCB1cy5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7XG4gICAgICBmb3IgKHZhciBhID0gMCwgbyA9IGlzKGUsIDUwMCk7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSBvW2FdLCB1ID0gMCwgbCA9IDAsIHAgPSBzOyBsIDwgcC5sZW5ndGg7IGwgKz0gMSkgdSArPSBwW2xdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQodSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgdGhpcy5pbmRleEFycmF5KSwgaCA9IGMudmVydGV4TGVuZ3RoLCBmID0gW10sIHkgPSBbXSwgZCA9IDAsIG0gPSBzOyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgIHZhciB2ID0gbVtkXTtcbiAgICAgICAgICBpZiAoMCAhPT0gdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHYgIT09IHNbMF0gJiYgeS5wdXNoKGYubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuc2VnbWVudHMyLnByZXBhcmVTZWdtZW50KHYubGVuZ3RoLCB0aGlzLmxheW91dFZlcnRleEFycmF5LCB0aGlzLmluZGV4QXJyYXkyKSxcbiAgICAgICAgICAgICAgeCA9IGcudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayh2WzBdLngsIHZbMF0ueSksIHRoaXMuaW5kZXhBcnJheTIuZW1wbGFjZUJhY2soeCArIHYubGVuZ3RoIC0gMSwgeCksIGYucHVzaCh2WzBdLngpLCBmLnB1c2godlswXS55KTtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAxOyBiIDwgdi5sZW5ndGg7IGIrKykgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayh2W2JdLngsIHZbYl0ueSksIHRoaXMuaW5kZXhBcnJheTIuZW1wbGFjZUJhY2soeCArIGIgLSAxLCB4ICsgYiksIGYucHVzaCh2W2JdLngpLCBmLnB1c2godltiXS55KTtcbiAgICAgICAgICAgIGcudmVydGV4TGVuZ3RoICs9IHYubGVuZ3RoLCBnLnByaW1pdGl2ZUxlbmd0aCArPSB2Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgdyA9IHpvKGYsIHkpLCBfID0gMDsgXyA8IHcubGVuZ3RoOyBfICs9IDMpIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhoICsgd1tfXSwgaCArIHdbXyArIDFdLCBoICsgd1tfICsgMl0pO1xuICAgICAgICBjLnZlcnRleExlbmd0aCArPSB1LCBjLnByaW1pdGl2ZUxlbmd0aCArPSB3Lmxlbmd0aCAvIDM7XG4gICAgICB9XG4gICAgICB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5wb3B1bGF0ZVBhaW50QXJyYXlzKHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoLCB0LCByLCBpLCBuKTtcbiAgICB9LCBPbihcIkZpbGxCdWNrZXRcIiwgdXMsIHtcbiAgICAgIG9taXQ6IFtcImxheWVyc1wiLCBcInBhdHRlcm5GZWF0dXJlc1wiXVxuICAgIH0pO1xuICAgIHZhciBscyA9IG5ldyBfaSh7XG4gICAgICAgIFwiZmlsbC1zb3J0LWtleVwiOiBuZXcgZ2koUHQubGF5b3V0X2ZpbGxbXCJmaWxsLXNvcnQta2V5XCJdKVxuICAgICAgfSksXG4gICAgICBwcyA9IHtcbiAgICAgICAgcGFpbnQ6IG5ldyBfaSh7XG4gICAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiBuZXcgdmkoUHQucGFpbnRfZmlsbFtcImZpbGwtYW50aWFsaWFzXCJdKSxcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBuZXcgZ2koUHQucGFpbnRfZmlsbFtcImZpbGwtb3BhY2l0eVwiXSksXG4gICAgICAgICAgXCJmaWxsLWNvbG9yXCI6IG5ldyBnaShQdC5wYWludF9maWxsW1wiZmlsbC1jb2xvclwiXSksXG4gICAgICAgICAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X2ZpbGxbXCJmaWxsLW91dGxpbmUtY29sb3JcIl0pLFxuICAgICAgICAgIFwiZmlsbC10cmFuc2xhdGVcIjogbmV3IHZpKFB0LnBhaW50X2ZpbGxbXCJmaWxsLXRyYW5zbGF0ZVwiXSksXG4gICAgICAgICAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IHZpKFB0LnBhaW50X2ZpbGxbXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIl0pLFxuICAgICAgICAgIFwiZmlsbC1wYXR0ZXJuXCI6IG5ldyB4aShQdC5wYWludF9maWxsW1wiZmlsbC1wYXR0ZXJuXCJdKVxuICAgICAgICB9KSxcbiAgICAgICAgbGF5b3V0OiBsc1xuICAgICAgfSxcbiAgICAgIGNzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZShlKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHBzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgICAgdC5wcm90b3R5cGUucmVjYWxjdWxhdGUuY2FsbCh0aGlzLCBlLCByKTtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMucGFpbnQuX3ZhbHVlc1tcImZpbGwtb3V0bGluZS1jb2xvclwiXTtcbiAgICAgICAgICBcImNvbnN0YW50XCIgPT09IG4udmFsdWUua2luZCAmJiB2b2lkIDAgPT09IG4udmFsdWUudmFsdWUgJiYgKHRoaXMucGFpbnQuX3ZhbHVlc1tcImZpbGwtb3V0bGluZS1jb2xvclwiXSA9IHRoaXMucGFpbnQuX3ZhbHVlc1tcImZpbGwtY29sb3JcIl0pO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5jcmVhdGVCdWNrZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdXModCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5UmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBybyh0aGlzLnBhaW50LmdldChcImZpbGwtdHJhbnNsYXRlXCIpKTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICAgICAgcmV0dXJuIFphKG5vKHQsIHRoaXMucGFpbnQuZ2V0KFwiZmlsbC10cmFuc2xhdGVcIiksIHRoaXMucGFpbnQuZ2V0KFwiZmlsbC10cmFuc2xhdGUtYW5jaG9yXCIpLCBhLmFuZ2xlLCBvKSwgbik7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmlzVGlsZUNsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9LCBlO1xuICAgICAgfShBaSksXG4gICAgICBocyA9IHppKFt7XG4gICAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYV9ub3JtYWxfZWRcIixcbiAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgICB9XSwgNCkubWVtYmVycyxcbiAgICAgIGZzID0geXM7XG4gICAgZnVuY3Rpb24geXModCwgZSwgciwgbiwgaSkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge30sIHRoaXMuZXh0ZW50ID0gciwgdGhpcy50eXBlID0gMCwgdGhpcy5fcGJmID0gdCwgdGhpcy5fZ2VvbWV0cnkgPSAtMSwgdGhpcy5fa2V5cyA9IG4sIHRoaXMuX3ZhbHVlcyA9IGksIHQucmVhZEZpZWxkcyhkcywgdGhpcywgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRzKHQsIGUsIHIpIHtcbiAgICAgIDEgPT0gdCA/IGUuaWQgPSByLnJlYWRWYXJpbnQoKSA6IDIgPT0gdCA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zOyB0LnBvcyA8IHI7KSB7XG4gICAgICAgICAgdmFyIG4gPSBlLl9rZXlzW3QucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIGkgPSBlLl92YWx1ZXNbdC5yZWFkVmFyaW50KCldO1xuICAgICAgICAgIGUucHJvcGVydGllc1tuXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0ociwgZSkgOiAzID09IHQgPyBlLnR5cGUgPSByLnJlYWRWYXJpbnQoKSA6IDQgPT0gdCAmJiAoZS5fZ2VvbWV0cnkgPSByLnBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1zKHQpIHtcbiAgICAgIGZvciAodmFyIGUsIHIsIG4gPSAwLCBpID0gMCwgYSA9IHQubGVuZ3RoLCBvID0gYSAtIDE7IGkgPCBhOyBvID0gaSsrKSBuICs9ICgociA9IHRbb10pLnggLSAoZSA9IHRbaV0pLngpICogKGUueSArIHIueSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgeXMudHlwZXMgPSBbXCJVbmtub3duXCIsIFwiUG9pbnRcIiwgXCJMaW5lU3RyaW5nXCIsIFwiUG9seWdvblwiXSwgeXMucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fcGJmO1xuICAgICAgdC5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICAgIGZvciAodmFyIGUsIHIgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zLCBuID0gMSwgYSA9IDAsIG8gPSAwLCBzID0gMCwgdSA9IFtdOyB0LnBvcyA8IHI7KSB7XG4gICAgICAgIGlmIChhIDw9IDApIHtcbiAgICAgICAgICB2YXIgbCA9IHQucmVhZFZhcmludCgpO1xuICAgICAgICAgIG4gPSA3ICYgbCwgYSA9IGwgPj4gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS0tLCAxID09PSBuIHx8IDIgPT09IG4pIG8gKz0gdC5yZWFkU1ZhcmludCgpLCBzICs9IHQucmVhZFNWYXJpbnQoKSwgMSA9PT0gbiAmJiAoZSAmJiB1LnB1c2goZSksIGUgPSBbXSksIGUucHVzaChuZXcgaShvLCBzKSk7ZWxzZSB7XG4gICAgICAgICAgaWYgKDcgIT09IG4pIHRocm93IG5ldyBFcnJvcihcInVua25vd24gY29tbWFuZCBcIiArIG4pO1xuICAgICAgICAgIGUgJiYgZS5wdXNoKGVbMF0uY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlICYmIHUucHVzaChlKSwgdTtcbiAgICB9LCB5cy5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fcGJmO1xuICAgICAgdC5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcbiAgICAgIGZvciAodmFyIGUgPSB0LnJlYWRWYXJpbnQoKSArIHQucG9zLCByID0gMSwgbiA9IDAsIGkgPSAwLCBhID0gMCwgbyA9IDEgLyAwLCBzID0gLTEgLyAwLCB1ID0gMSAvIDAsIGwgPSAtMSAvIDA7IHQucG9zIDwgZTspIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHZhciBwID0gdC5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgciA9IDcgJiBwLCBuID0gcCA+PiAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLS0sIDEgPT09IHIgfHwgMiA9PT0gcikgKGkgKz0gdC5yZWFkU1ZhcmludCgpKSA8IG8gJiYgKG8gPSBpKSwgaSA+IHMgJiYgKHMgPSBpKSwgKGEgKz0gdC5yZWFkU1ZhcmludCgpKSA8IHUgJiYgKHUgPSBhKSwgYSA+IGwgJiYgKGwgPSBhKTtlbHNlIGlmICg3ICE9PSByKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbW1hbmQgXCIgKyByKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbywgdSwgcywgbF07XG4gICAgfSwgeXMucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbixcbiAgICAgICAgaSxcbiAgICAgICAgYSA9IHRoaXMuZXh0ZW50ICogTWF0aC5wb3coMiwgciksXG4gICAgICAgIG8gPSB0aGlzLmV4dGVudCAqIHQsXG4gICAgICAgIHMgPSB0aGlzLmV4dGVudCAqIGUsXG4gICAgICAgIHUgPSB0aGlzLmxvYWRHZW9tZXRyeSgpLFxuICAgICAgICBsID0geXMudHlwZXNbdGhpcy50eXBlXTtcbiAgICAgIGZ1bmN0aW9uIHAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgciA9IHRbZV07XG4gICAgICAgICAgdFtlXSA9IFszNjAgKiAoci54ICsgbykgLyBhIC0gMTgwLCAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKCgxODAgLSAzNjAgKiAoci55ICsgcykgLyBhKSAqIE1hdGguUEkgLyAxODApKSAtIDkwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgZm9yIChuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIGNbbl0gPSB1W25dWzBdO1xuICAgICAgICAgIHAodSA9IGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZm9yIChuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIHAodVtuXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmb3IgKHUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlIDw9IDEpIHJldHVybiBbdF07XG4gICAgICAgICAgICBmb3IgKHZhciByLCBuLCBpID0gW10sIGEgPSAwOyBhIDwgZTsgYSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gbXModFthXSk7XG4gICAgICAgICAgICAgIDAgIT09IG8gJiYgKHZvaWQgMCA9PT0gbiAmJiAobiA9IG8gPCAwKSwgbiA9PT0gbyA8IDAgPyAociAmJiBpLnB1c2gociksIHIgPSBbdFthXV0pIDogci5wdXNoKHRbYV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByICYmIGkucHVzaChyKSwgaTtcbiAgICAgICAgICB9KHUpLCBuID0gMDsgbiA8IHUubGVuZ3RoOyBuKyspIGZvciAoaSA9IDA7IGkgPCB1W25dLmxlbmd0aDsgaSsrKSBwKHVbbl1baV0pO1xuICAgICAgfVxuICAgICAgMSA9PT0gdS5sZW5ndGggPyB1ID0gdVswXSA6IGwgPSBcIk11bHRpXCIgKyBsO1xuICAgICAgdmFyIGggPSB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IGwsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IHVcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFwiaWRcIiBpbiB0aGlzICYmIChoLmlkID0gdGhpcy5pZCksIGg7XG4gICAgfTtcbiAgICB2YXIgdnMgPSBncztcbiAgICBmdW5jdGlvbiBncyh0LCBlKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSAxLCB0aGlzLm5hbWUgPSBudWxsLCB0aGlzLmV4dGVudCA9IDQwOTYsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5fcGJmID0gdCwgdGhpcy5fa2V5cyA9IFtdLCB0aGlzLl92YWx1ZXMgPSBbXSwgdGhpcy5fZmVhdHVyZXMgPSBbXSwgdC5yZWFkRmllbGRzKHhzLCB0aGlzLCBlKSwgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhzKHQsIGUsIHIpIHtcbiAgICAgIDE1ID09PSB0ID8gZS52ZXJzaW9uID0gci5yZWFkVmFyaW50KCkgOiAxID09PSB0ID8gZS5uYW1lID0gci5yZWFkU3RyaW5nKCkgOiA1ID09PSB0ID8gZS5leHRlbnQgPSByLnJlYWRWYXJpbnQoKSA6IDIgPT09IHQgPyBlLl9mZWF0dXJlcy5wdXNoKHIucG9zKSA6IDMgPT09IHQgPyBlLl9rZXlzLnB1c2goci5yZWFkU3RyaW5nKCkpIDogNCA9PT0gdCAmJiBlLl92YWx1ZXMucHVzaChmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gbnVsbCwgciA9IHQucmVhZFZhcmludCgpICsgdC5wb3M7IHQucG9zIDwgcjspIHtcbiAgICAgICAgICB2YXIgbiA9IHQucmVhZFZhcmludCgpID4+IDM7XG4gICAgICAgICAgZSA9IDEgPT09IG4gPyB0LnJlYWRTdHJpbmcoKSA6IDIgPT09IG4gPyB0LnJlYWRGbG9hdCgpIDogMyA9PT0gbiA/IHQucmVhZERvdWJsZSgpIDogNCA9PT0gbiA/IHQucmVhZFZhcmludDY0KCkgOiA1ID09PSBuID8gdC5yZWFkVmFyaW50KCkgOiA2ID09PSBuID8gdC5yZWFkU1ZhcmludCgpIDogNyA9PT0gbiA/IHQucmVhZEJvb2xlYW4oKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KHIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnModCwgZSwgcikge1xuICAgICAgaWYgKDMgPT09IHQpIHtcbiAgICAgICAgdmFyIG4gPSBuZXcgdnMociwgci5yZWFkVmFyaW50KCkgKyByLnBvcyk7XG4gICAgICAgIG4ubGVuZ3RoICYmIChlW24ubmFtZV0gPSBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3MucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQgPCAwIHx8IHQgPj0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJmZWF0dXJlIGluZGV4IG91dCBvZiBib3VuZHNcIik7XG4gICAgICB0aGlzLl9wYmYucG9zID0gdGhpcy5fZmVhdHVyZXNbdF07XG4gICAgICB2YXIgZSA9IHRoaXMuX3BiZi5yZWFkVmFyaW50KCkgKyB0aGlzLl9wYmYucG9zO1xuICAgICAgcmV0dXJuIG5ldyBmcyh0aGlzLl9wYmYsIGUsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xuICAgIH07XG4gICAgdmFyIHdzID0ge1xuICAgICAgICBWZWN0b3JUaWxlOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHRoaXMubGF5ZXJzID0gdC5yZWFkRmllbGRzKGJzLCB7fSwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIFZlY3RvclRpbGVGZWF0dXJlOiBmcyxcbiAgICAgICAgVmVjdG9yVGlsZUxheWVyOiB2c1xuICAgICAgfSxcbiAgICAgIF9zID0gd3MuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMsXG4gICAgICBBcyA9IE1hdGgucG93KDIsIDEzKTtcbiAgICBmdW5jdGlvbiBTcyh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICB0LmVtcGxhY2VCYWNrKGUsIHIsIDIgKiBNYXRoLmZsb29yKG4gKiBBcykgKyBvLCBpICogQXMgKiAyLCBhICogQXMgKiAyLCBNYXRoLnJvdW5kKHMpKTtcbiAgICB9XG4gICAgdmFyIGtzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5vdmVyc2NhbGluZyA9IHQub3ZlcnNjYWxpbmcsIHRoaXMubGF5ZXJzID0gdC5sYXllcnMsIHRoaXMubGF5ZXJJZHMgPSB0aGlzLmxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMuaGFzUGF0dGVybiA9ICExLCB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IE1pKCksIHRoaXMuaW5kZXhBcnJheSA9IG5ldyBxaSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IG5ldyBGYSh0LmxheWVycywgdC56b29tKSwgdGhpcy5zZWdtZW50cyA9IG5ldyB1YSgpLCB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJJZHMgPSB0aGlzLmxheWVycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaXNTdGF0ZURlcGVuZGVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBJcyh0LCBlKSB7XG4gICAgICByZXR1cm4gdC54ID09PSBlLnggJiYgKHQueCA8IDAgfHwgdC54ID4gODE5MikgfHwgdC55ID09PSBlLnkgJiYgKHQueSA8IDAgfHwgdC55ID4gODE5Mik7XG4gICAgfVxuICAgIGtzLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzID0gW10sIHRoaXMuaGFzUGF0dGVybiA9IG9zKFwiZmlsbC1leHRydXNpb25cIiwgdGhpcy5sYXllcnMsIGUpO1xuICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSB0OyBuIDwgaS5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICB2YXIgYSA9IGlbbl0sXG4gICAgICAgICAgbyA9IGEuZmVhdHVyZSxcbiAgICAgICAgICBzID0gYS5pZCxcbiAgICAgICAgICB1ID0gYS5pbmRleCxcbiAgICAgICAgICBsID0gYS5zb3VyY2VMYXllckluZGV4LFxuICAgICAgICAgIHAgPSB0aGlzLmxheWVyc1swXS5fZmVhdHVyZUZpbHRlci5uZWVkR2VvbWV0cnksXG4gICAgICAgICAgYyA9IGphKG8sIHApO1xuICAgICAgICBpZiAodGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIuZmlsdGVyKG5ldyB1aSh0aGlzLnpvb20pLCBjLCByKSkge1xuICAgICAgICAgIHZhciBoID0ge1xuICAgICAgICAgICAgaWQ6IHMsXG4gICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiBsLFxuICAgICAgICAgICAgaW5kZXg6IHUsXG4gICAgICAgICAgICBnZW9tZXRyeTogcCA/IGMuZ2VvbWV0cnkgOiBVYShvKSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG8ucHJvcGVydGllcyxcbiAgICAgICAgICAgIHR5cGU6IG8udHlwZSxcbiAgICAgICAgICAgIHBhdHRlcm5zOiB7fVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5oYXNQYXR0ZXJuID8gdGhpcy5mZWF0dXJlcy5wdXNoKHNzKFwiZmlsbC1leHRydXNpb25cIiwgdGhpcy5sYXllcnMsIGgsIHRoaXMuem9vbSwgZSkpIDogdGhpcy5hZGRGZWF0dXJlKGgsIGguZ2VvbWV0cnksIHUsIHIsIHt9KSwgZS5mZWF0dXJlSW5kZXguaW5zZXJ0KG8sIGguZ2VvbWV0cnksIHUsIGwsIHRoaXMuaW5kZXgsICEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGtzLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBmb3IgKHZhciBuID0gMCwgaSA9IHRoaXMuZmVhdHVyZXM7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGEsIGEuZ2VvbWV0cnksIGEuaW5kZXgsIGUsIHIpO1xuICAgICAgfVxuICAgIH0sIGtzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycywgcik7XG4gICAgfSwga3MucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG4gICAgfSwga3MucHJvdG90eXBlLnVwbG9hZFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudXBsb2FkZWQgfHwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwga3MucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLnVwbG9hZGVkIHx8ICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGhzKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5KSksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnVwbG9hZCh0KSwgdGhpcy51cGxvYWRlZCA9ICEwO1xuICAgIH0sIGtzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCkpO1xuICAgIH0sIGtzLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBvID0gaXMoZSwgNTAwKTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IG9bYV0sIHUgPSAwLCBsID0gMCwgcCA9IHM7IGwgPCBwLmxlbmd0aDsgbCArPSAxKSB1ICs9IHBbbF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5zZWdtZW50cy5wcmVwYXJlU2VnbWVudCg0LCB0aGlzLmxheW91dFZlcnRleEFycmF5LCB0aGlzLmluZGV4QXJyYXkpLCBoID0gMCwgZiA9IHM7IGggPCBmLmxlbmd0aDsgaCArPSAxKSB7XG4gICAgICAgICAgdmFyIHkgPSBmW2hdO1xuICAgICAgICAgIGlmICgwICE9PSB5Lmxlbmd0aCAmJiAhKChCID0geSkuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnggPCAwO1xuICAgICAgICAgIH0pIHx8IEIuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnggPiA4MTkyO1xuICAgICAgICAgIH0pIHx8IEIuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnkgPCAwO1xuICAgICAgICAgIH0pIHx8IEIuZXZlcnkoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnkgPiA4MTkyO1xuICAgICAgICAgIH0pKSkgZm9yICh2YXIgZCA9IDAsIG0gPSAwOyBtIDwgeS5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgdmFyIHYgPSB5W21dO1xuICAgICAgICAgICAgaWYgKG0gPj0gMSkge1xuICAgICAgICAgICAgICB2YXIgZyA9IHlbbSAtIDFdO1xuICAgICAgICAgICAgICBpZiAoIUlzKHYsIGcpKSB7XG4gICAgICAgICAgICAgICAgYy52ZXJ0ZXhMZW5ndGggKyA0ID4gdWEuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEggJiYgKGMgPSB0aGlzLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSkpO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdi5zdWIoZykuX3BlcnAoKS5fdW5pdCgpLFxuICAgICAgICAgICAgICAgICAgYiA9IGcuZGlzdCh2KTtcbiAgICAgICAgICAgICAgICBkICsgYiA+IDMyNzY4ICYmIChkID0gMCksIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHYueCwgdi55LCB4LngsIHgueSwgMCwgMCwgZCksIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHYueCwgdi55LCB4LngsIHgueSwgMCwgMSwgZCksIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIGcueCwgZy55LCB4LngsIHgueSwgMCwgMCwgZCArPSBiKSwgU3ModGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgZy54LCBnLnksIHgueCwgeC55LCAwLCAxLCBkKTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGMudmVydGV4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhBcnJheS5lbXBsYWNlQmFjayh3LCB3ICsgMiwgdyArIDEpLCB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2sodyArIDEsIHcgKyAyLCB3ICsgMyksIGMudmVydGV4TGVuZ3RoICs9IDQsIGMucHJpbWl0aXZlTGVuZ3RoICs9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMudmVydGV4TGVuZ3RoICsgdSA+IHVhLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIICYmIChjID0gdGhpcy5zZWdtZW50cy5wcmVwYXJlU2VnbWVudCh1LCB0aGlzLmxheW91dFZlcnRleEFycmF5LCB0aGlzLmluZGV4QXJyYXkpKSwgXCJQb2x5Z29uXCIgPT09IF9zW3QudHlwZV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBfID0gW10sIEEgPSBbXSwgUyA9IGMudmVydGV4TGVuZ3RoLCBrID0gMCwgSSA9IHM7IGsgPCBJLmxlbmd0aDsgayArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeiA9IElba107XG4gICAgICAgICAgICBpZiAoMCAhPT0gei5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgeiAhPT0gc1swXSAmJiBBLnB1c2goXy5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgQyA9IDA7IEMgPCB6Lmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIEUgPSB6W0NdO1xuICAgICAgICAgICAgICAgIFNzKHRoaXMubGF5b3V0VmVydGV4QXJyYXksIEUueCwgRS55LCAwLCAwLCAxLCAxLCAwKSwgXy5wdXNoKEUueCksIF8ucHVzaChFLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIFAgPSB6byhfLCBBKSwgTSA9IDA7IE0gPCBQLmxlbmd0aDsgTSArPSAzKSB0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2soUyArIFBbTV0sIFMgKyBQW00gKyAyXSwgUyArIFBbTSArIDFdKTtcbiAgICAgICAgICBjLnByaW1pdGl2ZUxlbmd0aCArPSBQLmxlbmd0aCAvIDMsIGMudmVydGV4TGVuZ3RoICs9IHU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBCO1xuICAgICAgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMucG9wdWxhdGVQYWludEFycmF5cyh0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCwgdCwgciwgaSwgbik7XG4gICAgfSwgT24oXCJGaWxsRXh0cnVzaW9uQnVja2V0XCIsIGtzLCB7XG4gICAgICBvbWl0OiBbXCJsYXllcnNcIiwgXCJmZWF0dXJlc1wiXVxuICAgIH0pO1xuICAgIHZhciB6cyA9IHtcbiAgICAgICAgcGFpbnQ6IG5ldyBfaSh7XG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCI6IG5ldyB2aShQdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiXSksXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiBuZXcgZ2koUHRbXCJwYWludF9maWxsLWV4dHJ1c2lvblwiXVtcImZpbGwtZXh0cnVzaW9uLWNvbG9yXCJdKSxcbiAgICAgICAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOiBuZXcgdmkoUHRbXCJwYWludF9maWxsLWV4dHJ1c2lvblwiXVtcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiXSksXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yXCI6IG5ldyB2aShQdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiXSksXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCI6IG5ldyB4aShQdFtcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCJdW1wiZmlsbC1leHRydXNpb24tcGF0dGVyblwiXSksXG4gICAgICAgICAgXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIjogbmV3IGdpKFB0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIl0pLFxuICAgICAgICAgIFwiZmlsbC1leHRydXNpb24tYmFzZVwiOiBuZXcgZ2koUHRbXCJwYWludF9maWxsLWV4dHJ1c2lvblwiXVtcImZpbGwtZXh0cnVzaW9uLWJhc2VcIl0pLFxuICAgICAgICAgIFwiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnRcIjogbmV3IHZpKFB0W1wicGFpbnRfZmlsbC1leHRydXNpb25cIl1bXCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiXSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBDcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlLCB6cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuY3JlYXRlQnVja2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGtzKHQpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcm8odGhpcy5wYWludC5nZXQoXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIikpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5pczNEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlJbnRlcnNlY3RzRmVhdHVyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBhLCBvLCBzLCB1KSB7XG4gICAgICAgICAgdmFyIGwgPSBubyh0LCB0aGlzLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiKSwgdGhpcy5wYWludC5nZXQoXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yXCIpLCBvLmFuZ2xlLCBzKSxcbiAgICAgICAgICAgIHAgPSB0aGlzLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiKS5ldmFsdWF0ZShlLCByKSxcbiAgICAgICAgICAgIGMgPSB0aGlzLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLWJhc2VcIikuZXZhbHVhdGUoZSwgciksXG4gICAgICAgICAgICBoID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBvID0gMCwgcyA9IHQ7IG8gPCBzLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgICAgICAgICAgbCA9IFt1LngsIHUueSwgMCwgMV07XG4gICAgICAgICAgICAgICAgY28obCwgbCwgZSksIGEucHVzaChuZXcgaShsWzBdIC8gbFszXSwgbFsxXSAvIGxbM10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0obCwgdSksXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBvID0gW10sIHMgPSBuWzhdICogZSwgdSA9IG5bOV0gKiBlLCBsID0gblsxMF0gKiBlLCBwID0gblsxMV0gKiBlLCBjID0gbls4XSAqIHIsIGggPSBuWzldICogciwgZiA9IG5bMTBdICogciwgeSA9IG5bMTFdICogciwgZCA9IDAsIG0gPSB0OyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSBbXSwgZyA9IFtdLCB4ID0gMCwgYiA9IG1bZF07IHggPCBiLmxlbmd0aDsgeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdyA9IGJbeF0sXG4gICAgICAgICAgICAgICAgICAgIF8gPSB3LngsXG4gICAgICAgICAgICAgICAgICAgIEEgPSB3LnksXG4gICAgICAgICAgICAgICAgICAgIFMgPSBuWzBdICogXyArIG5bNF0gKiBBICsgblsxMl0sXG4gICAgICAgICAgICAgICAgICAgIGsgPSBuWzFdICogXyArIG5bNV0gKiBBICsgblsxM10sXG4gICAgICAgICAgICAgICAgICAgIEkgPSBuWzJdICogXyArIG5bNl0gKiBBICsgblsxNF0sXG4gICAgICAgICAgICAgICAgICAgIHogPSBuWzNdICogXyArIG5bN10gKiBBICsgblsxNV0sXG4gICAgICAgICAgICAgICAgICAgIEMgPSBJICsgbCxcbiAgICAgICAgICAgICAgICAgICAgRSA9IHogKyBwLFxuICAgICAgICAgICAgICAgICAgICBQID0gUyArIGMsXG4gICAgICAgICAgICAgICAgICAgIE0gPSBrICsgaCxcbiAgICAgICAgICAgICAgICAgICAgQiA9IEkgKyBmLFxuICAgICAgICAgICAgICAgICAgICBUID0geiArIHksXG4gICAgICAgICAgICAgICAgICAgIFYgPSBuZXcgaSgoUyArIHMpIC8gRSwgKGsgKyB1KSAvIEUpO1xuICAgICAgICAgICAgICAgICAgVi56ID0gQyAvIEUsIHYucHVzaChWKTtcbiAgICAgICAgICAgICAgICAgIHZhciBGID0gbmV3IGkoUCAvIFQsIE0gLyBUKTtcbiAgICAgICAgICAgICAgICAgIEYueiA9IEIgLyBULCBnLnB1c2goRik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEucHVzaCh2KSwgby5wdXNoKGcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBbYSwgb107XG4gICAgICAgICAgICB9KG4sIGMsIHAsIHUpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgdmFyIG4gPSAxIC8gMDtcbiAgICAgICAgICAgIFphKHIsIGUpICYmIChuID0gUHMociwgZVswXSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSBmb3IgKHZhciBhID0gZVtpXSwgbyA9IHRbaV0sIHMgPSAwOyBzIDwgYS5sZW5ndGggLSAxOyBzKyspIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBhW3NdLFxuICAgICAgICAgICAgICAgIGwgPSBbdSwgYVtzICsgMV0sIG9bcyArIDFdLCBvW3NdLCB1XTtcbiAgICAgICAgICAgICAgS2EociwgbCkgJiYgKG4gPSBNYXRoLm1pbihuLCBQcyhyLCBsKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG4gIT09IDEgLyAwICYmIG47XG4gICAgICAgICAgfShmWzBdLCBmWzFdLCBoKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oQWkpO1xuICAgIGZ1bmN0aW9uIEVzKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnggKiBlLnggKyB0LnkgKiBlLnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBzKHQsIGUpIHtcbiAgICAgIGlmICgxID09PSB0Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciByLCBuID0gMCwgaSA9IGVbbisrXTsgIXIgfHwgaS5lcXVhbHMocik7KSBpZiAoIShyID0gZVtuKytdKSkgcmV0dXJuIDEgLyAwO1xuICAgICAgICBmb3IgKDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICB2YXIgYSA9IGVbbl0sXG4gICAgICAgICAgICBvID0gdFswXSxcbiAgICAgICAgICAgIHMgPSByLnN1YihpKSxcbiAgICAgICAgICAgIHUgPSBhLnN1YihpKSxcbiAgICAgICAgICAgIGwgPSBvLnN1YihpKSxcbiAgICAgICAgICAgIHAgPSBFcyhzLCBzKSxcbiAgICAgICAgICAgIGMgPSBFcyhzLCB1KSxcbiAgICAgICAgICAgIGggPSBFcyh1LCB1KSxcbiAgICAgICAgICAgIGYgPSBFcyhsLCBzKSxcbiAgICAgICAgICAgIHkgPSBFcyhsLCB1KSxcbiAgICAgICAgICAgIGQgPSBwICogaCAtIGMgKiBjLFxuICAgICAgICAgICAgbSA9IChoICogZiAtIGMgKiB5KSAvIGQsXG4gICAgICAgICAgICB2ID0gKHAgKiB5IC0gYyAqIGYpIC8gZCxcbiAgICAgICAgICAgIGcgPSBpLnogKiAoMSAtIG0gLSB2KSArIHIueiAqIG0gKyBhLnogKiB2O1xuICAgICAgICAgIGlmIChpc0Zpbml0ZShnKSkgcmV0dXJuIGc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEgLyAwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgeCA9IDEgLyAwLCBiID0gMCwgdyA9IGU7IGIgPCB3Lmxlbmd0aDsgYiArPSAxKSB4ID0gTWF0aC5taW4oeCwgd1tiXS56KTtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICB2YXIgTXMgPSB6aShbe1xuICAgICAgICBuYW1lOiBcImFfcG9zX25vcm1hbFwiLFxuICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICB0eXBlOiBcIkludDE2XCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhX2RhdGFcIixcbiAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgdHlwZTogXCJVaW50OFwiXG4gICAgICB9XSwgNCkubWVtYmVycyxcbiAgICAgIEJzID0gemkoW3tcbiAgICAgICAgbmFtZTogXCJhX3V2X3hcIixcbiAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhX3NwbGl0X2luZGV4XCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgIHR5cGU6IFwiRmxvYXQzMlwiXG4gICAgICB9XSkubWVtYmVycyxcbiAgICAgIFRzID0gd3MuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMsXG4gICAgICBWcyA9IE1hdGguY29zKE1hdGguUEkgLyAxODAgKiAzNy41KSxcbiAgICAgIEZzID0gTWF0aC5wb3coMiwgMTQpIC8gLjUsXG4gICAgICBEcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgdGhpcy56b29tID0gdC56b29tLCB0aGlzLm92ZXJzY2FsaW5nID0gdC5vdmVyc2NhbGluZywgdGhpcy5sYXllcnMgPSB0LmxheWVycywgdGhpcy5sYXllcklkcyA9IHRoaXMubGF5ZXJzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMuaGFzUGF0dGVybiA9ICExLCB0aGlzLnBhdHRlcm5GZWF0dXJlcyA9IFtdLCB0aGlzLmxpbmVDbGlwc0FycmF5ID0gW10sIHRoaXMuZ3JhZGllbnRzID0ge30sIHRoaXMubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBlLmdyYWRpZW50c1t0LmlkXSA9IHt9O1xuICAgICAgICB9KSwgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSA9IG5ldyBCaSgpLCB0aGlzLmxheW91dFZlcnRleEFycmF5MiA9IG5ldyBUaSgpLCB0aGlzLmluZGV4QXJyYXkgPSBuZXcgcWkoKSwgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMgPSBuZXcgRmEodC5sYXllcnMsIHQuem9vbSksIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5tYXhMaW5lTGVuZ3RoID0gMCwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuaXNTdGF0ZURlcGVuZGVudCgpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIERzLnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLmhhc1BhdHRlcm4gPSBvcyhcImxpbmVcIiwgdGhpcy5sYXllcnMsIGUpO1xuICAgICAgZm9yICh2YXIgbiA9IHRoaXMubGF5ZXJzWzBdLmxheW91dC5nZXQoXCJsaW5lLXNvcnQta2V5XCIpLCBpID0gIW4uaXNDb25zdGFudCgpLCBhID0gW10sIG8gPSAwLCBzID0gdDsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIHUgPSBzW29dLFxuICAgICAgICAgIGwgPSB1LmZlYXR1cmUsXG4gICAgICAgICAgcCA9IHUuaWQsXG4gICAgICAgICAgYyA9IHUuaW5kZXgsXG4gICAgICAgICAgaCA9IHUuc291cmNlTGF5ZXJJbmRleCxcbiAgICAgICAgICBmID0gdGhpcy5sYXllcnNbMF0uX2ZlYXR1cmVGaWx0ZXIubmVlZEdlb21ldHJ5LFxuICAgICAgICAgIHkgPSBqYShsLCBmKTtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzWzBdLl9mZWF0dXJlRmlsdGVyLmZpbHRlcihuZXcgdWkodGhpcy56b29tKSwgeSwgcikpIHtcbiAgICAgICAgICB2YXIgZCA9IGkgPyBuLmV2YWx1YXRlKHksIHt9LCByKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICAgIGlkOiBwLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBsLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIHR5cGU6IGwudHlwZSxcbiAgICAgICAgICAgICAgc291cmNlTGF5ZXJJbmRleDogaCxcbiAgICAgICAgICAgICAgaW5kZXg6IGMsXG4gICAgICAgICAgICAgIGdlb21ldHJ5OiBmID8geS5nZW9tZXRyeSA6IFVhKGwpLFxuICAgICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgICAgICAgIHNvcnRLZXk6IGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgYS5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpICYmIGEuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5zb3J0S2V5IC0gZS5zb3J0S2V5O1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciB2ID0gMCwgZyA9IGE7IHYgPCBnLmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgIHZhciB4ID0gZ1t2XSxcbiAgICAgICAgICBiID0geC5nZW9tZXRyeSxcbiAgICAgICAgICB3ID0geC5pbmRleCxcbiAgICAgICAgICBfID0geC5zb3VyY2VMYXllckluZGV4O1xuICAgICAgICBpZiAodGhpcy5oYXNQYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIEEgPSBzcyhcImxpbmVcIiwgdGhpcy5sYXllcnMsIHgsIHRoaXMuem9vbSwgZSk7XG4gICAgICAgICAgdGhpcy5wYXR0ZXJuRmVhdHVyZXMucHVzaChBKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuYWRkRmVhdHVyZSh4LCBiLCB3LCByLCB7fSk7XG4gICAgICAgIGUuZmVhdHVyZUluZGV4Lmluc2VydCh0W3ddLmZlYXR1cmUsIGIsIHcsIF8sIHRoaXMuaW5kZXgpO1xuICAgICAgfVxuICAgIH0sIERzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycy5sZW5ndGggJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVycywgcik7XG4gICAgfSwgRHMucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gdGhpcy5wYXR0ZXJuRmVhdHVyZXM7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGEsIGEuZ2VvbWV0cnksIGEuaW5kZXgsIGUsIHIpO1xuICAgICAgfVxuICAgIH0sIERzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDAgPT09IHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgIH0sIERzLnByb3RvdHlwZS51cGxvYWRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnVwbG9hZGVkIHx8IHRoaXMucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkO1xuICAgIH0sIERzLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy51cGxvYWRlZCB8fCAoMCAhPT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheTIubGVuZ3RoICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlcjIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmxheW91dFZlcnRleEFycmF5MiwgQnMpKSwgdGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmxheW91dFZlcnRleEFycmF5LCBNcyksIHRoaXMuaW5kZXhCdWZmZXIgPSB0LmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhBcnJheSkpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy51cGxvYWQodCksIHRoaXMudXBsb2FkZWQgPSAhMDtcbiAgICB9LCBEcy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5kZXN0cm95KCksIHRoaXMuc2VnbWVudHMuZGVzdHJveSgpKTtcbiAgICB9LCBEcy5wcm90b3R5cGUubGluZUZlYXR1cmVDbGlwcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodC5wcm9wZXJ0aWVzICYmIHQucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcIm1hcGJveF9jbGlwX3N0YXJ0XCIpICYmIHQucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShcIm1hcGJveF9jbGlwX2VuZFwiKSkgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6ICt0LnByb3BlcnRpZXMubWFwYm94X2NsaXBfc3RhcnQsXG4gICAgICAgIGVuZDogK3QucHJvcGVydGllcy5tYXBib3hfY2xpcF9lbmRcbiAgICAgIH07XG4gICAgfSwgRHMucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdmFyIGEgPSB0aGlzLmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgIG8gPSBhLmdldChcImxpbmUtam9pblwiKS5ldmFsdWF0ZSh0LCB7fSksXG4gICAgICAgIHMgPSBhLmdldChcImxpbmUtY2FwXCIpLFxuICAgICAgICB1ID0gYS5nZXQoXCJsaW5lLW1pdGVyLWxpbWl0XCIpLFxuICAgICAgICBsID0gYS5nZXQoXCJsaW5lLXJvdW5kLWxpbWl0XCIpO1xuICAgICAgdGhpcy5saW5lQ2xpcHMgPSB0aGlzLmxpbmVGZWF0dXJlQ2xpcHModCk7XG4gICAgICBmb3IgKHZhciBwID0gMCwgYyA9IGU7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB0aGlzLmFkZExpbmUoY1twXSwgdCwgbywgcywgdSwgbCk7XG4gICAgICB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5wb3B1bGF0ZVBhaW50QXJyYXlzKHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoLCB0LCByLCBpLCBuKTtcbiAgICB9LCBEcy5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBpZiAodGhpcy5kaXN0YW5jZSA9IDAsIHRoaXMuc2NhbGVkRGlzdGFuY2UgPSAwLCB0aGlzLnRvdGFsRGlzdGFuY2UgPSAwLCB0aGlzLmxpbmVDbGlwcykge1xuICAgICAgICB0aGlzLmxpbmVDbGlwc0FycmF5LnB1c2godGhpcy5saW5lQ2xpcHMpO1xuICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHQubGVuZ3RoIC0gMTsgbysrKSB0aGlzLnRvdGFsRGlzdGFuY2UgKz0gdFtvXS5kaXN0KHRbbyArIDFdKTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsZWREaXN0YW5jZSgpLCB0aGlzLm1heExpbmVMZW5ndGggPSBNYXRoLm1heCh0aGlzLm1heExpbmVMZW5ndGgsIHRoaXMudG90YWxEaXN0YW5jZSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBzID0gXCJQb2x5Z29uXCIgPT09IFRzW2UudHlwZV0sIHUgPSB0Lmxlbmd0aDsgdSA+PSAyICYmIHRbdSAtIDFdLmVxdWFscyh0W3UgLSAyXSk7KSB1LS07XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHUgLSAxICYmIHRbbF0uZXF1YWxzKHRbbCArIDFdKTspIGwrKztcbiAgICAgIGlmICghKHUgPCAocyA/IDMgOiAyKSkpIHtcbiAgICAgICAgXCJiZXZlbFwiID09PSByICYmIChpID0gMS4wNSk7XG4gICAgICAgIHZhciBwLFxuICAgICAgICAgIGMgPSB0aGlzLm92ZXJzY2FsaW5nIDw9IDE2ID8gMTIyODgwIC8gKDUxMiAqIHRoaXMub3ZlcnNjYWxpbmcpIDogMCxcbiAgICAgICAgICBoID0gdGhpcy5zZWdtZW50cy5wcmVwYXJlU2VnbWVudCgxMCAqIHUsIHRoaXMubGF5b3V0VmVydGV4QXJyYXksIHRoaXMuaW5kZXhBcnJheSksXG4gICAgICAgICAgZiA9IHZvaWQgMCxcbiAgICAgICAgICB5ID0gdm9pZCAwLFxuICAgICAgICAgIGQgPSB2b2lkIDAsXG4gICAgICAgICAgbSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTIgPSAtMSwgcyAmJiAobSA9IHRbbF0uc3ViKHAgPSB0W3UgLSAyXSkuX3VuaXQoKS5fcGVycCgpKTtcbiAgICAgICAgZm9yICh2YXIgdiA9IGw7IHYgPCB1OyB2KyspIGlmICghKHkgPSB2ID09PSB1IC0gMSA/IHMgPyB0W2wgKyAxXSA6IHZvaWQgMCA6IHRbdiArIDFdKSB8fCAhdFt2XS5lcXVhbHMoeSkpIHtcbiAgICAgICAgICBtICYmIChkID0gbSksIHAgJiYgKGYgPSBwKSwgcCA9IHRbdl0sIG0gPSB5ID8geS5zdWIocCkuX3VuaXQoKS5fcGVycCgpIDogZDtcbiAgICAgICAgICB2YXIgZyA9IChkID0gZCB8fCBtKS5hZGQobSk7XG4gICAgICAgICAgMCA9PT0gZy54ICYmIDAgPT09IGcueSB8fCBnLl91bml0KCk7XG4gICAgICAgICAgdmFyIHggPSBkLnggKiBtLnggKyBkLnkgKiBtLnksXG4gICAgICAgICAgICBiID0gZy54ICogbS54ICsgZy55ICogbS55LFxuICAgICAgICAgICAgdyA9IDAgIT09IGIgPyAxIC8gYiA6IDEgLyAwLFxuICAgICAgICAgICAgXyA9IDIgKiBNYXRoLnNxcnQoMiAtIDIgKiBiKSxcbiAgICAgICAgICAgIEEgPSBiIDwgVnMgJiYgZiAmJiB5LFxuICAgICAgICAgICAgUyA9IGQueCAqIG0ueSAtIGQueSAqIG0ueCA+IDA7XG4gICAgICAgICAgaWYgKEEgJiYgdiA+IGwpIHtcbiAgICAgICAgICAgIHZhciBrID0gcC5kaXN0KGYpO1xuICAgICAgICAgICAgaWYgKGsgPiAyICogYykge1xuICAgICAgICAgICAgICB2YXIgSSA9IHAuc3ViKHAuc3ViKGYpLl9tdWx0KGMgLyBrKS5fcm91bmQoKSk7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzdGFuY2UoZiwgSSksIHRoaXMuYWRkQ3VycmVudFZlcnRleChJLCBkLCAwLCAwLCBoKSwgZiA9IEk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB6ID0gZiAmJiB5LFxuICAgICAgICAgICAgQyA9IHogPyByIDogcyA/IFwiYnV0dFwiIDogbjtcbiAgICAgICAgICBpZiAoeiAmJiBcInJvdW5kXCIgPT09IEMgJiYgKHcgPCBhID8gQyA9IFwibWl0ZXJcIiA6IHcgPD0gMiAmJiAoQyA9IFwiZmFrZXJvdW5kXCIpKSwgXCJtaXRlclwiID09PSBDICYmIHcgPiBpICYmIChDID0gXCJiZXZlbFwiKSwgXCJiZXZlbFwiID09PSBDICYmICh3ID4gMiAmJiAoQyA9IFwiZmxpcGJldmVsXCIpLCB3IDwgaSAmJiAoQyA9IFwibWl0ZXJcIikpLCBmICYmIHRoaXMudXBkYXRlRGlzdGFuY2UoZiwgcCksIFwibWl0ZXJcIiA9PT0gQykgZy5fbXVsdCh3KSwgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGcsIDAsIDAsIGgpO2Vsc2UgaWYgKFwiZmxpcGJldmVsXCIgPT09IEMpIHtcbiAgICAgICAgICAgIGlmICh3ID4gMTAwKSBnID0gbS5tdWx0KC0xKTtlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIEUgPSB3ICogZC5hZGQobSkubWFnKCkgLyBkLnN1YihtKS5tYWcoKTtcbiAgICAgICAgICAgICAgZy5fcGVycCgpLl9tdWx0KEUgKiAoUyA/IC0xIDogMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGcsIDAsIDAsIGgpLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZy5tdWx0KC0xKSwgMCwgMCwgaCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcImJldmVsXCIgPT09IEMgfHwgXCJmYWtlcm91bmRcIiA9PT0gQykge1xuICAgICAgICAgICAgdmFyIFAgPSAtTWF0aC5zcXJ0KHcgKiB3IC0gMSksXG4gICAgICAgICAgICAgIE0gPSBTID8gUCA6IDAsXG4gICAgICAgICAgICAgIEIgPSBTID8gMCA6IFA7XG4gICAgICAgICAgICBpZiAoZiAmJiB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZCwgTSwgQiwgaCksIFwiZmFrZXJvdW5kXCIgPT09IEMpIGZvciAodmFyIFQgPSBNYXRoLnJvdW5kKDE4MCAqIF8gLyBNYXRoLlBJIC8gMjApLCBWID0gMTsgViA8IFQ7IFYrKykge1xuICAgICAgICAgICAgICB2YXIgRiA9IFYgLyBUO1xuICAgICAgICAgICAgICBpZiAoLjUgIT09IEYpIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IEYgLSAuNTtcbiAgICAgICAgICAgICAgICBGICs9IEYgKiBEICogKEYgLSAxKSAqICgoMS4wOTA0ICsgeCAqICh4ICogKDMuNTU2NDUgLSAxLjQzNTE5ICogeCkgLSAzLjI0NTIpKSAqIEQgKiBEICsgKC44NDgwMTMgKyB4ICogKC4yMTU2MzggKiB4IC0gMS4wNjAyMSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgTCA9IG0uc3ViKGQpLl9tdWx0KEYpLl9hZGQoZCkuX3VuaXQoKS5fbXVsdChTID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgdGhpcy5hZGRIYWxmVmVydGV4KHAsIEwueCwgTC55LCAhMSwgUywgMCwgaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ICYmIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBtLCAtTSwgLUIsIGgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJidXR0XCIgPT09IEMpIHRoaXMuYWRkQ3VycmVudFZlcnRleChwLCBnLCAwLCAwLCBoKTtlbHNlIGlmIChcInNxdWFyZVwiID09PSBDKSB7XG4gICAgICAgICAgICB2YXIgUiA9IGYgPyAxIDogLTE7XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZywgUiwgUiwgaCk7XG4gICAgICAgICAgfSBlbHNlIFwicm91bmRcIiA9PT0gQyAmJiAoZiAmJiAodGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIGQsIDAsIDAsIGgpLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgZCwgMSwgMSwgaCwgITApKSwgeSAmJiAodGhpcy5hZGRDdXJyZW50VmVydGV4KHAsIG0sIC0xLCAtMSwgaCwgITApLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgocCwgbSwgMCwgMCwgaCkpKTtcbiAgICAgICAgICBpZiAoQSAmJiB2IDwgdSAtIDEpIHtcbiAgICAgICAgICAgIHZhciBPID0gcC5kaXN0KHkpO1xuICAgICAgICAgICAgaWYgKE8gPiAyICogYykge1xuICAgICAgICAgICAgICB2YXIgVSA9IHAuYWRkKHkuc3ViKHApLl9tdWx0KGMgLyBPKS5fcm91bmQoKSk7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzdGFuY2UocCwgVSksIHRoaXMuYWRkQ3VycmVudFZlcnRleChVLCBtLCAwLCAwLCBoKSwgcCA9IFU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgRHMucHJvdG90eXBlLmFkZEN1cnJlbnRWZXJ0ZXggPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgdm9pZCAwID09PSBhICYmIChhID0gITEpO1xuICAgICAgdmFyIG8gPSBlLnkgKiBuIC0gZS54LFxuICAgICAgICBzID0gLWUueSAtIGUueCAqIG47XG4gICAgICB0aGlzLmFkZEhhbGZWZXJ0ZXgodCwgZS54ICsgZS55ICogciwgZS55IC0gZS54ICogciwgYSwgITEsIHIsIGkpLCB0aGlzLmFkZEhhbGZWZXJ0ZXgodCwgbywgcywgYSwgITAsIC1uLCBpKSwgdGhpcy5kaXN0YW5jZSA+IEZzIC8gMiAmJiAwID09PSB0aGlzLnRvdGFsRGlzdGFuY2UgJiYgKHRoaXMuZGlzdGFuY2UgPSAwLCB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgodCwgZSwgciwgbiwgaSwgYSkpO1xuICAgIH0sIERzLnByb3RvdHlwZS5hZGRIYWxmVmVydGV4ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8pIHtcbiAgICAgIHZhciBzID0gLjUgKiAodGhpcy5saW5lQ2xpcHMgPyB0aGlzLnNjYWxlZERpc3RhbmNlICogKEZzIC0gMSkgOiB0aGlzLnNjYWxlZERpc3RhbmNlKTtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkuZW1wbGFjZUJhY2soKHQueCA8PCAxKSArIChuID8gMSA6IDApLCAodC55IDw8IDEpICsgKGkgPyAxIDogMCksIE1hdGgucm91bmQoNjMgKiBlKSArIDEyOCwgTWF0aC5yb3VuZCg2MyAqIHIpICsgMTI4LCAxICsgKDAgPT09IGEgPyAwIDogYSA8IDAgPyAtMSA6IDEpIHwgKDYzICYgcykgPDwgMiwgcyA+PiA2KSwgdGhpcy5saW5lQ2xpcHMgJiYgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheTIuZW1wbGFjZUJhY2soKHRoaXMuc2NhbGVkRGlzdGFuY2UgLSB0aGlzLmxpbmVDbGlwcy5zdGFydCkgLyAodGhpcy5saW5lQ2xpcHMuZW5kIC0gdGhpcy5saW5lQ2xpcHMuc3RhcnQpLCB0aGlzLmxpbmVDbGlwc0FycmF5Lmxlbmd0aCk7XG4gICAgICB2YXIgdSA9IG8udmVydGV4TGVuZ3RoKys7XG4gICAgICB0aGlzLmUxID49IDAgJiYgdGhpcy5lMiA+PSAwICYmICh0aGlzLmluZGV4QXJyYXkuZW1wbGFjZUJhY2sodGhpcy5lMSwgdGhpcy5lMiwgdSksIG8ucHJpbWl0aXZlTGVuZ3RoKyspLCBpID8gdGhpcy5lMiA9IHUgOiB0aGlzLmUxID0gdTtcbiAgICB9LCBEcy5wcm90b3R5cGUudXBkYXRlU2NhbGVkRGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNjYWxlZERpc3RhbmNlID0gdGhpcy5saW5lQ2xpcHMgPyB0aGlzLmxpbmVDbGlwcy5zdGFydCArICh0aGlzLmxpbmVDbGlwcy5lbmQgLSB0aGlzLmxpbmVDbGlwcy5zdGFydCkgKiB0aGlzLmRpc3RhbmNlIC8gdGhpcy50b3RhbERpc3RhbmNlIDogdGhpcy5kaXN0YW5jZTtcbiAgICB9LCBEcy5wcm90b3R5cGUudXBkYXRlRGlzdGFuY2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5kaXN0YW5jZSArPSB0LmRpc3QoZSksIHRoaXMudXBkYXRlU2NhbGVkRGlzdGFuY2UoKTtcbiAgICB9LCBPbihcIkxpbmVCdWNrZXRcIiwgRHMsIHtcbiAgICAgIG9taXQ6IFtcImxheWVyc1wiLCBcInBhdHRlcm5GZWF0dXJlc1wiXVxuICAgIH0pO1xuICAgIHZhciBMcyA9IG5ldyBfaSh7XG4gICAgICAgIFwibGluZS1jYXBcIjogbmV3IHZpKFB0LmxheW91dF9saW5lW1wibGluZS1jYXBcIl0pLFxuICAgICAgICBcImxpbmUtam9pblwiOiBuZXcgZ2koUHQubGF5b3V0X2xpbmVbXCJsaW5lLWpvaW5cIl0pLFxuICAgICAgICBcImxpbmUtbWl0ZXItbGltaXRcIjogbmV3IHZpKFB0LmxheW91dF9saW5lW1wibGluZS1taXRlci1saW1pdFwiXSksXG4gICAgICAgIFwibGluZS1yb3VuZC1saW1pdFwiOiBuZXcgdmkoUHQubGF5b3V0X2xpbmVbXCJsaW5lLXJvdW5kLWxpbWl0XCJdKSxcbiAgICAgICAgXCJsaW5lLXNvcnQta2V5XCI6IG5ldyBnaShQdC5sYXlvdXRfbGluZVtcImxpbmUtc29ydC1rZXlcIl0pXG4gICAgICB9KSxcbiAgICAgIFJzID0ge1xuICAgICAgICBwYWludDogbmV3IF9pKHtcbiAgICAgICAgICBcImxpbmUtb3BhY2l0eVwiOiBuZXcgZ2koUHQucGFpbnRfbGluZVtcImxpbmUtb3BhY2l0eVwiXSksXG4gICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IG5ldyBnaShQdC5wYWludF9saW5lW1wibGluZS1jb2xvclwiXSksXG4gICAgICAgICAgXCJsaW5lLXRyYW5zbGF0ZVwiOiBuZXcgdmkoUHQucGFpbnRfbGluZVtcImxpbmUtdHJhbnNsYXRlXCJdKSxcbiAgICAgICAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfbGluZVtcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiXSksXG4gICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IG5ldyBnaShQdC5wYWludF9saW5lW1wibGluZS13aWR0aFwiXSksXG4gICAgICAgICAgXCJsaW5lLWdhcC13aWR0aFwiOiBuZXcgZ2koUHQucGFpbnRfbGluZVtcImxpbmUtZ2FwLXdpZHRoXCJdKSxcbiAgICAgICAgICBcImxpbmUtb2Zmc2V0XCI6IG5ldyBnaShQdC5wYWludF9saW5lW1wibGluZS1vZmZzZXRcIl0pLFxuICAgICAgICAgIFwibGluZS1ibHVyXCI6IG5ldyBnaShQdC5wYWludF9saW5lW1wibGluZS1ibHVyXCJdKSxcbiAgICAgICAgICBcImxpbmUtZGFzaGFycmF5XCI6IG5ldyBiaShQdC5wYWludF9saW5lW1wibGluZS1kYXNoYXJyYXlcIl0pLFxuICAgICAgICAgIFwibGluZS1wYXR0ZXJuXCI6IG5ldyB4aShQdC5wYWludF9saW5lW1wibGluZS1wYXR0ZXJuXCJdKSxcbiAgICAgICAgICBcImxpbmUtZ3JhZGllbnRcIjogbmV3IHdpKFB0LnBhaW50X2xpbmVbXCJsaW5lLWdyYWRpZW50XCJdKVxuICAgICAgICB9KSxcbiAgICAgICAgbGF5b3V0OiBMc1xuICAgICAgfSxcbiAgICAgIE9zID0gbmV3IChmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5wb3NzaWJseUV2YWx1YXRlID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gciA9IG5ldyB1aShNYXRoLmZsb29yKHIuem9vbSksIHtcbiAgICAgICAgICAgIG5vdzogci5ub3csXG4gICAgICAgICAgICBmYWRlRHVyYXRpb246IHIuZmFkZUR1cmF0aW9uLFxuICAgICAgICAgICAgem9vbUhpc3Rvcnk6IHIuem9vbUhpc3RvcnksXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiByLnRyYW5zaXRpb25cbiAgICAgICAgICB9KSwgdC5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZS5jYWxsKHRoaXMsIGUsIHIpO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChlLCByLCBuLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHIgPSBoKHt9LCByLCB7XG4gICAgICAgICAgICB6b29tOiBNYXRoLmZsb29yKHIuem9vbSlcbiAgICAgICAgICB9KSwgdC5wcm90b3R5cGUuZXZhbHVhdGUuY2FsbCh0aGlzLCBlLCByLCBuLCBpKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oZ2kpKShScy5wYWludC5wcm9wZXJ0aWVzW1wibGluZS13aWR0aFwiXS5zcGVjaWZpY2F0aW9uKTtcbiAgICBPcy51c2VJbnRlZ2VyWm9vbSA9ICEwO1xuICAgIHZhciBVcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgdC5jYWxsKHRoaXMsIGUsIFJzKSwgdGhpcy5ncmFkaWVudFZlcnNpb24gPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX2hhbmRsZVNwZWNpYWxQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgXCJsaW5lLWdyYWRpZW50XCIgPT09IHQgJiYgKHRoaXMuc3RlcEludGVycG9sYW50ID0gdGhpcy5fdHJhbnNpdGlvbmFibGVQYWludC5fdmFsdWVzW1wibGluZS1ncmFkaWVudFwiXS52YWx1ZS5leHByZXNzaW9uLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEtlLCB0aGlzLmdyYWRpZW50VmVyc2lvbiA9ICh0aGlzLmdyYWRpZW50VmVyc2lvbiArIDEpICUgcyk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5ncmFkaWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uYWJsZVBhaW50Ll92YWx1ZXNbXCJsaW5lLWdyYWRpZW50XCJdLnZhbHVlLmV4cHJlc3Npb247XG4gICAgICB9LCBlLnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChlLCByKSB7XG4gICAgICAgIHQucHJvdG90eXBlLnJlY2FsY3VsYXRlLmNhbGwodGhpcywgZSwgciksIHRoaXMucGFpbnQuX3ZhbHVlc1tcImxpbmUtZmxvb3J3aWR0aFwiXSA9IE9zLnBvc3NpYmx5RXZhbHVhdGUodGhpcy5fdHJhbnNpdGlvbmluZ1BhaW50Ll92YWx1ZXNbXCJsaW5lLXdpZHRoXCJdLnZhbHVlLCBlKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRHModCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5xdWVyeVJhZGl1cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdCxcbiAgICAgICAgICByID0ganMoZW8oXCJsaW5lLXdpZHRoXCIsIHRoaXMsIGUpLCBlbyhcImxpbmUtZ2FwLXdpZHRoXCIsIHRoaXMsIGUpKSxcbiAgICAgICAgICBuID0gZW8oXCJsaW5lLW9mZnNldFwiLCB0aGlzLCBlKTtcbiAgICAgICAgcmV0dXJuIHIgLyAyICsgTWF0aC5hYnMobikgKyBybyh0aGlzLnBhaW50LmdldChcImxpbmUtdHJhbnNsYXRlXCIpKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcykge1xuICAgICAgICB2YXIgdSA9IG5vKHQsIHRoaXMucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGVcIiksIHRoaXMucGFpbnQuZ2V0KFwibGluZS10cmFuc2xhdGUtYW5jaG9yXCIpLCBvLmFuZ2xlLCBzKSxcbiAgICAgICAgICBsID0gcyAvIDIgKiBqcyh0aGlzLnBhaW50LmdldChcImxpbmUtd2lkdGhcIikuZXZhbHVhdGUoZSwgciksIHRoaXMucGFpbnQuZ2V0KFwibGluZS1nYXAtd2lkdGhcIikuZXZhbHVhdGUoZSwgcikpLFxuICAgICAgICAgIHAgPSB0aGlzLnBhaW50LmdldChcImxpbmUtb2Zmc2V0XCIpLmV2YWx1YXRlKGUsIHIpO1xuICAgICAgICByZXR1cm4gcCAmJiAobiA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IFtdLCBuID0gbmV3IGkoMCwgMCksIGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgZm9yICh2YXIgbyA9IHRbYV0sIHMgPSBbXSwgdSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gb1t1XSxcbiAgICAgICAgICAgICAgICBwID0gb1t1ICsgMV0sXG4gICAgICAgICAgICAgICAgYyA9IDAgPT09IHUgPyBuIDogbC5zdWIob1t1IC0gMV0pLl91bml0KCkuX3BlcnAoKSxcbiAgICAgICAgICAgICAgICBoID0gdSA9PT0gby5sZW5ndGggLSAxID8gbiA6IHAuc3ViKGwpLl91bml0KCkuX3BlcnAoKSxcbiAgICAgICAgICAgICAgICBmID0gYy5fYWRkKGgpLl91bml0KCk7XG4gICAgICAgICAgICAgIGYuX211bHQoMSAvIChmLnggKiBoLnggKyBmLnkgKiBoLnkpKSwgcy5wdXNoKGYuX211bHQoZSkuX2FkZChsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KG4sIHAgKiBzKSksIGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGVbbl07XG4gICAgICAgICAgICBpZiAodC5sZW5ndGggPj0gMykgZm9yICh2YXIgYSA9IDA7IGEgPCBpLmxlbmd0aDsgYSsrKSBpZiAoUWEodCwgaVthXSkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIGlmIChYYSh0LCBpLCByKSkgcmV0dXJuICEwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0odSwgbiwgbCk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5pc1RpbGVDbGlwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LCBlO1xuICAgIH0oQWkpO1xuICAgIGZ1bmN0aW9uIGpzKHQsIGUpIHtcbiAgICAgIHJldHVybiBlID4gMCA/IGUgKyAyICogdCA6IHQ7XG4gICAgfVxuICAgIHZhciBxcyA9IHppKFt7XG4gICAgICAgIG5hbWU6IFwiYV9wb3Nfb2Zmc2V0XCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDQsXG4gICAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImFfZGF0YVwiLFxuICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICB0eXBlOiBcIlVpbnQxNlwiXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYV9waXhlbG9mZnNldFwiLFxuICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICB0eXBlOiBcIkludDE2XCJcbiAgICAgIH1dLCA0KSxcbiAgICAgIE5zID0gemkoW3tcbiAgICAgICAgbmFtZTogXCJhX3Byb2plY3RlZF9wb3NcIixcbiAgICAgICAgY29tcG9uZW50czogMyxcbiAgICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICAgIH1dLCA0KSxcbiAgICAgIEtzID0gKHppKFt7XG4gICAgICAgIG5hbWU6IFwiYV9mYWRlX29wYWNpdHlcIixcbiAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgdHlwZTogXCJVaW50MzJcIlxuICAgICAgfV0sIDQpLCB6aShbe1xuICAgICAgICBuYW1lOiBcImFfcGxhY2VkXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgIHR5cGU6IFwiVWludDhcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImFfc2hpZnRcIixcbiAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICAgIH1dKSksXG4gICAgICBHcyA9ICh6aShbe1xuICAgICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICAgIG5hbWU6IFwiYW5jaG9yUG9pbnRYXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgICBuYW1lOiBcImFuY2hvclBvaW50WVwiXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgICAgbmFtZTogXCJ4MVwiXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgICAgbmFtZTogXCJ5MVwiXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgICAgbmFtZTogXCJ4MlwiXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgICAgbmFtZTogXCJ5MlwiXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiVWludDMyXCIsXG4gICAgICAgIG5hbWU6IFwiZmVhdHVyZUluZGV4XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgICAgbmFtZTogXCJzb3VyY2VMYXllckluZGV4XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgICAgbmFtZTogXCJidWNrZXRJbmRleFwiXG4gICAgICB9XSksIHppKFt7XG4gICAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6IFwiYV9hbmNob3JfcG9zXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgIHR5cGU6IFwiSW50MTZcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImFfZXh0cnVkZVwiLFxuICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICB0eXBlOiBcIkludDE2XCJcbiAgICAgIH1dLCA0KSksXG4gICAgICBacyA9IHppKFt7XG4gICAgICAgIG5hbWU6IFwiYV9wb3NcIixcbiAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgdHlwZTogXCJGbG9hdDMyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogXCJhX3JhZGl1c1wiLFxuICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICB0eXBlOiBcIkZsb2F0MzJcIlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImFfZmxhZ3NcIixcbiAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgdHlwZTogXCJJbnQxNlwiXG4gICAgICB9XSwgNCk7XG4gICAgZnVuY3Rpb24gWHModCwgZSwgcikge1xuICAgICAgcmV0dXJuIHQuc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnRleHQgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHZhciBuID0gZS5sYXlvdXQuZ2V0KFwidGV4dC10cmFuc2Zvcm1cIikuZXZhbHVhdGUociwge30pO1xuICAgICAgICAgIHJldHVybiBcInVwcGVyY2FzZVwiID09PSBuID8gdCA9IHQudG9Mb2NhbGVVcHBlckNhc2UoKSA6IFwibG93ZXJjYXNlXCIgPT09IG4gJiYgKHQgPSB0LnRvTG9jYWxlTG93ZXJDYXNlKCkpLCBzaS5hcHBseUFyYWJpY1NoYXBpbmcgJiYgKHQgPSBzaS5hcHBseUFyYWJpY1NoYXBpbmcodCkpLCB0O1xuICAgICAgICB9KHQudGV4dCwgZSwgcik7XG4gICAgICB9KSwgdDtcbiAgICB9XG4gICAgemkoW3tcbiAgICAgIG5hbWU6IFwidHJpYW5nbGVcIixcbiAgICAgIGNvbXBvbmVudHM6IDMsXG4gICAgICB0eXBlOiBcIlVpbnQxNlwiXG4gICAgfV0pLCB6aShbe1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJhbmNob3JYXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFuY2hvcllcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcImdseXBoU3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwibnVtR2x5cGhzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQzMlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0ZXhTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQzMlwiLFxuICAgICAgbmFtZTogXCJsaW5lU3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MzJcIixcbiAgICAgIG5hbWU6IFwibGluZUxlbmd0aFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwic2VnbWVudFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwibG93ZXJTaXplXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ1cHBlclNpemVcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgbmFtZTogXCJsaW5lT2Zmc2V0WFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICBuYW1lOiBcImxpbmVPZmZzZXRZXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQ4XCIsXG4gICAgICBuYW1lOiBcIndyaXRpbmdNb2RlXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQ4XCIsXG4gICAgICBuYW1lOiBcInBsYWNlZE9yaWVudGF0aW9uXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQ4XCIsXG4gICAgICBuYW1lOiBcImhpZGRlblwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MzJcIixcbiAgICAgIG5hbWU6IFwiY3Jvc3NUaWxlSURcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiYXNzb2NpYXRlZEljb25JbmRleFwiXG4gICAgfV0pLCB6aShbe1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJhbmNob3JYXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImFuY2hvcllcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwicmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwiY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcImxlZnRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwidmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwicGxhY2VkSWNvblN5bWJvbEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInZlcnRpY2FsUGxhY2VkSWNvblN5bWJvbEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJrZXlcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInRleHRCb3hTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ0ZXh0Qm94RW5kSW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInZlcnRpY2FsVGV4dEJveFN0YXJ0SW5kZXhcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcInZlcnRpY2FsVGV4dEJveEVuZEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJpY29uQm94U3RhcnRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwiaWNvbkJveEVuZEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0aWNhbEljb25Cb3hTdGFydEluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ2ZXJ0aWNhbEljb25Cb3hFbmRJbmRleFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwiZmVhdHVyZUluZGV4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJudW1Ib3Jpem9udGFsR2x5cGhWZXJ0aWNlc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MTZcIixcbiAgICAgIG5hbWU6IFwibnVtVmVydGljYWxHbHlwaFZlcnRpY2VzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJudW1JY29uVmVydGljZXNcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiVWludDE2XCIsXG4gICAgICBuYW1lOiBcIm51bVZlcnRpY2FsSWNvblZlcnRpY2VzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIlVpbnQxNlwiLFxuICAgICAgbmFtZTogXCJ1c2VSdW50aW1lQ29sbGlzaW9uQ2lyY2xlc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJVaW50MzJcIixcbiAgICAgIG5hbWU6IFwiY3Jvc3NUaWxlSURcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgbmFtZTogXCJ0ZXh0Qm94U2NhbGVcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiRmxvYXQzMlwiLFxuICAgICAgY29tcG9uZW50czogMixcbiAgICAgIG5hbWU6IFwidGV4dE9mZnNldFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJGbG9hdDMyXCIsXG4gICAgICBuYW1lOiBcImNvbGxpc2lvbkNpcmNsZURpYW1ldGVyXCJcbiAgICB9XSksIHppKFt7XG4gICAgICB0eXBlOiBcIkZsb2F0MzJcIixcbiAgICAgIG5hbWU6IFwib2Zmc2V0WFwiXG4gICAgfV0pLCB6aShbe1xuICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgbmFtZTogXCJ4XCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICBuYW1lOiBcInlcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgIG5hbWU6IFwidGlsZVVuaXREaXN0YW5jZUZyb21BbmNob3JcIlxuICAgIH1dKTtcbiAgICB2YXIgSnMgPSB7XG4gICAgICAgIFwiIVwiOiBcIu+4lVwiLFxuICAgICAgICBcIiNcIjogXCLvvINcIixcbiAgICAgICAgJDogXCLvvIRcIixcbiAgICAgICAgXCIlXCI6IFwi77yFXCIsXG4gICAgICAgIFwiJlwiOiBcIu+8hlwiLFxuICAgICAgICBcIihcIjogXCLvuLVcIixcbiAgICAgICAgXCIpXCI6IFwi77i2XCIsXG4gICAgICAgIFwiKlwiOiBcIu+8ilwiLFxuICAgICAgICBcIitcIjogXCLvvItcIixcbiAgICAgICAgXCIsXCI6IFwi77iQXCIsXG4gICAgICAgIFwiLVwiOiBcIu+4slwiLFxuICAgICAgICBcIi5cIjogXCLjg7tcIixcbiAgICAgICAgXCIvXCI6IFwi77yPXCIsXG4gICAgICAgIFwiOlwiOiBcIu+4k1wiLFxuICAgICAgICBcIjtcIjogXCLvuJRcIixcbiAgICAgICAgXCI8XCI6IFwi77i/XCIsXG4gICAgICAgIFwiPVwiOiBcIu+8nVwiLFxuICAgICAgICBcIj5cIjogXCLvuYBcIixcbiAgICAgICAgXCI/XCI6IFwi77iWXCIsXG4gICAgICAgIFwiQFwiOiBcIu+8oFwiLFxuICAgICAgICBcIltcIjogXCLvuYdcIixcbiAgICAgICAgXCJcXFxcXCI6IFwi77y8XCIsXG4gICAgICAgIFwiXVwiOiBcIu+5iFwiLFxuICAgICAgICBcIl5cIjogXCLvvL5cIixcbiAgICAgICAgXzogXCLvuLNcIixcbiAgICAgICAgXCJgXCI6IFwi772AXCIsXG4gICAgICAgIFwie1wiOiBcIu+4t1wiLFxuICAgICAgICBcInxcIjogXCLigJVcIixcbiAgICAgICAgXCJ9XCI6IFwi77i4XCIsXG4gICAgICAgIFwiflwiOiBcIu+9nlwiLFxuICAgICAgICBcIsKiXCI6IFwi77+gXCIsXG4gICAgICAgIFwiwqNcIjogXCLvv6FcIixcbiAgICAgICAgXCLCpVwiOiBcIu+/pVwiLFxuICAgICAgICBcIsKmXCI6IFwi77+kXCIsXG4gICAgICAgIFwiwqxcIjogXCLvv6JcIixcbiAgICAgICAgXCLCr1wiOiBcIu+/o1wiLFxuICAgICAgICBcIuKAk1wiOiBcIu+4slwiLFxuICAgICAgICBcIuKAlFwiOiBcIu+4sVwiLFxuICAgICAgICBcIuKAmFwiOiBcIu+5g1wiLFxuICAgICAgICBcIuKAmVwiOiBcIu+5hFwiLFxuICAgICAgICBcIuKAnFwiOiBcIu+5gVwiLFxuICAgICAgICBcIuKAnVwiOiBcIu+5glwiLFxuICAgICAgICBcIuKAplwiOiBcIu+4mVwiLFxuICAgICAgICBcIuKAp1wiOiBcIuODu1wiLFxuICAgICAgICBcIuKCqVwiOiBcIu+/plwiLFxuICAgICAgICBcIuOAgVwiOiBcIu+4kVwiLFxuICAgICAgICBcIuOAglwiOiBcIu+4klwiLFxuICAgICAgICBcIuOAiFwiOiBcIu+4v1wiLFxuICAgICAgICBcIuOAiVwiOiBcIu+5gFwiLFxuICAgICAgICBcIuOAilwiOiBcIu+4vVwiLFxuICAgICAgICBcIuOAi1wiOiBcIu+4vlwiLFxuICAgICAgICBcIuOAjFwiOiBcIu+5gVwiLFxuICAgICAgICBcIuOAjVwiOiBcIu+5glwiLFxuICAgICAgICBcIuOAjlwiOiBcIu+5g1wiLFxuICAgICAgICBcIuOAj1wiOiBcIu+5hFwiLFxuICAgICAgICBcIuOAkFwiOiBcIu+4u1wiLFxuICAgICAgICBcIuOAkVwiOiBcIu+4vFwiLFxuICAgICAgICBcIuOAlFwiOiBcIu+4uVwiLFxuICAgICAgICBcIuOAlVwiOiBcIu+4ulwiLFxuICAgICAgICBcIuOAllwiOiBcIu+4l1wiLFxuICAgICAgICBcIuOAl1wiOiBcIu+4mFwiLFxuICAgICAgICBcIu+8gVwiOiBcIu+4lVwiLFxuICAgICAgICBcIu+8iFwiOiBcIu+4tVwiLFxuICAgICAgICBcIu+8iVwiOiBcIu+4tlwiLFxuICAgICAgICBcIu+8jFwiOiBcIu+4kFwiLFxuICAgICAgICBcIu+8jVwiOiBcIu+4slwiLFxuICAgICAgICBcIu+8jlwiOiBcIuODu1wiLFxuICAgICAgICBcIu+8mlwiOiBcIu+4k1wiLFxuICAgICAgICBcIu+8m1wiOiBcIu+4lFwiLFxuICAgICAgICBcIu+8nFwiOiBcIu+4v1wiLFxuICAgICAgICBcIu+8nlwiOiBcIu+5gFwiLFxuICAgICAgICBcIu+8n1wiOiBcIu+4llwiLFxuICAgICAgICBcIu+8u1wiOiBcIu+5h1wiLFxuICAgICAgICBcIu+8vVwiOiBcIu+5iFwiLFxuICAgICAgICBcIu+8v1wiOiBcIu+4s1wiLFxuICAgICAgICBcIu+9m1wiOiBcIu+4t1wiLFxuICAgICAgICBcIu+9nFwiOiBcIuKAlVwiLFxuICAgICAgICBcIu+9nVwiOiBcIu+4uFwiLFxuICAgICAgICBcIu+9n1wiOiBcIu+4tVwiLFxuICAgICAgICBcIu+9oFwiOiBcIu+4tlwiLFxuICAgICAgICBcIu+9oVwiOiBcIu+4klwiLFxuICAgICAgICBcIu+9olwiOiBcIu+5gVwiLFxuICAgICAgICBcIu+9o1wiOiBcIu+5glwiXG4gICAgICB9LFxuICAgICAgSHMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB2YXIgYSxcbiAgICAgICAgICBvLFxuICAgICAgICAgIHMgPSA4ICogaSAtIG4gLSAxLFxuICAgICAgICAgIHUgPSAoMSA8PCBzKSAtIDEsXG4gICAgICAgICAgbCA9IHUgPj4gMSxcbiAgICAgICAgICBwID0gLTcsXG4gICAgICAgICAgYyA9IHIgPyBpIC0gMSA6IDAsXG4gICAgICAgICAgaCA9IHIgPyAtMSA6IDEsXG4gICAgICAgICAgZiA9IHRbZSArIGNdO1xuICAgICAgICBmb3IgKGMgKz0gaCwgYSA9IGYgJiAoMSA8PCAtcCkgLSAxLCBmID4+PSAtcCwgcCArPSBzOyBwID4gMDsgYSA9IDI1NiAqIGEgKyB0W2UgKyBjXSwgYyArPSBoLCBwIC09IDgpO1xuICAgICAgICBmb3IgKG8gPSBhICYgKDEgPDwgLXApIC0gMSwgYSA+Pj0gLXAsIHAgKz0gbjsgcCA+IDA7IG8gPSAyNTYgKiBvICsgdFtlICsgY10sIGMgKz0gaCwgcCAtPSA4KTtcbiAgICAgICAgaWYgKDAgPT09IGEpIGEgPSAxIC0gbDtlbHNlIHtcbiAgICAgICAgICBpZiAoYSA9PT0gdSkgcmV0dXJuIG8gPyBOYU4gOiAxIC8gMCAqIChmID8gLTEgOiAxKTtcbiAgICAgICAgICBvICs9IE1hdGgucG93KDIsIG4pLCBhIC09IGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChmID8gLTEgOiAxKSAqIG8gKiBNYXRoLnBvdygyLCBhIC0gbik7XG4gICAgICB9LFxuICAgICAgWXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgICB2YXIgbyxcbiAgICAgICAgICBzLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgbCA9IDggKiBhIC0gaSAtIDEsXG4gICAgICAgICAgcCA9ICgxIDw8IGwpIC0gMSxcbiAgICAgICAgICBjID0gcCA+PiAxLFxuICAgICAgICAgIGggPSAyMyA9PT0gaSA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCxcbiAgICAgICAgICBmID0gbiA/IDAgOiBhIC0gMSxcbiAgICAgICAgICB5ID0gbiA/IDEgOiAtMSxcbiAgICAgICAgICBkID0gZSA8IDAgfHwgMCA9PT0gZSAmJiAxIC8gZSA8IDAgPyAxIDogMDtcbiAgICAgICAgZm9yIChlID0gTWF0aC5hYnMoZSksIGlzTmFOKGUpIHx8IGUgPT09IDEgLyAwID8gKHMgPSBpc05hTihlKSA/IDEgOiAwLCBvID0gcCkgOiAobyA9IE1hdGguZmxvb3IoTWF0aC5sb2coZSkgLyBNYXRoLkxOMiksIGUgKiAodSA9IE1hdGgucG93KDIsIC1vKSkgPCAxICYmIChvLS0sIHUgKj0gMiksIChlICs9IG8gKyBjID49IDEgPyBoIC8gdSA6IGggKiBNYXRoLnBvdygyLCAxIC0gYykpICogdSA+PSAyICYmIChvKyssIHUgLz0gMiksIG8gKyBjID49IHAgPyAocyA9IDAsIG8gPSBwKSA6IG8gKyBjID49IDEgPyAocyA9IChlICogdSAtIDEpICogTWF0aC5wb3coMiwgaSksIG8gKz0gYykgOiAocyA9IGUgKiBNYXRoLnBvdygyLCBjIC0gMSkgKiBNYXRoLnBvdygyLCBpKSwgbyA9IDApKTsgaSA+PSA4OyB0W3IgKyBmXSA9IDI1NSAmIHMsIGYgKz0geSwgcyAvPSAyNTYsIGkgLT0gOCk7XG4gICAgICAgIGZvciAobyA9IG8gPDwgaSB8IHMsIGwgKz0gaTsgbCA+IDA7IHRbciArIGZdID0gMjU1ICYgbywgZiArPSB5LCBvIC89IDI1NiwgbCAtPSA4KTtcbiAgICAgICAgdFtyICsgZiAtIHldIHw9IDEyOCAqIGQ7XG4gICAgICB9LFxuICAgICAgJHMgPSBXcztcbiAgICBmdW5jdGlvbiBXcyh0KSB7XG4gICAgICB0aGlzLmJ1ZiA9IEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodCkgPyB0IDogbmV3IFVpbnQ4QXJyYXkodCB8fCAwKSwgdGhpcy5wb3MgPSAwLCB0aGlzLnR5cGUgPSAwLCB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgV3MuVmFyaW50ID0gMCwgV3MuRml4ZWQ2NCA9IDEsIFdzLkJ5dGVzID0gMiwgV3MuRml4ZWQzMiA9IDU7XG4gICAgdmFyIFFzID0gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgVGV4dERlY29kZXIgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTtcbiAgICBmdW5jdGlvbiB0dSh0KSB7XG4gICAgICByZXR1cm4gdC50eXBlID09PSBXcy5CeXRlcyA/IHQucmVhZFZhcmludCgpICsgdC5wb3MgOiB0LnBvcyArIDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV1KHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiByID8gNDI5NDk2NzI5NiAqIGUgKyAodCA+Pj4gMCkgOiA0Mjk0OTY3Mjk2ICogKGUgPj4+IDApICsgKHQgPj4+IDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUgPD0gMTYzODMgPyAxIDogZSA8PSAyMDk3MTUxID8gMiA6IGUgPD0gMjY4NDM1NDU1ID8gMyA6IE1hdGguZmxvb3IoTWF0aC5sb2coZSkgLyAoNyAqIE1hdGguTE4yKSk7XG4gICAgICByLnJlYWxsb2Mobik7XG4gICAgICBmb3IgKHZhciBpID0gci5wb3MgLSAxOyBpID49IHQ7IGktLSkgci5idWZbaSArIG5dID0gci5idWZbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykgZS53cml0ZVZhcmludCh0W3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSBlLndyaXRlU1ZhcmludCh0W3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSBlLndyaXRlRmxvYXQodFtyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG91KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykgZS53cml0ZURvdWJsZSh0W3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3UodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSBlLndyaXRlQm9vbGVhbih0W3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSBlLndyaXRlRml4ZWQzMih0W3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbHUodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSBlLndyaXRlU0ZpeGVkMzIodFtyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykgZS53cml0ZUZpeGVkNjQodFtyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1KHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykgZS53cml0ZVNGaXhlZDY0KHRbcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodSh0LCBlKSB7XG4gICAgICByZXR1cm4gKHRbZV0gfCB0W2UgKyAxXSA8PCA4IHwgdFtlICsgMl0gPDwgMTYpICsgMTY3NzcyMTYgKiB0W2UgKyAzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnUodCwgZSwgcikge1xuICAgICAgdFtyXSA9IGUsIHRbciArIDFdID0gZSA+Pj4gOCwgdFtyICsgMl0gPSBlID4+PiAxNiwgdFtyICsgM10gPSBlID4+PiAyNDtcbiAgICB9XG4gICAgZnVuY3Rpb24geXUodCwgZSkge1xuICAgICAgcmV0dXJuICh0W2VdIHwgdFtlICsgMV0gPDwgOCB8IHRbZSArIDJdIDw8IDE2KSArICh0W2UgKyAzXSA8PCAyNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGR1KHQsIGUsIHIpIHtcbiAgICAgIDEgPT09IHQgJiYgci5yZWFkTWVzc2FnZShtdSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11KHQsIGUsIHIpIHtcbiAgICAgIGlmICgzID09PSB0KSB7XG4gICAgICAgIHZhciBuID0gci5yZWFkTWVzc2FnZSh2dSwge30pLFxuICAgICAgICAgIGkgPSBuLndpZHRoLFxuICAgICAgICAgIGEgPSBuLmhlaWdodCxcbiAgICAgICAgICBvID0gbi5sZWZ0LFxuICAgICAgICAgIHMgPSBuLnRvcCxcbiAgICAgICAgICB1ID0gbi5hZHZhbmNlO1xuICAgICAgICBlLnB1c2goe1xuICAgICAgICAgIGlkOiBuLmlkLFxuICAgICAgICAgIGJpdG1hcDogbmV3IHhvKHtcbiAgICAgICAgICAgIHdpZHRoOiBpICsgNixcbiAgICAgICAgICAgIGhlaWdodDogYSArIDZcbiAgICAgICAgICB9LCBuLmJpdG1hcCksXG4gICAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgICAgd2lkdGg6IGksXG4gICAgICAgICAgICBoZWlnaHQ6IGEsXG4gICAgICAgICAgICBsZWZ0OiBvLFxuICAgICAgICAgICAgdG9wOiBzLFxuICAgICAgICAgICAgYWR2YW5jZTogdVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZ1KHQsIGUsIHIpIHtcbiAgICAgIDEgPT09IHQgPyBlLmlkID0gci5yZWFkVmFyaW50KCkgOiAyID09PSB0ID8gZS5iaXRtYXAgPSByLnJlYWRCeXRlcygpIDogMyA9PT0gdCA/IGUud2lkdGggPSByLnJlYWRWYXJpbnQoKSA6IDQgPT09IHQgPyBlLmhlaWdodCA9IHIucmVhZFZhcmludCgpIDogNSA9PT0gdCA/IGUubGVmdCA9IHIucmVhZFNWYXJpbnQoKSA6IDYgPT09IHQgPyBlLnRvcCA9IHIucmVhZFNWYXJpbnQoKSA6IDcgPT09IHQgJiYgKGUuYWR2YW5jZSA9IHIucmVhZFZhcmludCgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3UodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gMCwgaSA9IHQ7IG4gPCBpLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBhID0gaVtuXTtcbiAgICAgICAgZSArPSBhLncgKiBhLmgsIHIgPSBNYXRoLm1heChyLCBhLncpO1xuICAgICAgfVxuICAgICAgdC5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBlLmggLSB0Lmg7XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIG8gPSBbe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3OiBNYXRoLm1heChNYXRoLmNlaWwoTWF0aC5zcXJ0KGUgLyAuOTUpKSwgciksXG4gICAgICAgICAgaDogMSAvIDBcbiAgICAgICAgfV0sIHMgPSAwLCB1ID0gMCwgbCA9IDAsIHAgPSB0OyBsIDwgcC5sZW5ndGg7IGwgKz0gMSkgZm9yICh2YXIgYyA9IHBbbF0sIGggPSBvLmxlbmd0aCAtIDE7IGggPj0gMDsgaC0tKSB7XG4gICAgICAgIHZhciBmID0gb1toXTtcbiAgICAgICAgaWYgKCEoYy53ID4gZi53IHx8IGMuaCA+IGYuaCkpIHtcbiAgICAgICAgICBpZiAoYy54ID0gZi54LCBjLnkgPSBmLnksIHUgPSBNYXRoLm1heCh1LCBjLnkgKyBjLmgpLCBzID0gTWF0aC5tYXgocywgYy54ICsgYy53KSwgYy53ID09PSBmLncgJiYgYy5oID09PSBmLmgpIHtcbiAgICAgICAgICAgIHZhciB5ID0gby5wb3AoKTtcbiAgICAgICAgICAgIGggPCBvLmxlbmd0aCAmJiAob1toXSA9IHkpO1xuICAgICAgICAgIH0gZWxzZSBjLmggPT09IGYuaCA/IChmLnggKz0gYy53LCBmLncgLT0gYy53KSA6IGMudyA9PT0gZi53ID8gKGYueSArPSBjLmgsIGYuaCAtPSBjLmgpIDogKG8ucHVzaCh7XG4gICAgICAgICAgICB4OiBmLnggKyBjLncsXG4gICAgICAgICAgICB5OiBmLnksXG4gICAgICAgICAgICB3OiBmLncgLSBjLncsXG4gICAgICAgICAgICBoOiBjLmhcbiAgICAgICAgICB9KSwgZi55ICs9IGMuaCwgZi5oIC09IGMuaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHMsXG4gICAgICAgIGg6IHUsXG4gICAgICAgIGZpbGw6IGUgLyAocyAqIHUpIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICAgIFdzLnByb3RvdHlwZSA9IHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5idWYgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHJlYWRGaWVsZHM6IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIGZvciAociA9IHIgfHwgdGhpcy5sZW5ndGg7IHRoaXMucG9zIDwgcjspIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgaSA9IG4gPj4gMyxcbiAgICAgICAgICAgIGEgPSB0aGlzLnBvcztcbiAgICAgICAgICB0aGlzLnR5cGUgPSA3ICYgbiwgdChpLCBlLCB0aGlzKSwgdGhpcy5wb3MgPT09IGEgJiYgdGhpcy5za2lwKG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmllbGRzKHQsIGUsIHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MpO1xuICAgICAgfSxcbiAgICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gaHUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zICs9IDQsIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFNGaXhlZDMyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0geXUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zICs9IDQsIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZEZpeGVkNjQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBodSh0aGlzLmJ1ZiwgdGhpcy5wb3MpICsgNDI5NDk2NzI5NiAqIGh1KHRoaXMuYnVmLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gOCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBodSh0aGlzLmJ1ZiwgdGhpcy5wb3MpICsgNDI5NDk2NzI5NiAqIHl1KHRoaXMuYnVmLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKz0gOCwgdDtcbiAgICAgIH0sXG4gICAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBIcyh0aGlzLmJ1ZiwgdGhpcy5wb3MsICEwLCAyMywgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArPSA0LCB0O1xuICAgICAgfSxcbiAgICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBIcyh0aGlzLmJ1ZiwgdGhpcy5wb3MsICEwLCA1MiwgOCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArPSA4LCB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgbiA9IHRoaXMuYnVmO1xuICAgICAgICByZXR1cm4gZSA9IDEyNyAmIChyID0gblt0aGlzLnBvcysrXSksIHIgPCAxMjggPyBlIDogKGUgfD0gKDEyNyAmIChyID0gblt0aGlzLnBvcysrXSkpIDw8IDcsIHIgPCAxMjggPyBlIDogKGUgfD0gKDEyNyAmIChyID0gblt0aGlzLnBvcysrXSkpIDw8IDE0LCByIDwgMTI4ID8gZSA6IChlIHw9ICgxMjcgJiAociA9IG5bdGhpcy5wb3MrK10pKSA8PCAyMSwgciA8IDEyOCA/IGUgOiBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgIHZhciBuLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGEgPSByLmJ1ZjtcbiAgICAgICAgICBpZiAobiA9ICgxMTIgJiAoaSA9IGFbci5wb3MrK10pKSA+PiA0LCBpIDwgMTI4KSByZXR1cm4gZXUodCwgbiwgZSk7XG4gICAgICAgICAgaWYgKG4gfD0gKDEyNyAmIChpID0gYVtyLnBvcysrXSkpIDw8IDMsIGkgPCAxMjgpIHJldHVybiBldSh0LCBuLCBlKTtcbiAgICAgICAgICBpZiAobiB8PSAoMTI3ICYgKGkgPSBhW3IucG9zKytdKSkgPDwgMTAsIGkgPCAxMjgpIHJldHVybiBldSh0LCBuLCBlKTtcbiAgICAgICAgICBpZiAobiB8PSAoMTI3ICYgKGkgPSBhW3IucG9zKytdKSkgPDwgMTcsIGkgPCAxMjgpIHJldHVybiBldSh0LCBuLCBlKTtcbiAgICAgICAgICBpZiAobiB8PSAoMTI3ICYgKGkgPSBhW3IucG9zKytdKSkgPDwgMjQsIGkgPCAxMjgpIHJldHVybiBldSh0LCBuLCBlKTtcbiAgICAgICAgICBpZiAobiB8PSAoMSAmIChpID0gYVtyLnBvcysrXSkpIDw8IDMxLCBpIDwgMTI4KSByZXR1cm4gZXUodCwgbiwgZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdmFyaW50IG5vdCBtb3JlIHRoYW4gMTAgYnl0ZXNcIik7XG4gICAgICAgIH0oZSB8PSAoMTUgJiAociA9IG5bdGhpcy5wb3NdKSkgPDwgMjgsIHQsIHRoaXMpKSkpO1xuICAgICAgfSxcbiAgICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVmFyaW50KCEwKTtcbiAgICAgIH0sXG4gICAgICByZWFkU1ZhcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgICAgICByZXR1cm4gdCAlIDIgPT0gMSA/ICh0ICsgMSkgLyAtMiA6IHQgLyAyO1xuICAgICAgfSxcbiAgICAgIHJlYWRCb29sZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICAgIH0sXG4gICAgICByZWFkU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyxcbiAgICAgICAgICBlID0gdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA9IHQsIHQgLSBlID49IDEyICYmIFFzID8gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICByZXR1cm4gUXMuZGVjb2RlKHQuc3ViYXJyYXkoZSwgcikpO1xuICAgICAgICB9KHRoaXMuYnVmLCBlLCB0KSA6IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IFwiXCIsIGkgPSBlOyBpIDwgcjspIHtcbiAgICAgICAgICAgIHZhciBhLFxuICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICB1ID0gdFtpXSxcbiAgICAgICAgICAgICAgbCA9IG51bGwsXG4gICAgICAgICAgICAgIHAgPSB1ID4gMjM5ID8gNCA6IHUgPiAyMjMgPyAzIDogdSA+IDE5MSA/IDIgOiAxO1xuICAgICAgICAgICAgaWYgKGkgKyBwID4gcikgYnJlYWs7XG4gICAgICAgICAgICAxID09PSBwID8gdSA8IDEyOCAmJiAobCA9IHUpIDogMiA9PT0gcCA/IDEyOCA9PSAoMTkyICYgKGEgPSB0W2kgKyAxXSkpICYmIChsID0gKDMxICYgdSkgPDwgNiB8IDYzICYgYSkgPD0gMTI3ICYmIChsID0gbnVsbCkgOiAzID09PSBwID8gKG8gPSB0W2kgKyAyXSwgMTI4ID09ICgxOTIgJiAoYSA9IHRbaSArIDFdKSkgJiYgMTI4ID09ICgxOTIgJiBvKSAmJiAoKGwgPSAoMTUgJiB1KSA8PCAxMiB8ICg2MyAmIGEpIDw8IDYgfCA2MyAmIG8pIDw9IDIwNDcgfHwgbCA+PSA1NTI5NiAmJiBsIDw9IDU3MzQzKSAmJiAobCA9IG51bGwpKSA6IDQgPT09IHAgJiYgKG8gPSB0W2kgKyAyXSwgcyA9IHRbaSArIDNdLCAxMjggPT0gKDE5MiAmIChhID0gdFtpICsgMV0pKSAmJiAxMjggPT0gKDE5MiAmIG8pICYmIDEyOCA9PSAoMTkyICYgcykgJiYgKChsID0gKDE1ICYgdSkgPDwgMTggfCAoNjMgJiBhKSA8PCAxMiB8ICg2MyAmIG8pIDw8IDYgfCA2MyAmIHMpIDw9IDY1NTM1IHx8IGwgPj0gMTExNDExMikgJiYgKGwgPSBudWxsKSksIG51bGwgPT09IGwgPyAobCA9IDY1NTMzLCBwID0gMSkgOiBsID4gNjU1MzUgJiYgKGwgLT0gNjU1MzYsIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsID4+PiAxMCAmIDEwMjMgfCA1NTI5NiksIGwgPSA1NjMyMCB8IDEwMjMgJiBsKSwgbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGwpLCBpICs9IHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9KHRoaXMuYnVmLCBlLCB0KTtcbiAgICAgIH0sXG4gICAgICByZWFkQnl0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgIGUgPSB0aGlzLmJ1Zi5zdWJhcnJheSh0aGlzLnBvcywgdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA9IHQsIGU7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZFZhcmludDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gV3MuQnl0ZXMpIHJldHVybiB0LnB1c2godGhpcy5yZWFkVmFyaW50KGUpKTtcbiAgICAgICAgdmFyIHIgPSB0dSh0aGlzKTtcbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCByOykgdC5wdXNoKHRoaXMucmVhZFZhcmludChlKSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRTVmFyaW50OiBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBXcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRTVmFyaW50KCkpO1xuICAgICAgICB2YXIgZSA9IHR1KHRoaXMpO1xuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB0LnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZEJvb2xlYW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHZhciBlID0gdHUodGhpcyk7XG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHQucHVzaCh0aGlzLnJlYWRCb29sZWFuKCkpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZEZsb2F0KCkpO1xuICAgICAgICB2YXIgZSA9IHR1KHRoaXMpO1xuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB0LnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWREb3VibGU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgdmFyIGUgPSB0dSh0aGlzKTtcbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCBlOykgdC5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZEZpeGVkMzI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHZhciBlID0gdHUodGhpcyk7XG4gICAgICAgIGZvciAodCA9IHQgfHwgW107IHRoaXMucG9zIDwgZTspIHQucHVzaCh0aGlzLnJlYWRGaXhlZDMyKCkpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFdzLkJ5dGVzKSByZXR1cm4gdC5wdXNoKHRoaXMucmVhZFNGaXhlZDMyKCkpO1xuICAgICAgICB2YXIgZSA9IHR1KHRoaXMpO1xuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB0LnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfSxcbiAgICAgIHJlYWRQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBXcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICB2YXIgZSA9IHR1KHRoaXMpO1xuICAgICAgICBmb3IgKHQgPSB0IHx8IFtdOyB0aGlzLnBvcyA8IGU7KSB0LnB1c2godGhpcy5yZWFkRml4ZWQ2NCgpKTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBXcy5CeXRlcykgcmV0dXJuIHQucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTtcbiAgICAgICAgdmFyIGUgPSB0dSh0aGlzKTtcbiAgICAgICAgZm9yICh0ID0gdCB8fCBbXTsgdGhpcy5wb3MgPCBlOykgdC5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG4gICAgICBza2lwOiBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IDcgJiB0O1xuICAgICAgICBpZiAoZSA9PT0gV3MuVmFyaW50KSBmb3IgKDsgdGhpcy5idWZbdGhpcy5wb3MrK10gPiAxMjc7KTtlbHNlIGlmIChlID09PSBXcy5CeXRlcykgdGhpcy5wb3MgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zO2Vsc2UgaWYgKGUgPT09IFdzLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7ZWxzZSB7XG4gICAgICAgICAgaWYgKGUgIT09IFdzLkZpeGVkNjQpIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQgdHlwZTogXCIgKyBlKTtcbiAgICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGVUYWc6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodCA8PCAzIHwgZSk7XG4gICAgICB9LFxuICAgICAgcmVhbGxvYzogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMubGVuZ3RoIHx8IDE2OyBlIDwgdGhpcy5wb3MgKyB0OykgZSAqPSAyO1xuICAgICAgICBpZiAoZSAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgciA9IG5ldyBVaW50OEFycmF5KGUpO1xuICAgICAgICAgIHIuc2V0KHRoaXMuYnVmKSwgdGhpcy5idWYgPSByLCB0aGlzLmxlbmd0aCA9IGU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gdGhpcy5wb3MsIHRoaXMucG9zID0gMCwgdGhpcy5idWYuc3ViYXJyYXkoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRml4ZWQzMjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpLCBmdSh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSA0O1xuICAgICAgfSxcbiAgICAgIHdyaXRlU0ZpeGVkMzI6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KSwgZnUodGhpcy5idWYsIHQsIHRoaXMucG9zKSwgdGhpcy5wb3MgKz0gNDtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZpeGVkNjQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KSwgZnUodGhpcy5idWYsIC0xICYgdCwgdGhpcy5wb3MpLCBmdSh0aGlzLmJ1ZiwgTWF0aC5mbG9vcih0ICogKDEgLyA0Mjk0OTY3Mjk2KSksIHRoaXMucG9zICsgNCksIHRoaXMucG9zICs9IDg7XG4gICAgICB9LFxuICAgICAgd3JpdGVTRml4ZWQ2NDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpLCBmdSh0aGlzLmJ1ZiwgLTEgJiB0LCB0aGlzLnBvcyksIGZ1KHRoaXMuYnVmLCBNYXRoLmZsb29yKHQgKiAoMSAvIDQyOTQ5NjcyOTYpKSwgdGhpcy5wb3MgKyA0KSwgdGhpcy5wb3MgKz0gODtcbiAgICAgIH0sXG4gICAgICB3cml0ZVZhcmludDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgKHQgPSArdCB8fCAwKSA+IDI2ODQzNTQ1NSB8fCB0IDwgMCA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIHIsIG47XG4gICAgICAgICAgaWYgKHQgPj0gMCA/IChyID0gdCAlIDQyOTQ5NjcyOTYgfCAwLCBuID0gdCAvIDQyOTQ5NjcyOTYgfCAwKSA6IChuID0gfigtdCAvIDQyOTQ5NjcyOTYpLCA0Mjk0OTY3Mjk1IF4gKHIgPSB+KC10ICUgNDI5NDk2NzI5NikpID8gciA9IHIgKyAxIHwgMCA6IChyID0gMCwgbiA9IG4gKyAxIHwgMCkpLCB0ID49IDB4MTAwMDAwMDAwMDAwMDAwMDAgfHwgdCA8IC0weDEwMDAwMDAwMDAwMDAwMDAwKSB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiB2YXJpbnQgZG9lc24ndCBmaXQgaW50byAxMCBieXRlc1wiKTtcbiAgICAgICAgICBlLnJlYWxsb2MoMTApLCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgICAgICAgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCB0ID4+Pj0gNywgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCB0ID4+Pj0gNywgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCB0ID4+Pj0gNywgci5idWZbci5wb3MrK10gPSAxMjcgJiB0IHwgMTI4LCByLmJ1ZltyLnBvc10gPSAxMjcgJiAodCA+Pj49IDcpO1xuICAgICAgICAgIH0ociwgMCwgZSksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICB2YXIgciA9ICg3ICYgdCkgPDwgNDtcbiAgICAgICAgICAgIGUuYnVmW2UucG9zKytdIHw9IHIgfCAoKHQgPj4+PSAzKSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQgfCAoKHQgPj4+PSA3KSA/IDEyOCA6IDApLCB0ICYmIChlLmJ1ZltlLnBvcysrXSA9IDEyNyAmIHQpKSkpKTtcbiAgICAgICAgICB9KG4sIGUpO1xuICAgICAgICB9KHQsIHRoaXMpIDogKHRoaXMucmVhbGxvYyg0KSwgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAxMjcgJiB0IHwgKHQgPiAxMjcgPyAxMjggOiAwKSwgdCA8PSAxMjcgfHwgKHRoaXMuYnVmW3RoaXMucG9zKytdID0gMTI3ICYgKHQgPj4+PSA3KSB8ICh0ID4gMTI3ID8gMTI4IDogMCksIHQgPD0gMTI3IHx8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IDEyNyAmICh0ID4+Pj0gNykgfCAodCA+IDEyNyA/IDEyOCA6IDApLCB0IDw9IDEyNyB8fCAodGhpcy5idWZbdGhpcy5wb3MrK10gPSB0ID4+PiA3ICYgMTI3KSkpKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVNWYXJpbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodCA8IDAgPyAyICogLXQgLSAxIDogMiAqIHQpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChCb29sZWFuKHQpKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVN0cmluZzogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdCA9IFN0cmluZyh0KSwgdGhpcy5yZWFsbG9jKDQgKiB0Lmxlbmd0aCksIHRoaXMucG9zKys7XG4gICAgICAgIHZhciBlID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICBmb3IgKHZhciBuLCBpLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIGlmICgobiA9IGUuY2hhckNvZGVBdChhKSkgPiA1NTI5NSAmJiBuIDwgNTczNDQpIHtcbiAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgbiA+IDU2MzE5IHx8IGEgKyAxID09PSBlLmxlbmd0aCA/ICh0W3IrK10gPSAyMzksIHRbcisrXSA9IDE5MSwgdFtyKytdID0gMTg5KSA6IGkgPSBuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuIDwgNTYzMjApIHtcbiAgICAgICAgICAgICAgICB0W3IrK10gPSAyMzksIHRbcisrXSA9IDE5MSwgdFtyKytdID0gMTg5LCBpID0gbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuID0gaSAtIDU1Mjk2IDw8IDEwIHwgbiAtIDU2MzIwIHwgNjU1MzYsIGkgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGkgJiYgKHRbcisrXSA9IDIzOSwgdFtyKytdID0gMTkxLCB0W3IrK10gPSAxODksIGkgPSBudWxsKTtcbiAgICAgICAgICAgIG4gPCAxMjggPyB0W3IrK10gPSBuIDogKG4gPCAyMDQ4ID8gdFtyKytdID0gbiA+PiA2IHwgMTkyIDogKG4gPCA2NTUzNiA/IHRbcisrXSA9IG4gPj4gMTIgfCAyMjQgOiAodFtyKytdID0gbiA+PiAxOCB8IDI0MCwgdFtyKytdID0gbiA+PiAxMiAmIDYzIHwgMTI4KSwgdFtyKytdID0gbiA+PiA2ICYgNjMgfCAxMjgpLCB0W3IrK10gPSA2MyAmIG4gfCAxMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MpO1xuICAgICAgICB2YXIgciA9IHRoaXMucG9zIC0gZTtcbiAgICAgICAgciA+PSAxMjggJiYgcnUoZSwgciwgdGhpcyksIHRoaXMucG9zID0gZSAtIDEsIHRoaXMud3JpdGVWYXJpbnQociksIHRoaXMucG9zICs9IHI7XG4gICAgICB9LFxuICAgICAgd3JpdGVGbG9hdDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpLCBZcyh0aGlzLmJ1ZiwgdCwgdGhpcy5wb3MsICEwLCAyMywgNCksIHRoaXMucG9zICs9IDQ7XG4gICAgICB9LFxuICAgICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KSwgWXModGhpcy5idWYsIHQsIHRoaXMucG9zLCAhMCwgNTIsIDgpLCB0aGlzLnBvcyArPSA4O1xuICAgICAgfSxcbiAgICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdC5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoZSksIHRoaXMucmVhbGxvYyhlKTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBlOyByKyspIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdFtyXTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVJhd01lc3NhZ2U6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIHZhciByID0gdGhpcy5wb3M7XG4gICAgICAgIHQoZSwgdGhpcyk7XG4gICAgICAgIHZhciBuID0gdGhpcy5wb3MgLSByO1xuICAgICAgICBuID49IDEyOCAmJiBydShyLCBuLCB0aGlzKSwgdGhpcy5wb3MgPSByIC0gMSwgdGhpcy53cml0ZVZhcmludChuKSwgdGhpcy5wb3MgKz0gbjtcbiAgICAgIH0sXG4gICAgICB3cml0ZU1lc3NhZ2U6IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuQnl0ZXMpLCB0aGlzLndyaXRlUmF3TWVzc2FnZShlLCByKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZFZhcmludDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgbnUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkU1ZhcmludDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgaXUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkQm9vbGVhbjogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgc3UsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkRmxvYXQ6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIGF1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZERvdWJsZTogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgb3UsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkRml4ZWQzMjogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgZS5sZW5ndGggJiYgdGhpcy53cml0ZU1lc3NhZ2UodCwgdXUsIGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIGx1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZEZpeGVkNjQ6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGUubGVuZ3RoICYmIHRoaXMud3JpdGVNZXNzYWdlKHQsIHB1LCBlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBlLmxlbmd0aCAmJiB0aGlzLndyaXRlTWVzc2FnZSh0LCBjdSwgZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVCeXRlc0ZpZWxkOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLkJ5dGVzKSwgdGhpcy53cml0ZUJ5dGVzKGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLkZpeGVkMzIpLCB0aGlzLndyaXRlRml4ZWQzMihlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVNGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuRml4ZWQzMiksIHRoaXMud3JpdGVTRml4ZWQzMihlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZUZpeGVkNjRGaWVsZDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5GaXhlZDY0KSwgdGhpcy53cml0ZUZpeGVkNjQoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLkZpeGVkNjQpLCB0aGlzLndyaXRlU0ZpeGVkNjQoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVWYXJpbnRGaWVsZDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5WYXJpbnQpLCB0aGlzLndyaXRlVmFyaW50KGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU1ZhcmludEZpZWxkOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHQsIFdzLlZhcmludCksIHRoaXMud3JpdGVTVmFyaW50KGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuQnl0ZXMpLCB0aGlzLndyaXRlU3RyaW5nKGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRmxvYXRGaWVsZDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0LCBXcy5GaXhlZDMyKSwgdGhpcy53cml0ZUZsb2F0KGUpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlRG91YmxlRmllbGQ6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodCwgV3MuRml4ZWQ2NCksIHRoaXMud3JpdGVEb3VibGUoZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0LCBCb29sZWFuKGUpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB4dSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciByID0gZS5waXhlbFJhdGlvLFxuICAgICAgICAgIG4gPSBlLnZlcnNpb24sXG4gICAgICAgICAgaSA9IGUuc3RyZXRjaFgsXG4gICAgICAgICAgYSA9IGUuc3RyZXRjaFksXG4gICAgICAgICAgbyA9IGUuY29udGVudDtcbiAgICAgICAgdGhpcy5wYWRkZWRSZWN0ID0gdCwgdGhpcy5waXhlbFJhdGlvID0gciwgdGhpcy5zdHJldGNoWCA9IGksIHRoaXMuc3RyZXRjaFkgPSBhLCB0aGlzLmNvbnRlbnQgPSBvLCB0aGlzLnZlcnNpb24gPSBuO1xuICAgICAgfSxcbiAgICAgIGJ1ID0ge1xuICAgICAgICB0bDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYnI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHRsYnI6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXlTaXplOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIGJ1LnRsLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbdGhpcy5wYWRkZWRSZWN0LnggKyAxLCB0aGlzLnBhZGRlZFJlY3QueSArIDFdO1xuICAgIH0sIGJ1LmJyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbdGhpcy5wYWRkZWRSZWN0LnggKyB0aGlzLnBhZGRlZFJlY3QudyAtIDEsIHRoaXMucGFkZGVkUmVjdC55ICsgdGhpcy5wYWRkZWRSZWN0LmggLSAxXTtcbiAgICB9LCBidS50bGJyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRsLmNvbmNhdCh0aGlzLmJyKTtcbiAgICB9LCBidS5kaXNwbGF5U2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWyh0aGlzLnBhZGRlZFJlY3QudyAtIDIpIC8gdGhpcy5waXhlbFJhdGlvLCAodGhpcy5wYWRkZWRSZWN0LmggLSAyKSAvIHRoaXMucGl4ZWxSYXRpb107XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoeHUucHJvdG90eXBlLCBidSk7XG4gICAgdmFyIHd1ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0ge30sXG4gICAgICAgIG4gPSB7fTtcbiAgICAgIHRoaXMuaGF2ZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICAgICAgdmFyIGkgPSBbXTtcbiAgICAgIHRoaXMuYWRkSW1hZ2VzKHQsIHIsIGkpLCB0aGlzLmFkZEltYWdlcyhlLCBuLCBpKTtcbiAgICAgIHZhciBhID0gZ3UoaSksXG4gICAgICAgIG8gPSBuZXcgYm8oe1xuICAgICAgICAgIHdpZHRoOiBhLncgfHwgMSxcbiAgICAgICAgICBoZWlnaHQ6IGEuaCB8fCAxXG4gICAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgcyBpbiB0KSB7XG4gICAgICAgIHZhciB1ID0gdFtzXSxcbiAgICAgICAgICBsID0gcltzXS5wYWRkZWRSZWN0O1xuICAgICAgICBiby5jb3B5KHUuZGF0YSwgbywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogbC54ICsgMSxcbiAgICAgICAgICB5OiBsLnkgKyAxXG4gICAgICAgIH0sIHUuZGF0YSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwIGluIGUpIHtcbiAgICAgICAgdmFyIGMgPSBlW3BdLFxuICAgICAgICAgIGggPSBuW3BdLnBhZGRlZFJlY3QsXG4gICAgICAgICAgZiA9IGgueCArIDEsXG4gICAgICAgICAgeSA9IGgueSArIDEsXG4gICAgICAgICAgZCA9IGMuZGF0YS53aWR0aCxcbiAgICAgICAgICBtID0gYy5kYXRhLmhlaWdodDtcbiAgICAgICAgYm8uY29weShjLmRhdGEsIG8sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGYsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9LCBjLmRhdGEpLCBiby5jb3B5KGMuZGF0YSwgbywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogbSAtIDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGYsXG4gICAgICAgICAgeTogeSAtIDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHdpZHRoOiBkLFxuICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9KSwgYm8uY29weShjLmRhdGEsIG8sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGYsXG4gICAgICAgICAgeTogeSArIG1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHdpZHRoOiBkLFxuICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9KSwgYm8uY29weShjLmRhdGEsIG8sIHtcbiAgICAgICAgICB4OiBkIC0gMSxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBmIC0gMSxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBoZWlnaHQ6IG1cbiAgICAgICAgfSksIGJvLmNvcHkoYy5kYXRhLCBvLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBmICsgZCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICBoZWlnaHQ6IG1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmltYWdlID0gbywgdGhpcy5pY29uUG9zaXRpb25zID0gciwgdGhpcy5wYXR0ZXJuUG9zaXRpb25zID0gbjtcbiAgICB9O1xuICAgIHd1LnByb3RvdHlwZS5hZGRJbWFnZXMgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiBpbiB0KSB7XG4gICAgICAgIHZhciBpID0gdFtuXSxcbiAgICAgICAgICBhID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3OiBpLmRhdGEud2lkdGggKyAyLFxuICAgICAgICAgICAgaDogaS5kYXRhLmhlaWdodCArIDJcbiAgICAgICAgICB9O1xuICAgICAgICByLnB1c2goYSksIGVbbl0gPSBuZXcgeHUoYSwgaSksIGkuaGFzUmVuZGVyQ2FsbGJhY2sgJiYgdGhpcy5oYXZlUmVuZGVyQ2FsbGJhY2tzLnB1c2gobik7XG4gICAgICB9XG4gICAgfSwgd3UucHJvdG90eXBlLnBhdGNoVXBkYXRlZEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByIGluIHQuZGlzcGF0Y2hSZW5kZXJDYWxsYmFja3ModGhpcy5oYXZlUmVuZGVyQ2FsbGJhY2tzKSwgdC51cGRhdGVkSW1hZ2VzKSB0aGlzLnBhdGNoVXBkYXRlZEltYWdlKHRoaXMuaWNvblBvc2l0aW9uc1tyXSwgdC5nZXRJbWFnZShyKSwgZSksIHRoaXMucGF0Y2hVcGRhdGVkSW1hZ2UodGhpcy5wYXR0ZXJuUG9zaXRpb25zW3JdLCB0LmdldEltYWdlKHIpLCBlKTtcbiAgICB9LCB3dS5wcm90b3R5cGUucGF0Y2hVcGRhdGVkSW1hZ2UgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHQgJiYgZSAmJiB0LnZlcnNpb24gIT09IGUudmVyc2lvbikge1xuICAgICAgICB0LnZlcnNpb24gPSBlLnZlcnNpb247XG4gICAgICAgIHZhciBuID0gdC50bDtcbiAgICAgICAgci51cGRhdGUoZS5kYXRhLCB2b2lkIDAsIHtcbiAgICAgICAgICB4OiBuWzBdLFxuICAgICAgICAgIHk6IG5bMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgT24oXCJJbWFnZVBvc2l0aW9uXCIsIHh1KSwgT24oXCJJbWFnZUF0bGFzXCIsIHd1KTtcbiAgICB2YXIgX3UgPSB7XG4gICAgICAgIGhvcml6b250YWw6IDEsXG4gICAgICAgIHZlcnRpY2FsOiAyLFxuICAgICAgICBob3Jpem9udGFsT25seTogM1xuICAgICAgfSxcbiAgICAgIEF1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjYWxlID0gMSwgdGhpcy5mb250U3RhY2sgPSBcIlwiLCB0aGlzLmltYWdlTmFtZSA9IG51bGw7XG4gICAgICB9O1xuICAgIEF1LmZvclRleHQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBuZXcgQXUoKTtcbiAgICAgIHJldHVybiByLnNjYWxlID0gdCB8fCAxLCByLmZvbnRTdGFjayA9IGUsIHI7XG4gICAgfSwgQXUuZm9ySW1hZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBuZXcgQXUoKTtcbiAgICAgIHJldHVybiBlLmltYWdlTmFtZSA9IHQsIGU7XG4gICAgfTtcbiAgICB2YXIgU3UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRleHQgPSBcIlwiLCB0aGlzLnNlY3Rpb25JbmRleCA9IFtdLCB0aGlzLnNlY3Rpb25zID0gW10sIHRoaXMuaW1hZ2VTZWN0aW9uSUQgPSBudWxsO1xuICAgIH07XG4gICAgZnVuY3Rpb24ga3UodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCwgYywgaCwgZiwgeSwgZCkge1xuICAgICAgdmFyIG0sXG4gICAgICAgIHYgPSBTdS5mcm9tRmVhdHVyZSh0LCBpKTtcbiAgICAgIGMgPT09IF91LnZlcnRpY2FsICYmIHYudmVydGljYWxpemVQdW5jdHVhdGlvbigpO1xuICAgICAgdmFyIGcgPSBzaS5wcm9jZXNzQmlkaXJlY3Rpb25hbFRleHQsXG4gICAgICAgIHggPSBzaS5wcm9jZXNzU3R5bGVkQmlkaXJlY3Rpb25hbFRleHQ7XG4gICAgICBpZiAoZyAmJiAxID09PSB2LnNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICBtID0gW107XG4gICAgICAgIGZvciAodmFyIGIgPSAwLCB3ID0gZyh2LnRvU3RyaW5nKCksIEJ1KHYsIGwsIGEsIGUsIG4sIGYsIHkpKTsgYiA8IHcubGVuZ3RoOyBiICs9IDEpIHtcbiAgICAgICAgICB2YXIgXyA9IHdbYl0sXG4gICAgICAgICAgICBBID0gbmV3IFN1KCk7XG4gICAgICAgICAgQS50ZXh0ID0gXywgQS5zZWN0aW9ucyA9IHYuc2VjdGlvbnM7XG4gICAgICAgICAgZm9yICh2YXIgUyA9IDA7IFMgPCBfLmxlbmd0aDsgUysrKSBBLnNlY3Rpb25JbmRleC5wdXNoKDApO1xuICAgICAgICAgIG0ucHVzaChBKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4KSB7XG4gICAgICAgIG0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIEkgPSB4KHYudGV4dCwgdi5zZWN0aW9uSW5kZXgsIEJ1KHYsIGwsIGEsIGUsIG4sIGYsIHkpKTsgayA8IEkubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICB2YXIgeiA9IElba10sXG4gICAgICAgICAgICBDID0gbmV3IFN1KCk7XG4gICAgICAgICAgQy50ZXh0ID0gelswXSwgQy5zZWN0aW9uSW5kZXggPSB6WzFdLCBDLnNlY3Rpb25zID0gdi5zZWN0aW9ucywgbS5wdXNoKEMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgbSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSBbXSwgbiA9IHQudGV4dCwgaSA9IDAsIGEgPSAwLCBvID0gZTsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICB2YXIgcyA9IG9bYV07XG4gICAgICAgICAgci5wdXNoKHQuc3Vic3RyaW5nKGksIHMpKSwgaSA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkgPCBuLmxlbmd0aCAmJiByLnB1c2godC5zdWJzdHJpbmcoaSwgbi5sZW5ndGgpKSwgcjtcbiAgICAgIH0odiwgQnUodiwgbCwgYSwgZSwgbiwgZiwgeSkpO1xuICAgICAgdmFyIEUgPSBbXSxcbiAgICAgICAgUCA9IHtcbiAgICAgICAgICBwb3NpdGlvbmVkTGluZXM6IEUsXG4gICAgICAgICAgdGV4dDogdi50b1N0cmluZygpLFxuICAgICAgICAgIHRvcDogcFsxXSxcbiAgICAgICAgICBib3R0b206IHBbMV0sXG4gICAgICAgICAgbGVmdDogcFswXSxcbiAgICAgICAgICByaWdodDogcFswXSxcbiAgICAgICAgICB3cml0aW5nTW9kZTogYyxcbiAgICAgICAgICBpY29uc0luVGV4dDogITEsXG4gICAgICAgICAgdmVydGljYWxpemFibGU6ICExXG4gICAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IDAsIGYgPSAtMTcsIHkgPSAwLCBkID0gMCwgbSA9IFwicmlnaHRcIiA9PT0gcyA/IDEgOiBcImxlZnRcIiA9PT0gcyA/IDAgOiAuNSwgdiA9IDAsIGcgPSAwLCB4ID0gaTsgZyA8IHgubGVuZ3RoOyBnICs9IDEpIHtcbiAgICAgICAgICB2YXIgYiA9IHhbZ107XG4gICAgICAgICAgYi50cmltKCk7XG4gICAgICAgICAgdmFyIHcgPSBiLmdldE1heFNjYWxlKCksXG4gICAgICAgICAgICBfID0gMjQgKiAodyAtIDEpLFxuICAgICAgICAgICAgQSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoczogW10sXG4gICAgICAgICAgICAgIGxpbmVPZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgdC5wb3NpdGlvbmVkTGluZXNbdl0gPSBBO1xuICAgICAgICAgIHZhciBTID0gQS5wb3NpdGlvbmVkR2x5cGhzLFxuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgaWYgKGIubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgYi5sZW5ndGgoKTsgSSsrKSB7XG4gICAgICAgICAgICAgIHZhciB6ID0gYi5nZXRTZWN0aW9uKEkpLFxuICAgICAgICAgICAgICAgIEMgPSBiLmdldFNlY3Rpb25JbmRleChJKSxcbiAgICAgICAgICAgICAgICBFID0gYi5nZXRDaGFyQ29kZShJKSxcbiAgICAgICAgICAgICAgICBQID0gMCxcbiAgICAgICAgICAgICAgICBNID0gbnVsbCxcbiAgICAgICAgICAgICAgICBCID0gbnVsbCxcbiAgICAgICAgICAgICAgICBUID0gbnVsbCxcbiAgICAgICAgICAgICAgICBWID0gMjQsXG4gICAgICAgICAgICAgICAgRiA9ICEodSA9PT0gX3UuaG9yaXpvbnRhbCB8fCAhcCAmJiAhSm4oRSkgfHwgcCAmJiAoSXVbRV0gfHwgKEsgPSBFLCBabi5BcmFiaWMoSykgfHwgWm5bXCJBcmFiaWMgU3VwcGxlbWVudFwiXShLKSB8fCBabltcIkFyYWJpYyBFeHRlbmRlZC1BXCJdKEspIHx8IFpuW1wiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXCJdKEspIHx8IFpuW1wiQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1CXCJdKEspKSkpO1xuICAgICAgICAgICAgICBpZiAoei5pbWFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IG5bei5pbWFnZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghRCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgVCA9IHouaW1hZ2VOYW1lLCB0Lmljb25zSW5UZXh0ID0gdC5pY29uc0luVGV4dCB8fCAhMCwgQiA9IEQucGFkZGVkUmVjdDtcbiAgICAgICAgICAgICAgICB2YXIgTCA9IEQuZGlzcGxheVNpemU7XG4gICAgICAgICAgICAgICAgei5zY2FsZSA9IDI0ICogei5zY2FsZSAvIGMsIFAgPSBfICsgKDI0IC0gTFsxXSAqIHouc2NhbGUpLCBWID0gKE0gPSB7XG4gICAgICAgICAgICAgICAgICB3aWR0aDogTFswXSxcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogTFsxXSxcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IDEsXG4gICAgICAgICAgICAgICAgICB0b3A6IC0zLFxuICAgICAgICAgICAgICAgICAgYWR2YW5jZTogRiA/IExbMV0gOiBMWzBdXG4gICAgICAgICAgICAgICAgfSkuYWR2YW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgUiA9IEYgPyBMWzBdICogei5zY2FsZSAtIDI0ICogdyA6IExbMV0gKiB6LnNjYWxlIC0gMjQgKiB3O1xuICAgICAgICAgICAgICAgIFIgPiAwICYmIFIgPiBrICYmIChrID0gUik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIE8gPSByW3ouZm9udFN0YWNrXSxcbiAgICAgICAgICAgICAgICAgIFUgPSBPICYmIE9bRV07XG4gICAgICAgICAgICAgICAgaWYgKFUgJiYgVS5yZWN0KSBCID0gVS5yZWN0LCBNID0gVS5tZXRyaWNzO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGogPSBlW3ouZm9udFN0YWNrXSxcbiAgICAgICAgICAgICAgICAgICAgcSA9IGogJiYgaltFXTtcbiAgICAgICAgICAgICAgICAgIGlmICghcSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBNID0gcS5tZXRyaWNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBQID0gMjQgKiAodyAtIHouc2NhbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEYgPyAodC52ZXJ0aWNhbGl6YWJsZSA9ICEwLCBTLnB1c2goe1xuICAgICAgICAgICAgICAgIGdseXBoOiBFLFxuICAgICAgICAgICAgICAgIGltYWdlTmFtZTogVCxcbiAgICAgICAgICAgICAgICB4OiBoLFxuICAgICAgICAgICAgICAgIHk6IGYgKyBQLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBGLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6LnNjYWxlLFxuICAgICAgICAgICAgICAgIGZvbnRTdGFjazogei5mb250U3RhY2ssXG4gICAgICAgICAgICAgICAgc2VjdGlvbkluZGV4OiBDLFxuICAgICAgICAgICAgICAgIG1ldHJpY3M6IE0sXG4gICAgICAgICAgICAgICAgcmVjdDogQlxuICAgICAgICAgICAgICB9KSwgaCArPSBWICogei5zY2FsZSArIGwpIDogKFMucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2x5cGg6IEUsXG4gICAgICAgICAgICAgICAgaW1hZ2VOYW1lOiBULFxuICAgICAgICAgICAgICAgIHg6IGgsXG4gICAgICAgICAgICAgICAgeTogZiArIFAsXG4gICAgICAgICAgICAgICAgdmVydGljYWw6IEYsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHouc2NhbGUsXG4gICAgICAgICAgICAgICAgZm9udFN0YWNrOiB6LmZvbnRTdGFjayxcbiAgICAgICAgICAgICAgICBzZWN0aW9uSW5kZXg6IEMsXG4gICAgICAgICAgICAgICAgbWV0cmljczogTSxcbiAgICAgICAgICAgICAgICByZWN0OiBCXG4gICAgICAgICAgICAgIH0pLCBoICs9IE0uYWR2YW5jZSAqIHouc2NhbGUgKyBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDAgIT09IFMubGVuZ3RoICYmICh5ID0gTWF0aC5tYXgoaCAtIGwsIHkpLCBWdShTLCAwLCBTLmxlbmd0aCAtIDEsIG0sIGspKSwgaCA9IDA7XG4gICAgICAgICAgICB2YXIgTiA9IGEgKiB3ICsgaztcbiAgICAgICAgICAgIEEubGluZU9mZnNldCA9IE1hdGgubWF4KGssIF8pLCBmICs9IE4sIGQgPSBNYXRoLm1heChOLCBkKSwgKyt2O1xuICAgICAgICAgIH0gZWxzZSBmICs9IGEsICsrdjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgSyxcbiAgICAgICAgICBHID0gZiAtIC0xNyxcbiAgICAgICAgICBaID0gVHUobyksXG4gICAgICAgICAgWCA9IFouaG9yaXpvbnRhbEFsaWduLFxuICAgICAgICAgIEogPSBaLnZlcnRpY2FsQWxpZ247XG4gICAgICAgIChmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSkge1xuICAgICAgICAgIHZhciBsLFxuICAgICAgICAgICAgcCA9IChlIC0gcikgKiBpO1xuICAgICAgICAgIGwgPSBhICE9PSBvID8gLXMgKiBuIC0gLTE3IDogKC1uICogdSArIC41KSAqIG87XG4gICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGggPSB0OyBjIDwgaC5sZW5ndGg7IGMgKz0gMSkgZm9yICh2YXIgZiA9IDAsIHkgPSBoW2NdLnBvc2l0aW9uZWRHbHlwaHM7IGYgPCB5Lmxlbmd0aDsgZiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHlbZl07XG4gICAgICAgICAgICBkLnggKz0gcCwgZC55ICs9IGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0LnBvc2l0aW9uZWRMaW5lcywgbSwgWCwgSiwgeSwgZCwgYSwgRywgaS5sZW5ndGgpLCB0LnRvcCArPSAtSiAqIEcsIHQuYm90dG9tID0gdC50b3AgKyBHLCB0LmxlZnQgKz0gLVggKiB5LCB0LnJpZ2h0ID0gdC5sZWZ0ICsgeTtcbiAgICAgIH0oUCwgZSwgciwgbiwgbSwgbywgcywgdSwgYywgbCwgaCwgZCksICFmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSBpZiAoMCAhPT0gcltlXS5wb3NpdGlvbmVkR2x5cGhzLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9KEUpICYmIFA7XG4gICAgfVxuICAgIFN1LmZyb21GZWF0dXJlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSBuZXcgU3UoKSwgbiA9IDA7IG4gPCB0LnNlY3Rpb25zLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciBpID0gdC5zZWN0aW9uc1tuXTtcbiAgICAgICAgaS5pbWFnZSA/IHIuYWRkSW1hZ2VTZWN0aW9uKGkpIDogci5hZGRUZXh0U2VjdGlvbihpLCBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIFN1LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9LCBTdS5wcm90b3R5cGUuZ2V0U2VjdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWN0aW9uc1t0aGlzLnNlY3Rpb25JbmRleFt0XV07XG4gICAgfSwgU3UucHJvdG90eXBlLmdldFNlY3Rpb25JbmRleCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWN0aW9uSW5kZXhbdF07XG4gICAgfSwgU3UucHJvdG90eXBlLmdldENoYXJDb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuY2hhckNvZGVBdCh0KTtcbiAgICB9LCBTdS5wcm90b3R5cGUudmVydGljYWxpemVQdW5jdHVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBcIlwiLCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICB2YXIgbiA9IHQuY2hhckNvZGVBdChyICsgMSkgfHwgbnVsbCxcbiAgICAgICAgICAgIGkgPSB0LmNoYXJDb2RlQXQociAtIDEpIHx8IG51bGw7XG4gICAgICAgICAgZSArPSBuICYmIEhuKG4pICYmICFKc1t0W3IgKyAxXV0gfHwgaSAmJiBIbihpKSAmJiAhSnNbdFtyIC0gMV1dIHx8ICFKc1t0W3JdXSA/IHRbcl0gOiBKc1t0W3JdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0odGhpcy50ZXh0KTtcbiAgICB9LCBTdS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgPSAwLCBlID0gMDsgZSA8IHRoaXMudGV4dC5sZW5ndGggJiYgSXVbdGhpcy50ZXh0LmNoYXJDb2RlQXQoZSldOyBlKyspIHQrKztcbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLnRleHQubGVuZ3RoLCBuID0gdGhpcy50ZXh0Lmxlbmd0aCAtIDE7IG4gPj0gMCAmJiBuID49IHQgJiYgSXVbdGhpcy50ZXh0LmNoYXJDb2RlQXQobildOyBuLS0pIHItLTtcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcodCwgciksIHRoaXMuc2VjdGlvbkluZGV4ID0gdGhpcy5zZWN0aW9uSW5kZXguc2xpY2UodCwgcik7XG4gICAgfSwgU3UucHJvdG90eXBlLnN1YnN0cmluZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IG5ldyBTdSgpO1xuICAgICAgcmV0dXJuIHIudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcodCwgZSksIHIuc2VjdGlvbkluZGV4ID0gdGhpcy5zZWN0aW9uSW5kZXguc2xpY2UodCwgZSksIHIuc2VjdGlvbnMgPSB0aGlzLnNlY3Rpb25zLCByO1xuICAgIH0sIFN1LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfSwgU3UucHJvdG90eXBlLmdldE1heFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuc2VjdGlvbkluZGV4LnJlZHVjZShmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZSwgdC5zZWN0aW9uc1tyXS5zY2FsZSk7XG4gICAgICB9LCAwKTtcbiAgICB9LCBTdS5wcm90b3R5cGUuYWRkVGV4dFNlY3Rpb24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy50ZXh0ICs9IHQudGV4dCwgdGhpcy5zZWN0aW9ucy5wdXNoKEF1LmZvclRleHQodC5zY2FsZSwgdC5mb250U3RhY2sgfHwgZSkpO1xuICAgICAgZm9yICh2YXIgciA9IHRoaXMuc2VjdGlvbnMubGVuZ3RoIC0gMSwgbiA9IDA7IG4gPCB0LnRleHQubGVuZ3RoOyArK24pIHRoaXMuc2VjdGlvbkluZGV4LnB1c2gocik7XG4gICAgfSwgU3UucHJvdG90eXBlLmFkZEltYWdlU2VjdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuaW1hZ2UgPyB0LmltYWdlLm5hbWUgOiBcIlwiO1xuICAgICAgaWYgKDAgIT09IGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5nZXROZXh0SW1hZ2VTZWN0aW9uQ2hhckNvZGUoKTtcbiAgICAgICAgciA/ICh0aGlzLnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyKSwgdGhpcy5zZWN0aW9ucy5wdXNoKEF1LmZvckltYWdlKGUpKSwgdGhpcy5zZWN0aW9uSW5kZXgucHVzaCh0aGlzLnNlY3Rpb25zLmxlbmd0aCAtIDEpKSA6IEEoXCJSZWFjaGVkIG1heGltdW0gbnVtYmVyIG9mIGltYWdlcyA2NDAxXCIpO1xuICAgICAgfSBlbHNlIEEoXCJDYW4ndCBhZGQgRm9ybWF0dGVkU2VjdGlvbiB3aXRoIGFuIGVtcHR5IGltYWdlLlwiKTtcbiAgICB9LCBTdS5wcm90b3R5cGUuZ2V0TmV4dEltYWdlU2VjdGlvbkNoYXJDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VTZWN0aW9uSUQgPyB0aGlzLmltYWdlU2VjdGlvbklEID49IDYzNzQzID8gbnVsbCA6ICsrdGhpcy5pbWFnZVNlY3Rpb25JRCA6ICh0aGlzLmltYWdlU2VjdGlvbklEID0gNTczNDQsIHRoaXMuaW1hZ2VTZWN0aW9uSUQpO1xuICAgIH07XG4gICAgdmFyIEl1ID0ge1xuICAgICAgICA5OiAhMCxcbiAgICAgICAgMTA6ICEwLFxuICAgICAgICAxMTogITAsXG4gICAgICAgIDEyOiAhMCxcbiAgICAgICAgMTM6ICEwLFxuICAgICAgICAzMjogITBcbiAgICAgIH0sXG4gICAgICB6dSA9IHt9O1xuICAgIGZ1bmN0aW9uIEN1KHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIGlmIChlLmltYWdlTmFtZSkge1xuICAgICAgICB2YXIgbyA9IG5bZS5pbWFnZU5hbWVdO1xuICAgICAgICByZXR1cm4gbyA/IG8uZGlzcGxheVNpemVbMF0gKiBlLnNjYWxlICogMjQgLyBhICsgaSA6IDA7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IHJbZS5mb250U3RhY2tdLFxuICAgICAgICB1ID0gcyAmJiBzW3RdO1xuICAgICAgcmV0dXJuIHUgPyB1Lm1ldHJpY3MuYWR2YW5jZSAqIGUuc2NhbGUgKyBpIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRXUodCwgZSwgciwgbikge1xuICAgICAgdmFyIGkgPSBNYXRoLnBvdyh0IC0gZSwgMik7XG4gICAgICByZXR1cm4gbiA/IHQgPCBlID8gaSAvIDIgOiAyICogaSA6IGkgKyBNYXRoLmFicyhyKSAqIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFB1KHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHJldHVybiAxMCA9PT0gdCAmJiAobiAtPSAxZTQpLCByICYmIChuICs9IDE1MCksIDQwICE9PSB0ICYmIDY1Mjg4ICE9PSB0IHx8IChuICs9IDUwKSwgNDEgIT09IGUgJiYgNjUyODkgIT09IGUgfHwgKG4gKz0gNTApLCBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNdSh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICBmb3IgKHZhciBvID0gbnVsbCwgcyA9IEV1KGUsIHIsIGksIGEpLCB1ID0gMCwgbCA9IG47IHUgPCBsLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIHZhciBwID0gbFt1XSxcbiAgICAgICAgICBjID0gRXUoZSAtIHAueCwgciwgaSwgYSkgKyBwLmJhZG5lc3M7XG4gICAgICAgIGMgPD0gcyAmJiAobyA9IHAsIHMgPSBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiB0LFxuICAgICAgICB4OiBlLFxuICAgICAgICBwcmlvckJyZWFrOiBvLFxuICAgICAgICBiYWRuZXNzOiBzXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBCdSh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICBpZiAoXCJwb2ludFwiICE9PSBhKSByZXR1cm4gW107XG4gICAgICBpZiAoIXQpIHJldHVybiBbXTtcbiAgICAgIGZvciAodmFyIHMsIHUgPSBbXSwgbCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICAgICAgZm9yICh2YXIgbyA9IDAsIHMgPSAwOyBzIDwgdC5sZW5ndGgoKTsgcysrKSB7XG4gICAgICAgICAgICB2YXIgdSA9IHQuZ2V0U2VjdGlvbihzKTtcbiAgICAgICAgICAgIG8gKz0gQ3UodC5nZXRDaGFyQ29kZShzKSwgdSwgbiwgaSwgZSwgYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvIC8gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKG8gLyByKSk7XG4gICAgICAgIH0odCwgZSwgciwgbiwgaSwgbyksIHAgPSB0LnRleHQuaW5kZXhPZihcIuKAi1wiKSA+PSAwLCBjID0gMCwgaCA9IDA7IGggPCB0Lmxlbmd0aCgpOyBoKyspIHtcbiAgICAgICAgdmFyIGYgPSB0LmdldFNlY3Rpb24oaCksXG4gICAgICAgICAgeSA9IHQuZ2V0Q2hhckNvZGUoaCk7XG4gICAgICAgIGlmIChJdVt5XSB8fCAoYyArPSBDdSh5LCBmLCBuLCBpLCBlLCBvKSksIGggPCB0Lmxlbmd0aCgpIC0gMSkge1xuICAgICAgICAgIHZhciBkID0gISgocyA9IHkpIDwgMTE5MDQgfHwgIShabltcIkJvcG9tb2ZvIEV4dGVuZGVkXCJdKHMpIHx8IFpuLkJvcG9tb2ZvKHMpIHx8IFpuW1wiQ0pLIENvbXBhdGliaWxpdHkgRm9ybXNcIl0ocykgfHwgWm5bXCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXCJdKHMpIHx8IFpuW1wiQ0pLIENvbXBhdGliaWxpdHlcIl0ocykgfHwgWm5bXCJDSksgUmFkaWNhbHMgU3VwcGxlbWVudFwiXShzKSB8fCBabltcIkNKSyBTdHJva2VzXCJdKHMpIHx8IFpuW1wiQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXCJdKHMpIHx8IFpuW1wiQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQVwiXShzKSB8fCBabltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHNcIl0ocykgfHwgWm5bXCJFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXCJdKHMpIHx8IFpuW1wiSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcIl0ocykgfHwgWm4uSGlyYWdhbmEocykgfHwgWm5bXCJJZGVvZ3JhcGhpYyBEZXNjcmlwdGlvbiBDaGFyYWN0ZXJzXCJdKHMpIHx8IFpuW1wiS2FuZ3hpIFJhZGljYWxzXCJdKHMpIHx8IFpuW1wiS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1wiXShzKSB8fCBabi5LYXRha2FuYShzKSB8fCBabltcIlZlcnRpY2FsIEZvcm1zXCJdKHMpIHx8IFpuW1wiWWkgUmFkaWNhbHNcIl0ocykgfHwgWm5bXCJZaSBTeWxsYWJsZXNcIl0ocykpKTtcbiAgICAgICAgICAoenVbeV0gfHwgZCB8fCBmLmltYWdlTmFtZSkgJiYgdS5wdXNoKE11KGggKyAxLCBjLCBsLCB1LCBQdSh5LCB0LmdldENoYXJDb2RlKGggKyAxKSwgZCAmJiBwKSwgITEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHQoZSkge1xuICAgICAgICByZXR1cm4gZSA/IHQoZS5wcmlvckJyZWFrKS5jb25jYXQoZS5pbmRleCkgOiBbXTtcbiAgICAgIH0oTXUodC5sZW5ndGgoKSwgYywgbCwgdSwgMCwgITApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHUodCkge1xuICAgICAgdmFyIGUgPSAuNSxcbiAgICAgICAgciA9IC41O1xuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgICAgICBlID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgIGUgPSAwO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgICAgICByID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgICAgIHIgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiBlLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiByXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWdSh0LCBlLCByLCBuLCBpKSB7XG4gICAgICBpZiAobiB8fCBpKSBmb3IgKHZhciBhID0gdFtyXSwgbyA9ICh0W3JdLnggKyBhLm1ldHJpY3MuYWR2YW5jZSAqIGEuc2NhbGUpICogbiwgcyA9IGU7IHMgPD0gcjsgcysrKSB0W3NdLnggLT0gbywgdFtzXS55ICs9IGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZ1KHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHZhciBvLFxuICAgICAgICBzID0gdC5pbWFnZTtcbiAgICAgIGlmIChzLmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHUgPSBzLmNvbnRlbnQsXG4gICAgICAgICAgbCA9IHMucGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBvID0gW3VbMF0gLyBsLCB1WzFdIC8gbCwgcy5kaXNwbGF5U2l6ZVswXSAtIHVbMl0gLyBsLCBzLmRpc3BsYXlTaXplWzFdIC0gdVszXSAvIGxdO1xuICAgICAgfVxuICAgICAgdmFyIHAsXG4gICAgICAgIGMsXG4gICAgICAgIGgsXG4gICAgICAgIGYsXG4gICAgICAgIHkgPSBlLmxlZnQgKiBhLFxuICAgICAgICBkID0gZS5yaWdodCAqIGE7XG4gICAgICBcIndpZHRoXCIgPT09IHIgfHwgXCJib3RoXCIgPT09IHIgPyAoZiA9IGlbMF0gKyB5IC0gblszXSwgYyA9IGlbMF0gKyBkICsgblsxXSkgOiBjID0gKGYgPSBpWzBdICsgKHkgKyBkIC0gcy5kaXNwbGF5U2l6ZVswXSkgLyAyKSArIHMuZGlzcGxheVNpemVbMF07XG4gICAgICB2YXIgbSA9IGUudG9wICogYSxcbiAgICAgICAgdiA9IGUuYm90dG9tICogYTtcbiAgICAgIHJldHVybiBcImhlaWdodFwiID09PSByIHx8IFwiYm90aFwiID09PSByID8gKHAgPSBpWzFdICsgbSAtIG5bMF0sIGggPSBpWzFdICsgdiArIG5bMl0pIDogaCA9IChwID0gaVsxXSArIChtICsgdiAtIHMuZGlzcGxheVNpemVbMV0pIC8gMikgKyBzLmRpc3BsYXlTaXplWzFdLCB7XG4gICAgICAgIGltYWdlOiBzLFxuICAgICAgICB0b3A6IHAsXG4gICAgICAgIHJpZ2h0OiBjLFxuICAgICAgICBib3R0b206IGgsXG4gICAgICAgIGxlZnQ6IGYsXG4gICAgICAgIGNvbGxpc2lvblBhZGRpbmc6IG9cbiAgICAgIH07XG4gICAgfVxuICAgIHp1WzEwXSA9ICEwLCB6dVszMl0gPSAhMCwgenVbMzhdID0gITAsIHp1WzQwXSA9ICEwLCB6dVs0MV0gPSAhMCwgenVbNDNdID0gITAsIHp1WzQ1XSA9ICEwLCB6dVs0N10gPSAhMCwgenVbMTczXSA9ICEwLCB6dVsxODNdID0gITAsIHp1WzgyMDNdID0gITAsIHp1WzgyMDhdID0gITAsIHp1WzgyMTFdID0gITAsIHp1WzgyMzFdID0gITA7XG4gICAgdmFyIER1ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZ1bmN0aW9uIGUoZSwgciwgbiwgaSkge1xuICAgICAgICB0LmNhbGwodGhpcywgZSwgciksIHRoaXMuYW5nbGUgPSBuLCB2b2lkIDAgIT09IGkgJiYgKHRoaXMuc2VnbWVudCA9IGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZSh0aGlzLngsIHRoaXMueSwgdGhpcy5hbmdsZSwgdGhpcy5zZWdtZW50KTtcbiAgICAgIH0sIGU7XG4gICAgfShpKTtcbiAgICBmdW5jdGlvbiBMdSh0LCBlKSB7XG4gICAgICB2YXIgciA9IGUuZXhwcmVzc2lvbjtcbiAgICAgIGlmIChcImNvbnN0YW50XCIgPT09IHIua2luZCkgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJjb25zdGFudFwiLFxuICAgICAgICBsYXlvdXRTaXplOiByLmV2YWx1YXRlKG5ldyB1aSh0ICsgMSkpXG4gICAgICB9O1xuICAgICAgaWYgKFwic291cmNlXCIgPT09IHIua2luZCkgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJzb3VyY2VcIlxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIG4gPSByLnpvb21TdG9wcywgaSA9IHIuaW50ZXJwb2xhdGlvblR5cGUsIGEgPSAwOyBhIDwgbi5sZW5ndGggJiYgblthXSA8PSB0OykgYSsrO1xuICAgICAgZm9yICh2YXIgbyA9IGEgPSBNYXRoLm1heCgwLCBhIC0gMSk7IG8gPCBuLmxlbmd0aCAmJiBuW29dIDwgdCArIDE7KSBvKys7XG4gICAgICBvID0gTWF0aC5taW4obi5sZW5ndGggLSAxLCBvKTtcbiAgICAgIHZhciBzID0gblthXSxcbiAgICAgICAgdSA9IG5bb107XG4gICAgICByZXR1cm4gXCJjb21wb3NpdGVcIiA9PT0gci5raW5kID8ge1xuICAgICAgICBraW5kOiBcImNvbXBvc2l0ZVwiLFxuICAgICAgICBtaW5ab29tOiBzLFxuICAgICAgICBtYXhab29tOiB1LFxuICAgICAgICBpbnRlcnBvbGF0aW9uVHlwZTogaVxuICAgICAgfSA6IHtcbiAgICAgICAga2luZDogXCJjYW1lcmFcIixcbiAgICAgICAgbWluWm9vbTogcyxcbiAgICAgICAgbWF4Wm9vbTogdSxcbiAgICAgICAgbWluU2l6ZTogci5ldmFsdWF0ZShuZXcgdWkocykpLFxuICAgICAgICBtYXhTaXplOiByLmV2YWx1YXRlKG5ldyB1aSh1KSksXG4gICAgICAgIGludGVycG9sYXRpb25UeXBlOiBpXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSdSh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IGUudVNpemUsXG4gICAgICAgIGkgPSByLmxvd2VyU2l6ZTtcbiAgICAgIHJldHVybiBcInNvdXJjZVwiID09PSB0LmtpbmQgPyBpIC8gMTI4IDogXCJjb21wb3NpdGVcIiA9PT0gdC5raW5kID8gR2UoaSAvIDEyOCwgci51cHBlclNpemUgLyAxMjgsIGUudVNpemVUKSA6IG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIE91KHQsIGUpIHtcbiAgICAgIHZhciByID0gMCxcbiAgICAgICAgbiA9IDA7XG4gICAgICBpZiAoXCJjb25zdGFudFwiID09PSB0LmtpbmQpIG4gPSB0LmxheW91dFNpemU7ZWxzZSBpZiAoXCJzb3VyY2VcIiAhPT0gdC5raW5kKSB7XG4gICAgICAgIHZhciBpID0gdC5pbnRlcnBvbGF0aW9uVHlwZSxcbiAgICAgICAgICBhID0gaSA/IHAob3IuaW50ZXJwb2xhdGlvbkZhY3RvcihpLCBlLCB0Lm1pblpvb20sIHQubWF4Wm9vbSksIDAsIDEpIDogMDtcbiAgICAgICAgXCJjYW1lcmFcIiA9PT0gdC5raW5kID8gbiA9IEdlKHQubWluU2l6ZSwgdC5tYXhTaXplLCBhKSA6IHIgPSBhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVNpemVUOiByLFxuICAgICAgICB1U2l6ZTogblxuICAgICAgfTtcbiAgICB9XG4gICAgT24oXCJBbmNob3JcIiwgRHUpO1xuICAgIHZhciBVdSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgZ2V0U2l6ZURhdGE6IEx1LFxuICAgICAgZXZhbHVhdGVTaXplRm9yRmVhdHVyZTogUnUsXG4gICAgICBldmFsdWF0ZVNpemVGb3Jab29tOiBPdSxcbiAgICAgIFNJWkVfUEFDS19GQUNUT1I6IDEyOFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGp1KHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUuc2VnbWVudCkgcmV0dXJuICEwO1xuICAgICAgZm9yICh2YXIgYSA9IGUsIG8gPSBlLnNlZ21lbnQgKyAxLCBzID0gMDsgcyA+IC1yIC8gMjspIHtcbiAgICAgICAgaWYgKC0tbyA8IDApIHJldHVybiAhMTtcbiAgICAgICAgcyAtPSB0W29dLmRpc3QoYSksIGEgPSB0W29dO1xuICAgICAgfVxuICAgICAgcyArPSB0W29dLmRpc3QodFtvICsgMV0pLCBvKys7XG4gICAgICBmb3IgKHZhciB1ID0gW10sIGwgPSAwOyBzIDwgciAvIDI7KSB7XG4gICAgICAgIHZhciBwID0gdFtvXSxcbiAgICAgICAgICBjID0gdFtvICsgMV07XG4gICAgICAgIGlmICghYykgcmV0dXJuICExO1xuICAgICAgICB2YXIgaCA9IHRbbyAtIDFdLmFuZ2xlVG8ocCkgLSBwLmFuZ2xlVG8oYyk7XG4gICAgICAgIGZvciAoaCA9IE1hdGguYWJzKChoICsgMyAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKSAtIE1hdGguUEkpLCB1LnB1c2goe1xuICAgICAgICAgIGRpc3RhbmNlOiBzLFxuICAgICAgICAgIGFuZ2xlRGVsdGE6IGhcbiAgICAgICAgfSksIGwgKz0gaDsgcyAtIHVbMF0uZGlzdGFuY2UgPiBuOykgbCAtPSB1LnNoaWZ0KCkuYW5nbGVEZWx0YTtcbiAgICAgICAgaWYgKGwgPiBpKSByZXR1cm4gITE7XG4gICAgICAgIG8rKywgcyArPSBwLmRpc3QoYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1KHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gMDsgciA8IHQubGVuZ3RoIC0gMTsgcisrKSBlICs9IHRbcl0uZGlzdCh0W3IgKyAxXSk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTnUodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHQgPyAuNiAqIGUgKiByIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gS3UodCwgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHQgPyB0LnJpZ2h0IC0gdC5sZWZ0IDogMCwgZSA/IGUucmlnaHQgLSBlLmxlZnQgOiAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR3UodCwgZSwgciwgbiwgaSwgYSkge1xuICAgICAgZm9yICh2YXIgbyA9IE51KHIsIGksIGEpLCBzID0gS3UociwgbikgKiBhLCB1ID0gMCwgbCA9IHF1KHQpIC8gMiwgcCA9IDA7IHAgPCB0Lmxlbmd0aCAtIDE7IHArKykge1xuICAgICAgICB2YXIgYyA9IHRbcF0sXG4gICAgICAgICAgaCA9IHRbcCArIDFdLFxuICAgICAgICAgIGYgPSBjLmRpc3QoaCk7XG4gICAgICAgIGlmICh1ICsgZiA+IGwpIHtcbiAgICAgICAgICB2YXIgeSA9IChsIC0gdSkgLyBmLFxuICAgICAgICAgICAgZCA9IEdlKGMueCwgaC54LCB5KSxcbiAgICAgICAgICAgIG0gPSBHZShjLnksIGgueSwgeSksXG4gICAgICAgICAgICB2ID0gbmV3IER1KGQsIG0sIGguYW5nbGVUbyhjKSwgcCk7XG4gICAgICAgICAgcmV0dXJuIHYuX3JvdW5kKCksICFvIHx8IGp1KHQsIHYsIHMsIG8sIGUpID8gdiA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICB1ICs9IGY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFp1KHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUpIHtcbiAgICAgIHZhciBsID0gTnUobiwgYSwgbyksXG4gICAgICAgIHAgPSBLdShuLCBpKSxcbiAgICAgICAgYyA9IHAgKiBvLFxuICAgICAgICBoID0gMCA9PT0gdFswXS54IHx8IHRbMF0ueCA9PT0gdSB8fCAwID09PSB0WzBdLnkgfHwgdFswXS55ID09PSB1O1xuICAgICAgcmV0dXJuIGUgLSBjIDwgZSAvIDQgJiYgKGUgPSBjICsgZSAvIDQpLCBmdW5jdGlvbiB0KGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpIHtcbiAgICAgICAgZm9yICh2YXIgcCA9IG8gLyAyLCBjID0gcXUoZSksIGggPSAwLCBmID0gciAtIG4sIHkgPSBbXSwgZCA9IDA7IGQgPCBlLmxlbmd0aCAtIDE7IGQrKykge1xuICAgICAgICAgIGZvciAodmFyIG0gPSBlW2RdLCB2ID0gZVtkICsgMV0sIGcgPSBtLmRpc3QodiksIHggPSB2LmFuZ2xlVG8obSk7IGYgKyBuIDwgaCArIGc7KSB7XG4gICAgICAgICAgICB2YXIgYiA9ICgoZiArPSBuKSAtIGgpIC8gZyxcbiAgICAgICAgICAgICAgdyA9IEdlKG0ueCwgdi54LCBiKSxcbiAgICAgICAgICAgICAgXyA9IEdlKG0ueSwgdi55LCBiKTtcbiAgICAgICAgICAgIGlmICh3ID49IDAgJiYgdyA8IGwgJiYgXyA+PSAwICYmIF8gPCBsICYmIGYgLSBwID49IDAgJiYgZiArIHAgPD0gYykge1xuICAgICAgICAgICAgICB2YXIgQSA9IG5ldyBEdSh3LCBfLCB4LCBkKTtcbiAgICAgICAgICAgICAgQS5fcm91bmQoKSwgaSAmJiAhanUoZSwgQSwgbywgaSwgYSkgfHwgeS5wdXNoKEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBoICs9IGc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUgfHwgeS5sZW5ndGggfHwgcyB8fCAoeSA9IHQoZSwgaCAvIDIsIG4sIGksIGEsIG8sIHMsICEwLCBsKSksIHk7XG4gICAgICB9KHQsIGggPyBlIC8gMiAqIHMgJSBlIDogKHAgLyAyICsgMiAqIGEpICogbyAqIHMgJSBlLCBlLCBsLCByLCBjLCBoLCAhMSwgdSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFh1KHQsIGUsIHIsIG4sIGEpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKSBmb3IgKHZhciB1ID0gdFtzXSwgbCA9IHZvaWQgMCwgcCA9IDA7IHAgPCB1Lmxlbmd0aCAtIDE7IHArKykge1xuICAgICAgICB2YXIgYyA9IHVbcF0sXG4gICAgICAgICAgaCA9IHVbcCArIDFdO1xuICAgICAgICBjLnggPCBlICYmIGgueCA8IGUgfHwgKGMueCA8IGUgPyBjID0gbmV3IGkoZSwgYy55ICsgKGUgLSBjLngpIC8gKGgueCAtIGMueCkgKiAoaC55IC0gYy55KSkuX3JvdW5kKCkgOiBoLnggPCBlICYmIChoID0gbmV3IGkoZSwgYy55ICsgKGUgLSBjLngpIC8gKGgueCAtIGMueCkgKiAoaC55IC0gYy55KSkuX3JvdW5kKCkpLCBjLnkgPCByICYmIGgueSA8IHIgfHwgKGMueSA8IHIgPyBjID0gbmV3IGkoYy54ICsgKHIgLSBjLnkpIC8gKGgueSAtIGMueSkgKiAoaC54IC0gYy54KSwgcikuX3JvdW5kKCkgOiBoLnkgPCByICYmIChoID0gbmV3IGkoYy54ICsgKHIgLSBjLnkpIC8gKGgueSAtIGMueSkgKiAoaC54IC0gYy54KSwgcikuX3JvdW5kKCkpLCBjLnggPj0gbiAmJiBoLnggPj0gbiB8fCAoYy54ID49IG4gPyBjID0gbmV3IGkobiwgYy55ICsgKG4gLSBjLngpIC8gKGgueCAtIGMueCkgKiAoaC55IC0gYy55KSkuX3JvdW5kKCkgOiBoLnggPj0gbiAmJiAoaCA9IG5ldyBpKG4sIGMueSArIChuIC0gYy54KSAvIChoLnggLSBjLngpICogKGgueSAtIGMueSkpLl9yb3VuZCgpKSwgYy55ID49IGEgJiYgaC55ID49IGEgfHwgKGMueSA+PSBhID8gYyA9IG5ldyBpKGMueCArIChhIC0gYy55KSAvIChoLnkgLSBjLnkpICogKGgueCAtIGMueCksIGEpLl9yb3VuZCgpIDogaC55ID49IGEgJiYgKGggPSBuZXcgaShjLnggKyAoYSAtIGMueSkgLyAoaC55IC0gYy55KSAqIChoLnggLSBjLngpLCBhKS5fcm91bmQoKSksIGwgJiYgYy5lcXVhbHMobFtsLmxlbmd0aCAtIDFdKSB8fCBvLnB1c2gobCA9IFtjXSksIGwucHVzaChoKSkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZnVuY3Rpb24gSnUodCwgZSwgciwgbikge1xuICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgbyA9IHQuaW1hZ2UsXG4gICAgICAgIHMgPSBvLnBpeGVsUmF0aW8sXG4gICAgICAgIHUgPSBvLnBhZGRlZFJlY3QudyAtIDIsXG4gICAgICAgIGwgPSBvLnBhZGRlZFJlY3QuaCAtIDIsXG4gICAgICAgIHAgPSB0LnJpZ2h0IC0gdC5sZWZ0LFxuICAgICAgICBjID0gdC5ib3R0b20gLSB0LnRvcCxcbiAgICAgICAgaCA9IG8uc3RyZXRjaFggfHwgW1swLCB1XV0sXG4gICAgICAgIGYgPSBvLnN0cmV0Y2hZIHx8IFtbMCwgbF1dLFxuICAgICAgICB5ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdCArIGVbMV0gLSBlWzBdO1xuICAgICAgICB9LFxuICAgICAgICBkID0gaC5yZWR1Y2UoeSwgMCksXG4gICAgICAgIG0gPSBmLnJlZHVjZSh5LCAwKSxcbiAgICAgICAgdiA9IHUgLSBkLFxuICAgICAgICBnID0gbCAtIG0sXG4gICAgICAgIHggPSAwLFxuICAgICAgICBiID0gZCxcbiAgICAgICAgdyA9IDAsXG4gICAgICAgIF8gPSBtLFxuICAgICAgICBBID0gMCxcbiAgICAgICAgUyA9IHYsXG4gICAgICAgIGsgPSAwLFxuICAgICAgICBJID0gZztcbiAgICAgIGlmIChvLmNvbnRlbnQgJiYgbikge1xuICAgICAgICB2YXIgeiA9IG8uY29udGVudDtcbiAgICAgICAgeCA9IEh1KGgsIDAsIHpbMF0pLCB3ID0gSHUoZiwgMCwgelsxXSksIGIgPSBIdShoLCB6WzBdLCB6WzJdKSwgXyA9IEh1KGYsIHpbMV0sIHpbM10pLCBBID0gelswXSAtIHgsIGsgPSB6WzFdIC0gdywgUyA9IHpbMl0gLSB6WzBdIC0gYiwgSSA9IHpbM10gLSB6WzFdIC0gXztcbiAgICAgIH1cbiAgICAgIHZhciBDID0gZnVuY3Rpb24gKG4sIGEsIHUsIGwpIHtcbiAgICAgICAgdmFyIGggPSAkdShuLnN0cmV0Y2ggLSB4LCBiLCBwLCB0LmxlZnQpLFxuICAgICAgICAgIGYgPSBXdShuLmZpeGVkIC0gQSwgUywgbi5zdHJldGNoLCBkKSxcbiAgICAgICAgICB5ID0gJHUoYS5zdHJldGNoIC0gdywgXywgYywgdC50b3ApLFxuICAgICAgICAgIHYgPSBXdShhLmZpeGVkIC0gaywgSSwgYS5zdHJldGNoLCBtKSxcbiAgICAgICAgICBnID0gJHUodS5zdHJldGNoIC0geCwgYiwgcCwgdC5sZWZ0KSxcbiAgICAgICAgICB6ID0gV3UodS5maXhlZCAtIEEsIFMsIHUuc3RyZXRjaCwgZCksXG4gICAgICAgICAgQyA9ICR1KGwuc3RyZXRjaCAtIHcsIF8sIGMsIHQudG9wKSxcbiAgICAgICAgICBFID0gV3UobC5maXhlZCAtIGssIEksIGwuc3RyZXRjaCwgbSksXG4gICAgICAgICAgUCA9IG5ldyBpKGgsIHkpLFxuICAgICAgICAgIE0gPSBuZXcgaShnLCB5KSxcbiAgICAgICAgICBCID0gbmV3IGkoZywgQyksXG4gICAgICAgICAgVCA9IG5ldyBpKGgsIEMpLFxuICAgICAgICAgIFYgPSBuZXcgaShmIC8gcywgdiAvIHMpLFxuICAgICAgICAgIEYgPSBuZXcgaSh6IC8gcywgRSAvIHMpLFxuICAgICAgICAgIEQgPSBlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgaWYgKEQpIHtcbiAgICAgICAgICB2YXIgTCA9IE1hdGguc2luKEQpLFxuICAgICAgICAgICAgUiA9IE1hdGguY29zKEQpLFxuICAgICAgICAgICAgTyA9IFtSLCAtTCwgTCwgUl07XG4gICAgICAgICAgUC5fbWF0TXVsdChPKSwgTS5fbWF0TXVsdChPKSwgVC5fbWF0TXVsdChPKSwgQi5fbWF0TXVsdChPKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVSA9IG4uc3RyZXRjaCArIG4uZml4ZWQsXG4gICAgICAgICAgaiA9IGEuc3RyZXRjaCArIGEuZml4ZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGw6IFAsXG4gICAgICAgICAgdHI6IE0sXG4gICAgICAgICAgYmw6IFQsXG4gICAgICAgICAgYnI6IEIsXG4gICAgICAgICAgdGV4OiB7XG4gICAgICAgICAgICB4OiBvLnBhZGRlZFJlY3QueCArIDEgKyBVLFxuICAgICAgICAgICAgeTogby5wYWRkZWRSZWN0LnkgKyAxICsgaixcbiAgICAgICAgICAgIHc6IHUuc3RyZXRjaCArIHUuZml4ZWQgLSBVLFxuICAgICAgICAgICAgaDogbC5zdHJldGNoICsgbC5maXhlZCAtIGpcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRpbmdNb2RlOiB2b2lkIDAsXG4gICAgICAgICAgZ2x5cGhPZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICBzZWN0aW9uSW5kZXg6IDAsXG4gICAgICAgICAgcGl4ZWxPZmZzZXRUTDogVixcbiAgICAgICAgICBwaXhlbE9mZnNldEJSOiBGLFxuICAgICAgICAgIG1pbkZvbnRTY2FsZVg6IFMgLyBzIC8gcCxcbiAgICAgICAgICBtaW5Gb250U2NhbGVZOiBJIC8gcyAvIGMsXG4gICAgICAgICAgaXNTREY6IHJcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBpZiAobiAmJiAoby5zdHJldGNoWCB8fCBvLnN0cmV0Y2hZKSkgZm9yICh2YXIgRSA9IFl1KGgsIHYsIGQpLCBQID0gWXUoZiwgZywgbSksIE0gPSAwOyBNIDwgRS5sZW5ndGggLSAxOyBNKyspIGZvciAodmFyIEIgPSBFW01dLCBUID0gRVtNICsgMV0sIFYgPSAwOyBWIDwgUC5sZW5ndGggLSAxOyBWKyspIGEucHVzaChDKEIsIFBbVl0sIFQsIFBbViArIDFdKSk7ZWxzZSBhLnB1c2goQyh7XG4gICAgICAgIGZpeGVkOiAwLFxuICAgICAgICBzdHJldGNoOiAtMVxuICAgICAgfSwge1xuICAgICAgICBmaXhlZDogMCxcbiAgICAgICAgc3RyZXRjaDogLTFcbiAgICAgIH0sIHtcbiAgICAgICAgZml4ZWQ6IDAsXG4gICAgICAgIHN0cmV0Y2g6IHUgKyAxXG4gICAgICB9LCB7XG4gICAgICAgIGZpeGVkOiAwLFxuICAgICAgICBzdHJldGNoOiBsICsgMVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEh1KHQsIGUsIHIpIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvID0gYVtpXTtcbiAgICAgICAgbiArPSBNYXRoLm1heChlLCBNYXRoLm1pbihyLCBvWzFdKSkgLSBNYXRoLm1heChlLCBNYXRoLm1pbihyLCBvWzBdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gWXUodCwgZSwgcikge1xuICAgICAgZm9yICh2YXIgbiA9IFt7XG4gICAgICAgICAgZml4ZWQ6IC0xLFxuICAgICAgICAgIHN0cmV0Y2g6IDBcbiAgICAgICAgfV0sIGkgPSAwLCBhID0gdDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBhW2ldLFxuICAgICAgICAgIHMgPSBvWzBdLFxuICAgICAgICAgIHUgPSBvWzFdLFxuICAgICAgICAgIGwgPSBuW24ubGVuZ3RoIC0gMV07XG4gICAgICAgIG4ucHVzaCh7XG4gICAgICAgICAgZml4ZWQ6IHMgLSBsLnN0cmV0Y2gsXG4gICAgICAgICAgc3RyZXRjaDogbC5zdHJldGNoXG4gICAgICAgIH0pLCBuLnB1c2goe1xuICAgICAgICAgIGZpeGVkOiBzIC0gbC5zdHJldGNoLFxuICAgICAgICAgIHN0cmV0Y2g6IGwuc3RyZXRjaCArICh1IC0gcylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbi5wdXNoKHtcbiAgICAgICAgZml4ZWQ6IGUgKyAxLFxuICAgICAgICBzdHJldGNoOiByXG4gICAgICB9KSwgbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gJHUodCwgZSwgciwgbikge1xuICAgICAgcmV0dXJuIHQgLyBlICogciArIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFd1KHQsIGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiB0IC0gZSAqIHIgLyBuO1xuICAgIH1cbiAgICB2YXIgUXUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcywgdSwgbCwgcCkge1xuICAgICAgICBpZiAodGhpcy5ib3hTdGFydEluZGV4ID0gdC5sZW5ndGgsIGwpIHtcbiAgICAgICAgICB2YXIgYyA9IG8udG9wLFxuICAgICAgICAgICAgaCA9IG8uYm90dG9tLFxuICAgICAgICAgICAgZiA9IG8uY29sbGlzaW9uUGFkZGluZztcbiAgICAgICAgICBmICYmIChjIC09IGZbMV0sIGggKz0gZlszXSk7XG4gICAgICAgICAgdmFyIHkgPSBoIC0gYztcbiAgICAgICAgICB5ID4gMCAmJiAoeSA9IE1hdGgubWF4KDEwLCB5KSwgdGhpcy5jaXJjbGVEaWFtZXRlciA9IHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkID0gby50b3AgKiBzIC0gdSxcbiAgICAgICAgICAgIG0gPSBvLmJvdHRvbSAqIHMgKyB1LFxuICAgICAgICAgICAgdiA9IG8ubGVmdCAqIHMgLSB1LFxuICAgICAgICAgICAgZyA9IG8ucmlnaHQgKiBzICsgdSxcbiAgICAgICAgICAgIHggPSBvLmNvbGxpc2lvblBhZGRpbmc7XG4gICAgICAgICAgaWYgKHggJiYgKHYgLT0geFswXSAqIHMsIGQgLT0geFsxXSAqIHMsIGcgKz0geFsyXSAqIHMsIG0gKz0geFszXSAqIHMpLCBwKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBpKHYsIGQpLFxuICAgICAgICAgICAgICB3ID0gbmV3IGkoZywgZCksXG4gICAgICAgICAgICAgIF8gPSBuZXcgaSh2LCBtKSxcbiAgICAgICAgICAgICAgQSA9IG5ldyBpKGcsIG0pLFxuICAgICAgICAgICAgICBTID0gcCAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgICAgICBiLl9yb3RhdGUoUyksIHcuX3JvdGF0ZShTKSwgXy5fcm90YXRlKFMpLCBBLl9yb3RhdGUoUyksIHYgPSBNYXRoLm1pbihiLngsIHcueCwgXy54LCBBLngpLCBnID0gTWF0aC5tYXgoYi54LCB3LngsIF8ueCwgQS54KSwgZCA9IE1hdGgubWluKGIueSwgdy55LCBfLnksIEEueSksIG0gPSBNYXRoLm1heChiLnksIHcueSwgXy55LCBBLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0LmVtcGxhY2VCYWNrKGUueCwgZS55LCB2LCBkLCBnLCBtLCByLCBuLCBhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJveEVuZEluZGV4ID0gdC5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgdGwgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpZiAodm9pZCAwID09PSB0ICYmICh0ID0gW10pLCB2b2lkIDAgPT09IGUgJiYgKGUgPSBlbCksIHRoaXMuZGF0YSA9IHQsIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCwgdGhpcy5jb21wYXJlID0gZSwgdGhpcy5sZW5ndGggPiAwKSBmb3IgKHZhciByID0gKHRoaXMubGVuZ3RoID4+IDEpIC0gMTsgciA+PSAwOyByLS0pIHRoaXMuX2Rvd24ocik7XG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIGVsKHQsIGUpIHtcbiAgICAgIHJldHVybiB0IDwgZSA/IC0xIDogdCA+IGUgPyAxIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmwodCwgZSwgcikge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMSksIHZvaWQgMCA9PT0gciAmJiAociA9ICExKTtcbiAgICAgIGZvciAodmFyIG4gPSAxIC8gMCwgYSA9IDEgLyAwLCBvID0gLTEgLyAwLCBzID0gLTEgLyAwLCB1ID0gdFswXSwgbCA9IDA7IGwgPCB1Lmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIHZhciBwID0gdVtsXTtcbiAgICAgICAgKCFsIHx8IHAueCA8IG4pICYmIChuID0gcC54KSwgKCFsIHx8IHAueSA8IGEpICYmIChhID0gcC55KSwgKCFsIHx8IHAueCA+IG8pICYmIChvID0gcC54KSwgKCFsIHx8IHAueSA+IHMpICYmIChzID0gcC55KTtcbiAgICAgIH1cbiAgICAgIHZhciBjID0gTWF0aC5taW4obyAtIG4sIHMgLSBhKSxcbiAgICAgICAgaCA9IGMgLyAyLFxuICAgICAgICBmID0gbmV3IHRsKFtdLCBubCk7XG4gICAgICBpZiAoMCA9PT0gYykgcmV0dXJuIG5ldyBpKG4sIGEpO1xuICAgICAgZm9yICh2YXIgeSA9IG47IHkgPCBvOyB5ICs9IGMpIGZvciAodmFyIGQgPSBhOyBkIDwgczsgZCArPSBjKSBmLnB1c2gobmV3IGlsKHkgKyBoLCBkICsgaCwgaCwgdCkpO1xuICAgICAgZm9yICh2YXIgbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwLCBuID0gMCwgaSA9IHRbMF0sIGEgPSAwLCBvID0gaS5sZW5ndGgsIHMgPSBvIC0gMTsgYSA8IG87IHMgPSBhKyspIHtcbiAgICAgICAgICAgIHZhciB1ID0gaVthXSxcbiAgICAgICAgICAgICAgbCA9IGlbc10sXG4gICAgICAgICAgICAgIHAgPSB1LnggKiBsLnkgLSBsLnggKiB1Lnk7XG4gICAgICAgICAgICByICs9ICh1LnggKyBsLngpICogcCwgbiArPSAodS55ICsgbC55KSAqIHAsIGUgKz0gMyAqIHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgaWwociAvIGUsIG4gLyBlLCAwLCB0KTtcbiAgICAgICAgfSh0KSwgdiA9IGYubGVuZ3RoOyBmLmxlbmd0aDspIHtcbiAgICAgICAgdmFyIGcgPSBmLnBvcCgpO1xuICAgICAgICAoZy5kID4gbS5kIHx8ICFtLmQpICYmIChtID0gZywgciAmJiBjb25zb2xlLmxvZyhcImZvdW5kIGJlc3QgJWQgYWZ0ZXIgJWQgcHJvYmVzXCIsIE1hdGgucm91bmQoMWU0ICogZy5kKSAvIDFlNCwgdikpLCBnLm1heCAtIG0uZCA8PSBlIHx8IChmLnB1c2gobmV3IGlsKGcucC54IC0gKGggPSBnLmggLyAyKSwgZy5wLnkgLSBoLCBoLCB0KSksIGYucHVzaChuZXcgaWwoZy5wLnggKyBoLCBnLnAueSAtIGgsIGgsIHQpKSwgZi5wdXNoKG5ldyBpbChnLnAueCAtIGgsIGcucC55ICsgaCwgaCwgdCkpLCBmLnB1c2gobmV3IGlsKGcucC54ICsgaCwgZy5wLnkgKyBoLCBoLCB0KSksIHYgKz0gNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gciAmJiAoY29uc29sZS5sb2coXCJudW0gcHJvYmVzOiBcIiArIHYpLCBjb25zb2xlLmxvZyhcImJlc3QgZGlzdGFuY2U6IFwiICsgbS5kKSksIG0ucDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmwodCwgZSkge1xuICAgICAgcmV0dXJuIGUubWF4IC0gdC5tYXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlsKHQsIGUsIHIsIG4pIHtcbiAgICAgIHRoaXMucCA9IG5ldyBpKHQsIGUpLCB0aGlzLmggPSByLCB0aGlzLmQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciByID0gITEsIG4gPSAxIC8gMCwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSBmb3IgKHZhciBhID0gZVtpXSwgbyA9IDAsIHMgPSBhLmxlbmd0aCwgdSA9IHMgLSAxOyBvIDwgczsgdSA9IG8rKykge1xuICAgICAgICAgIHZhciBsID0gYVtvXSxcbiAgICAgICAgICAgIHAgPSBhW3VdO1xuICAgICAgICAgIGwueSA+IHQueSAhPSBwLnkgPiB0LnkgJiYgdC54IDwgKHAueCAtIGwueCkgKiAodC55IC0gbC55KSAvIChwLnkgLSBsLnkpICsgbC54ICYmIChyID0gIXIpLCBuID0gTWF0aC5taW4obiwgJGEodCwgbCwgcCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAociA/IDEgOiAtMSkgKiBNYXRoLnNxcnQobik7XG4gICAgICB9KHRoaXMucCwgbiksIHRoaXMubWF4ID0gdGhpcy5kICsgdGhpcy5oICogTWF0aC5TUVJUMjtcbiAgICB9XG4gICAgdGwucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5kYXRhLnB1c2godCksIHRoaXMubGVuZ3RoKyssIHRoaXMuX3VwKHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfSwgdGwucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgwICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuZGF0YVswXSxcbiAgICAgICAgICBlID0gdGhpcy5kYXRhLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgtLSwgdGhpcy5sZW5ndGggPiAwICYmICh0aGlzLmRhdGFbMF0gPSBlLCB0aGlzLl9kb3duKDApKSwgdDtcbiAgICAgIH1cbiAgICB9LCB0bC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfSwgdGwucHJvdG90eXBlLl91cCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5kYXRhLCByID0gdGhpcy5jb21wYXJlLCBuID0gZVt0XTsgdCA+IDA7KSB7XG4gICAgICAgIHZhciBpID0gdCAtIDEgPj4gMSxcbiAgICAgICAgICBhID0gZVtpXTtcbiAgICAgICAgaWYgKHIobiwgYSkgPj0gMCkgYnJlYWs7XG4gICAgICAgIGVbdF0gPSBhLCB0ID0gaTtcbiAgICAgIH1cbiAgICAgIGVbdF0gPSBuO1xuICAgIH0sIHRsLnByb3RvdHlwZS5fZG93biA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5kYXRhLCByID0gdGhpcy5jb21wYXJlLCBuID0gdGhpcy5sZW5ndGggPj4gMSwgaSA9IGVbdF07IHQgPCBuOykge1xuICAgICAgICB2YXIgYSA9IDEgKyAodCA8PCAxKSxcbiAgICAgICAgICBvID0gZVthXSxcbiAgICAgICAgICBzID0gYSArIDE7XG4gICAgICAgIGlmIChzIDwgdGhpcy5sZW5ndGggJiYgcihlW3NdLCBvKSA8IDAgJiYgKGEgPSBzLCBvID0gZVtzXSksIHIobywgaSkgPj0gMCkgYnJlYWs7XG4gICAgICAgIGVbdF0gPSBvLCB0ID0gYTtcbiAgICAgIH1cbiAgICAgIGVbdF0gPSBpO1xuICAgIH07XG4gICAgdmFyIGFsID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGZ1bmN0aW9uIG9sKHQsIGUpIHtcbiAgICAgIHJldHVybiBlWzFdICE9PSBhbCA/IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgc3dpdGNoIChlID0gTWF0aC5hYnMoZSksIHIgPSBNYXRoLmFicyhyKSwgdCkge1xuICAgICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICBpID0gciAtIDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6XG4gICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgaSA9IDcgLSByO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICBuID0gLWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgbiA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuLCBpXTtcbiAgICAgIH0odCwgZVswXSwgZVsxXSkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgciA9IDAsXG4gICAgICAgICAgbiA9IDA7XG4gICAgICAgIGUgPCAwICYmIChlID0gMCk7XG4gICAgICAgIHZhciBpID0gZSAvIE1hdGguc3FydCgyKTtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJ0b3AtbGVmdFwiOlxuICAgICAgICAgICAgbiA9IGkgLSA3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOlxuICAgICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgICAgbiA9IDcgLSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgbiA9IDcgLSBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgbiA9IGUgLSA3O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgXCJ0b3AtcmlnaHRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgICByID0gLWk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgICAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgICAgICAgIHIgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIHIgPSBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICByID0gLWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyLCBuXTtcbiAgICAgIH0odCwgZVswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNsKHQpIHtcbiAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1yaWdodFwiOlxuICAgICAgICBjYXNlIFwiYm90dG9tLXJpZ2h0XCI6XG4gICAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInRvcC1sZWZ0XCI6XG4gICAgICAgIGNhc2UgXCJib3R0b20tbGVmdFwiOlxuICAgICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImNlbnRlclwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bCh0LCBlLCByLCBuLCBhLCBvLCBzLCB1LCBsLCBwLCBjLCBoLCBmLCB5LCBkKSB7XG4gICAgICB2YXIgbSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBhLCBvLCBzLCB1KSB7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IG4ubGF5b3V0LmdldChcInRleHQtcm90YXRlXCIpLmV2YWx1YXRlKG8sIHt9KSAqIE1hdGguUEkgLyAxODAsIHAgPSBbXSwgYyA9IDAsIGggPSBlLnBvc2l0aW9uZWRMaW5lczsgYyA8IGgubGVuZ3RoOyBjICs9IDEpIGZvciAodmFyIGYgPSBoW2NdLCB5ID0gMCwgZCA9IGYucG9zaXRpb25lZEdseXBoczsgeSA8IGQubGVuZ3RoOyB5ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtID0gZFt5XTtcbiAgICAgICAgICAgIGlmIChtLnJlY3QpIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBtLnJlY3QgfHwge30sXG4gICAgICAgICAgICAgICAgZyA9IDQsXG4gICAgICAgICAgICAgICAgeCA9ICEwLFxuICAgICAgICAgICAgICAgIGIgPSAxLFxuICAgICAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgICAgIF8gPSAoYSB8fCB1KSAmJiBtLnZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIEEgPSBtLm1ldHJpY3MuYWR2YW5jZSAqIG0uc2NhbGUgLyAyO1xuICAgICAgICAgICAgICBpZiAodSAmJiBlLnZlcnRpY2FsaXphYmxlICYmICh3ID0gZi5saW5lT2Zmc2V0IC8gMiAtIChtLmltYWdlTmFtZSA/IC0oMjQgLSBtLm1ldHJpY3Mud2lkdGggKiBtLnNjYWxlKSAvIDIgOiAyNCAqIChtLnNjYWxlIC0gMSkpKSwgbS5pbWFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgUyA9IHNbbS5pbWFnZU5hbWVdO1xuICAgICAgICAgICAgICAgIHggPSBTLnNkZiwgZyA9IDEgLyAoYiA9IFMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGsgPSBhID8gW20ueCArIEEsIG0ueV0gOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgSSA9IGEgPyBbMCwgMF0gOiBbbS54ICsgQSArIHJbMF0sIG0ueSArIHJbMV0gLSB3XSxcbiAgICAgICAgICAgICAgICB6ID0gWzAsIDBdO1xuICAgICAgICAgICAgICBfICYmICh6ID0gSSwgSSA9IFswLCAwXSk7XG4gICAgICAgICAgICAgIHZhciBDID0gKG0ubWV0cmljcy5sZWZ0IC0gZykgKiBtLnNjYWxlIC0gQSArIElbMF0sXG4gICAgICAgICAgICAgICAgRSA9ICgtbS5tZXRyaWNzLnRvcCAtIGcpICogbS5zY2FsZSArIElbMV0sXG4gICAgICAgICAgICAgICAgUCA9IEMgKyB2LncgKiBtLnNjYWxlIC8gYixcbiAgICAgICAgICAgICAgICBNID0gRSArIHYuaCAqIG0uc2NhbGUgLyBiLFxuICAgICAgICAgICAgICAgIEIgPSBuZXcgaShDLCBFKSxcbiAgICAgICAgICAgICAgICBUID0gbmV3IGkoUCwgRSksXG4gICAgICAgICAgICAgICAgViA9IG5ldyBpKEMsIE0pLFxuICAgICAgICAgICAgICAgIEYgPSBuZXcgaShQLCBNKTtcbiAgICAgICAgICAgICAgaWYgKF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgRCA9IG5ldyBpKC1BLCBBIC0gLTE3KSxcbiAgICAgICAgICAgICAgICAgIEwgPSAtTWF0aC5QSSAvIDIsXG4gICAgICAgICAgICAgICAgICBSID0gMTIgLSBBLFxuICAgICAgICAgICAgICAgICAgTyA9IG5ldyBpKDIyIC0gUiwgLShtLmltYWdlTmFtZSA/IFIgOiAwKSksXG4gICAgICAgICAgICAgICAgICBVID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShpLCBbbnVsbF0uY29uY2F0KHopKSkoKTtcbiAgICAgICAgICAgICAgICBCLl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChPKS5fYWRkKFUpLCBULl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChPKS5fYWRkKFUpLCBWLl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChPKS5fYWRkKFUpLCBGLl9yb3RhdGVBcm91bmQoTCwgRCkuX2FkZChPKS5fYWRkKFUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSBNYXRoLnNpbihsKSxcbiAgICAgICAgICAgICAgICAgIHEgPSBNYXRoLmNvcyhsKSxcbiAgICAgICAgICAgICAgICAgIE4gPSBbcSwgLWosIGosIHFdO1xuICAgICAgICAgICAgICAgIEIuX21hdE11bHQoTiksIFQuX21hdE11bHQoTiksIFYuX21hdE11bHQoTiksIEYuX21hdE11bHQoTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIEsgPSBuZXcgaSgwLCAwKSxcbiAgICAgICAgICAgICAgICBHID0gbmV3IGkoMCwgMCk7XG4gICAgICAgICAgICAgIHAucHVzaCh7XG4gICAgICAgICAgICAgICAgdGw6IEIsXG4gICAgICAgICAgICAgICAgdHI6IFQsXG4gICAgICAgICAgICAgICAgYmw6IFYsXG4gICAgICAgICAgICAgICAgYnI6IEYsXG4gICAgICAgICAgICAgICAgdGV4OiB2LFxuICAgICAgICAgICAgICAgIHdyaXRpbmdNb2RlOiBlLndyaXRpbmdNb2RlLFxuICAgICAgICAgICAgICAgIGdseXBoT2Zmc2V0OiBrLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25JbmRleDogbS5zZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgaXNTREY6IHgsXG4gICAgICAgICAgICAgICAgcGl4ZWxPZmZzZXRUTDogSyxcbiAgICAgICAgICAgICAgICBwaXhlbE9mZnNldEJSOiBHLFxuICAgICAgICAgICAgICAgIG1pbkZvbnRTY2FsZVg6IDAsXG4gICAgICAgICAgICAgICAgbWluRm9udFNjYWxlWTogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0oMCwgciwgdSwgYSwgbywgcywgbiwgdC5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50KSxcbiAgICAgICAgdiA9IHQudGV4dFNpemVEYXRhLFxuICAgICAgICBnID0gbnVsbDtcbiAgICAgIFwic291cmNlXCIgPT09IHYua2luZCA/IChnID0gWzEyOCAqIGEubGF5b3V0LmdldChcInRleHQtc2l6ZVwiKS5ldmFsdWF0ZShzLCB7fSldKVswXSA+IDMyNjQwICYmIEEodC5sYXllcklkc1swXSArICc6IFZhbHVlIGZvciBcInRleHQtc2l6ZVwiIGlzID49IDI1NS4gUmVkdWNlIHlvdXIgXCJ0ZXh0LXNpemVcIi4nKSA6IFwiY29tcG9zaXRlXCIgPT09IHYua2luZCAmJiAoKGcgPSBbMTI4ICogeS5jb21wb3NpdGVUZXh0U2l6ZXNbMF0uZXZhbHVhdGUocywge30sIGQpLCAxMjggKiB5LmNvbXBvc2l0ZVRleHRTaXplc1sxXS5ldmFsdWF0ZShzLCB7fSwgZCldKVswXSA+IDMyNjQwIHx8IGdbMV0gPiAzMjY0MCkgJiYgQSh0LmxheWVySWRzWzBdICsgJzogVmFsdWUgZm9yIFwidGV4dC1zaXplXCIgaXMgPj0gMjU1LiBSZWR1Y2UgeW91ciBcInRleHQtc2l6ZVwiLicpLCB0LmFkZFN5bWJvbHModC50ZXh0LCBtLCBnLCB1LCBvLCBzLCBwLCBlLCBsLmxpbmVTdGFydEluZGV4LCBsLmxpbmVMZW5ndGgsIGYsIGQpO1xuICAgICAgZm9yICh2YXIgeCA9IDAsIGIgPSBjOyB4IDwgYi5sZW5ndGg7IHggKz0gMSkgaFtiW3hdXSA9IHQudGV4dC5wbGFjZWRTeW1ib2xBcnJheS5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIDQgKiBtLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGwodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0KSByZXR1cm4gdFtlXTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwbCh0LCBlLCByLCBuKSB7XG4gICAgICB2YXIgaSA9IHQuY29tcGFyZVRleHQ7XG4gICAgICBpZiAoZSBpbiBpKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBpW2VdLCBvID0gYS5sZW5ndGggLSAxOyBvID49IDA7IG8tLSkgaWYgKG4uZGlzdChhW29dKSA8IHIpIHJldHVybiAhMDtcbiAgICAgIH0gZWxzZSBpW2VdID0gW107XG4gICAgICByZXR1cm4gaVtlXS5wdXNoKG4pLCAhMTtcbiAgICB9XG4gICAgdmFyIGNsID0gd3MuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMsXG4gICAgICBobCA9IFt7XG4gICAgICAgIG5hbWU6IFwiYV9mYWRlX29wYWNpdHlcIixcbiAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgdHlwZTogXCJVaW50OFwiLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1dO1xuICAgIGZ1bmN0aW9uIGZsKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgpIHtcbiAgICAgIHZhciBmID0gcyA/IE1hdGgubWluKDMyNjQwLCBNYXRoLnJvdW5kKHNbMF0pKSA6IDAsXG4gICAgICAgIHkgPSBzID8gTWF0aC5taW4oMzI2NDAsIE1hdGgucm91bmQoc1sxXSkpIDogMDtcbiAgICAgIHQuZW1wbGFjZUJhY2soZSwgciwgTWF0aC5yb3VuZCgzMiAqIG4pLCBNYXRoLnJvdW5kKDMyICogaSksIGEsIG8sIChmIDw8IDEpICsgKHUgPyAxIDogMCksIHksIDE2ICogbCwgMTYgKiBwLCAyNTYgKiBjLCAyNTYgKiBoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geWwodCwgZSwgcikge1xuICAgICAgdC5lbXBsYWNlQmFjayhlLngsIGUueSwgciksIHQuZW1wbGFjZUJhY2soZS54LCBlLnksIHIpLCB0LmVtcGxhY2VCYWNrKGUueCwgZS55LCByKSwgdC5lbXBsYWNlQmFjayhlLngsIGUueSwgcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRsKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdC5zZWN0aW9uczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIGlmIChXbihyW2VdLnRleHQpKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHZhciBtbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IEZpKCksIHRoaXMuaW5kZXhBcnJheSA9IG5ldyBxaSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucyA9IHQsIHRoaXMuc2VnbWVudHMgPSBuZXcgdWEoKSwgdGhpcy5keW5hbWljTGF5b3V0VmVydGV4QXJyYXkgPSBuZXcgRGkoKSwgdGhpcy5vcGFjaXR5VmVydGV4QXJyYXkgPSBuZXcgTGkoKSwgdGhpcy5wbGFjZWRTeW1ib2xBcnJheSA9IG5ldyB0YSgpO1xuICAgIH07XG4gICAgbWwucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGggJiYgMCA9PT0gdGhpcy5pbmRleEFycmF5Lmxlbmd0aCAmJiAwID09PSB0aGlzLmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGggJiYgMCA9PT0gdGhpcy5vcGFjaXR5VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgIH0sIG1sLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdGhpcy5pc0VtcHR5KCkgfHwgKHIgJiYgKHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgcXMubWVtYmVycyksIHRoaXMuaW5kZXhCdWZmZXIgPSB0LmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuaW5kZXhBcnJheSwgZSksIHRoaXMuZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuZHluYW1pY0xheW91dFZlcnRleEFycmF5LCBOcy5tZW1iZXJzLCAhMCksIHRoaXMub3BhY2l0eVZlcnRleEJ1ZmZlciA9IHQuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMub3BhY2l0eVZlcnRleEFycmF5LCBobCwgITApLCB0aGlzLm9wYWNpdHlWZXJ0ZXhCdWZmZXIuaXRlbVNpemUgPSAxKSwgKHIgfHwgbikgJiYgdGhpcy5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBsb2FkKHQpKTtcbiAgICB9LCBtbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyICYmICh0aGlzLmxheW91dFZlcnRleEJ1ZmZlci5kZXN0cm95KCksIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLnByb2dyYW1Db25maWd1cmF0aW9ucy5kZXN0cm95KCksIHRoaXMuc2VnbWVudHMuZGVzdHJveSgpLCB0aGlzLmR5bmFtaWNMYXlvdXRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLm9wYWNpdHlWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpKTtcbiAgICB9LCBPbihcIlN5bWJvbEJ1ZmZlcnNcIiwgbWwpO1xuICAgIHZhciB2bCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEFycmF5ID0gbmV3IHQoKSwgdGhpcy5sYXlvdXRBdHRyaWJ1dGVzID0gZSwgdGhpcy5pbmRleEFycmF5ID0gbmV3IHIoKSwgdGhpcy5zZWdtZW50cyA9IG5ldyB1YSgpLCB0aGlzLmNvbGxpc2lvblZlcnRleEFycmF5ID0gbmV3IGppKCk7XG4gICAgfTtcbiAgICB2bC5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyID0gdC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSwgdGhpcy5sYXlvdXRBdHRyaWJ1dGVzKSwgdGhpcy5pbmRleEJ1ZmZlciA9IHQuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5pbmRleEFycmF5KSwgdGhpcy5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIgPSB0LmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLmNvbGxpc2lvblZlcnRleEFycmF5LCBLcy5tZW1iZXJzLCAhMCk7XG4gICAgfSwgdmwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciAmJiAodGhpcy5sYXlvdXRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpLCB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKSwgdGhpcy5zZWdtZW50cy5kZXN0cm95KCksIHRoaXMuY29sbGlzaW9uVmVydGV4QnVmZmVyLmRlc3Ryb3koKSk7XG4gICAgfSwgT24oXCJDb2xsaXNpb25CdWZmZXJzXCIsIHZsKTtcbiAgICB2YXIgZ2wgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IHQuY29sbGlzaW9uQm94QXJyYXksIHRoaXMuem9vbSA9IHQuem9vbSwgdGhpcy5vdmVyc2NhbGluZyA9IHQub3ZlcnNjYWxpbmcsIHRoaXMubGF5ZXJzID0gdC5sYXllcnMsIHRoaXMubGF5ZXJJZHMgPSB0aGlzLmxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICB9KSwgdGhpcy5pbmRleCA9IHQuaW5kZXgsIHRoaXMucGl4ZWxSYXRpbyA9IHQucGl4ZWxSYXRpbywgdGhpcy5zb3VyY2VMYXllckluZGV4ID0gdC5zb3VyY2VMYXllckluZGV4LCB0aGlzLmhhc1BhdHRlcm4gPSAhMSwgdGhpcy5oYXNSVExUZXh0ID0gITEsIHRoaXMuc29ydEtleVJhbmdlcyA9IFtdLCB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5ID0gW10sIHRoaXMucGxhY2VtZW50SW52UHJvak1hdHJpeCA9IHNvKFtdKSwgdGhpcy5wbGFjZW1lbnRWaWV3cG9ydE1hdHJpeCA9IHNvKFtdKTtcbiAgICAgIHZhciBlID0gdGhpcy5sYXllcnNbMF0uX3VuZXZhbHVhdGVkTGF5b3V0Ll92YWx1ZXM7XG4gICAgICB0aGlzLnRleHRTaXplRGF0YSA9IEx1KHRoaXMuem9vbSwgZVtcInRleHQtc2l6ZVwiXSksIHRoaXMuaWNvblNpemVEYXRhID0gTHUodGhpcy56b29tLCBlW1wiaWNvbi1zaXplXCJdKTtcbiAgICAgIHZhciByID0gdGhpcy5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICBuID0gci5nZXQoXCJzeW1ib2wtc29ydC1rZXlcIiksXG4gICAgICAgIGkgPSByLmdldChcInN5bWJvbC16LW9yZGVyXCIpO1xuICAgICAgdGhpcy5jYW5PdmVybGFwID0gci5nZXQoXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIikgfHwgci5nZXQoXCJpY29uLWFsbG93LW92ZXJsYXBcIikgfHwgci5nZXQoXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIikgfHwgci5nZXQoXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIiksIHRoaXMuc29ydEZlYXR1cmVzQnlLZXkgPSBcInZpZXdwb3J0LXlcIiAhPT0gaSAmJiAhbi5pc0NvbnN0YW50KCksIHRoaXMuc29ydEZlYXR1cmVzQnlZID0gKFwidmlld3BvcnQteVwiID09PSBpIHx8IFwiYXV0b1wiID09PSBpICYmICF0aGlzLnNvcnRGZWF0dXJlc0J5S2V5KSAmJiB0aGlzLmNhbk92ZXJsYXAsIFwicG9pbnRcIiA9PT0gci5nZXQoXCJzeW1ib2wtcGxhY2VtZW50XCIpICYmICh0aGlzLndyaXRpbmdNb2RlcyA9IHIuZ2V0KFwidGV4dC13cml0aW5nLW1vZGVcIikubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBfdVt0XTtcbiAgICAgIH0pKSwgdGhpcy5zdGF0ZURlcGVuZGVudExheWVySWRzID0gdGhpcy5sYXllcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LmlzU3RhdGVEZXBlbmRlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pZDtcbiAgICAgIH0pLCB0aGlzLnNvdXJjZUlEID0gdC5zb3VyY2VJRDtcbiAgICB9O1xuICAgIGdsLnByb3RvdHlwZS5jcmVhdGVBcnJheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRleHQgPSBuZXcgbWwobmV3IEZhKHRoaXMubGF5ZXJzLCB0aGlzLnpvb20sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiAvXnRleHQvLnRlc3QodCk7XG4gICAgICB9KSksIHRoaXMuaWNvbiA9IG5ldyBtbChuZXcgRmEodGhpcy5sYXllcnMsIHRoaXMuem9vbSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIC9eaWNvbi8udGVzdCh0KTtcbiAgICAgIH0pKSwgdGhpcy5nbHlwaE9mZnNldEFycmF5ID0gbmV3IG5hKCksIHRoaXMubGluZVZlcnRleEFycmF5ID0gbmV3IGlhKCksIHRoaXMuc3ltYm9sSW5zdGFuY2VzID0gbmV3IHJhKCk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmNhbGN1bGF0ZUdseXBoRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykgaWYgKGVbdC5jaGFyQ29kZUF0KGEpXSA9ICEwLCAociB8fCBuKSAmJiBpKSB7XG4gICAgICAgIHZhciBvID0gSnNbdC5jaGFyQXQoYSldO1xuICAgICAgICBvICYmIChlW28uY2hhckNvZGVBdCgwKV0gPSAhMCk7XG4gICAgICB9XG4gICAgfSwgZ2wucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5sYXllcnNbMF0sXG4gICAgICAgIGkgPSBuLmxheW91dCxcbiAgICAgICAgYSA9IGkuZ2V0KFwidGV4dC1mb250XCIpLFxuICAgICAgICBvID0gaS5nZXQoXCJ0ZXh0LWZpZWxkXCIpLFxuICAgICAgICBzID0gaS5nZXQoXCJpY29uLWltYWdlXCIpLFxuICAgICAgICB1ID0gKFwiY29uc3RhbnRcIiAhPT0gby52YWx1ZS5raW5kIHx8IG8udmFsdWUudmFsdWUgaW5zdGFuY2VvZiBpZSAmJiAhby52YWx1ZS52YWx1ZS5pc0VtcHR5KCkgfHwgby52YWx1ZS52YWx1ZS50b1N0cmluZygpLmxlbmd0aCA+IDApICYmIChcImNvbnN0YW50XCIgIT09IGEudmFsdWUua2luZCB8fCBhLnZhbHVlLnZhbHVlLmxlbmd0aCA+IDApLFxuICAgICAgICBsID0gXCJjb25zdGFudFwiICE9PSBzLnZhbHVlLmtpbmQgfHwgISFzLnZhbHVlLnZhbHVlIHx8IE9iamVjdC5rZXlzKHMucGFyYW1ldGVycykubGVuZ3RoID4gMCxcbiAgICAgICAgcCA9IGkuZ2V0KFwic3ltYm9sLXNvcnQta2V5XCIpO1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXMgPSBbXSwgdSB8fCBsKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSBlLmljb25EZXBlbmRlbmNpZXMsIGggPSBlLmdseXBoRGVwZW5kZW5jaWVzLCBmID0gZS5hdmFpbGFibGVJbWFnZXMsIHkgPSBuZXcgdWkodGhpcy56b29tKSwgZCA9IDAsIG0gPSB0OyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICAgIHZhciB2ID0gbVtkXSxcbiAgICAgICAgICAgIGcgPSB2LmZlYXR1cmUsXG4gICAgICAgICAgICB4ID0gdi5pZCxcbiAgICAgICAgICAgIGIgPSB2LmluZGV4LFxuICAgICAgICAgICAgdyA9IHYuc291cmNlTGF5ZXJJbmRleCxcbiAgICAgICAgICAgIF8gPSBuLl9mZWF0dXJlRmlsdGVyLm5lZWRHZW9tZXRyeSxcbiAgICAgICAgICAgIEEgPSBqYShnLCBfKTtcbiAgICAgICAgICBpZiAobi5fZmVhdHVyZUZpbHRlci5maWx0ZXIoeSwgQSwgcikpIHtcbiAgICAgICAgICAgIF8gfHwgKEEuZ2VvbWV0cnkgPSBVYShnKSk7XG4gICAgICAgICAgICB2YXIgUyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICAgIHZhciBrID0gbi5nZXRWYWx1ZUFuZFJlc29sdmVUb2tlbnMoXCJ0ZXh0LWZpZWxkXCIsIEEsIHIsIGYpLFxuICAgICAgICAgICAgICAgIEkgPSBpZS5mYWN0b3J5KGspO1xuICAgICAgICAgICAgICBkbChJKSAmJiAodGhpcy5oYXNSVExUZXh0ID0gITApLCAoIXRoaXMuaGFzUlRMVGV4dCB8fCBcInVuYXZhaWxhYmxlXCIgPT09IGFpKCkgfHwgdGhpcy5oYXNSVExUZXh0ICYmIHNpLmlzUGFyc2VkKCkpICYmIChTID0gWHMoSSwgbiwgQSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHogPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICB2YXIgQyA9IG4uZ2V0VmFsdWVBbmRSZXNvbHZlVG9rZW5zKFwiaWNvbi1pbWFnZVwiLCBBLCByLCBmKTtcbiAgICAgICAgICAgICAgeiA9IEMgaW5zdGFuY2VvZiBhZSA/IEMgOiBhZS5mcm9tU3RyaW5nKEMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFMgfHwgeikge1xuICAgICAgICAgICAgICB2YXIgRSA9IHRoaXMuc29ydEZlYXR1cmVzQnlLZXkgPyBwLmV2YWx1YXRlKEEsIHt9LCByKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHgsXG4gICAgICAgICAgICAgICAgdGV4dDogUyxcbiAgICAgICAgICAgICAgICBpY29uOiB6LFxuICAgICAgICAgICAgICAgIGluZGV4OiBiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IHcsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IEEuZ2VvbWV0cnksXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogZy5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIHR5cGU6IGNsW2cudHlwZV0sXG4gICAgICAgICAgICAgICAgc29ydEtleTogRVxuICAgICAgICAgICAgICB9KSwgeiAmJiAoY1t6Lm5hbWVdID0gITApLCBTKSB7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBhLmV2YWx1YXRlKEEsIHt9LCByKS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgIE0gPSBcIm1hcFwiID09PSBpLmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpICYmIFwicG9pbnRcIiAhPT0gaS5nZXQoXCJzeW1ib2wtcGxhY2VtZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCA9IHRoaXMud3JpdGluZ01vZGVzICYmIHRoaXMud3JpdGluZ01vZGVzLmluZGV4T2YoX3UudmVydGljYWwpID49IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgQiA9IDAsIFQgPSBTLnNlY3Rpb25zOyBCIDwgVC5sZW5ndGg7IEIgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIFYgPSBUW0JdO1xuICAgICAgICAgICAgICAgICAgaWYgKFYuaW1hZ2UpIGNbVi5pbWFnZS5uYW1lXSA9ICEwO2Vsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRiA9IFhuKFMudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgICAgRCA9IFYuZm9udFN0YWNrIHx8IFAsXG4gICAgICAgICAgICAgICAgICAgICAgTCA9IGhbRF0gPSBoW0RdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUdseXBoRGVwZW5kZW5jaWVzKFYudGV4dCwgTCwgTSwgdGhpcy5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50LCBGKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXCJsaW5lXCIgPT09IGkuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSAmJiAodGhpcy5mZWF0dXJlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB7fSxcbiAgICAgICAgICAgIHIgPSB7fSxcbiAgICAgICAgICAgIG4gPSBbXSxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIGZ1bmN0aW9uIGEoZSkge1xuICAgICAgICAgICAgbi5wdXNoKHRbZV0pLCBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIG8odCwgZSwgaSkge1xuICAgICAgICAgICAgdmFyIGEgPSByW3RdO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSByW3RdLCByW2VdID0gYSwgblthXS5nZW9tZXRyeVswXS5wb3AoKSwgblthXS5nZW9tZXRyeVswXSA9IG5bYV0uZ2VvbWV0cnlbMF0uY29uY2F0KGlbMF0pLCBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBzKHQsIHIsIGkpIHtcbiAgICAgICAgICAgIHZhciBhID0gZVtyXTtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgZVtyXSwgZVt0XSA9IGEsIG5bYV0uZ2VvbWV0cnlbMF0uc2hpZnQoKSwgblthXS5nZW9tZXRyeVswXSA9IGlbMF0uY29uY2F0KG5bYV0uZ2VvbWV0cnlbMF0pLCBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB1KHQsIGUsIHIpIHtcbiAgICAgICAgICAgIHZhciBuID0gciA/IGVbMF1bZVswXS5sZW5ndGggLSAxXSA6IGVbMF1bMF07XG4gICAgICAgICAgICByZXR1cm4gdCArIFwiOlwiICsgbi54ICsgXCI6XCIgKyBuLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdC5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIHAgPSB0W2xdLFxuICAgICAgICAgICAgICBjID0gcC5nZW9tZXRyeSxcbiAgICAgICAgICAgICAgaCA9IHAudGV4dCA/IHAudGV4dC50b1N0cmluZygpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICAgIHZhciBmID0gdShoLCBjKSxcbiAgICAgICAgICAgICAgICB5ID0gdShoLCBjLCAhMCk7XG4gICAgICAgICAgICAgIGlmIChmIGluIHIgJiYgeSBpbiBlICYmIHJbZl0gIT09IGVbeV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHMoZiwgeSwgYyksXG4gICAgICAgICAgICAgICAgICBtID0gbyhmLCB5LCBuW2RdLmdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZVtmXSwgZGVsZXRlIHJbeV0sIHJbdShoLCBuW21dLmdlb21ldHJ5LCAhMCldID0gbSwgbltkXS5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBmIGluIHIgPyBvKGYsIHksIGMpIDogeSBpbiBlID8gcyhmLCB5LCBjKSA6IChhKGwpLCBlW2ZdID0gaSAtIDEsIHJbeV0gPSBpIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2UgYShsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG4uZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5nZW9tZXRyeTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSh0aGlzLmZlYXR1cmVzKSksIHRoaXMuc29ydEZlYXR1cmVzQnlLZXkgJiYgdGhpcy5mZWF0dXJlcy5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHQuc29ydEtleSAtIGUuc29ydEtleTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgZ2wucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnN0YXRlRGVwZW5kZW50TGF5ZXJzLmxlbmd0aCAmJiAodGhpcy50ZXh0LnByb2dyYW1Db25maWd1cmF0aW9ucy51cGRhdGVQYWludEFycmF5cyh0LCBlLCB0aGlzLmxheWVycywgciksIHRoaXMuaWNvbi5wcm9ncmFtQ29uZmlndXJhdGlvbnMudXBkYXRlUGFpbnRBcnJheXModCwgZSwgdGhpcy5sYXllcnMsIHIpKTtcbiAgICB9LCBnbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGggJiYgIXRoaXMuaGFzUlRMVGV4dDtcbiAgICB9LCBnbC5wcm90b3R5cGUudXBsb2FkUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy51cGxvYWRlZCB8fCB0aGlzLnRleHQucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLm5lZWRzVXBsb2FkIHx8IHRoaXMuaWNvbi5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQ7XG4gICAgfSwgZ2wucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAhdGhpcy51cGxvYWRlZCAmJiB0aGlzLmhhc0RlYnVnRGF0YSgpICYmICh0aGlzLnRleHRDb2xsaXNpb25Cb3gudXBsb2FkKHQpLCB0aGlzLmljb25Db2xsaXNpb25Cb3gudXBsb2FkKHQpKSwgdGhpcy50ZXh0LnVwbG9hZCh0LCB0aGlzLnNvcnRGZWF0dXJlc0J5WSwgIXRoaXMudXBsb2FkZWQsIHRoaXMudGV4dC5wcm9ncmFtQ29uZmlndXJhdGlvbnMubmVlZHNVcGxvYWQpLCB0aGlzLmljb24udXBsb2FkKHQsIHRoaXMuc29ydEZlYXR1cmVzQnlZLCAhdGhpcy51cGxvYWRlZCwgdGhpcy5pY29uLnByb2dyYW1Db25maWd1cmF0aW9ucy5uZWVkc1VwbG9hZCksIHRoaXMudXBsb2FkZWQgPSAhMDtcbiAgICB9LCBnbC5wcm90b3R5cGUuZGVzdHJveURlYnVnRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGV4dENvbGxpc2lvbkJveC5kZXN0cm95KCksIHRoaXMuaWNvbkNvbGxpc2lvbkJveC5kZXN0cm95KCk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRleHQuZGVzdHJveSgpLCB0aGlzLmljb24uZGVzdHJveSgpLCB0aGlzLmhhc0RlYnVnRGF0YSgpICYmIHRoaXMuZGVzdHJveURlYnVnRGF0YSgpO1xuICAgIH0sIGdsLnByb3RvdHlwZS5hZGRUb0xpbmVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHRoaXMubGluZVZlcnRleEFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICh2b2lkIDAgIT09IHQuc2VnbWVudCkge1xuICAgICAgICBmb3IgKHZhciBuID0gdC5kaXN0KGVbdC5zZWdtZW50ICsgMV0pLCBpID0gdC5kaXN0KGVbdC5zZWdtZW50XSksIGEgPSB7fSwgbyA9IHQuc2VnbWVudCArIDE7IG8gPCBlLmxlbmd0aDsgbysrKSBhW29dID0ge1xuICAgICAgICAgIHg6IGVbb10ueCxcbiAgICAgICAgICB5OiBlW29dLnksXG4gICAgICAgICAgdGlsZVVuaXREaXN0YW5jZUZyb21BbmNob3I6IG5cbiAgICAgICAgfSwgbyA8IGUubGVuZ3RoIC0gMSAmJiAobiArPSBlW28gKyAxXS5kaXN0KGVbb10pKTtcbiAgICAgICAgZm9yICh2YXIgcyA9IHQuc2VnbWVudCB8fCAwOyBzID49IDA7IHMtLSkgYVtzXSA9IHtcbiAgICAgICAgICB4OiBlW3NdLngsXG4gICAgICAgICAgeTogZVtzXS55LFxuICAgICAgICAgIHRpbGVVbml0RGlzdGFuY2VGcm9tQW5jaG9yOiBpXG4gICAgICAgIH0sIHMgPiAwICYmIChpICs9IGVbcyAtIDFdLmRpc3QoZVtzXSkpO1xuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGUubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICB2YXIgbCA9IGFbdV07XG4gICAgICAgICAgdGhpcy5saW5lVmVydGV4QXJyYXkuZW1wbGFjZUJhY2sobC54LCBsLnksIGwudGlsZVVuaXREaXN0YW5jZUZyb21BbmNob3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lU3RhcnRJbmRleDogcixcbiAgICAgICAgbGluZUxlbmd0aDogdGhpcy5saW5lVmVydGV4QXJyYXkubGVuZ3RoIC0gclxuICAgICAgfTtcbiAgICB9LCBnbC5wcm90b3R5cGUuYWRkU3ltYm9scyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1LCBsLCBwLCBjKSB7XG4gICAgICBmb3IgKHZhciBoID0gdC5pbmRleEFycmF5LCBmID0gdC5sYXlvdXRWZXJ0ZXhBcnJheSwgeSA9IHQuc2VnbWVudHMucHJlcGFyZVNlZ21lbnQoNCAqIGUubGVuZ3RoLCBmLCBoLCB0aGlzLmNhbk92ZXJsYXAgPyBhLnNvcnRLZXkgOiB2b2lkIDApLCBkID0gdGhpcy5nbHlwaE9mZnNldEFycmF5Lmxlbmd0aCwgbSA9IHkudmVydGV4TGVuZ3RoLCB2ID0gdGhpcy5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIG8gPT09IF91LnZlcnRpY2FsID8gTWF0aC5QSSAvIDIgOiAwLCBnID0gYS50ZXh0ICYmIGEudGV4dC5zZWN0aW9ucywgeCA9IDA7IHggPCBlLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIHZhciBiID0gZVt4XSxcbiAgICAgICAgICB3ID0gYi50bCxcbiAgICAgICAgICBfID0gYi50cixcbiAgICAgICAgICBBID0gYi5ibCxcbiAgICAgICAgICBTID0gYi5icixcbiAgICAgICAgICBrID0gYi50ZXgsXG4gICAgICAgICAgSSA9IGIucGl4ZWxPZmZzZXRUTCxcbiAgICAgICAgICB6ID0gYi5waXhlbE9mZnNldEJSLFxuICAgICAgICAgIEMgPSBiLm1pbkZvbnRTY2FsZVgsXG4gICAgICAgICAgRSA9IGIubWluRm9udFNjYWxlWSxcbiAgICAgICAgICBQID0gYi5nbHlwaE9mZnNldCxcbiAgICAgICAgICBNID0gYi5pc1NERixcbiAgICAgICAgICBCID0gYi5zZWN0aW9uSW5kZXgsXG4gICAgICAgICAgVCA9IHkudmVydGV4TGVuZ3RoLFxuICAgICAgICAgIFYgPSBQWzFdO1xuICAgICAgICBmbChmLCBzLngsIHMueSwgdy54LCBWICsgdy55LCBrLngsIGsueSwgciwgTSwgSS54LCBJLnksIEMsIEUpLCBmbChmLCBzLngsIHMueSwgXy54LCBWICsgXy55LCBrLnggKyBrLncsIGsueSwgciwgTSwgei54LCBJLnksIEMsIEUpLCBmbChmLCBzLngsIHMueSwgQS54LCBWICsgQS55LCBrLngsIGsueSArIGsuaCwgciwgTSwgSS54LCB6LnksIEMsIEUpLCBmbChmLCBzLngsIHMueSwgUy54LCBWICsgUy55LCBrLnggKyBrLncsIGsueSArIGsuaCwgciwgTSwgei54LCB6LnksIEMsIEUpLCB5bCh0LmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheSwgcywgdiksIGguZW1wbGFjZUJhY2soVCwgVCArIDEsIFQgKyAyKSwgaC5lbXBsYWNlQmFjayhUICsgMSwgVCArIDIsIFQgKyAzKSwgeS52ZXJ0ZXhMZW5ndGggKz0gNCwgeS5wcmltaXRpdmVMZW5ndGggKz0gMiwgdGhpcy5nbHlwaE9mZnNldEFycmF5LmVtcGxhY2VCYWNrKFBbMF0pLCB4ICE9PSBlLmxlbmd0aCAtIDEgJiYgQiA9PT0gZVt4ICsgMV0uc2VjdGlvbkluZGV4IHx8IHQucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLnBvcHVsYXRlUGFpbnRBcnJheXMoZi5sZW5ndGgsIGEsIGEuaW5kZXgsIHt9LCBjLCBnICYmIGdbQl0pO1xuICAgICAgfVxuICAgICAgdC5wbGFjZWRTeW1ib2xBcnJheS5lbXBsYWNlQmFjayhzLngsIHMueSwgZCwgdGhpcy5nbHlwaE9mZnNldEFycmF5Lmxlbmd0aCAtIGQsIG0sIHUsIGwsIHMuc2VnbWVudCwgciA/IHJbMF0gOiAwLCByID8gclsxXSA6IDAsIG5bMF0sIG5bMV0sIG8sIDAsICExLCAwLCBwKTtcbiAgICB9LCBnbC5wcm90b3R5cGUuX2FkZENvbGxpc2lvbkRlYnVnVmVydGV4ID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEpIHtcbiAgICAgIHJldHVybiBlLmVtcGxhY2VCYWNrKDAsIDApLCB0LmVtcGxhY2VCYWNrKHIueCwgci55LCBuLCBpLCBNYXRoLnJvdW5kKGEueCksIE1hdGgucm91bmQoYS55KSk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmFkZENvbGxpc2lvbkRlYnVnVmVydGljZXMgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgYSwgbywgcykge1xuICAgICAgdmFyIHUgPSBhLnNlZ21lbnRzLnByZXBhcmVTZWdtZW50KDQsIGEubGF5b3V0VmVydGV4QXJyYXksIGEuaW5kZXhBcnJheSksXG4gICAgICAgIGwgPSB1LnZlcnRleExlbmd0aCxcbiAgICAgICAgcCA9IGEubGF5b3V0VmVydGV4QXJyYXksXG4gICAgICAgIGMgPSBhLmNvbGxpc2lvblZlcnRleEFycmF5LFxuICAgICAgICBoID0gcy5hbmNob3JYLFxuICAgICAgICBmID0gcy5hbmNob3JZO1xuICAgICAgdGhpcy5fYWRkQ29sbGlzaW9uRGVidWdWZXJ0ZXgocCwgYywgbywgaCwgZiwgbmV3IGkodCwgZSkpLCB0aGlzLl9hZGRDb2xsaXNpb25EZWJ1Z1ZlcnRleChwLCBjLCBvLCBoLCBmLCBuZXcgaShyLCBlKSksIHRoaXMuX2FkZENvbGxpc2lvbkRlYnVnVmVydGV4KHAsIGMsIG8sIGgsIGYsIG5ldyBpKHIsIG4pKSwgdGhpcy5fYWRkQ29sbGlzaW9uRGVidWdWZXJ0ZXgocCwgYywgbywgaCwgZiwgbmV3IGkodCwgbikpLCB1LnZlcnRleExlbmd0aCArPSA0O1xuICAgICAgdmFyIHkgPSBhLmluZGV4QXJyYXk7XG4gICAgICB5LmVtcGxhY2VCYWNrKGwsIGwgKyAxKSwgeS5lbXBsYWNlQmFjayhsICsgMSwgbCArIDIpLCB5LmVtcGxhY2VCYWNrKGwgKyAyLCBsICsgMyksIHkuZW1wbGFjZUJhY2sobCArIDMsIGwpLCB1LnByaW1pdGl2ZUxlbmd0aCArPSA0O1xuICAgIH0sIGdsLnByb3RvdHlwZS5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSB0OyBpIDwgZTsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jb2xsaXNpb25Cb3hBcnJheS5nZXQoaSk7XG4gICAgICAgIHRoaXMuYWRkQ29sbGlzaW9uRGVidWdWZXJ0aWNlcyhhLngxLCBhLnkxLCBhLngyLCBhLnkyLCBuID8gdGhpcy50ZXh0Q29sbGlzaW9uQm94IDogdGhpcy5pY29uQ29sbGlzaW9uQm94LCBhLmFuY2hvclBvaW50LCByKTtcbiAgICAgIH1cbiAgICB9LCBnbC5wcm90b3R5cGUuZ2VuZXJhdGVDb2xsaXNpb25EZWJ1Z0J1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmhhc0RlYnVnRGF0YSgpICYmIHRoaXMuZGVzdHJveURlYnVnRGF0YSgpLCB0aGlzLnRleHRDb2xsaXNpb25Cb3ggPSBuZXcgdmwoT2ksIEdzLm1lbWJlcnMsIEppKSwgdGhpcy5pY29uQ29sbGlzaW9uQm94ID0gbmV3IHZsKE9pLCBHcy5tZW1iZXJzLCBKaSk7XG4gICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5zeW1ib2xJbnN0YW5jZXMuZ2V0KHQpO1xuICAgICAgICB0aGlzLmFkZERlYnVnQ29sbGlzaW9uQm94ZXMoZS50ZXh0Qm94U3RhcnRJbmRleCwgZS50ZXh0Qm94RW5kSW5kZXgsIGUsICEwKSwgdGhpcy5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzKGUudmVydGljYWxUZXh0Qm94U3RhcnRJbmRleCwgZS52ZXJ0aWNhbFRleHRCb3hFbmRJbmRleCwgZSwgITApLCB0aGlzLmFkZERlYnVnQ29sbGlzaW9uQm94ZXMoZS5pY29uQm94U3RhcnRJbmRleCwgZS5pY29uQm94RW5kSW5kZXgsIGUsICExKSwgdGhpcy5hZGREZWJ1Z0NvbGxpc2lvbkJveGVzKGUudmVydGljYWxJY29uQm94U3RhcnRJbmRleCwgZS52ZXJ0aWNhbEljb25Cb3hFbmRJbmRleCwgZSwgITEpO1xuICAgICAgfVxuICAgIH0sIGdsLnByb3RvdHlwZS5fZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlc0ZvclN5bWJvbCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzLCB1KSB7XG4gICAgICBmb3IgKHZhciBsID0ge30sIHAgPSBlOyBwIDwgcjsgcCsrKSB7XG4gICAgICAgIHZhciBjID0gdC5nZXQocCk7XG4gICAgICAgIGwudGV4dEJveCA9IHtcbiAgICAgICAgICB4MTogYy54MSxcbiAgICAgICAgICB5MTogYy55MSxcbiAgICAgICAgICB4MjogYy54MixcbiAgICAgICAgICB5MjogYy55MixcbiAgICAgICAgICBhbmNob3JQb2ludFg6IGMuYW5jaG9yUG9pbnRYLFxuICAgICAgICAgIGFuY2hvclBvaW50WTogYy5hbmNob3JQb2ludFlcbiAgICAgICAgfSwgbC50ZXh0RmVhdHVyZUluZGV4ID0gYy5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaCA9IG47IGggPCBpOyBoKyspIHtcbiAgICAgICAgdmFyIGYgPSB0LmdldChoKTtcbiAgICAgICAgbC52ZXJ0aWNhbFRleHRCb3ggPSB7XG4gICAgICAgICAgeDE6IGYueDEsXG4gICAgICAgICAgeTE6IGYueTEsXG4gICAgICAgICAgeDI6IGYueDIsXG4gICAgICAgICAgeTI6IGYueTIsXG4gICAgICAgICAgYW5jaG9yUG9pbnRYOiBmLmFuY2hvclBvaW50WCxcbiAgICAgICAgICBhbmNob3JQb2ludFk6IGYuYW5jaG9yUG9pbnRZXG4gICAgICAgIH0sIGwudmVydGljYWxUZXh0RmVhdHVyZUluZGV4ID0gZi5mZWF0dXJlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgeSA9IGE7IHkgPCBvOyB5KyspIHtcbiAgICAgICAgdmFyIGQgPSB0LmdldCh5KTtcbiAgICAgICAgbC5pY29uQm94ID0ge1xuICAgICAgICAgIHgxOiBkLngxLFxuICAgICAgICAgIHkxOiBkLnkxLFxuICAgICAgICAgIHgyOiBkLngyLFxuICAgICAgICAgIHkyOiBkLnkyLFxuICAgICAgICAgIGFuY2hvclBvaW50WDogZC5hbmNob3JQb2ludFgsXG4gICAgICAgICAgYW5jaG9yUG9pbnRZOiBkLmFuY2hvclBvaW50WVxuICAgICAgICB9LCBsLmljb25GZWF0dXJlSW5kZXggPSBkLmZlYXR1cmVJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBtID0gczsgbSA8IHU7IG0rKykge1xuICAgICAgICB2YXIgdiA9IHQuZ2V0KG0pO1xuICAgICAgICBsLnZlcnRpY2FsSWNvbkJveCA9IHtcbiAgICAgICAgICB4MTogdi54MSxcbiAgICAgICAgICB5MTogdi55MSxcbiAgICAgICAgICB4Mjogdi54MixcbiAgICAgICAgICB5Mjogdi55MixcbiAgICAgICAgICBhbmNob3JQb2ludFg6IHYuYW5jaG9yUG9pbnRYLFxuICAgICAgICAgIGFuY2hvclBvaW50WTogdi5hbmNob3JQb2ludFlcbiAgICAgICAgfSwgbC52ZXJ0aWNhbEljb25GZWF0dXJlSW5kZXggPSB2LmZlYXR1cmVJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gbDtcbiAgICB9LCBnbC5wcm90b3R5cGUuZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNvbGxpc2lvbkFycmF5cyA9IFtdO1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCB0aGlzLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgciA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmdldChlKTtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25BcnJheXMucHVzaCh0aGlzLl9kZXNlcmlhbGl6ZUNvbGxpc2lvbkJveGVzRm9yU3ltYm9sKHQsIHIudGV4dEJveFN0YXJ0SW5kZXgsIHIudGV4dEJveEVuZEluZGV4LCByLnZlcnRpY2FsVGV4dEJveFN0YXJ0SW5kZXgsIHIudmVydGljYWxUZXh0Qm94RW5kSW5kZXgsIHIuaWNvbkJveFN0YXJ0SW5kZXgsIHIuaWNvbkJveEVuZEluZGV4LCByLnZlcnRpY2FsSWNvbkJveFN0YXJ0SW5kZXgsIHIudmVydGljYWxJY29uQm94RW5kSW5kZXgpKTtcbiAgICAgIH1cbiAgICB9LCBnbC5wcm90b3R5cGUuaGFzVGV4dERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0LnNlZ21lbnRzLmdldCgpLmxlbmd0aCA+IDA7XG4gICAgfSwgZ2wucHJvdG90eXBlLmhhc0ljb25EYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWNvbi5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAwO1xuICAgIH0sIGdsLnByb3RvdHlwZS5oYXNEZWJ1Z0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0Q29sbGlzaW9uQm94ICYmIHRoaXMuaWNvbkNvbGxpc2lvbkJveDtcbiAgICB9LCBnbC5wcm90b3R5cGUuaGFzVGV4dENvbGxpc2lvbkJveERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNEZWJ1Z0RhdGEoKSAmJiB0aGlzLnRleHRDb2xsaXNpb25Cb3guc2VnbWVudHMuZ2V0KCkubGVuZ3RoID4gMDtcbiAgICB9LCBnbC5wcm90b3R5cGUuaGFzSWNvbkNvbGxpc2lvbkJveERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNEZWJ1Z0RhdGEoKSAmJiB0aGlzLmljb25Db2xsaXNpb25Cb3guc2VnbWVudHMuZ2V0KCkubGVuZ3RoID4gMDtcbiAgICB9LCBnbC5wcm90b3R5cGUuYWRkSW5kaWNlc0ZvclBsYWNlZFN5bWJvbCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gdC5wbGFjZWRTeW1ib2xBcnJheS5nZXQoZSksIG4gPSByLnZlcnRleFN0YXJ0SW5kZXggKyA0ICogci5udW1HbHlwaHMsIGkgPSByLnZlcnRleFN0YXJ0SW5kZXg7IGkgPCBuOyBpICs9IDQpIHQuaW5kZXhBcnJheS5lbXBsYWNlQmFjayhpLCBpICsgMSwgaSArIDIpLCB0LmluZGV4QXJyYXkuZW1wbGFjZUJhY2soaSArIDEsIGkgKyAyLCBpICsgMyk7XG4gICAgfSwgZ2wucHJvdG90eXBlLmdldFNvcnRlZFN5bWJvbEluZGV4ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMuc29ydGVkQW5nbGUgPT09IHQgJiYgdm9pZCAwICE9PSB0aGlzLnN5bWJvbEluc3RhbmNlSW5kZXhlcykgcmV0dXJuIHRoaXMuc3ltYm9sSW5zdGFuY2VJbmRleGVzO1xuICAgICAgZm9yICh2YXIgZSA9IE1hdGguc2luKHQpLCByID0gTWF0aC5jb3ModCksIG4gPSBbXSwgaSA9IFtdLCBhID0gW10sIG8gPSAwOyBvIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoOyArK28pIHtcbiAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICB2YXIgcyA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmdldChvKTtcbiAgICAgICAgbi5wdXNoKDAgfCBNYXRoLnJvdW5kKGUgKiBzLmFuY2hvclggKyByICogcy5hbmNob3JZKSksIGkucHVzaChzLmZlYXR1cmVJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiBuW3RdIC0gbltlXSB8fCBpW2VdIC0gaVt0XTtcbiAgICAgIH0pLCBhO1xuICAgIH0sIGdsLnByb3RvdHlwZS5hZGRUb1NvcnRLZXlSYW5nZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSB0aGlzLnNvcnRLZXlSYW5nZXNbdGhpcy5zb3J0S2V5UmFuZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgciAmJiByLnNvcnRLZXkgPT09IGUgPyByLnN5bWJvbEluc3RhbmNlRW5kID0gdCArIDEgOiB0aGlzLnNvcnRLZXlSYW5nZXMucHVzaCh7XG4gICAgICAgIHNvcnRLZXk6IGUsXG4gICAgICAgIHN5bWJvbEluc3RhbmNlU3RhcnQ6IHQsXG4gICAgICAgIHN5bWJvbEluc3RhbmNlRW5kOiB0ICsgMVxuICAgICAgfSk7XG4gICAgfSwgZ2wucHJvdG90eXBlLnNvcnRGZWF0dXJlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5zb3J0RmVhdHVyZXNCeVkgJiYgdGhpcy5zb3J0ZWRBbmdsZSAhPT0gdCAmJiAhKHRoaXMudGV4dC5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAxIHx8IHRoaXMuaWNvbi5zZWdtZW50cy5nZXQoKS5sZW5ndGggPiAxKSkge1xuICAgICAgICB0aGlzLnN5bWJvbEluc3RhbmNlSW5kZXhlcyA9IHRoaXMuZ2V0U29ydGVkU3ltYm9sSW5kZXhlcyh0KSwgdGhpcy5zb3J0ZWRBbmdsZSA9IHQsIHRoaXMudGV4dC5pbmRleEFycmF5LmNsZWFyKCksIHRoaXMuaWNvbi5pbmRleEFycmF5LmNsZWFyKCksIHRoaXMuZmVhdHVyZVNvcnRPcmRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciByID0gMCwgbiA9IHRoaXMuc3ltYm9sSW5zdGFuY2VJbmRleGVzOyByIDwgbi5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5zeW1ib2xJbnN0YW5jZXMuZ2V0KG5bcl0pO1xuICAgICAgICAgIHRoaXMuZmVhdHVyZVNvcnRPcmRlci5wdXNoKGkuZmVhdHVyZUluZGV4KSwgW2kucmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIGkuY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBpLmxlZnRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhdLmZvckVhY2goZnVuY3Rpb24gKHQsIHIsIG4pIHtcbiAgICAgICAgICAgIHQgPj0gMCAmJiBuLmluZGV4T2YodCkgPT09IHIgJiYgZS5hZGRJbmRpY2VzRm9yUGxhY2VkU3ltYm9sKGUudGV4dCwgdCk7XG4gICAgICAgICAgfSksIGkudmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXggPj0gMCAmJiB0aGlzLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wodGhpcy50ZXh0LCBpLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4KSwgaS5wbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiB0aGlzLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wodGhpcy5pY29uLCBpLnBsYWNlZEljb25TeW1ib2xJbmRleCksIGkudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiB0aGlzLmFkZEluZGljZXNGb3JQbGFjZWRTeW1ib2wodGhpcy5pY29uLCBpLnZlcnRpY2FsUGxhY2VkSWNvblN5bWJvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHQuaW5kZXhCdWZmZXIgJiYgdGhpcy50ZXh0LmluZGV4QnVmZmVyLnVwZGF0ZURhdGEodGhpcy50ZXh0LmluZGV4QXJyYXkpLCB0aGlzLmljb24uaW5kZXhCdWZmZXIgJiYgdGhpcy5pY29uLmluZGV4QnVmZmVyLnVwZGF0ZURhdGEodGhpcy5pY29uLmluZGV4QXJyYXkpO1xuICAgICAgfVxuICAgIH0sIE9uKFwiU3ltYm9sQnVja2V0XCIsIGdsLCB7XG4gICAgICBvbWl0OiBbXCJsYXllcnNcIiwgXCJjb2xsaXNpb25Cb3hBcnJheVwiLCBcImZlYXR1cmVzXCIsIFwiY29tcGFyZVRleHRcIl1cbiAgICB9KSwgZ2wuTUFYX0dMWVBIUyA9IDY1NTM1LCBnbC5hZGREeW5hbWljQXR0cmlidXRlcyA9IHlsO1xuICAgIHZhciB4bCA9IG5ldyBfaSh7XG4gICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInN5bWJvbC1wbGFjZW1lbnRcIl0pLFxuICAgICAgICBcInN5bWJvbC1zcGFjaW5nXCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wic3ltYm9sLXNwYWNpbmdcIl0pLFxuICAgICAgICBcInN5bWJvbC1hdm9pZC1lZGdlc1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInN5bWJvbC1hdm9pZC1lZGdlc1wiXSksXG4gICAgICAgIFwic3ltYm9sLXNvcnQta2V5XCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1wic3ltYm9sLXNvcnQta2V5XCJdKSxcbiAgICAgICAgXCJzeW1ib2wtei1vcmRlclwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInN5bWJvbC16LW9yZGVyXCJdKSxcbiAgICAgICAgXCJpY29uLWFsbG93LW92ZXJsYXBcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWFsbG93LW92ZXJsYXBcIl0pLFxuICAgICAgICBcImljb24taWdub3JlLXBsYWNlbWVudFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24taWdub3JlLXBsYWNlbWVudFwiXSksXG4gICAgICAgIFwiaWNvbi1vcHRpb25hbFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24tb3B0aW9uYWxcIl0pLFxuICAgICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIl0pLFxuICAgICAgICBcImljb24tc2l6ZVwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcImljb24tc2l6ZVwiXSksXG4gICAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24tdGV4dC1maXRcIl0pLFxuICAgICAgICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24tdGV4dC1maXQtcGFkZGluZ1wiXSksXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcImljb24taW1hZ2VcIl0pLFxuICAgICAgICBcImljb24tcm90YXRlXCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1wiaWNvbi1yb3RhdGVcIl0pLFxuICAgICAgICBcImljb24tcGFkZGluZ1wiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcImljb24tcGFkZGluZ1wiXSksXG4gICAgICAgIFwiaWNvbi1rZWVwLXVwcmlnaHRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWtlZXAtdXByaWdodFwiXSksXG4gICAgICAgIFwiaWNvbi1vZmZzZXRcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLW9mZnNldFwiXSksXG4gICAgICAgIFwiaWNvbi1hbmNob3JcIjogbmV3IGdpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLWFuY2hvclwiXSksXG4gICAgICAgIFwiaWNvbi1waXRjaC1hbGlnbm1lbnRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJpY29uLXBpdGNoLWFsaWdubWVudFwiXSksXG4gICAgICAgIFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiXSksXG4gICAgICAgIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiXSksXG4gICAgICAgIFwidGV4dC1maWVsZFwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtZmllbGRcIl0pLFxuICAgICAgICBcInRleHQtZm9udFwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtZm9udFwiXSksXG4gICAgICAgIFwidGV4dC1zaXplXCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1zaXplXCJdKSxcbiAgICAgICAgXCJ0ZXh0LW1heC13aWR0aFwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtbWF4LXdpZHRoXCJdKSxcbiAgICAgICAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1saW5lLWhlaWdodFwiXSksXG4gICAgICAgIFwidGV4dC1sZXR0ZXItc3BhY2luZ1wiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtbGV0dGVyLXNwYWNpbmdcIl0pLFxuICAgICAgICBcInRleHQtanVzdGlmeVwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtanVzdGlmeVwiXSksXG4gICAgICAgIFwidGV4dC1yYWRpYWwtb2Zmc2V0XCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1yYWRpYWwtb2Zmc2V0XCJdKSxcbiAgICAgICAgXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtdmFyaWFibGUtYW5jaG9yXCJdKSxcbiAgICAgICAgXCJ0ZXh0LWFuY2hvclwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtYW5jaG9yXCJdKSxcbiAgICAgICAgXCJ0ZXh0LW1heC1hbmdsZVwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtbWF4LWFuZ2xlXCJdKSxcbiAgICAgICAgXCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtd3JpdGluZy1tb2RlXCJdKSxcbiAgICAgICAgXCJ0ZXh0LXJvdGF0ZVwiOiBuZXcgZ2koUHQubGF5b3V0X3N5bWJvbFtcInRleHQtcm90YXRlXCJdKSxcbiAgICAgICAgXCJ0ZXh0LXBhZGRpbmdcIjogbmV3IHZpKFB0LmxheW91dF9zeW1ib2xbXCJ0ZXh0LXBhZGRpbmdcIl0pLFxuICAgICAgICBcInRleHQta2VlcC11cHJpZ2h0XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1rZWVwLXVwcmlnaHRcIl0pLFxuICAgICAgICBcInRleHQtdHJhbnNmb3JtXCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC10cmFuc2Zvcm1cIl0pLFxuICAgICAgICBcInRleHQtb2Zmc2V0XCI6IG5ldyBnaShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1vZmZzZXRcIl0pLFxuICAgICAgICBcInRleHQtYWxsb3ctb3ZlcmxhcFwiOiBuZXcgdmkoUHQubGF5b3V0X3N5bWJvbFtcInRleHQtYWxsb3ctb3ZlcmxhcFwiXSksXG4gICAgICAgIFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1pZ25vcmUtcGxhY2VtZW50XCJdKSxcbiAgICAgICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IG5ldyB2aShQdC5sYXlvdXRfc3ltYm9sW1widGV4dC1vcHRpb25hbFwiXSlcbiAgICAgIH0pLFxuICAgICAgYmwgPSB7XG4gICAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICAgIFwiaWNvbi1vcGFjaXR5XCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJpY29uLW9wYWNpdHlcIl0pLFxuICAgICAgICAgIFwiaWNvbi1jb2xvclwiOiBuZXcgZ2koUHQucGFpbnRfc3ltYm9sW1wiaWNvbi1jb2xvclwiXSksXG4gICAgICAgICAgXCJpY29uLWhhbG8tY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcImljb24taGFsby1jb2xvclwiXSksXG4gICAgICAgICAgXCJpY29uLWhhbG8td2lkdGhcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcImljb24taGFsby13aWR0aFwiXSksXG4gICAgICAgICAgXCJpY29uLWhhbG8tYmx1clwiOiBuZXcgZ2koUHQucGFpbnRfc3ltYm9sW1wiaWNvbi1oYWxvLWJsdXJcIl0pLFxuICAgICAgICAgIFwiaWNvbi10cmFuc2xhdGVcIjogbmV3IHZpKFB0LnBhaW50X3N5bWJvbFtcImljb24tdHJhbnNsYXRlXCJdKSxcbiAgICAgICAgICBcImljb24tdHJhbnNsYXRlLWFuY2hvclwiOiBuZXcgdmkoUHQucGFpbnRfc3ltYm9sW1wiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCJdKSxcbiAgICAgICAgICBcInRleHQtb3BhY2l0eVwiOiBuZXcgZ2koUHQucGFpbnRfc3ltYm9sW1widGV4dC1vcGFjaXR5XCJdKSxcbiAgICAgICAgICBcInRleHQtY29sb3JcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcInRleHQtY29sb3JcIl0sIHtcbiAgICAgICAgICAgIHJ1bnRpbWVUeXBlOiBxdCxcbiAgICAgICAgICAgIGdldE92ZXJyaWRlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdC50ZXh0Q29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzT3ZlcnJpZGU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAhIXQudGV4dENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwidGV4dC1oYWxvLWNvbG9yXCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJ0ZXh0LWhhbG8tY29sb3JcIl0pLFxuICAgICAgICAgIFwidGV4dC1oYWxvLXdpZHRoXCI6IG5ldyBnaShQdC5wYWludF9zeW1ib2xbXCJ0ZXh0LWhhbG8td2lkdGhcIl0pLFxuICAgICAgICAgIFwidGV4dC1oYWxvLWJsdXJcIjogbmV3IGdpKFB0LnBhaW50X3N5bWJvbFtcInRleHQtaGFsby1ibHVyXCJdKSxcbiAgICAgICAgICBcInRleHQtdHJhbnNsYXRlXCI6IG5ldyB2aShQdC5wYWludF9zeW1ib2xbXCJ0ZXh0LXRyYW5zbGF0ZVwiXSksXG4gICAgICAgICAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjogbmV3IHZpKFB0LnBhaW50X3N5bWJvbFtcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiXSlcbiAgICAgICAgfSksXG4gICAgICAgIGxheW91dDogeGxcbiAgICAgIH0sXG4gICAgICB3bCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHQucHJvcGVydHkub3ZlcnJpZGVzID8gdC5wcm9wZXJ0eS5vdmVycmlkZXMucnVudGltZVR5cGUgOiBSdCwgdGhpcy5kZWZhdWx0VmFsdWUgPSB0O1xuICAgICAgfTtcbiAgICB3bC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQuZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZGVmYXVsdFZhbHVlLnByb3BlcnR5Lm92ZXJyaWRlcztcbiAgICAgICAgaWYgKGUgJiYgZS5oYXNPdmVycmlkZSh0LmZvcm1hdHRlZFNlY3Rpb24pKSByZXR1cm4gZS5nZXRPdmVycmlkZSh0LmZvcm1hdHRlZFNlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQuZmVhdHVyZSAmJiB0LmZlYXR1cmVTdGF0ZSA/IHRoaXMuZGVmYXVsdFZhbHVlLmV2YWx1YXRlKHQuZmVhdHVyZSwgdC5mZWF0dXJlU3RhdGUpIDogdGhpcy5kZWZhdWx0VmFsdWUucHJvcGVydHkuc3BlY2lmaWNhdGlvbi5kZWZhdWx0O1xuICAgIH0sIHdsLnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUuaXNDb25zdGFudCgpIHx8IHQodGhpcy5kZWZhdWx0VmFsdWUudmFsdWUuX3N0eWxlRXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgICB9LCB3bC5wcm90b3R5cGUub3V0cHV0RGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCB3bC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgT24oXCJGb3JtYXRTZWN0aW9uT3ZlcnJpZGVcIiwgd2wsIHtcbiAgICAgIG9taXQ6IFtcImRlZmF1bHRWYWx1ZVwiXVxuICAgIH0pO1xuICAgIHZhciBfbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlLCBibCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgIGlmICh0LnByb3RvdHlwZS5yZWNhbGN1bGF0ZS5jYWxsKHRoaXMsIGUsIHIpLCBcImF1dG9cIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgKHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiXSA9IFwicG9pbnRcIiAhPT0gdGhpcy5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSA/IFwibWFwXCIgOiBcInZpZXdwb3J0XCIpLCBcImF1dG9cIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgKHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiXSA9IFwicG9pbnRcIiAhPT0gdGhpcy5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSA/IFwibWFwXCIgOiBcInZpZXdwb3J0XCIpLCBcImF1dG9cIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIikgJiYgKHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiXSA9IHRoaXMubGF5b3V0LmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpKSwgXCJhdXRvXCIgPT09IHRoaXMubGF5b3V0LmdldChcImljb24tcGl0Y2gtYWxpZ25tZW50XCIpICYmICh0aGlzLmxheW91dC5fdmFsdWVzW1wiaWNvbi1waXRjaC1hbGlnbm1lbnRcIl0gPSB0aGlzLmxheW91dC5nZXQoXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiKSksIFwicG9pbnRcIiA9PT0gdGhpcy5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmxheW91dC5nZXQoXCJ0ZXh0LXdyaXRpbmctbW9kZVwiKTtcbiAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBbXSwgYSA9IDAsIG8gPSBuOyBhIDwgby5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gb1thXTtcbiAgICAgICAgICAgICAgICBpLmluZGV4T2YocykgPCAwICYmIGkucHVzaChzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmxheW91dC5fdmFsdWVzW1widGV4dC13cml0aW5nLW1vZGVcIl0gPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHRoaXMubGF5b3V0Ll92YWx1ZXNbXCJ0ZXh0LXdyaXRpbmctbW9kZVwiXSA9IFtcImhvcml6b250YWxcIl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NldFBhaW50T3ZlcnJpZGVzKCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmdldFZhbHVlQW5kUmVzb2x2ZVRva2VucyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmxheW91dC5nZXQodCkuZXZhbHVhdGUoZSwge30sIHIsIG4pLFxuICAgICAgICAgICAgYSA9IHRoaXMuX3VuZXZhbHVhdGVkTGF5b3V0Ll92YWx1ZXNbdF07XG4gICAgICAgICAgcmV0dXJuIGEuaXNEYXRhRHJpdmVuKCkgfHwgWnIoYS52YWx1ZSkgfHwgIWkgPyBpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnJlcGxhY2UoL3soW157fV0rKX0vZywgZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIgaW4gdCA/IFN0cmluZyh0W3JdKSA6IFwiXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KGUucHJvcGVydGllcywgaSk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmNyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBnbCh0KTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUucXVlcnlSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnF1ZXJ5SW50ZXJzZWN0c0ZlYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5fc2V0UGFpbnRPdmVycmlkZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IDAsIHIgPSBibC5wYWludC5vdmVycmlkYWJsZVByb3BlcnRpZXM7IHQgPCByLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJbdF07XG4gICAgICAgICAgICBpZiAoZS5oYXNQYWludE92ZXJyaWRlKHRoaXMubGF5b3V0LCBuKSkge1xuICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5wYWludC5nZXQobiksXG4gICAgICAgICAgICAgICAgbyA9IG5ldyB3bChhKSxcbiAgICAgICAgICAgICAgICBzID0gbmV3IEdyKG8sIGEucHJvcGVydHkuc3BlY2lmaWNhdGlvbik7XG4gICAgICAgICAgICAgIGkgPSBcImNvbnN0YW50XCIgPT09IGEudmFsdWUua2luZCB8fCBcInNvdXJjZVwiID09PSBhLnZhbHVlLmtpbmQgPyBuZXcgSnIoXCJzb3VyY2VcIiwgcykgOiBuZXcgSHIoXCJjb21wb3NpdGVcIiwgcywgYS52YWx1ZS56b29tU3RvcHMsIGEudmFsdWUuX2ludGVycG9sYXRpb25UeXBlKSwgdGhpcy5wYWludC5fdmFsdWVzW25dID0gbmV3IGRpKGEucHJvcGVydHksIGksIGEucGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlLnByb3RvdHlwZS5faGFuZGxlT3ZlcnJpZGFibGVQYWludFByb3BlcnR5VXBkYXRlID0gZnVuY3Rpb24gKHQsIHIsIG4pIHtcbiAgICAgICAgICByZXR1cm4gISghdGhpcy5sYXlvdXQgfHwgci5pc0RhdGFEcml2ZW4oKSB8fCBuLmlzRGF0YURyaXZlbigpKSAmJiBlLmhhc1BhaW50T3ZlcnJpZGUodGhpcy5sYXlvdXQsIHQpO1xuICAgICAgICB9LCBlLmhhc1BhaW50T3ZlcnJpZGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0gdC5nZXQoXCJ0ZXh0LWZpZWxkXCIpLFxuICAgICAgICAgICAgbiA9IGJsLnBhaW50LnByb3BlcnRpZXNbZV0sXG4gICAgICAgICAgICBpID0gITEsXG4gICAgICAgICAgICBhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDAsIHIgPSB0OyBlIDwgci5sZW5ndGg7IGUgKz0gMSkgaWYgKG4ub3ZlcnJpZGVzICYmIG4ub3ZlcnJpZGVzLmhhc092ZXJyaWRlKHJbZV0pKSByZXR1cm4gdm9pZCAoaSA9ICEwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKFwiY29uc3RhbnRcIiA9PT0gci52YWx1ZS5raW5kICYmIHIudmFsdWUudmFsdWUgaW5zdGFuY2VvZiBpZSkgYShyLnZhbHVlLnZhbHVlLnNlY3Rpb25zKTtlbHNlIGlmIChcInNvdXJjZVwiID09PSByLnZhbHVlLmtpbmQpIHtcbiAgICAgICAgICAgIHZhciBvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBpIHx8ICh0IGluc3RhbmNlb2YgcGUgJiYgdWUodC52YWx1ZSkgPT09IFp0ID8gYSh0LnZhbHVlLnNlY3Rpb25zKSA6IHQgaW5zdGFuY2VvZiB5ZSA/IGEodC5zZWN0aW9ucykgOiB0LmVhY2hDaGlsZChvKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHMgPSByLnZhbHVlO1xuICAgICAgICAgICAgcy5fc3R5bGVFeHByZXNzaW9uICYmIG8ocy5fc3R5bGVFeHByZXNzaW9uLmV4cHJlc3Npb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oQWkpLFxuICAgICAgQWwgPSB7XG4gICAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBuZXcgdmkoUHQucGFpbnRfYmFja2dyb3VuZFtcImJhY2tncm91bmQtY29sb3JcIl0pLFxuICAgICAgICAgIFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IG5ldyBiaShQdC5wYWludF9iYWNrZ3JvdW5kW1wiYmFja2dyb3VuZC1wYXR0ZXJuXCJdKSxcbiAgICAgICAgICBcImJhY2tncm91bmQtb3BhY2l0eVwiOiBuZXcgdmkoUHQucGFpbnRfYmFja2dyb3VuZFtcImJhY2tncm91bmQtb3BhY2l0eVwiXSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBTbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlLCBBbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZTtcbiAgICAgIH0oQWkpLFxuICAgICAga2wgPSB7XG4gICAgICAgIHBhaW50OiBuZXcgX2koe1xuICAgICAgICAgIFwicmFzdGVyLW9wYWNpdHlcIjogbmV3IHZpKFB0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1vcGFjaXR5XCJdKSxcbiAgICAgICAgICBcInJhc3Rlci1odWUtcm90YXRlXCI6IG5ldyB2aShQdC5wYWludF9yYXN0ZXJbXCJyYXN0ZXItaHVlLXJvdGF0ZVwiXSksXG4gICAgICAgICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1taW5cIjogbmV3IHZpKFB0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiXSksXG4gICAgICAgICAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjogbmV3IHZpKFB0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiXSksXG4gICAgICAgICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiBuZXcgdmkoUHQucGFpbnRfcmFzdGVyW1wicmFzdGVyLXNhdHVyYXRpb25cIl0pLFxuICAgICAgICAgIFwicmFzdGVyLWNvbnRyYXN0XCI6IG5ldyB2aShQdC5wYWludF9yYXN0ZXJbXCJyYXN0ZXItY29udHJhc3RcIl0pLFxuICAgICAgICAgIFwicmFzdGVyLXJlc2FtcGxpbmdcIjogbmV3IHZpKFB0LnBhaW50X3Jhc3RlcltcInJhc3Rlci1yZXNhbXBsaW5nXCJdKSxcbiAgICAgICAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IG5ldyB2aShQdC5wYWludF9yYXN0ZXJbXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiXSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBJbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlLCBrbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZTtcbiAgICAgIH0oQWkpLFxuICAgICAgemwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKGUpIHtcbiAgICAgICAgICB0LmNhbGwodGhpcywgZSwge30pLCB0aGlzLmltcGxlbWVudGF0aW9uID0gZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5pczNEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBcIjNkXCIgPT09IHRoaXMuaW1wbGVtZW50YXRpb24ucmVuZGVyaW5nTW9kZTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuaGFzT2Zmc2NyZWVuUGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwICE9PSB0aGlzLmltcGxlbWVudGF0aW9uLnByZXJlbmRlcjtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUudXBkYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUuaGFzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHt9LCBlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7fSwgZS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24ub25BZGQgJiYgdGhpcy5pbXBsZW1lbnRhdGlvbi5vbkFkZCh0LCB0LnBhaW50ZXIuY29udGV4dC5nbCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLmltcGxlbWVudGF0aW9uLm9uUmVtb3ZlICYmIHRoaXMuaW1wbGVtZW50YXRpb24ub25SZW1vdmUodCwgdC5wYWludGVyLmNvbnRleHQuZ2wpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShBaSksXG4gICAgICBDbCA9IHtcbiAgICAgICAgY2lyY2xlOiBobyxcbiAgICAgICAgaGVhdG1hcDogQW8sXG4gICAgICAgIGhpbGxzaGFkZToga28sXG4gICAgICAgIGZpbGw6IGNzLFxuICAgICAgICBcImZpbGwtZXh0cnVzaW9uXCI6IENzLFxuICAgICAgICBsaW5lOiBVcyxcbiAgICAgICAgc3ltYm9sOiBfbCxcbiAgICAgICAgYmFja2dyb3VuZDogU2wsXG4gICAgICAgIHJhc3RlcjogSWxcbiAgICAgIH0sXG4gICAgICBFbCA9IG8uSFRNTEltYWdlRWxlbWVudCxcbiAgICAgIFBsID0gby5IVE1MQ2FudmFzRWxlbWVudCxcbiAgICAgIE1sID0gby5IVE1MVmlkZW9FbGVtZW50LFxuICAgICAgQmwgPSBvLkltYWdlRGF0YSxcbiAgICAgIFRsID0gby5JbWFnZUJpdG1hcCxcbiAgICAgIFZsID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdCwgdGhpcy5mb3JtYXQgPSByLCB0aGlzLnRleHR1cmUgPSB0LmdsLmNyZWF0ZVRleHR1cmUoKSwgdGhpcy51cGRhdGUoZSwgbik7XG4gICAgICB9O1xuICAgIFZsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSB0LndpZHRoLFxuICAgICAgICBpID0gdC5oZWlnaHQsXG4gICAgICAgIGEgPSAhKHRoaXMuc2l6ZSAmJiB0aGlzLnNpemVbMF0gPT09IG4gJiYgdGhpcy5zaXplWzFdID09PSBpIHx8IHIpLFxuICAgICAgICBvID0gdGhpcy5jb250ZXh0LFxuICAgICAgICBzID0gby5nbDtcbiAgICAgIGlmICh0aGlzLnVzZU1pcG1hcCA9IEJvb2xlYW4oZSAmJiBlLnVzZU1pcG1hcCksIHMuYmluZFRleHR1cmUocy5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpLCBvLnBpeGVsU3RvcmVVbnBhY2tGbGlwWS5zZXQoITEpLCBvLnBpeGVsU3RvcmVVbnBhY2suc2V0KDEpLCBvLnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhLnNldCh0aGlzLmZvcm1hdCA9PT0gcy5SR0JBICYmICghZSB8fCAhMSAhPT0gZS5wcmVtdWx0aXBseSkpLCBhKSB0aGlzLnNpemUgPSBbbiwgaV0sIHQgaW5zdGFuY2VvZiBFbCB8fCB0IGluc3RhbmNlb2YgUGwgfHwgdCBpbnN0YW5jZW9mIE1sIHx8IHQgaW5zdGFuY2VvZiBCbCB8fCBUbCAmJiB0IGluc3RhbmNlb2YgVGwgPyBzLnRleEltYWdlMkQocy5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgdGhpcy5mb3JtYXQsIHMuVU5TSUdORURfQllURSwgdCkgOiBzLnRleEltYWdlMkQocy5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgbiwgaSwgMCwgdGhpcy5mb3JtYXQsIHMuVU5TSUdORURfQllURSwgdC5kYXRhKTtlbHNlIHtcbiAgICAgICAgdmFyIHUgPSByIHx8IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsID0gdS54LFxuICAgICAgICAgIHAgPSB1Lnk7XG4gICAgICAgIHQgaW5zdGFuY2VvZiBFbCB8fCB0IGluc3RhbmNlb2YgUGwgfHwgdCBpbnN0YW5jZW9mIE1sIHx8IHQgaW5zdGFuY2VvZiBCbCB8fCBUbCAmJiB0IGluc3RhbmNlb2YgVGwgPyBzLnRleFN1YkltYWdlMkQocy5URVhUVVJFXzJELCAwLCBsLCBwLCBzLlJHQkEsIHMuVU5TSUdORURfQllURSwgdCkgOiBzLnRleFN1YkltYWdlMkQocy5URVhUVVJFXzJELCAwLCBsLCBwLCBuLCBpLCBzLlJHQkEsIHMuVU5TSUdORURfQllURSwgdC5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXNlTWlwbWFwICYmIHRoaXMuaXNTaXplUG93ZXJPZlR3bygpICYmIHMuZ2VuZXJhdGVNaXBtYXAocy5URVhUVVJFXzJEKTtcbiAgICB9LCBWbC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgIG4uYmluZFRleHR1cmUobi5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpLCByICE9PSBuLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCB8fCB0aGlzLmlzU2l6ZVBvd2VyT2ZUd28oKSB8fCAociA9IG4uTElORUFSKSwgdCAhPT0gdGhpcy5maWx0ZXIgJiYgKG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsIG4uVEVYVFVSRV9NQUdfRklMVEVSLCB0KSwgbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX01JTl9GSUxURVIsIHIgfHwgdCksIHRoaXMuZmlsdGVyID0gdCksIGUgIT09IHRoaXMud3JhcCAmJiAobi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCwgbi5URVhUVVJFX1dSQVBfUywgZSksIG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsIG4uVEVYVFVSRV9XUkFQX1QsIGUpLCB0aGlzLndyYXAgPSBlKTtcbiAgICB9LCBWbC5wcm90b3R5cGUuaXNTaXplUG93ZXJPZlR3byA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemVbMF0gPT09IHRoaXMuc2l6ZVsxXSAmJiBNYXRoLmxvZyh0aGlzLnNpemVbMF0pIC8gTWF0aC5MTjIgJSAxID09IDA7XG4gICAgfSwgVmwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpLCB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIEZsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcbiAgICAgIHRoaXMuX2NhbGxiYWNrID0gdCwgdGhpcy5fdHJpZ2dlcmVkID0gITEsIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIE1lc3NhZ2VDaGFubmVsICYmICh0aGlzLl9jaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksIHRoaXMuX2NoYW5uZWwucG9ydDIub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlLl90cmlnZ2VyZWQgPSAhMSwgZS5fY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgRmwucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICB0aGlzLl90cmlnZ2VyZWQgfHwgKHRoaXMuX3RyaWdnZXJlZCA9ICEwLCB0aGlzLl9jaGFubmVsID8gdGhpcy5fY2hhbm5lbC5wb3J0MS5wb3N0TWVzc2FnZSghMCkgOiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC5fdHJpZ2dlcmVkID0gITEsIHQuX2NhbGxiYWNrKCk7XG4gICAgICB9LCAwKSk7XG4gICAgfSwgRmwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jaGFubmVsLCB0aGlzLl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH07XG4gICAgdmFyIERsID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdCwgdGhpcy5wYXJlbnQgPSBlLCB0aGlzLm1hcElkID0gciwgdGhpcy5jYWxsYmFja3MgPSB7fSwgdGhpcy50YXNrcyA9IHt9LCB0aGlzLnRhc2tRdWV1ZSA9IFtdLCB0aGlzLmNhbmNlbENhbGxiYWNrcyA9IHt9LCB2KFtcInJlY2VpdmVcIiwgXCJwcm9jZXNzXCJdLCB0aGlzKSwgdGhpcy5pbnZva2VyID0gbmV3IEZsKHRoaXMucHJvY2VzcyksIHRoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMucmVjZWl2ZSwgITEpLCB0aGlzLmdsb2JhbFNjb3BlID0gSSgpID8gdCA6IG87XG4gICAgfTtcbiAgICBmdW5jdGlvbiBMbCh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IDIgKiBNYXRoLlBJICogNjM3ODEzNyAvIDI1NiAvIE1hdGgucG93KDIsIHIpO1xuICAgICAgcmV0dXJuIFt0ICogbiAtIDIgKiBNYXRoLlBJICogNjM3ODEzNyAvIDIsIGUgKiBuIC0gMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gMl07XG4gICAgfVxuICAgIERsLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9ICExKTtcbiAgICAgIHZhciBvID0gTWF0aC5yb3VuZCgxZTE4ICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICByICYmICh0aGlzLmNhbGxiYWNrc1tvXSA9IHIpO1xuICAgICAgdmFyIHMgPSBFKHRoaXMuZ2xvYmFsU2NvcGUpID8gdm9pZCAwIDogW107XG4gICAgICByZXR1cm4gdGhpcy50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpZDogbyxcbiAgICAgICAgdHlwZTogdCxcbiAgICAgICAgaGFzQ2FsbGJhY2s6ICEhcixcbiAgICAgICAgdGFyZ2V0TWFwSWQ6IG4sXG4gICAgICAgIG11c3RRdWV1ZTogaSxcbiAgICAgICAgc291cmNlTWFwSWQ6IHRoaXMubWFwSWQsXG4gICAgICAgIGRhdGE6IE5uKGUsIHMpXG4gICAgICB9LCBzKSwge1xuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByICYmIGRlbGV0ZSBhLmNhbGxiYWNrc1tvXSwgYS50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaWQ6IG8sXG4gICAgICAgICAgICB0eXBlOiBcIjxjYW5jZWw+XCIsXG4gICAgICAgICAgICB0YXJnZXRNYXBJZDogbixcbiAgICAgICAgICAgIHNvdXJjZU1hcElkOiBhLm1hcElkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgRGwucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmRhdGEsXG4gICAgICAgIHIgPSBlLmlkO1xuICAgICAgaWYgKHIgJiYgKCFlLnRhcmdldE1hcElkIHx8IHRoaXMubWFwSWQgPT09IGUudGFyZ2V0TWFwSWQpKSBpZiAoXCI8Y2FuY2VsPlwiID09PSBlLnR5cGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFza3Nbcl07XG4gICAgICAgIHZhciBuID0gdGhpcy5jYW5jZWxDYWxsYmFja3Nbcl07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbmNlbENhbGxiYWNrc1tyXSwgbiAmJiBuKCk7XG4gICAgICB9IGVsc2UgSSgpIHx8IGUubXVzdFF1ZXVlID8gKHRoaXMudGFza3Nbcl0gPSBlLCB0aGlzLnRhc2tRdWV1ZS5wdXNoKHIpLCB0aGlzLmludm9rZXIudHJpZ2dlcigpKSA6IHRoaXMucHJvY2Vzc1Rhc2sociwgZSk7XG4gICAgfSwgRGwucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy50YXNrUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy50YXNrUXVldWUuc2hpZnQoKSxcbiAgICAgICAgICBlID0gdGhpcy50YXNrc1t0XTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFza3NbdF0sIHRoaXMudGFza1F1ZXVlLmxlbmd0aCAmJiB0aGlzLmludm9rZXIudHJpZ2dlcigpLCBlICYmIHRoaXMucHJvY2Vzc1Rhc2sodCwgZSk7XG4gICAgICB9XG4gICAgfSwgRGwucHJvdG90eXBlLnByb2Nlc3NUYXNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdGhpcztcbiAgICAgIGlmIChcIjxyZXNwb25zZT5cIiA9PT0gZS50eXBlKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jYWxsYmFja3NbdF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1t0XSwgbiAmJiAoZS5lcnJvciA/IG4oS24oZS5lcnJvcikpIDogbihudWxsLCBLbihlLmRhdGEpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9ICExLFxuICAgICAgICAgIGEgPSBFKHRoaXMuZ2xvYmFsU2NvcGUpID8gdm9pZCAwIDogW10sXG4gICAgICAgICAgbyA9IGUuaGFzQ2FsbGJhY2sgPyBmdW5jdGlvbiAoZSwgbikge1xuICAgICAgICAgICAgaSA9ICEwLCBkZWxldGUgci5jYW5jZWxDYWxsYmFja3NbdF0sIHIudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgaWQ6IHQsXG4gICAgICAgICAgICAgIHR5cGU6IFwiPHJlc3BvbnNlPlwiLFxuICAgICAgICAgICAgICBzb3VyY2VNYXBJZDogci5tYXBJZCxcbiAgICAgICAgICAgICAgZXJyb3I6IGUgPyBObihlKSA6IG51bGwsXG4gICAgICAgICAgICAgIGRhdGE6IE5uKG4sIGEpXG4gICAgICAgICAgICB9LCBhKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGkgPSAhMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHMgPSBudWxsLFxuICAgICAgICAgIHUgPSBLbihlLmRhdGEpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRbZS50eXBlXSkgcyA9IHRoaXMucGFyZW50W2UudHlwZV0oZS5zb3VyY2VNYXBJZCwgdSwgbyk7ZWxzZSBpZiAodGhpcy5wYXJlbnQuZ2V0V29ya2VyU291cmNlKSB7XG4gICAgICAgICAgdmFyIGwgPSBlLnR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIHMgPSB0aGlzLnBhcmVudC5nZXRXb3JrZXJTb3VyY2UoZS5zb3VyY2VNYXBJZCwgbFswXSwgdS5zb3VyY2UpW2xbMV1dKHUsIG8pO1xuICAgICAgICB9IGVsc2UgbyhuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBmdW5jdGlvbiBcIiArIGUudHlwZSkpO1xuICAgICAgICAhaSAmJiBzICYmIHMuY2FuY2VsICYmICh0aGlzLmNhbmNlbENhbGxiYWNrc1t0XSA9IHMuY2FuY2VsKTtcbiAgICAgIH1cbiAgICB9LCBEbC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pbnZva2VyLnJlbW92ZSgpLCB0aGlzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLnJlY2VpdmUsICExKTtcbiAgICB9O1xuICAgIHZhciBSbCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0ICYmIChlID8gdGhpcy5zZXRTb3V0aFdlc3QodCkuc2V0Tm9ydGhFYXN0KGUpIDogNCA9PT0gdC5sZW5ndGggPyB0aGlzLnNldFNvdXRoV2VzdChbdFswXSwgdFsxXV0pLnNldE5vcnRoRWFzdChbdFsyXSwgdFszXV0pIDogdGhpcy5zZXRTb3V0aFdlc3QodFswXSkuc2V0Tm9ydGhFYXN0KHRbMV0pKTtcbiAgICB9O1xuICAgIFJsLnByb3RvdHlwZS5zZXROb3J0aEVhc3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lID0gdCBpbnN0YW5jZW9mIE9sID8gbmV3IE9sKHQubG5nLCB0LmxhdCkgOiBPbC5jb252ZXJ0KHQpLCB0aGlzO1xuICAgIH0sIFJsLnByb3RvdHlwZS5zZXRTb3V0aFdlc3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N3ID0gdCBpbnN0YW5jZW9mIE9sID8gbmV3IE9sKHQubG5nLCB0LmxhdCkgOiBPbC5jb252ZXJ0KHQpLCB0aGlzO1xuICAgIH0sIFJsLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgIHIsXG4gICAgICAgIG4gPSB0aGlzLl9zdyxcbiAgICAgICAgaSA9IHRoaXMuX25lO1xuICAgICAgaWYgKHQgaW5zdGFuY2VvZiBPbCkgZSA9IHQsIHIgPSB0O2Vsc2Uge1xuICAgICAgICBpZiAoISh0IGluc3RhbmNlb2YgUmwpKSByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/IDQgPT09IHQubGVuZ3RoIHx8IHQuZXZlcnkoQXJyYXkuaXNBcnJheSkgPyB0aGlzLmV4dGVuZChSbC5jb252ZXJ0KHQpKSA6IHRoaXMuZXh0ZW5kKE9sLmNvbnZlcnQodCkpIDogdGhpcztcbiAgICAgICAgaWYgKHIgPSB0Ll9uZSwgIShlID0gdC5fc3cpIHx8ICFyKSByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuIHx8IGkgPyAobi5sbmcgPSBNYXRoLm1pbihlLmxuZywgbi5sbmcpLCBuLmxhdCA9IE1hdGgubWluKGUubGF0LCBuLmxhdCksIGkubG5nID0gTWF0aC5tYXgoci5sbmcsIGkubG5nKSwgaS5sYXQgPSBNYXRoLm1heChyLmxhdCwgaS5sYXQpKSA6ICh0aGlzLl9zdyA9IG5ldyBPbChlLmxuZywgZS5sYXQpLCB0aGlzLl9uZSA9IG5ldyBPbChyLmxuZywgci5sYXQpKSwgdGhpcztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBPbCgodGhpcy5fc3cubG5nICsgdGhpcy5fbmUubG5nKSAvIDIsICh0aGlzLl9zdy5sYXQgKyB0aGlzLl9uZS5sYXQpIC8gMik7XG4gICAgfSwgUmwucHJvdG90eXBlLmdldFNvdXRoV2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0Tm9ydGhFYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lO1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXROb3J0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9sKHRoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldE5vcnRoKCkpO1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXRTb3V0aEVhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IE9sKHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldFNvdXRoKCkpO1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXRXZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N3LmxuZztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0U291dGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3cubGF0O1xuICAgIH0sIFJsLnByb3RvdHlwZS5nZXRFYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lLmxuZztcbiAgICB9LCBSbC5wcm90b3R5cGUuZ2V0Tm9ydGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmUubGF0O1xuICAgIH0sIFJsLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLl9zdy50b0FycmF5KCksIHRoaXMuX25lLnRvQXJyYXkoKV07XG4gICAgfSwgUmwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiTG5nTGF0Qm91bmRzKFwiICsgdGhpcy5fc3cudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuX25lLnRvU3RyaW5nKCkgKyBcIilcIjtcbiAgICB9LCBSbC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuX3N3ICYmIHRoaXMuX25lKTtcbiAgICB9LCBSbC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBPbC5jb252ZXJ0KHQpLFxuICAgICAgICByID0gZS5sbmcsXG4gICAgICAgIG4gPSBlLmxhdCxcbiAgICAgICAgaSA9IHRoaXMuX3N3LmxuZyA8PSByICYmIHIgPD0gdGhpcy5fbmUubG5nO1xuICAgICAgcmV0dXJuIHRoaXMuX3N3LmxuZyA+IHRoaXMuX25lLmxuZyAmJiAoaSA9IHRoaXMuX3N3LmxuZyA+PSByICYmIHIgPj0gdGhpcy5fbmUubG5nKSwgdGhpcy5fc3cubGF0IDw9IG4gJiYgbiA8PSB0aGlzLl9uZS5sYXQgJiYgaTtcbiAgICB9LCBSbC5jb252ZXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiAhdCB8fCB0IGluc3RhbmNlb2YgUmwgPyB0IDogbmV3IFJsKHQpO1xuICAgIH07XG4gICAgdmFyIE9sID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmIChpc05hTih0KSB8fCBpc05hTihlKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMbmdMYXQgb2JqZWN0OiAoXCIgKyB0ICsgXCIsIFwiICsgZSArIFwiKVwiKTtcbiAgICAgIGlmICh0aGlzLmxuZyA9ICt0LCB0aGlzLmxhdCA9ICtlLCB0aGlzLmxhdCA+IDkwIHx8IHRoaXMubGF0IDwgLTkwKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExuZ0xhdCBsYXRpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC05MCBhbmQgOTBcIik7XG4gICAgfTtcbiAgICBPbC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgT2woYyh0aGlzLmxuZywgLTE4MCwgMTgwKSwgdGhpcy5sYXQpO1xuICAgIH0sIE9sLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmxuZywgdGhpcy5sYXRdO1xuICAgIH0sIE9sLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIkxuZ0xhdChcIiArIHRoaXMubG5nICsgXCIsIFwiICsgdGhpcy5sYXQgKyBcIilcIjtcbiAgICB9LCBPbC5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgIHIgPSB0aGlzLmxhdCAqIGUsXG4gICAgICAgIG4gPSB0LmxhdCAqIGUsXG4gICAgICAgIGkgPSBNYXRoLnNpbihyKSAqIE1hdGguc2luKG4pICsgTWF0aC5jb3MocikgKiBNYXRoLmNvcyhuKSAqIE1hdGguY29zKCh0LmxuZyAtIHRoaXMubG5nKSAqIGUpO1xuICAgICAgcmV0dXJuIDYzNzEwMDguOCAqIE1hdGguYWNvcyhNYXRoLm1pbihpLCAxKSk7XG4gICAgfSwgT2wucHJvdG90eXBlLnRvQm91bmRzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IDApO1xuICAgICAgdmFyIGUgPSAzNjAgKiB0IC8gNDAwNzUwMTcsXG4gICAgICAgIHIgPSBlIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIHRoaXMubGF0KTtcbiAgICAgIHJldHVybiBuZXcgUmwobmV3IE9sKHRoaXMubG5nIC0gciwgdGhpcy5sYXQgLSBlKSwgbmV3IE9sKHRoaXMubG5nICsgciwgdGhpcy5sYXQgKyBlKSk7XG4gICAgfSwgT2wuY29udmVydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIE9sKSByZXR1cm4gdDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpICYmICgyID09PSB0Lmxlbmd0aCB8fCAzID09PSB0Lmxlbmd0aCkpIHJldHVybiBuZXcgT2woTnVtYmVyKHRbMF0pLCBOdW1iZXIodFsxXSkpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHQpICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgcmV0dXJuIG5ldyBPbChOdW1iZXIoXCJsbmdcIiBpbiB0ID8gdC5sbmcgOiB0LmxvbiksIE51bWJlcih0LmxhdCkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYExuZ0xhdExpa2VgIGFyZ3VtZW50IG11c3QgYmUgc3BlY2lmaWVkIGFzIGEgTG5nTGF0IGluc3RhbmNlLCBhbiBvYmplY3Qge2xuZzogPGxuZz4sIGxhdDogPGxhdD59LCBhbiBvYmplY3Qge2xvbjogPGxuZz4sIGxhdDogPGxhdD59LCBvciBhbiBhcnJheSBvZiBbPGxuZz4sIDxsYXQ+XVwiKTtcbiAgICB9O1xuICAgIHZhciBVbCA9IDIgKiBNYXRoLlBJICogNjM3MTAwOC44O1xuICAgIGZ1bmN0aW9uIGpsKHQpIHtcbiAgICAgIHJldHVybiBVbCAqIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcWwodCkge1xuICAgICAgcmV0dXJuICgxODAgKyB0KSAvIDM2MDtcbiAgICB9XG4gICAgZnVuY3Rpb24gTmwodCkge1xuICAgICAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyB0ICogTWF0aC5QSSAvIDM2MCkpKSAvIDM2MDtcbiAgICB9XG4gICAgZnVuY3Rpb24gS2wodCwgZSkge1xuICAgICAgcmV0dXJuIHQgLyBqbChlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR2wodCkge1xuICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoKDE4MCAtIDM2MCAqIHQpICogTWF0aC5QSSAvIDE4MCkpIC0gOTA7XG4gICAgfVxuICAgIHZhciBabCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSAwKSwgdGhpcy54ID0gK3QsIHRoaXMueSA9ICtlLCB0aGlzLnogPSArcjtcbiAgICB9O1xuICAgIFpsLmZyb21MbmdMYXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMCk7XG4gICAgICB2YXIgciA9IE9sLmNvbnZlcnQodCk7XG4gICAgICByZXR1cm4gbmV3IFpsKHFsKHIubG5nKSwgTmwoci5sYXQpLCBLbChlLCByLmxhdCkpO1xuICAgIH0sIFpsLnByb3RvdHlwZS50b0xuZ0xhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgT2woMzYwICogdGhpcy54IC0gMTgwLCBHbCh0aGlzLnkpKTtcbiAgICB9LCBabC5wcm90b3R5cGUudG9BbHRpdHVkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnogKiBqbChHbCh0aGlzLnkpKTtcbiAgICB9LCBabC5wcm90b3R5cGUubWV0ZXJJbk1lcmNhdG9yQ29vcmRpbmF0ZVVuaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDEgLyBVbCAqICh0ID0gR2wodGhpcy55KSwgMSAvIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMTgwKSk7XG4gICAgICB2YXIgdDtcbiAgICB9O1xuICAgIHZhciBYbCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB0aGlzLnogPSB0LCB0aGlzLnggPSBlLCB0aGlzLnkgPSByLCB0aGlzLmtleSA9IFlsKDAsIHQsIHQsIGUsIHIpO1xuICAgIH07XG4gICAgWGwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy56ID09PSB0LnogJiYgdGhpcy54ID09PSB0LnggJiYgdGhpcy55ID09PSB0Lnk7XG4gICAgfSwgWGwucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgcixcbiAgICAgICAgbixcbiAgICAgICAgaSxcbiAgICAgICAgYSxcbiAgICAgICAgbyxcbiAgICAgICAgcyA9IChuID0gdGhpcy55LCBpID0gdGhpcy56LCBhID0gTGwoMjU2ICogKHIgPSB0aGlzLngpLCAyNTYgKiAobiA9IE1hdGgucG93KDIsIGkpIC0gbiAtIDEpLCBpKSwgbyA9IExsKDI1NiAqIChyICsgMSksIDI1NiAqIChuICsgMSksIGkpLCBhWzBdICsgXCIsXCIgKyBhWzFdICsgXCIsXCIgKyBvWzBdICsgXCIsXCIgKyBvWzFdKSxcbiAgICAgICAgdSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiwgaSA9IFwiXCIsIGEgPSB0OyBhID4gMDsgYS0tKSBpICs9IChlICYgKG4gPSAxIDw8IGEgLSAxKSA/IDEgOiAwKSArIChyICYgbiA/IDIgOiAwKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSh0aGlzLnosIHRoaXMueCwgdGhpcy55KTtcbiAgICAgIHJldHVybiB0Wyh0aGlzLnggKyB0aGlzLnkpICUgdC5sZW5ndGhdLnJlcGxhY2UoXCJ7cHJlZml4fVwiLCAodGhpcy54ICUgMTYpLnRvU3RyaW5nKDE2KSArICh0aGlzLnkgJSAxNikudG9TdHJpbmcoMTYpKS5yZXBsYWNlKFwie3p9XCIsIFN0cmluZyh0aGlzLnopKS5yZXBsYWNlKFwie3h9XCIsIFN0cmluZyh0aGlzLngpKS5yZXBsYWNlKFwie3l9XCIsIFN0cmluZyhcInRtc1wiID09PSBlID8gTWF0aC5wb3coMiwgdGhpcy56KSAtIHRoaXMueSAtIDEgOiB0aGlzLnkpKS5yZXBsYWNlKFwie3F1YWRrZXl9XCIsIHUpLnJlcGxhY2UoXCJ7YmJveC1lcHNnLTM4NTd9XCIsIHMpO1xuICAgIH0sIFhsLnByb3RvdHlwZS5nZXRUaWxlUG9pbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBNYXRoLnBvdygyLCB0aGlzLnopO1xuICAgICAgcmV0dXJuIG5ldyBpKDgxOTIgKiAodC54ICogZSAtIHRoaXMueCksIDgxOTIgKiAodC55ICogZSAtIHRoaXMueSkpO1xuICAgIH0sIFhsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnogKyBcIi9cIiArIHRoaXMueCArIFwiL1wiICsgdGhpcy55O1xuICAgIH07XG4gICAgdmFyIEpsID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdGhpcy53cmFwID0gdCwgdGhpcy5jYW5vbmljYWwgPSBlLCB0aGlzLmtleSA9IFlsKHQsIGUueiwgZS56LCBlLngsIGUueSk7XG4gICAgICB9LFxuICAgICAgSGwgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgICB0aGlzLm92ZXJzY2FsZWRaID0gdCwgdGhpcy53cmFwID0gZSwgdGhpcy5jYW5vbmljYWwgPSBuZXcgWGwociwgK24sICtpKSwgdGhpcy5rZXkgPSBZbChlLCB0LCByLCBuLCBpKTtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gWWwodCwgZSwgciwgbiwgaSkge1xuICAgICAgKHQgKj0gMikgPCAwICYmICh0ID0gLTEgKiB0IC0gMSk7XG4gICAgICB2YXIgYSA9IDEgPDwgcjtcbiAgICAgIHJldHVybiAoYSAqIGEgKiB0ICsgYSAqIGkgKyBuKS50b1N0cmluZygzNikgKyByLnRvU3RyaW5nKDM2KSArIGUudG9TdHJpbmcoMzYpO1xuICAgIH1cbiAgICBIbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJzY2FsZWRaID09PSB0Lm92ZXJzY2FsZWRaICYmIHRoaXMud3JhcCA9PT0gdC53cmFwICYmIHRoaXMuY2Fub25pY2FsLmVxdWFscyh0LmNhbm9uaWNhbCk7XG4gICAgfSwgSGwucHJvdG90eXBlLnNjYWxlZFRvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jYW5vbmljYWwueiAtIHQ7XG4gICAgICByZXR1cm4gdCA+IHRoaXMuY2Fub25pY2FsLnogPyBuZXcgSGwodCwgdGhpcy53cmFwLCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KSA6IG5ldyBIbCh0LCB0aGlzLndyYXAsIHQsIHRoaXMuY2Fub25pY2FsLnggPj4gZSwgdGhpcy5jYW5vbmljYWwueSA+PiBlKTtcbiAgICB9LCBIbC5wcm90b3R5cGUuY2FsY3VsYXRlU2NhbGVkS2V5ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdGhpcy5jYW5vbmljYWwueiAtIHQ7XG4gICAgICByZXR1cm4gdCA+IHRoaXMuY2Fub25pY2FsLnogPyBZbCh0aGlzLndyYXAgKiArZSwgdCwgdGhpcy5jYW5vbmljYWwueiwgdGhpcy5jYW5vbmljYWwueCwgdGhpcy5jYW5vbmljYWwueSkgOiBZbCh0aGlzLndyYXAgKiArZSwgdCwgdCwgdGhpcy5jYW5vbmljYWwueCA+PiByLCB0aGlzLmNhbm9uaWNhbC55ID4+IHIpO1xuICAgIH0sIEhsLnByb3RvdHlwZS5pc0NoaWxkT2YgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHQud3JhcCAhPT0gdGhpcy53cmFwKSByZXR1cm4gITE7XG4gICAgICB2YXIgZSA9IHRoaXMuY2Fub25pY2FsLnogLSB0LmNhbm9uaWNhbC56O1xuICAgICAgcmV0dXJuIDAgPT09IHQub3ZlcnNjYWxlZFogfHwgdC5vdmVyc2NhbGVkWiA8IHRoaXMub3ZlcnNjYWxlZFogJiYgdC5jYW5vbmljYWwueCA9PT0gdGhpcy5jYW5vbmljYWwueCA+PiBlICYmIHQuY2Fub25pY2FsLnkgPT09IHRoaXMuY2Fub25pY2FsLnkgPj4gZTtcbiAgICB9LCBIbC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMub3ZlcnNjYWxlZFogPj0gdCkgcmV0dXJuIFtuZXcgSGwodGhpcy5vdmVyc2NhbGVkWiArIDEsIHRoaXMud3JhcCwgdGhpcy5jYW5vbmljYWwueiwgdGhpcy5jYW5vbmljYWwueCwgdGhpcy5jYW5vbmljYWwueSldO1xuICAgICAgdmFyIGUgPSB0aGlzLmNhbm9uaWNhbC56ICsgMSxcbiAgICAgICAgciA9IDIgKiB0aGlzLmNhbm9uaWNhbC54LFxuICAgICAgICBuID0gMiAqIHRoaXMuY2Fub25pY2FsLnk7XG4gICAgICByZXR1cm4gW25ldyBIbChlLCB0aGlzLndyYXAsIGUsIHIsIG4pLCBuZXcgSGwoZSwgdGhpcy53cmFwLCBlLCByICsgMSwgbiksIG5ldyBIbChlLCB0aGlzLndyYXAsIGUsIHIsIG4gKyAxKSwgbmV3IEhsKGUsIHRoaXMud3JhcCwgZSwgciArIDEsIG4gKyAxKV07XG4gICAgfSwgSGwucHJvdG90eXBlLmlzTGVzc1RoYW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMud3JhcCA8IHQud3JhcCB8fCAhKHRoaXMud3JhcCA+IHQud3JhcCkgJiYgKHRoaXMub3ZlcnNjYWxlZFogPCB0Lm92ZXJzY2FsZWRaIHx8ICEodGhpcy5vdmVyc2NhbGVkWiA+IHQub3ZlcnNjYWxlZFopICYmICh0aGlzLmNhbm9uaWNhbC54IDwgdC5jYW5vbmljYWwueCB8fCAhKHRoaXMuY2Fub25pY2FsLnggPiB0LmNhbm9uaWNhbC54KSAmJiB0aGlzLmNhbm9uaWNhbC55IDwgdC5jYW5vbmljYWwueSkpO1xuICAgIH0sIEhsLnByb3RvdHlwZS53cmFwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBIbCh0aGlzLm92ZXJzY2FsZWRaLCAwLCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KTtcbiAgICB9LCBIbC5wcm90b3R5cGUudW53cmFwVG8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5ldyBIbCh0aGlzLm92ZXJzY2FsZWRaLCB0LCB0aGlzLmNhbm9uaWNhbC56LCB0aGlzLmNhbm9uaWNhbC54LCB0aGlzLmNhbm9uaWNhbC55KTtcbiAgICB9LCBIbC5wcm90b3R5cGUub3ZlcnNjYWxlRmFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIHRoaXMub3ZlcnNjYWxlZFogLSB0aGlzLmNhbm9uaWNhbC56KTtcbiAgICB9LCBIbC5wcm90b3R5cGUudG9VbndyYXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEpsKHRoaXMud3JhcCwgdGhpcy5jYW5vbmljYWwpO1xuICAgIH0sIEhsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm92ZXJzY2FsZWRaICsgXCIvXCIgKyB0aGlzLmNhbm9uaWNhbC54ICsgXCIvXCIgKyB0aGlzLmNhbm9uaWNhbC55O1xuICAgIH0sIEhsLnByb3RvdHlwZS5nZXRUaWxlUG9pbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsLmdldFRpbGVQb2ludChuZXcgWmwodC54IC0gdGhpcy53cmFwLCB0LnkpKTtcbiAgICB9LCBPbihcIkNhbm9uaWNhbFRpbGVJRFwiLCBYbCksIE9uKFwiT3ZlcnNjYWxlZFRpbGVJRFwiLCBIbCwge1xuICAgICAgb21pdDogW1wicG9zTWF0cml4XCJdXG4gICAgfSk7XG4gICAgdmFyICRsID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmICh0aGlzLnVpZCA9IHQsIGUuaGVpZ2h0ICE9PSBlLndpZHRoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRFTSB0aWxlcyBtdXN0IGJlIHNxdWFyZVwiKTtcbiAgICAgIGlmIChyICYmIFwibWFwYm94XCIgIT09IHIgJiYgXCJ0ZXJyYXJpdW1cIiAhPT0gcikgcmV0dXJuIEEoJ1wiJyArIHIgKyAnXCIgaXMgbm90IGEgdmFsaWQgZW5jb2RpbmcgdHlwZS4gVmFsaWQgdHlwZXMgaW5jbHVkZSBcIm1hcGJveFwiIGFuZCBcInRlcnJhcml1bVwiLicpO1xuICAgICAgdGhpcy5zdHJpZGUgPSBlLmhlaWdodDtcbiAgICAgIHZhciBuID0gdGhpcy5kaW0gPSBlLmhlaWdodCAtIDI7XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkoZS5kYXRhLmJ1ZmZlciksIHRoaXMuZW5jb2RpbmcgPSByIHx8IFwibWFwYm94XCI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgdGhpcy5kYXRhW3RoaXMuX2lkeCgtMSwgaSldID0gdGhpcy5kYXRhW3RoaXMuX2lkeCgwLCBpKV0sIHRoaXMuZGF0YVt0aGlzLl9pZHgobiwgaSldID0gdGhpcy5kYXRhW3RoaXMuX2lkeChuIC0gMSwgaSldLCB0aGlzLmRhdGFbdGhpcy5faWR4KGksIC0xKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KGksIDApXSwgdGhpcy5kYXRhW3RoaXMuX2lkeChpLCBuKV0gPSB0aGlzLmRhdGFbdGhpcy5faWR4KGksIG4gLSAxKV07XG4gICAgICB0aGlzLmRhdGFbdGhpcy5faWR4KC0xLCAtMSldID0gdGhpcy5kYXRhW3RoaXMuX2lkeCgwLCAwKV0sIHRoaXMuZGF0YVt0aGlzLl9pZHgobiwgLTEpXSA9IHRoaXMuZGF0YVt0aGlzLl9pZHgobiAtIDEsIDApXSwgdGhpcy5kYXRhW3RoaXMuX2lkeCgtMSwgbildID0gdGhpcy5kYXRhW3RoaXMuX2lkeCgwLCBuIC0gMSldLCB0aGlzLmRhdGFbdGhpcy5faWR4KG4sIG4pXSA9IHRoaXMuZGF0YVt0aGlzLl9pZHgobiAtIDEsIG4gLSAxKV07XG4gICAgfTtcbiAgICAkbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciksXG4gICAgICAgIG4gPSA0ICogdGhpcy5faWR4KHQsIGUpO1xuICAgICAgcmV0dXJuIChcInRlcnJhcml1bVwiID09PSB0aGlzLmVuY29kaW5nID8gdGhpcy5fdW5wYWNrVGVycmFyaXVtIDogdGhpcy5fdW5wYWNrTWFwYm94KShyW25dLCByW24gKyAxXSwgcltuICsgMl0pO1xuICAgIH0sICRsLnByb3RvdHlwZS5nZXRVbnBhY2tWZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJ0ZXJyYXJpdW1cIiA9PT0gdGhpcy5lbmNvZGluZyA/IFsyNTYsIDEsIDEgLyAyNTYsIDMyNzY4XSA6IFs2NTUzLjYsIDI1LjYsIC4xLCAxZTRdO1xuICAgIH0sICRsLnByb3RvdHlwZS5faWR4ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0IDwgLTEgfHwgdCA+PSB0aGlzLmRpbSArIDEgfHwgZSA8IC0xIHx8IGUgPj0gdGhpcy5kaW0gKyAxKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBzb3VyY2UgY29vcmRpbmF0ZXMgZm9yIERFTSBkYXRhXCIpO1xuICAgICAgcmV0dXJuIChlICsgMSkgKiB0aGlzLnN0cmlkZSArICh0ICsgMSk7XG4gICAgfSwgJGwucHJvdG90eXBlLl91bnBhY2tNYXBib3ggPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuICgyNTYgKiB0ICogMjU2ICsgMjU2ICogZSArIHIpIC8gMTAgLSAxZTQ7XG4gICAgfSwgJGwucHJvdG90eXBlLl91bnBhY2tUZXJyYXJpdW0gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIDI1NiAqIHQgKyBlICsgciAvIDI1NiAtIDMyNzY4O1xuICAgIH0sICRsLnByb3RvdHlwZS5nZXRQaXhlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGJvKHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc3RyaWRlLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc3RyaWRlXG4gICAgICB9LCBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKSk7XG4gICAgfSwgJGwucHJvdG90eXBlLmJhY2tmaWxsQm9yZGVyID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIGlmICh0aGlzLmRpbSAhPT0gdC5kaW0pIHRocm93IG5ldyBFcnJvcihcImRlbSBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gICAgICB2YXIgbiA9IGUgKiB0aGlzLmRpbSxcbiAgICAgICAgaSA9IGUgKiB0aGlzLmRpbSArIHRoaXMuZGltLFxuICAgICAgICBhID0gciAqIHRoaXMuZGltLFxuICAgICAgICBvID0gciAqIHRoaXMuZGltICsgdGhpcy5kaW07XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBuID0gaSAtIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpID0gbiArIDE7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHIpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICBhID0gbyAtIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvID0gYSArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBzID0gLWUgKiB0aGlzLmRpbSwgdSA9IC1yICogdGhpcy5kaW0sIGwgPSBhOyBsIDwgbzsgbCsrKSBmb3IgKHZhciBwID0gbjsgcCA8IGk7IHArKykgdGhpcy5kYXRhW3RoaXMuX2lkeChwLCBsKV0gPSB0LmRhdGFbdGhpcy5faWR4KHAgKyBzLCBsICsgdSldO1xuICAgIH0sIE9uKFwiREVNRGF0YVwiLCAkbCk7XG4gICAgdmFyIFdsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX3N0cmluZ1RvTnVtYmVyID0ge30sIHRoaXMuX251bWJlclRvU3RyaW5nID0gW107XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgdmFyIHIgPSB0W2VdO1xuICAgICAgICB0aGlzLl9zdHJpbmdUb051bWJlcltyXSA9IGUsIHRoaXMuX251bWJlclRvU3RyaW5nW2VdID0gcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIFdsLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ1RvTnVtYmVyW3RdO1xuICAgIH0sIFdsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX251bWJlclRvU3RyaW5nW3RdO1xuICAgIH07XG4gICAgdmFyIFFsID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgICAgdGhpcy50eXBlID0gXCJGZWF0dXJlXCIsIHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlID0gdCwgdC5feiA9IGUsIHQuX3ggPSByLCB0Ll95ID0gbiwgdGhpcy5wcm9wZXJ0aWVzID0gdC5wcm9wZXJ0aWVzLCB0aGlzLmlkID0gaTtcbiAgICAgIH0sXG4gICAgICB0cCA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdHAuZ2VvbWV0cnkuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdGhpcy5fZ2VvbWV0cnkgJiYgKHRoaXMuX2dlb21ldHJ5ID0gdGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUudG9HZW9KU09OKHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlLl94LCB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS5feSwgdGhpcy5fdmVjdG9yVGlsZUZlYXR1cmUuX3opLmdlb21ldHJ5KSwgdGhpcy5fZ2VvbWV0cnk7XG4gICAgfSwgdHAuZ2VvbWV0cnkuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2dlb21ldHJ5ID0gdDtcbiAgICB9LCBRbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB7XG4gICAgICAgIGdlb21ldHJ5OiB0aGlzLmdlb21ldHJ5XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzKSBcIl9nZW9tZXRyeVwiICE9PSBlICYmIFwiX3ZlY3RvclRpbGVGZWF0dXJlXCIgIT09IGUgJiYgKHRbZV0gPSB0aGlzW2VdKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFFsLnByb3RvdHlwZSwgdHApO1xuICAgIHZhciBlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7fSwgdGhpcy5zdGF0ZUNoYW5nZXMgPSB7fSwgdGhpcy5kZWxldGVkU3RhdGVzID0ge307XG4gICAgfTtcbiAgICBlcC5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBTdHJpbmcoZSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZUNoYW5nZXNbdF0gPSB0aGlzLnN0YXRlQ2hhbmdlc1t0XSB8fCB7fSwgdGhpcy5zdGF0ZUNoYW5nZXNbdF1bbl0gPSB0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSB8fCB7fSwgaCh0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSwgciksIG51bGwgPT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XSkgZm9yICh2YXIgaSBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gPSB7fSwgdGhpcy5zdGF0ZVt0XSkgaSAhPT0gbiAmJiAodGhpcy5kZWxldGVkU3RhdGVzW3RdW2ldID0gbnVsbCk7ZWxzZSBpZiAodGhpcy5kZWxldGVkU3RhdGVzW3RdICYmIG51bGwgPT09IHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSkgZm9yICh2YXIgYSBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gPSB7fSwgdGhpcy5zdGF0ZVt0XVtuXSkgclthXSB8fCAodGhpcy5kZWxldGVkU3RhdGVzW3RdW25dW2FdID0gbnVsbCk7ZWxzZSBmb3IgKHZhciBvIGluIHIpIHRoaXMuZGVsZXRlZFN0YXRlc1t0XSAmJiB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gJiYgbnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dW29dICYmIGRlbGV0ZSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl1bb107XG4gICAgfSwgZXAucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICBpZiAobnVsbCAhPT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdKSB7XG4gICAgICAgIHZhciBuID0gU3RyaW5nKGUpO1xuICAgICAgICBpZiAodGhpcy5kZWxldGVkU3RhdGVzW3RdID0gdGhpcy5kZWxldGVkU3RhdGVzW3RdIHx8IHt9LCByICYmIHZvaWQgMCAhPT0gZSkgbnVsbCAhPT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dICYmICh0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gPSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF1bbl0gfHwge30sIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXVtyXSA9IG51bGwpO2Vsc2UgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlQ2hhbmdlc1t0XSAmJiB0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSkgZm9yIChyIGluIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSA9IHt9LCB0aGlzLnN0YXRlQ2hhbmdlc1t0XVtuXSkgdGhpcy5kZWxldGVkU3RhdGVzW3RdW25dW3JdID0gbnVsbDtlbHNlIHRoaXMuZGVsZXRlZFN0YXRlc1t0XVtuXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB0aGlzLmRlbGV0ZWRTdGF0ZXNbdF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sIGVwLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IFN0cmluZyhlKSxcbiAgICAgICAgbiA9IGgoe30sICh0aGlzLnN0YXRlW3RdIHx8IHt9KVtyXSwgKHRoaXMuc3RhdGVDaGFuZ2VzW3RdIHx8IHt9KVtyXSk7XG4gICAgICBpZiAobnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW3RdKSByZXR1cm4ge307XG4gICAgICBpZiAodGhpcy5kZWxldGVkU3RhdGVzW3RdKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5kZWxldGVkU3RhdGVzW3RdW2VdO1xuICAgICAgICBpZiAobnVsbCA9PT0gaSkgcmV0dXJuIHt9O1xuICAgICAgICBmb3IgKHZhciBhIGluIGkpIGRlbGV0ZSBuW2FdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSwgZXAucHJvdG90eXBlLmluaXRpYWxpemVUaWxlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdC5zZXRGZWF0dXJlU3RhdGUodGhpcy5zdGF0ZSwgZSk7XG4gICAgfSwgZXAucHJvdG90eXBlLmNvYWxlc2NlQ2hhbmdlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IHt9O1xuICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLnN0YXRlQ2hhbmdlcykge1xuICAgICAgICB0aGlzLnN0YXRlW25dID0gdGhpcy5zdGF0ZVtuXSB8fCB7fTtcbiAgICAgICAgdmFyIGkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgYSBpbiB0aGlzLnN0YXRlQ2hhbmdlc1tuXSkgdGhpcy5zdGF0ZVtuXVthXSB8fCAodGhpcy5zdGF0ZVtuXVthXSA9IHt9KSwgaCh0aGlzLnN0YXRlW25dW2FdLCB0aGlzLnN0YXRlQ2hhbmdlc1tuXVthXSksIGlbYV0gPSB0aGlzLnN0YXRlW25dW2FdO1xuICAgICAgICByW25dID0gaTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5kZWxldGVkU3RhdGVzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVbb10gPSB0aGlzLnN0YXRlW29dIHx8IHt9O1xuICAgICAgICB2YXIgcyA9IHt9O1xuICAgICAgICBpZiAobnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW29dKSBmb3IgKHZhciB1IGluIHRoaXMuc3RhdGVbb10pIHNbdV0gPSB7fSwgdGhpcy5zdGF0ZVtvXVt1XSA9IHt9O2Vsc2UgZm9yICh2YXIgbCBpbiB0aGlzLmRlbGV0ZWRTdGF0ZXNbb10pIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gdGhpcy5kZWxldGVkU3RhdGVzW29dW2xdKSB0aGlzLnN0YXRlW29dW2xdID0ge307ZWxzZSBmb3IgKHZhciBwID0gMCwgYyA9IE9iamVjdC5rZXlzKHRoaXMuZGVsZXRlZFN0YXRlc1tvXVtsXSk7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSBkZWxldGUgdGhpcy5zdGF0ZVtvXVtsXVtjW3BdXTtcbiAgICAgICAgICBzW2xdID0gdGhpcy5zdGF0ZVtvXVtsXTtcbiAgICAgICAgfVxuICAgICAgICByW29dID0gcltvXSB8fCB7fSwgaChyW29dLCBzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlQ2hhbmdlcyA9IHt9LCB0aGlzLmRlbGV0ZWRTdGF0ZXMgPSB7fSwgMCAhPT0gT2JqZWN0LmtleXMocikubGVuZ3RoKSBmb3IgKHZhciBmIGluIHQpIHRbZl0uc2V0RmVhdHVyZVN0YXRlKHIsIGUpO1xuICAgIH07XG4gICAgdmFyIHJwID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMudGlsZUlEID0gdCwgdGhpcy54ID0gdC5jYW5vbmljYWwueCwgdGhpcy55ID0gdC5jYW5vbmljYWwueSwgdGhpcy56ID0gdC5jYW5vbmljYWwueiwgdGhpcy5ncmlkID0gbmV3IFZuKDgxOTIsIDE2LCAwKSwgdGhpcy5ncmlkM0QgPSBuZXcgVm4oODE5MiwgMTYsIDApLCB0aGlzLmZlYXR1cmVJbmRleEFycmF5ID0gbmV3IG9hKCksIHRoaXMucHJvbW90ZUlkID0gZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5wKHQsIGUsIHIsIG4sIGkpIHtcbiAgICAgIHJldHVybiB4KHQsIGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgICAgIHZhciBvID0gZSBpbnN0YW5jZW9mIG1pID8gZS5nZXQoYSkgOiBudWxsO1xuICAgICAgICByZXR1cm4gbyAmJiBvLmV2YWx1YXRlID8gby5ldmFsdWF0ZShyLCBuLCBpKSA6IG87XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IDEgLyAwLCByID0gMSAvIDAsIG4gPSAtMSAvIDAsIGkgPSAtMSAvIDAsIGEgPSAwLCBvID0gdDsgYSA8IG8ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgdmFyIHMgPSBvW2FdO1xuICAgICAgICBlID0gTWF0aC5taW4oZSwgcy54KSwgciA9IE1hdGgubWluKHIsIHMueSksIG4gPSBNYXRoLm1heChuLCBzLngpLCBpID0gTWF0aC5tYXgoaSwgcy55KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IGUsXG4gICAgICAgIG1pblk6IHIsXG4gICAgICAgIG1heFg6IG4sXG4gICAgICAgIG1heFk6IGlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwKHQsIGUpIHtcbiAgICAgIHJldHVybiBlIC0gdDtcbiAgICB9XG4gICAgcnAucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuZmVhdHVyZUluZGV4QXJyYXkubGVuZ3RoO1xuICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5lbXBsYWNlQmFjayhyLCBuLCBpKTtcbiAgICAgIGZvciAodmFyIHMgPSBhID8gdGhpcy5ncmlkM0QgOiB0aGlzLmdyaWQsIHUgPSAwOyB1IDwgZS5sZW5ndGg7IHUrKykge1xuICAgICAgICBmb3IgKHZhciBsID0gZVt1XSwgcCA9IFsxIC8gMCwgMSAvIDAsIC0xIC8gMCwgLTEgLyAwXSwgYyA9IDA7IGMgPCBsLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgdmFyIGggPSBsW2NdO1xuICAgICAgICAgIHBbMF0gPSBNYXRoLm1pbihwWzBdLCBoLngpLCBwWzFdID0gTWF0aC5taW4ocFsxXSwgaC55KSwgcFsyXSA9IE1hdGgubWF4KHBbMl0sIGgueCksIHBbM10gPSBNYXRoLm1heChwWzNdLCBoLnkpO1xuICAgICAgICB9XG4gICAgICAgIHBbMF0gPCA4MTkyICYmIHBbMV0gPCA4MTkyICYmIHBbMl0gPj0gMCAmJiBwWzNdID49IDAgJiYgcy5pbnNlcnQobywgcFswXSwgcFsxXSwgcFsyXSwgcFszXSk7XG4gICAgICB9XG4gICAgfSwgcnAucHJvdG90eXBlLmxvYWRWVExheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZ0TGF5ZXJzIHx8ICh0aGlzLnZ0TGF5ZXJzID0gbmV3IHdzLlZlY3RvclRpbGUobmV3ICRzKHRoaXMucmF3VGlsZURhdGEpKS5sYXllcnMsIHRoaXMuc291cmNlTGF5ZXJDb2RlciA9IG5ldyBXbCh0aGlzLnZ0TGF5ZXJzID8gT2JqZWN0LmtleXModGhpcy52dExheWVycykuc29ydCgpIDogW1wiX2dlb2pzb25UaWxlTGF5ZXJcIl0pKSwgdGhpcy52dExheWVycztcbiAgICB9LCBycC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAodCwgZSwgciwgbikge1xuICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgdGhpcy5sb2FkVlRMYXllcnMoKTtcbiAgICAgIGZvciAodmFyIG8gPSB0LnBhcmFtcyB8fCB7fSwgcyA9IDgxOTIgLyB0LnRpbGVTaXplIC8gdC5zY2FsZSwgdSA9IHNuKG8uZmlsdGVyKSwgbCA9IHQucXVlcnlHZW9tZXRyeSwgcCA9IHQucXVlcnlQYWRkaW5nICogcywgYyA9IGlwKGwpLCBoID0gdGhpcy5ncmlkLnF1ZXJ5KGMubWluWCAtIHAsIGMubWluWSAtIHAsIGMubWF4WCArIHAsIGMubWF4WSArIHApLCBmID0gaXAodC5jYW1lcmFRdWVyeUdlb21ldHJ5KSwgeSA9IHRoaXMuZ3JpZDNELnF1ZXJ5KGYubWluWCAtIHAsIGYubWluWSAtIHAsIGYubWF4WCArIHAsIGYubWF4WSArIHAsIGZ1bmN0aW9uIChlLCByLCBuLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0LCBlLCByLCBuLCBhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBvID0gMCwgcyA9IHQ7IG8gPCBzLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB1ID0gc1tvXTtcbiAgICAgICAgICAgICAgaWYgKGUgPD0gdS54ICYmIHIgPD0gdS55ICYmIG4gPj0gdS54ICYmIGEgPj0gdS55KSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IFtuZXcgaShlLCByKSwgbmV3IGkoZSwgYSksIG5ldyBpKG4sIGEpLCBuZXcgaShuLCByKV07XG4gICAgICAgICAgICBpZiAodC5sZW5ndGggPiAyKSBmb3IgKHZhciBwID0gMCwgYyA9IGw7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSBpZiAoUWEodCwgY1twXSkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgdC5sZW5ndGggLSAxOyBoKyspIGlmICh0byh0W2hdLCB0W2ggKyAxXSwgbCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9KHQuY2FtZXJhUXVlcnlHZW9tZXRyeSwgZSAtIHAsIHIgLSBwLCBuICsgcCwgYSArIHApO1xuICAgICAgICB9KSwgZCA9IDAsIG0gPSB5OyBkIDwgbS5sZW5ndGg7IGQgKz0gMSkgaC5wdXNoKG1bZF0pO1xuICAgICAgaC5zb3J0KGFwKTtcbiAgICAgIGZvciAodmFyIHYsIGcgPSB7fSwgeCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgdmFyIHAgPSBoW2ldO1xuICAgICAgICAgIGlmIChwICE9PSB2KSB7XG4gICAgICAgICAgICB2ID0gcDtcbiAgICAgICAgICAgIHZhciBjID0gYS5mZWF0dXJlSW5kZXhBcnJheS5nZXQocCksXG4gICAgICAgICAgICAgIGYgPSBudWxsO1xuICAgICAgICAgICAgYS5sb2FkTWF0Y2hpbmdGZWF0dXJlKGcsIGMuYnVja2V0SW5kZXgsIGMuc291cmNlTGF5ZXJJbmRleCwgYy5mZWF0dXJlSW5kZXgsIHUsIG8ubGF5ZXJzLCBvLmF2YWlsYWJsZUltYWdlcywgZSwgciwgbiwgZnVuY3Rpb24gKGUsIHIsIG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGYgfHwgKGYgPSBVYShlKSksIHIucXVlcnlJbnRlcnNlY3RzRmVhdHVyZShsLCBlLCBuLCBmLCBhLnosIHQudHJhbnNmb3JtLCBzLCB0LnBpeGVsUG9zTWF0cml4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgYiA9IDA7IGIgPCBoLmxlbmd0aDsgYisrKSB4KGIpO1xuICAgICAgcmV0dXJuIGc7XG4gICAgfSwgcnAucHJvdG90eXBlLmxvYWRNYXRjaGluZ0ZlYXR1cmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbywgcywgdSwgbCwgcCkge1xuICAgICAgdmFyIGMgPSB0aGlzLmJ1Y2tldExheWVySURzW2VdO1xuICAgICAgaWYgKCFhIHx8IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykgaWYgKGUuaW5kZXhPZih0W3JdKSA+PSAwKSByZXR1cm4gITA7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0oYSwgYykpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLnNvdXJjZUxheWVyQ29kZXIuZGVjb2RlKHIpLFxuICAgICAgICAgIHkgPSB0aGlzLnZ0TGF5ZXJzW2ZdLmZlYXR1cmUobik7XG4gICAgICAgIGlmIChpLm5lZWRHZW9tZXRyeSkge1xuICAgICAgICAgIHZhciBkID0gamEoeSwgITApO1xuICAgICAgICAgIGlmICghaS5maWx0ZXIobmV3IHVpKHRoaXMudGlsZUlELm92ZXJzY2FsZWRaKSwgZCwgdGhpcy50aWxlSUQuY2Fub25pY2FsKSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCFpLmZpbHRlcihuZXcgdWkodGhpcy50aWxlSUQub3ZlcnNjYWxlZFopLCB5KSkgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBtID0gdGhpcy5nZXRJZCh5LCBmKSwgdiA9IDA7IHYgPCBjLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgdmFyIGcgPSBjW3ZdO1xuICAgICAgICAgIGlmICghKGEgJiYgYS5pbmRleE9mKGcpIDwgMCkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc1tnXTtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgIHZhciBiID0ge307XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gbSAmJiBsICYmIChiID0gbC5nZXRTdGF0ZSh4LnNvdXJjZUxheWVyIHx8IFwiX2dlb2pzb25UaWxlTGF5ZXJcIiwgbSkpO1xuICAgICAgICAgICAgICB2YXIgdyA9IGgoe30sIHVbZ10pO1xuICAgICAgICAgICAgICB3LnBhaW50ID0gbnAody5wYWludCwgeC5wYWludCwgeSwgYiwgbyksIHcubGF5b3V0ID0gbnAody5sYXlvdXQsIHgubGF5b3V0LCB5LCBiLCBvKTtcbiAgICAgICAgICAgICAgdmFyIF8gPSAhcCB8fCBwKHksIHgsIGIpO1xuICAgICAgICAgICAgICBpZiAoXykge1xuICAgICAgICAgICAgICAgIHZhciBBID0gbmV3IFFsKHksIHRoaXMueiwgdGhpcy54LCB0aGlzLnksIG0pO1xuICAgICAgICAgICAgICAgIEEubGF5ZXIgPSB3O1xuICAgICAgICAgICAgICAgIHZhciBTID0gdFtnXTtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IFMgJiYgKFMgPSB0W2ddID0gW10pLCBTLnB1c2goe1xuICAgICAgICAgICAgICAgICAgZmVhdHVyZUluZGV4OiBuLFxuICAgICAgICAgICAgICAgICAgZmVhdHVyZTogQSxcbiAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblo6IF9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHJwLnByb3RvdHlwZS5sb29rdXBTeW1ib2xGZWF0dXJlcyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvLCBzKSB7XG4gICAgICB2YXIgdSA9IHt9O1xuICAgICAgdGhpcy5sb2FkVlRMYXllcnMoKTtcbiAgICAgIGZvciAodmFyIGwgPSBzbihpKSwgcCA9IDAsIGMgPSB0OyBwIDwgYy5sZW5ndGg7IHAgKz0gMSkgdGhpcy5sb2FkTWF0Y2hpbmdGZWF0dXJlKHUsIHIsIG4sIGNbcF0sIGwsIGEsIG8sIHMsIGUpO1xuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgcnAucHJvdG90eXBlLmhhc0xheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSAwLCByID0gdGhpcy5idWNrZXRMYXllcklEczsgZSA8IHIubGVuZ3RoOyBlICs9IDEpIGZvciAodmFyIG4gPSAwLCBpID0gcltlXTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIGlmICh0ID09PSBpW25dKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgcnAucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdC5pZDtcbiAgICAgIHJldHVybiB0aGlzLnByb21vdGVJZCAmJiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgKHIgPSB0LnByb3BlcnRpZXNbXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5wcm9tb3RlSWQgPyB0aGlzLnByb21vdGVJZCA6IHRoaXMucHJvbW90ZUlkW2VdXSkgJiYgKHIgPSBOdW1iZXIocikpLCByO1xuICAgIH0sIE9uKFwiRmVhdHVyZUluZGV4XCIsIHJwLCB7XG4gICAgICBvbWl0OiBbXCJyYXdUaWxlRGF0YVwiLCBcInNvdXJjZUxheWVyQ29kZXJcIl1cbiAgICB9KTtcbiAgICB2YXIgb3AgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy50aWxlSUQgPSB0LCB0aGlzLnVpZCA9IHkoKSwgdGhpcy51c2VzID0gMCwgdGhpcy50aWxlU2l6ZSA9IGUsIHRoaXMuYnVja2V0cyA9IHt9LCB0aGlzLmV4cGlyYXRpb25UaW1lID0gbnVsbCwgdGhpcy5xdWVyeVBhZGRpbmcgPSAwLCB0aGlzLmhhc1N5bWJvbEJ1Y2tldHMgPSAhMSwgdGhpcy5oYXNSVExUZXh0ID0gITEsIHRoaXMuZGVwZW5kZW5jaWVzID0ge30sIHRoaXMuZXhwaXJlZFJlcXVlc3RDb3VudCA9IDAsIHRoaXMuc3RhdGUgPSBcImxvYWRpbmdcIjtcbiAgICB9O1xuICAgIG9wLnByb3RvdHlwZS5yZWdpc3RlckZhZGVEdXJhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQgKyB0aGlzLnRpbWVBZGRlZDtcbiAgICAgIGUgPCBSLm5vdygpIHx8IHRoaXMuZmFkZUVuZFRpbWUgJiYgZSA8IHRoaXMuZmFkZUVuZFRpbWUgfHwgKHRoaXMuZmFkZUVuZFRpbWUgPSBlKTtcbiAgICB9LCBvcC5wcm90b3R5cGUud2FzUmVxdWVzdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiZXJyb3JlZFwiID09PSB0aGlzLnN0YXRlIHx8IFwibG9hZGVkXCIgPT09IHRoaXMuc3RhdGUgfHwgXCJyZWxvYWRpbmdcIiA9PT0gdGhpcy5zdGF0ZTtcbiAgICB9LCBvcC5wcm90b3R5cGUubG9hZFZlY3RvckRhdGEgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHRoaXMuaGFzRGF0YSgpICYmIHRoaXMudW5sb2FkVmVjdG9yRGF0YSgpLCB0aGlzLnN0YXRlID0gXCJsb2FkZWRcIiwgdCkge1xuICAgICAgICBmb3IgKHZhciBuIGluIHQuZmVhdHVyZUluZGV4ICYmICh0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCA9IHQuZmVhdHVyZUluZGV4LCB0LnJhd1RpbGVEYXRhID8gKHRoaXMubGF0ZXN0UmF3VGlsZURhdGEgPSB0LnJhd1RpbGVEYXRhLCB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5yYXdUaWxlRGF0YSA9IHQucmF3VGlsZURhdGEpIDogdGhpcy5sYXRlc3RSYXdUaWxlRGF0YSAmJiAodGhpcy5sYXRlc3RGZWF0dXJlSW5kZXgucmF3VGlsZURhdGEgPSB0aGlzLmxhdGVzdFJhd1RpbGVEYXRhKSksIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSB0LmNvbGxpc2lvbkJveEFycmF5LCB0aGlzLmJ1Y2tldHMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciByID0ge307XG4gICAgICAgICAgaWYgKCFlKSByZXR1cm4gcjtcbiAgICAgICAgICBmb3IgKHZhciBuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdCA9IGFbaV0sXG4gICAgICAgICAgICAgICAgbiA9IHQubGF5ZXJJZHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5nZXRMYXllcih0KTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICAgIGlmICgwICE9PSBuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHQubGF5ZXJzID0gbiwgdC5zdGF0ZURlcGVuZGVudExheWVySWRzICYmICh0LnN0YXRlRGVwZW5kZW50TGF5ZXJzID0gdC5zdGF0ZURlcGVuZGVudExheWVySWRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlkID09PSB0O1xuICAgICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG8gPSAwLCBzID0gbjsgbyA8IHMubGVuZ3RoOyBvICs9IDEpIHJbc1tvXS5pZF0gPSB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBpID0gMCwgYSA9IHQ7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSBuKCk7XG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0odC5idWNrZXRzLCBlLnN0eWxlKSwgdGhpcy5oYXNTeW1ib2xCdWNrZXRzID0gITEsIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5idWNrZXRzW25dO1xuICAgICAgICAgIGlmIChpIGluc3RhbmNlb2YgZ2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N5bWJvbEJ1Y2tldHMgPSAhMCwgIXIpIGJyZWFrO1xuICAgICAgICAgICAgaS5qdXN0UmVsb2FkZWQgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzUlRMVGV4dCA9ICExLCB0aGlzLmhhc1N5bWJvbEJ1Y2tldHMpIGZvciAodmFyIGEgaW4gdGhpcy5idWNrZXRzKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmJ1Y2tldHNbYV07XG4gICAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBnbCAmJiBvLmhhc1JUTFRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzUlRMVGV4dCA9ICEwLCBzaS5pc0xvYWRpbmcoKSB8fCBzaS5pc0xvYWRlZCgpIHx8IFwiZGVmZXJyZWRcIiAhPT0gYWkoKSB8fCBvaSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHMgaW4gdGhpcy5xdWVyeVBhZGRpbmcgPSAwLCB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICB2YXIgdSA9IHRoaXMuYnVja2V0c1tzXTtcbiAgICAgICAgICB0aGlzLnF1ZXJ5UGFkZGluZyA9IE1hdGgubWF4KHRoaXMucXVlcnlQYWRkaW5nLCBlLnN0eWxlLmdldExheWVyKHMpLnF1ZXJ5UmFkaXVzKHUpKTtcbiAgICAgICAgfVxuICAgICAgICB0LmltYWdlQXRsYXMgJiYgKHRoaXMuaW1hZ2VBdGxhcyA9IHQuaW1hZ2VBdGxhcyksIHQuZ2x5cGhBdGxhc0ltYWdlICYmICh0aGlzLmdseXBoQXRsYXNJbWFnZSA9IHQuZ2x5cGhBdGxhc0ltYWdlKTtcbiAgICAgIH0gZWxzZSB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gbmV3IFdpKCk7XG4gICAgfSwgb3AucHJvdG90eXBlLnVubG9hZFZlY3RvckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciB0IGluIHRoaXMuYnVja2V0cykgdGhpcy5idWNrZXRzW3RdLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuYnVja2V0cyA9IHt9LCB0aGlzLmltYWdlQXRsYXNUZXh0dXJlICYmIHRoaXMuaW1hZ2VBdGxhc1RleHR1cmUuZGVzdHJveSgpLCB0aGlzLmltYWdlQXRsYXMgJiYgKHRoaXMuaW1hZ2VBdGxhcyA9IG51bGwpLCB0aGlzLmdseXBoQXRsYXNUZXh0dXJlICYmIHRoaXMuZ2x5cGhBdGxhc1RleHR1cmUuZGVzdHJveSgpLCB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCA9IG51bGwsIHRoaXMuc3RhdGUgPSBcInVubG9hZGVkXCI7XG4gICAgfSwgb3AucHJvdG90eXBlLmdldEJ1Y2tldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5idWNrZXRzW3QuaWRdO1xuICAgIH0sIG9wLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmJ1Y2tldHNbZV07XG4gICAgICAgIHIudXBsb2FkUGVuZGluZygpICYmIHIudXBsb2FkKHQpO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSB0LmdsO1xuICAgICAgdGhpcy5pbWFnZUF0bGFzICYmICF0aGlzLmltYWdlQXRsYXMudXBsb2FkZWQgJiYgKHRoaXMuaW1hZ2VBdGxhc1RleHR1cmUgPSBuZXcgVmwodCwgdGhpcy5pbWFnZUF0bGFzLmltYWdlLCBuLlJHQkEpLCB0aGlzLmltYWdlQXRsYXMudXBsb2FkZWQgPSAhMCksIHRoaXMuZ2x5cGhBdGxhc0ltYWdlICYmICh0aGlzLmdseXBoQXRsYXNUZXh0dXJlID0gbmV3IFZsKHQsIHRoaXMuZ2x5cGhBdGxhc0ltYWdlLCBuLkFMUEhBKSwgdGhpcy5nbHlwaEF0bGFzSW1hZ2UgPSBudWxsKTtcbiAgICB9LCBvcC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmltYWdlQXRsYXMgJiYgdGhpcy5pbWFnZUF0bGFzLnBhdGNoVXBkYXRlZEltYWdlcyh0LCB0aGlzLmltYWdlQXRsYXNUZXh0dXJlKTtcbiAgICB9LCBvcC5wcm90b3R5cGUucXVlcnlSZW5kZXJlZEZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCAmJiB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5yYXdUaWxlRGF0YSA/IHRoaXMubGF0ZXN0RmVhdHVyZUluZGV4LnF1ZXJ5KHtcbiAgICAgICAgcXVlcnlHZW9tZXRyeTogbixcbiAgICAgICAgY2FtZXJhUXVlcnlHZW9tZXRyeTogaSxcbiAgICAgICAgc2NhbGU6IGEsXG4gICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICBwaXhlbFBvc01hdHJpeDogbCxcbiAgICAgICAgdHJhbnNmb3JtOiBzLFxuICAgICAgICBwYXJhbXM6IG8sXG4gICAgICAgIHF1ZXJ5UGFkZGluZzogdGhpcy5xdWVyeVBhZGRpbmcgKiB1XG4gICAgICB9LCB0LCBlLCByKSA6IHt9O1xuICAgIH0sIG9wLnByb3RvdHlwZS5xdWVyeVNvdXJjZUZlYXR1cmVzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gdGhpcy5sYXRlc3RGZWF0dXJlSW5kZXg7XG4gICAgICBpZiAociAmJiByLnJhd1RpbGVEYXRhKSB7XG4gICAgICAgIHZhciBuID0gci5sb2FkVlRMYXllcnMoKSxcbiAgICAgICAgICBpID0gZSA/IGUuc291cmNlTGF5ZXIgOiBcIlwiLFxuICAgICAgICAgIGEgPSBuLl9nZW9qc29uVGlsZUxheWVyIHx8IG5baV07XG4gICAgICAgIGlmIChhKSBmb3IgKHZhciBvID0gc24oZSAmJiBlLmZpbHRlciksIHMgPSB0aGlzLnRpbGVJRC5jYW5vbmljYWwsIHUgPSBzLnosIGwgPSBzLngsIHAgPSBzLnksIGMgPSB7XG4gICAgICAgICAgICB6OiB1LFxuICAgICAgICAgICAgeDogbCxcbiAgICAgICAgICAgIHk6IHBcbiAgICAgICAgICB9LCBoID0gMDsgaCA8IGEubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB2YXIgZiA9IGEuZmVhdHVyZShoKTtcbiAgICAgICAgICBpZiAoby5uZWVkR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHZhciB5ID0gamEoZiwgITApO1xuICAgICAgICAgICAgaWYgKCFvLmZpbHRlcihuZXcgdWkodGhpcy50aWxlSUQub3ZlcnNjYWxlZFopLCB5LCB0aGlzLnRpbGVJRC5jYW5vbmljYWwpKSBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFvLmZpbHRlcihuZXcgdWkodGhpcy50aWxlSUQub3ZlcnNjYWxlZFopLCBmKSkgY29udGludWU7XG4gICAgICAgICAgdmFyIGQgPSByLmdldElkKGYsIGkpLFxuICAgICAgICAgICAgbSA9IG5ldyBRbChmLCB1LCBsLCBwLCBkKTtcbiAgICAgICAgICBtLnRpbGUgPSBjLCB0LnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvcC5wcm90b3R5cGUuaGFzRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImxvYWRlZFwiID09PSB0aGlzLnN0YXRlIHx8IFwicmVsb2FkaW5nXCIgPT09IHRoaXMuc3RhdGUgfHwgXCJleHBpcmVkXCIgPT09IHRoaXMuc3RhdGU7XG4gICAgfSwgb3AucHJvdG90eXBlLnBhdHRlcm5zTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VBdGxhcyAmJiAhIU9iamVjdC5rZXlzKHRoaXMuaW1hZ2VBdGxhcy5wYXR0ZXJuUG9zaXRpb25zKS5sZW5ndGg7XG4gICAgfSwgb3AucHJvdG90eXBlLnNldEV4cGlyeURhdGEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHQuY2FjaGVDb250cm9sKSB7XG4gICAgICAgIHZhciByID0geih0LmNhY2hlQ29udHJvbCk7XG4gICAgICAgIHJbXCJtYXgtYWdlXCJdICYmICh0aGlzLmV4cGlyYXRpb25UaW1lID0gRGF0ZS5ub3coKSArIDFlMyAqIHJbXCJtYXgtYWdlXCJdKTtcbiAgICAgIH0gZWxzZSB0LmV4cGlyZXMgJiYgKHRoaXMuZXhwaXJhdGlvblRpbWUgPSBuZXcgRGF0ZSh0LmV4cGlyZXMpLmdldFRpbWUoKSk7XG4gICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSkge1xuICAgICAgICB2YXIgbiA9IERhdGUubm93KCksXG4gICAgICAgICAgaSA9ICExO1xuICAgICAgICBpZiAodGhpcy5leHBpcmF0aW9uVGltZSA+IG4pIGkgPSAhMTtlbHNlIGlmIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUgPCBlKSBpID0gITA7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZXhwaXJhdGlvblRpbWUgLSBlO1xuICAgICAgICAgICAgYSA/IHRoaXMuZXhwaXJhdGlvblRpbWUgPSBuICsgTWF0aC5tYXgoYSwgM2U0KSA6IGkgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpID0gITA7XG4gICAgICAgIGkgPyAodGhpcy5leHBpcmVkUmVxdWVzdENvdW50KyssIHRoaXMuc3RhdGUgPSBcImV4cGlyZWRcIikgOiB0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICAgICAgfVxuICAgIH0sIG9wLnByb3RvdHlwZS5nZXRFeHBpcnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUpIHJldHVybiB0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgPyAxZTMgKiAoMSA8PCBNYXRoLm1pbih0aGlzLmV4cGlyZWRSZXF1ZXN0Q291bnQgLSAxLCAzMSkpIDogTWF0aC5taW4odGhpcy5leHBpcmF0aW9uVGltZSAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBNYXRoLnBvdygyLCAzMSkgLSAxKTtcbiAgICB9LCBvcC5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICh0aGlzLmxhdGVzdEZlYXR1cmVJbmRleCAmJiB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5yYXdUaWxlRGF0YSAmJiAwICE9PSBPYmplY3Qua2V5cyh0KS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmxhdGVzdEZlYXR1cmVJbmRleC5sb2FkVlRMYXllcnMoKTtcbiAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmJ1Y2tldHMpIGlmIChlLnN0eWxlLmhhc0xheWVyKG4pKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLmJ1Y2tldHNbbl0sXG4gICAgICAgICAgICBhID0gaS5sYXllcnNbMF0uc291cmNlTGF5ZXIgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLFxuICAgICAgICAgICAgbyA9IHJbYV0sXG4gICAgICAgICAgICBzID0gdFthXTtcbiAgICAgICAgICBpZiAobyAmJiBzICYmIDAgIT09IE9iamVjdC5rZXlzKHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaS51cGRhdGUocywgbywgdGhpcy5pbWFnZUF0bGFzICYmIHRoaXMuaW1hZ2VBdGxhcy5wYXR0ZXJuUG9zaXRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciB1ID0gZSAmJiBlLnN0eWxlICYmIGUuc3R5bGUuZ2V0TGF5ZXIobik7XG4gICAgICAgICAgICB1ICYmICh0aGlzLnF1ZXJ5UGFkZGluZyA9IE1hdGgubWF4KHRoaXMucXVlcnlQYWRkaW5nLCB1LnF1ZXJ5UmFkaXVzKGkpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgb3AucHJvdG90eXBlLmhvbGRpbmdGb3JGYWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsO1xuICAgIH0sIG9wLnByb3RvdHlwZS5zeW1ib2xGYWRlRmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3ltYm9sRmFkZUhvbGRVbnRpbCB8fCB0aGlzLnN5bWJvbEZhZGVIb2xkVW50aWwgPCBSLm5vdygpO1xuICAgIH0sIG9wLnByb3RvdHlwZS5jbGVhckZhZGVIb2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsID0gdm9pZCAwO1xuICAgIH0sIG9wLnByb3RvdHlwZS5zZXRIb2xkRHVyYXRpb24gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5zeW1ib2xGYWRlSG9sZFVudGlsID0gUi5ub3coKSArIHQ7XG4gICAgfSwgb3AucHJvdG90eXBlLnNldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0ge30sIG4gPSAwLCBpID0gZTsgbiA8IGkubGVuZ3RoOyBuICs9IDEpIHJbaVtuXV0gPSAhMDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzW3RdID0gcjtcbiAgICB9LCBvcC5wcm90b3R5cGUuaGFzRGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciByID0gMCwgbiA9IHQ7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5kZXBlbmRlbmNpZXNbbltyXV07XG4gICAgICAgIGlmIChpKSBmb3IgKHZhciBhID0gMCwgbyA9IGU7IGEgPCBvLmxlbmd0aDsgYSArPSAxKSBpZiAoaVtvW2FdXSkgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH07XG4gICAgdmFyIHNwID0gby5wZXJmb3JtYW5jZSxcbiAgICAgIHVwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fbWFya3MgPSB7XG4gICAgICAgICAgc3RhcnQ6IFt0LnVybCwgXCJzdGFydFwiXS5qb2luKFwiI1wiKSxcbiAgICAgICAgICBlbmQ6IFt0LnVybCwgXCJlbmRcIl0uam9pbihcIiNcIiksXG4gICAgICAgICAgbWVhc3VyZTogdC51cmwudG9TdHJpbmcoKVxuICAgICAgICB9LCBzcC5tYXJrKHRoaXMuX21hcmtzLnN0YXJ0KTtcbiAgICAgIH07XG4gICAgdXAucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNwLm1hcmsodGhpcy5fbWFya3MuZW5kKTtcbiAgICAgIHZhciB0ID0gc3AuZ2V0RW50cmllc0J5TmFtZSh0aGlzLl9tYXJrcy5tZWFzdXJlKTtcbiAgICAgIHJldHVybiAwID09PSB0Lmxlbmd0aCAmJiAoc3AubWVhc3VyZSh0aGlzLl9tYXJrcy5tZWFzdXJlLCB0aGlzLl9tYXJrcy5zdGFydCwgdGhpcy5fbWFya3MuZW5kKSwgdCA9IHNwLmdldEVudHJpZXNCeU5hbWUodGhpcy5fbWFya3MubWVhc3VyZSksIHNwLmNsZWFyTWFya3ModGhpcy5fbWFya3Muc3RhcnQpLCBzcC5jbGVhck1hcmtzKHRoaXMuX21hcmtzLmVuZCksIHNwLmNsZWFyTWVhc3VyZXModGhpcy5fbWFya3MubWVhc3VyZSkpLCB0O1xuICAgIH0sIHQuQWN0b3IgPSBEbCwgdC5BbHBoYUltYWdlID0geG8sIHQuQ2Fub25pY2FsVGlsZUlEID0gWGwsIHQuQ29sbGlzaW9uQm94QXJyYXkgPSBXaSwgdC5Db2xvciA9IGVlLCB0LkRFTURhdGEgPSAkbCwgdC5EYXRhQ29uc3RhbnRQcm9wZXJ0eSA9IHZpLCB0LkRpY3Rpb25hcnlDb2RlciA9IFdsLCB0LkVYVEVOVCA9IDgxOTIsIHQuRXJyb3JFdmVudCA9IEN0LCB0LkV2YWx1YXRpb25QYXJhbWV0ZXJzID0gdWksIHQuRXZlbnQgPSB6dCwgdC5FdmVudGVkID0gRXQsIHQuRmVhdHVyZUluZGV4ID0gcnAsIHQuRmlsbEJ1Y2tldCA9IHVzLCB0LkZpbGxFeHRydXNpb25CdWNrZXQgPSBrcywgdC5JbWFnZUF0bGFzID0gd3UsIHQuSW1hZ2VQb3NpdGlvbiA9IHh1LCB0LkxpbmVCdWNrZXQgPSBEcywgdC5MbmdMYXQgPSBPbCwgdC5MbmdMYXRCb3VuZHMgPSBSbCwgdC5NZXJjYXRvckNvb3JkaW5hdGUgPSBabCwgdC5PTkVfRU0gPSAyNCwgdC5PdmVyc2NhbGVkVGlsZUlEID0gSGwsIHQuUG9pbnQgPSBpLCB0LlBvaW50JDEgPSBpLCB0LlByb3BlcnRpZXMgPSBfaSwgdC5Qcm90b2J1ZiA9ICRzLCB0LlJHQkFJbWFnZSA9IGJvLCB0LlJlcXVlc3RNYW5hZ2VyID0gRywgdC5SZXF1ZXN0UGVyZm9ybWFuY2UgPSB1cCwgdC5SZXNvdXJjZVR5cGUgPSB5dCwgdC5TZWdtZW50VmVjdG9yID0gdWEsIHQuU291cmNlRmVhdHVyZVN0YXRlID0gZXAsIHQuU3RydWN0QXJyYXlMYXlvdXQxdWkyID0gSGksIHQuU3RydWN0QXJyYXlMYXlvdXQyZjFmMmkxNiA9IFVpLCB0LlN0cnVjdEFycmF5TGF5b3V0Mmk0ID0gRWksIHQuU3RydWN0QXJyYXlMYXlvdXQzdWk2ID0gcWksIHQuU3RydWN0QXJyYXlMYXlvdXQ0aTggPSBQaSwgdC5TeW1ib2xCdWNrZXQgPSBnbCwgdC5UZXh0dXJlID0gVmwsIHQuVGlsZSA9IG9wLCB0LlRyYW5zaXRpb25hYmxlID0gY2ksIHQuVW5pZm9ybTFmID0gd2EsIHQuVW5pZm9ybTFpID0gYmEsIHQuVW5pZm9ybTJmID0gX2EsIHQuVW5pZm9ybTNmID0gQWEsIHQuVW5pZm9ybTRmID0gU2EsIHQuVW5pZm9ybUNvbG9yID0ga2EsIHQuVW5pZm9ybU1hdHJpeDRmID0gemEsIHQuVW53cmFwcGVkVGlsZUlEID0gSmwsIHQuVmFsaWRhdGlvbkVycm9yID0gTXQsIHQuV3JpdGluZ01vZGUgPSBfdSwgdC5ab29tSGlzdG9yeSA9IEduLCB0LmFkZCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdFswXSA9IGVbMF0gKyByWzBdLCB0WzFdID0gZVsxXSArIHJbMV0sIHRbMl0gPSBlWzJdICsgclsyXSwgdDtcbiAgICB9LCB0LmFkZER5bmFtaWNBdHRyaWJ1dGVzID0geWwsIHQuYXN5bmNBbGwgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKCF0Lmxlbmd0aCkgcmV0dXJuIHIobnVsbCwgW10pO1xuICAgICAgdmFyIG4gPSB0Lmxlbmd0aCxcbiAgICAgICAgaSA9IG5ldyBBcnJheSh0Lmxlbmd0aCksXG4gICAgICAgIGEgPSBudWxsO1xuICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uICh0LCBvKSB7XG4gICAgICAgIGUodCwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICB0ICYmIChhID0gdCksIGlbb10gPSBlLCAwID09IC0tbiAmJiByKGEsIGkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIHQuYmV6aWVyID0gdSwgdC5iaW5kQWxsID0gdiwgdC5icm93c2VyID0gUiwgdC5jYWNoZUVudHJ5UG9zc2libHlBZGRlZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICArK2h0ID4gdXQgJiYgKHQuZ2V0QWN0b3IoKS5zZW5kKFwiZW5mb3JjZUNhY2hlU2l6ZUxpbWl0XCIsIHN0KSwgaHQgPSAwKTtcbiAgICB9LCB0LmNsYW1wID0gcCwgdC5jbGVhclRpbGVDYWNoZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG8uY2FjaGVzLmRlbGV0ZShcIm1hcGJveC10aWxlc1wiKTtcbiAgICAgIHQgJiYgZS5jYXRjaCh0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHQoKTtcbiAgICAgIH0pO1xuICAgIH0sIHQuY2xpcExpbmUgPSBYdSwgdC5jbG9uZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG5ldyBvbygxNik7XG4gICAgICByZXR1cm4gZVswXSA9IHRbMF0sIGVbMV0gPSB0WzFdLCBlWzJdID0gdFsyXSwgZVszXSA9IHRbM10sIGVbNF0gPSB0WzRdLCBlWzVdID0gdFs1XSwgZVs2XSA9IHRbNl0sIGVbN10gPSB0WzddLCBlWzhdID0gdFs4XSwgZVs5XSA9IHRbOV0sIGVbMTBdID0gdFsxMF0sIGVbMTFdID0gdFsxMV0sIGVbMTJdID0gdFsxMl0sIGVbMTNdID0gdFsxM10sIGVbMTRdID0gdFsxNF0sIGVbMTVdID0gdFsxNV0sIGU7XG4gICAgfSwgdC5jbG9uZSQxID0gdywgdC5jbG9uZSQyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gbmV3IG9vKDMpO1xuICAgICAgcmV0dXJuIGVbMF0gPSB0WzBdLCBlWzFdID0gdFsxXSwgZVsyXSA9IHRbMl0sIGU7XG4gICAgfSwgdC5jb2xsaXNpb25DaXJjbGVMYXlvdXQgPSBacywgdC5jb25maWcgPSBPLCB0LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gbmV3IG9vKDE2KTtcbiAgICAgIHJldHVybiBvbyAhPSBGbG9hdDMyQXJyYXkgJiYgKHRbMV0gPSAwLCB0WzJdID0gMCwgdFszXSA9IDAsIHRbNF0gPSAwLCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAwLCB0WzldID0gMCwgdFsxMV0gPSAwLCB0WzEyXSA9IDAsIHRbMTNdID0gMCwgdFsxNF0gPSAwKSwgdFswXSA9IDEsIHRbNV0gPSAxLCB0WzEwXSA9IDEsIHRbMTVdID0gMSwgdDtcbiAgICB9LCB0LmNyZWF0ZSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgb28oOSk7XG4gICAgICByZXR1cm4gb28gIT0gRmxvYXQzMkFycmF5ICYmICh0WzFdID0gMCwgdFsyXSA9IDAsIHRbM10gPSAwLCB0WzVdID0gMCwgdFs2XSA9IDAsIHRbN10gPSAwKSwgdFswXSA9IDEsIHRbNF0gPSAxLCB0WzhdID0gMSwgdDtcbiAgICB9LCB0LmNyZWF0ZSQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgb28oNCk7XG4gICAgICByZXR1cm4gb28gIT0gRmxvYXQzMkFycmF5ICYmICh0WzFdID0gMCwgdFsyXSA9IDApLCB0WzBdID0gMSwgdFszXSA9IDEsIHQ7XG4gICAgfSwgdC5jcmVhdGVDb21tb25qc01vZHVsZSA9IGUsIHQuY3JlYXRlRXhwcmVzc2lvbiA9IFhyLCB0LmNyZWF0ZUxheW91dCA9IHppLCB0LmNyZWF0ZVN0eWxlTGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIFwiY3VzdG9tXCIgPT09IHQudHlwZSA/IG5ldyB6bCh0KSA6IG5ldyBDbFt0LnR5cGVdKHQpO1xuICAgIH0sIHQuY3Jvc3MgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICBpID0gZVsxXSxcbiAgICAgICAgYSA9IGVbMl0sXG4gICAgICAgIG8gPSByWzBdLFxuICAgICAgICBzID0gclsxXSxcbiAgICAgICAgdSA9IHJbMl07XG4gICAgICByZXR1cm4gdFswXSA9IGkgKiB1IC0gYSAqIHMsIHRbMV0gPSBhICogbyAtIG4gKiB1LCB0WzJdID0gbiAqIHMgLSBpICogbywgdDtcbiAgICB9LCB0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIHQoZSwgcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IGUubGVuZ3RoICE9PSByLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIGlmICghdChlW25dLCByW25dKSkgcmV0dXJuICExO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBudWxsICE9PSBlICYmIG51bGwgIT09IHIpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHIpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGUpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocikubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICAgIGZvciAodmFyIGkgaW4gZSkgaWYgKCF0KGVbaV0sIHJbaV0pKSByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlID09PSByO1xuICAgIH0sIHQuZG90ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0WzBdICogZVswXSArIHRbMV0gKiBlWzFdICsgdFsyXSAqIGVbMl07XG4gICAgfSwgdC5kb3QkMSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdFswXSAqIGVbMF0gKyB0WzFdICogZVsxXSArIHRbMl0gKiBlWzJdICsgdFszXSAqIGVbM107XG4gICAgfSwgdC5lYXNlID0gbCwgdC5lbWl0VmFsaWRhdGlvbkVycm9ycyA9IFRuLCB0LmVuZHNXaXRoID0gZywgdC5lbmZvcmNlQ2FjaGVTaXplTGltaXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgbHQoKSwgdHQgJiYgdHQudGhlbihmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmtleXMoKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCByLmxlbmd0aCAtIHQ7IG4rKykgZS5kZWxldGUocltuXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgdC5ldmFsdWF0ZVNpemVGb3JGZWF0dXJlID0gUnUsIHQuZXZhbHVhdGVTaXplRm9yWm9vbSA9IE91LCB0LmV2YWx1YXRlVmFyaWFibGVPZmZzZXQgPSBvbCwgdC5ldmVudGVkID0gaWksIHQuZXh0ZW5kID0gaCwgdC5mZWF0dXJlRmlsdGVyID0gc24sIHQuZmlsdGVyT2JqZWN0ID0gYiwgdC5mcm9tUm90YXRpb24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNpbihlKSxcbiAgICAgICAgbiA9IE1hdGguY29zKGUpO1xuICAgICAgcmV0dXJuIHRbMF0gPSBuLCB0WzFdID0gciwgdFsyXSA9IDAsIHRbM10gPSAtciwgdFs0XSA9IG4sIHRbNV0gPSAwLCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAxLCB0O1xuICAgIH0sIHQuZ2V0QW5jaG9yQWxpZ25tZW50ID0gVHUsIHQuZ2V0QW5jaG9ySnVzdGlmaWNhdGlvbiA9IHNsLCB0LmdldEFycmF5QnVmZmVyID0gd3QsIHQuZ2V0SW1hZ2UgPSBTdCwgdC5nZXRKU09OID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiBidChoKHQsIHtcbiAgICAgICAgdHlwZTogXCJqc29uXCJcbiAgICAgIH0pLCBlKTtcbiAgICB9LCB0LmdldFJUTFRleHRQbHVnaW5TdGF0dXMgPSBhaSwgdC5nZXRSZWZlcnJlciA9IG10LCB0LmdldFZpZGVvID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByLFxuICAgICAgICBuLFxuICAgICAgICBpID0gby5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICBpLm11dGVkID0gITAsIGkub25sb2Fkc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGUobnVsbCwgaSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciBzID0gby5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICAgICAgICByID0gdFthXSwgbiA9IHZvaWQgMCwgKG4gPSBvLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpKS5ocmVmID0gciwgKG4ucHJvdG9jb2wgIT09IG8uZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgfHwgbi5ob3N0ICE9PSBvLmRvY3VtZW50LmxvY2F0aW9uLmhvc3QpICYmIChpLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIiksIHMuc3JjID0gdFthXSwgaS5hcHBlbmRDaGlsZChzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgfSwgdC5pZGVudGl0eSA9IHNvLCB0LmludmVydCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgciA9IGVbMF0sXG4gICAgICAgIG4gPSBlWzFdLFxuICAgICAgICBpID0gZVsyXSxcbiAgICAgICAgYSA9IGVbM10sXG4gICAgICAgIG8gPSBlWzRdLFxuICAgICAgICBzID0gZVs1XSxcbiAgICAgICAgdSA9IGVbNl0sXG4gICAgICAgIGwgPSBlWzddLFxuICAgICAgICBwID0gZVs4XSxcbiAgICAgICAgYyA9IGVbOV0sXG4gICAgICAgIGggPSBlWzEwXSxcbiAgICAgICAgZiA9IGVbMTFdLFxuICAgICAgICB5ID0gZVsxMl0sXG4gICAgICAgIGQgPSBlWzEzXSxcbiAgICAgICAgbSA9IGVbMTRdLFxuICAgICAgICB2ID0gZVsxNV0sXG4gICAgICAgIGcgPSByICogcyAtIG4gKiBvLFxuICAgICAgICB4ID0gciAqIHUgLSBpICogbyxcbiAgICAgICAgYiA9IHIgKiBsIC0gYSAqIG8sXG4gICAgICAgIHcgPSBuICogdSAtIGkgKiBzLFxuICAgICAgICBfID0gbiAqIGwgLSBhICogcyxcbiAgICAgICAgQSA9IGkgKiBsIC0gYSAqIHUsXG4gICAgICAgIFMgPSBwICogZCAtIGMgKiB5LFxuICAgICAgICBrID0gcCAqIG0gLSBoICogeSxcbiAgICAgICAgSSA9IHAgKiB2IC0gZiAqIHksXG4gICAgICAgIHogPSBjICogbSAtIGggKiBkLFxuICAgICAgICBDID0gYyAqIHYgLSBmICogZCxcbiAgICAgICAgRSA9IGggKiB2IC0gZiAqIG0sXG4gICAgICAgIFAgPSBnICogRSAtIHggKiBDICsgYiAqIHogKyB3ICogSSAtIF8gKiBrICsgQSAqIFM7XG4gICAgICByZXR1cm4gUCA/ICh0WzBdID0gKHMgKiBFIC0gdSAqIEMgKyBsICogeikgKiAoUCA9IDEgLyBQKSwgdFsxXSA9IChpICogQyAtIG4gKiBFIC0gYSAqIHopICogUCwgdFsyXSA9IChkICogQSAtIG0gKiBfICsgdiAqIHcpICogUCwgdFszXSA9IChoICogXyAtIGMgKiBBIC0gZiAqIHcpICogUCwgdFs0XSA9ICh1ICogSSAtIG8gKiBFIC0gbCAqIGspICogUCwgdFs1XSA9IChyICogRSAtIGkgKiBJICsgYSAqIGspICogUCwgdFs2XSA9IChtICogYiAtIHkgKiBBIC0gdiAqIHgpICogUCwgdFs3XSA9IChwICogQSAtIGggKiBiICsgZiAqIHgpICogUCwgdFs4XSA9IChvICogQyAtIHMgKiBJICsgbCAqIFMpICogUCwgdFs5XSA9IChuICogSSAtIHIgKiBDIC0gYSAqIFMpICogUCwgdFsxMF0gPSAoeSAqIF8gLSBkICogYiArIHYgKiBnKSAqIFAsIHRbMTFdID0gKGMgKiBiIC0gcCAqIF8gLSBmICogZykgKiBQLCB0WzEyXSA9IChzICogayAtIG8gKiB6IC0gdSAqIFMpICogUCwgdFsxM10gPSAociAqIHogLSBuICogayArIGkgKiBTKSAqIFAsIHRbMTRdID0gKGQgKiB4IC0geSAqIHcgLSBtICogZykgKiBQLCB0WzE1XSA9IChwICogdyAtIGMgKiB4ICsgaCAqIGcpICogUCwgdCkgOiBudWxsO1xuICAgIH0sIHQuaXNDaGFyID0gWm4sIHQuaXNNYXBib3hVUkwgPSBaLCB0LmtleXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gW107XG4gICAgICBmb3IgKHZhciBuIGluIHQpIG4gaW4gZSB8fCByLnB1c2gobik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCB0Lm1ha2VSZXF1ZXN0ID0gYnQsIHQubWFwT2JqZWN0ID0geCwgdC5tZXJjYXRvclhmcm9tTG5nID0gcWwsIHQubWVyY2F0b3JZZnJvbUxhdCA9IE5sLCB0Lm1lcmNhdG9yWmZyb21BbHRpdHVkZSA9IEtsLCB0Lm11bCA9IHBvLCB0Lm11bHRpcGx5ID0gdW8sIHQubXZ0ID0gd3MsIHQubmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgPD0gMSA/IDEgOiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2codCkgLyBNYXRoLkxOMikpO1xuICAgIH0sIHQubm9ybWFsaXplID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHZhciByID0gZVswXSxcbiAgICAgICAgbiA9IGVbMV0sXG4gICAgICAgIGkgPSBlWzJdLFxuICAgICAgICBhID0gciAqIHIgKyBuICogbiArIGkgKiBpO1xuICAgICAgcmV0dXJuIGEgPiAwICYmIChhID0gMSAvIE1hdGguc3FydChhKSksIHRbMF0gPSBlWzBdICogYSwgdFsxXSA9IGVbMV0gKiBhLCB0WzJdID0gZVsyXSAqIGEsIHQ7XG4gICAgfSwgdC5udW1iZXIgPSBHZSwgdC5vZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSBmdCwgdC5vcnRobyA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBhLCBvKSB7XG4gICAgICB2YXIgcyA9IDEgLyAoZSAtIHIpLFxuICAgICAgICB1ID0gMSAvIChuIC0gaSksXG4gICAgICAgIGwgPSAxIC8gKGEgLSBvKTtcbiAgICAgIHJldHVybiB0WzBdID0gLTIgKiBzLCB0WzFdID0gMCwgdFsyXSA9IDAsIHRbM10gPSAwLCB0WzRdID0gMCwgdFs1XSA9IC0yICogdSwgdFs2XSA9IDAsIHRbN10gPSAwLCB0WzhdID0gMCwgdFs5XSA9IDAsIHRbMTBdID0gMiAqIGwsIHRbMTFdID0gMCwgdFsxMl0gPSAoZSArIHIpICogcywgdFsxM10gPSAoaSArIG4pICogdSwgdFsxNF0gPSAobyArIGEpICogbCwgdFsxNV0gPSAxLCB0O1xuICAgIH0sIHQucGFyc2VHbHlwaFBCRiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3ICRzKHQpLnJlYWRGaWVsZHMoZHUsIFtdKTtcbiAgICB9LCB0LnBiZiA9ICRzLCB0LnBlcmZvcm1TeW1ib2xMYXlvdXQgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSwgYSwgbykge1xuICAgICAgdC5jcmVhdGVBcnJheXMoKSwgdC50aWxlUGl4ZWxSYXRpbyA9IDgxOTIgLyAoNTEyICogdC5vdmVyc2NhbGluZyksIHQuY29tcGFyZVRleHQgPSB7fSwgdC5pY29uc05lZWRMaW5lYXIgPSAhMTtcbiAgICAgIHZhciBzID0gdC5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICB1ID0gdC5sYXllcnNbMF0uX3VuZXZhbHVhdGVkTGF5b3V0Ll92YWx1ZXMsXG4gICAgICAgIGwgPSB7fTtcbiAgICAgIGlmIChcImNvbXBvc2l0ZVwiID09PSB0LnRleHRTaXplRGF0YS5raW5kKSB7XG4gICAgICAgIHZhciBwID0gdC50ZXh0U2l6ZURhdGEsXG4gICAgICAgICAgYyA9IHAubWF4Wm9vbTtcbiAgICAgICAgbC5jb21wb3NpdGVUZXh0U2l6ZXMgPSBbdVtcInRleHQtc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aShwLm1pblpvb20pLCBvKSwgdVtcInRleHQtc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aShjKSwgbyldO1xuICAgICAgfVxuICAgICAgaWYgKFwiY29tcG9zaXRlXCIgPT09IHQuaWNvblNpemVEYXRhLmtpbmQpIHtcbiAgICAgICAgdmFyIGggPSB0Lmljb25TaXplRGF0YSxcbiAgICAgICAgICBmID0gaC5tYXhab29tO1xuICAgICAgICBsLmNvbXBvc2l0ZUljb25TaXplcyA9IFt1W1wiaWNvbi1zaXplXCJdLnBvc3NpYmx5RXZhbHVhdGUobmV3IHVpKGgubWluWm9vbSksIG8pLCB1W1wiaWNvbi1zaXplXCJdLnBvc3NpYmx5RXZhbHVhdGUobmV3IHVpKGYpLCBvKV07XG4gICAgICB9XG4gICAgICBsLmxheW91dFRleHRTaXplID0gdVtcInRleHQtc2l6ZVwiXS5wb3NzaWJseUV2YWx1YXRlKG5ldyB1aSh0Lnpvb20gKyAxKSwgbyksIGwubGF5b3V0SWNvblNpemUgPSB1W1wiaWNvbi1zaXplXCJdLnBvc3NpYmx5RXZhbHVhdGUobmV3IHVpKHQuem9vbSArIDEpLCBvKSwgbC50ZXh0TWF4U2l6ZSA9IHVbXCJ0ZXh0LXNpemVcIl0ucG9zc2libHlFdmFsdWF0ZShuZXcgdWkoMTgpKTtcbiAgICAgIGZvciAodmFyIHkgPSAyNCAqIHMuZ2V0KFwidGV4dC1saW5lLWhlaWdodFwiKSwgZCA9IFwibWFwXCIgPT09IHMuZ2V0KFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgXCJwb2ludFwiICE9PSBzLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksIG0gPSBzLmdldChcInRleHQta2VlcC11cHJpZ2h0XCIpLCB2ID0gcy5nZXQoXCJ0ZXh0LXNpemVcIiksIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGEgPSBiW3hdLFxuICAgICAgICAgICAgdSA9IHMuZ2V0KFwidGV4dC1mb250XCIpLmV2YWx1YXRlKGEsIHt9LCBvKS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgIHAgPSB2LmV2YWx1YXRlKGEsIHt9LCBvKSxcbiAgICAgICAgICAgIGMgPSBsLmxheW91dFRleHRTaXplLmV2YWx1YXRlKGEsIHt9LCBvKSxcbiAgICAgICAgICAgIGggPSBsLmxheW91dEljb25TaXplLmV2YWx1YXRlKGEsIHt9LCBvKSxcbiAgICAgICAgICAgIGYgPSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWw6IHt9LFxuICAgICAgICAgICAgICB2ZXJ0aWNhbDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZyA9IGEudGV4dCxcbiAgICAgICAgICAgIHcgPSBbMCwgMF07XG4gICAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgIHZhciBfID0gZy50b1N0cmluZygpLFxuICAgICAgICAgICAgICBTID0gMjQgKiBzLmdldChcInRleHQtbGV0dGVyLXNwYWNpbmdcIikuZXZhbHVhdGUoYSwge30sIG8pLFxuICAgICAgICAgICAgICBrID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMCwgciA9IHQ7IGUgPCByLmxlbmd0aDsgZSArPSAxKSBpZiAobiA9IHJbZV0uY2hhckNvZGVBdCgwKSwgWm4uQXJhYmljKG4pIHx8IFpuW1wiQXJhYmljIFN1cHBsZW1lbnRcIl0obikgfHwgWm5bXCJBcmFiaWMgRXh0ZW5kZWQtQVwiXShuKSB8fCBabltcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVwiXShuKSB8fCBabltcIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlwiXShuKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIHZhciBuO1xuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgfShfKSA/IFMgOiAwLFxuICAgICAgICAgICAgICBJID0gcy5nZXQoXCJ0ZXh0LWFuY2hvclwiKS5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICAgIHogPSBzLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpO1xuICAgICAgICAgICAgaWYgKCF6KSB7XG4gICAgICAgICAgICAgIHZhciBDID0gcy5nZXQoXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIikuZXZhbHVhdGUoYSwge30sIG8pO1xuICAgICAgICAgICAgICB3ID0gQyA/IG9sKEksIFsyNCAqIEMsIGFsXSkgOiBzLmdldChcInRleHQtb2Zmc2V0XCIpLmV2YWx1YXRlKGEsIHt9LCBvKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjQgKiB0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBFID0gZCA/IFwiY2VudGVyXCIgOiBzLmdldChcInRleHQtanVzdGlmeVwiKS5ldmFsdWF0ZShhLCB7fSwgbyksXG4gICAgICAgICAgICAgIFAgPSBzLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksXG4gICAgICAgICAgICAgIE0gPSBcInBvaW50XCIgPT09IFAgPyAyNCAqIHMuZ2V0KFwidGV4dC1tYXgtd2lkdGhcIikuZXZhbHVhdGUoYSwge30sIG8pIDogMCxcbiAgICAgICAgICAgICAgQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0LmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgWG4oXykgJiYgKGYudmVydGljYWwgPSBrdShnLCBlLCByLCBpLCB1LCBNLCB5LCBJLCBcImxlZnRcIiwgaywgdywgX3UudmVydGljYWwsICEwLCBQLCBjLCBwKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWQgJiYgeikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBUID0gXCJhdXRvXCIgPT09IEUgPyB6Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsKHQpO1xuICAgICAgICAgICAgICAgIH0pIDogW0VdLCBWID0gITEsIEYgPSAwOyBGIDwgVC5sZW5ndGg7IEYrKykge1xuICAgICAgICAgICAgICAgIHZhciBEID0gVFtGXTtcbiAgICAgICAgICAgICAgICBpZiAoIWYuaG9yaXpvbnRhbFtEXSkgaWYgKFYpIGYuaG9yaXpvbnRhbFtEXSA9IGYuaG9yaXpvbnRhbFswXTtlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBMID0ga3UoZywgZSwgciwgaSwgdSwgTSwgeSwgXCJjZW50ZXJcIiwgRCwgaywgdywgX3UuaG9yaXpvbnRhbCwgITEsIFAsIGMsIHApO1xuICAgICAgICAgICAgICAgICAgTCAmJiAoZi5ob3Jpem9udGFsW0RdID0gTCwgViA9IDEgPT09IEwucG9zaXRpb25lZExpbmVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFwiYXV0b1wiID09PSBFICYmIChFID0gc2woSSkpO1xuICAgICAgICAgICAgICB2YXIgUiA9IGt1KGcsIGUsIHIsIGksIHUsIE0sIHksIEksIEUsIGssIHcsIF91Lmhvcml6b250YWwsICExLCBQLCBjLCBwKTtcbiAgICAgICAgICAgICAgUiAmJiAoZi5ob3Jpem9udGFsW0VdID0gUiksIEIoKSwgWG4oXykgJiYgZCAmJiBtICYmIChmLnZlcnRpY2FsID0ga3UoZywgZSwgciwgaSwgdSwgTSwgeSwgSSwgRSwgaywgdywgX3UudmVydGljYWwsICExLCBQLCBjLCBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBPID0gdm9pZCAwLFxuICAgICAgICAgICAgVSA9ICExO1xuICAgICAgICAgIGlmIChhLmljb24gJiYgYS5pY29uLm5hbWUpIHtcbiAgICAgICAgICAgIHZhciBqID0gblthLmljb24ubmFtZV07XG4gICAgICAgICAgICBqICYmIChPID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBUdShyKSxcbiAgICAgICAgICAgICAgICBpID0gZVswXSAtIHQuZGlzcGxheVNpemVbMF0gKiBuLmhvcml6b250YWxBbGlnbixcbiAgICAgICAgICAgICAgICBhID0gZVsxXSAtIHQuZGlzcGxheVNpemVbMV0gKiBuLnZlcnRpY2FsQWxpZ247XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHQsXG4gICAgICAgICAgICAgICAgdG9wOiBhLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogYSArIHQuZGlzcGxheVNpemVbMV0sXG4gICAgICAgICAgICAgICAgbGVmdDogaSxcbiAgICAgICAgICAgICAgICByaWdodDogaSArIHQuZGlzcGxheVNpemVbMF1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oaVthLmljb24ubmFtZV0sIHMuZ2V0KFwiaWNvbi1vZmZzZXRcIikuZXZhbHVhdGUoYSwge30sIG8pLCBzLmdldChcImljb24tYW5jaG9yXCIpLmV2YWx1YXRlKGEsIHt9LCBvKSksIFUgPSBqLnNkZiwgdm9pZCAwID09PSB0LnNkZkljb25zID8gdC5zZGZJY29ucyA9IGouc2RmIDogdC5zZGZJY29ucyAhPT0gai5zZGYgJiYgQShcIlN0eWxlIHNoZWV0IHdhcm5pbmc6IENhbm5vdCBtaXggU0RGIGFuZCBub24tU0RGIGljb25zIGluIG9uZSBidWZmZXJcIiksIChqLnBpeGVsUmF0aW8gIT09IHQucGl4ZWxSYXRpbyB8fCAwICE9PSBzLmdldChcImljb24tcm90YXRlXCIpLmNvbnN0YW50T3IoMSkpICYmICh0Lmljb25zTmVlZExpbmVhciA9ICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBxID0gbGwoZi5ob3Jpem9udGFsKSB8fCBmLnZlcnRpY2FsO1xuICAgICAgICAgIHQuaWNvbnNJblRleHQgPSAhIXEgJiYgcS5pY29uc0luVGV4dCwgKHEgfHwgTykgJiYgZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHApIHtcbiAgICAgICAgICAgIHZhciBjID0gYS50ZXh0TWF4U2l6ZS5ldmFsdWF0ZShlLCB7fSk7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGMgJiYgKGMgPSBvKTtcbiAgICAgICAgICAgIHZhciBoLFxuICAgICAgICAgICAgICBmID0gdC5sYXllcnNbMF0ubGF5b3V0LFxuICAgICAgICAgICAgICB5ID0gZi5nZXQoXCJpY29uLW9mZnNldFwiKS5ldmFsdWF0ZShlLCB7fSwgcCksXG4gICAgICAgICAgICAgIGQgPSBsbChyLmhvcml6b250YWwpLFxuICAgICAgICAgICAgICBtID0gbyAvIDI0LFxuICAgICAgICAgICAgICB2ID0gdC50aWxlUGl4ZWxSYXRpbyAqIG0sXG4gICAgICAgICAgICAgIGcgPSB0LnRpbGVQaXhlbFJhdGlvICogYyAvIDI0LFxuICAgICAgICAgICAgICB4ID0gdC50aWxlUGl4ZWxSYXRpbyAqIHMsXG4gICAgICAgICAgICAgIGIgPSB0LnRpbGVQaXhlbFJhdGlvICogZi5nZXQoXCJzeW1ib2wtc3BhY2luZ1wiKSxcbiAgICAgICAgICAgICAgdyA9IGYuZ2V0KFwidGV4dC1wYWRkaW5nXCIpICogdC50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgXyA9IGYuZ2V0KFwiaWNvbi1wYWRkaW5nXCIpICogdC50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgUyA9IGYuZ2V0KFwidGV4dC1tYXgtYW5nbGVcIikgLyAxODAgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICBrID0gXCJtYXBcIiA9PT0gZi5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSAmJiBcInBvaW50XCIgIT09IGYuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSxcbiAgICAgICAgICAgICAgSSA9IFwibWFwXCIgPT09IGYuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIikgJiYgXCJwb2ludFwiICE9PSBmLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksXG4gICAgICAgICAgICAgIHogPSBmLmdldChcInN5bWJvbC1wbGFjZW1lbnRcIiksXG4gICAgICAgICAgICAgIEMgPSBiIC8gMixcbiAgICAgICAgICAgICAgRSA9IGYuZ2V0KFwiaWNvbi10ZXh0LWZpdFwiKTtcbiAgICAgICAgICAgIG4gJiYgXCJub25lXCIgIT09IEUgJiYgKHQuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiByLnZlcnRpY2FsICYmIChoID0gRnUobiwgci52ZXJ0aWNhbCwgRSwgZi5nZXQoXCJpY29uLXRleHQtZml0LXBhZGRpbmdcIiksIHksIG0pKSwgZCAmJiAobiA9IEZ1KG4sIGQsIEUsIGYuZ2V0KFwiaWNvbi10ZXh0LWZpdC1wYWRkaW5nXCIpLCB5LCBtKSkpO1xuICAgICAgICAgICAgdmFyIFAgPSBmdW5jdGlvbiAocywgYykge1xuICAgICAgICAgICAgICBjLnggPCAwIHx8IGMueCA+PSA4MTkyIHx8IGMueSA8IDAgfHwgYy55ID49IDgxOTIgfHwgZnVuY3Rpb24gKHQsIGUsIHIsIG4sIGksIGEsIG8sIHMsIHUsIGwsIHAsIGMsIGgsIGYsIHksIGQsIG0sIHYsIGcsIHgsIGIsIHcsIF8sIFMsIGspIHtcbiAgICAgICAgICAgICAgICB2YXIgSSxcbiAgICAgICAgICAgICAgICAgIHosXG4gICAgICAgICAgICAgICAgICBDLFxuICAgICAgICAgICAgICAgICAgRSxcbiAgICAgICAgICAgICAgICAgIFAsXG4gICAgICAgICAgICAgICAgICBNID0gdC5hZGRUb0xpbmVWZXJ0ZXhBcnJheShlLCByKSxcbiAgICAgICAgICAgICAgICAgIEIgPSAwLFxuICAgICAgICAgICAgICAgICAgVCA9IDAsXG4gICAgICAgICAgICAgICAgICBWID0gMCxcbiAgICAgICAgICAgICAgICAgIEYgPSAwLFxuICAgICAgICAgICAgICAgICAgRCA9IC0xLFxuICAgICAgICAgICAgICAgICAgTCA9IC0xLFxuICAgICAgICAgICAgICAgICAgUiA9IHt9LFxuICAgICAgICAgICAgICAgICAgTyA9IGZhKFwiXCIpLFxuICAgICAgICAgICAgICAgICAgVSA9IDAsXG4gICAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBzLl91bmV2YWx1YXRlZExheW91dC5nZXRWYWx1ZShcInRleHQtcmFkaWFsLW9mZnNldFwiKSA/IChVID0gKEkgPSBzLmxheW91dC5nZXQoXCJ0ZXh0LW9mZnNldFwiKS5ldmFsdWF0ZShiLCB7fSwgUykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMjQgKiB0O1xuICAgICAgICAgICAgICAgIH0pKVswXSwgaiA9IElbMV0pIDogKFUgPSAyNCAqIHMubGF5b3V0LmdldChcInRleHQtcmFkaWFsLW9mZnNldFwiKS5ldmFsdWF0ZShiLCB7fSwgUyksIGogPSBhbCksIHQuYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiBuLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcSA9IHMubGF5b3V0LmdldChcInRleHQtcm90YXRlXCIpLmV2YWx1YXRlKGIsIHt9LCBTKSArIDkwO1xuICAgICAgICAgICAgICAgICAgRSA9IG5ldyBRdSh1LCBlLCBsLCBwLCBjLCBuLnZlcnRpY2FsLCBoLCBmLCB5LCBxKSwgbyAmJiAoUCA9IG5ldyBRdSh1LCBlLCBsLCBwLCBjLCBvLCBtLCB2LCB5LCBxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgTiA9IHMubGF5b3V0LmdldChcImljb24tcm90YXRlXCIpLmV2YWx1YXRlKGIsIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgSyA9IFwibm9uZVwiICE9PSBzLmxheW91dC5nZXQoXCJpY29uLXRleHQtZml0XCIpLFxuICAgICAgICAgICAgICAgICAgICBHID0gSnUoaSwgTiwgXywgSyksXG4gICAgICAgICAgICAgICAgICAgIFogPSBvID8gSnUobywgTiwgXywgSykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBDID0gbmV3IFF1KHUsIGUsIGwsIHAsIGMsIGksIG0sIHYsICExLCBOKSwgQiA9IDQgKiBHLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHZhciBYID0gdC5pY29uU2l6ZURhdGEsXG4gICAgICAgICAgICAgICAgICAgIEogPSBudWxsO1xuICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiA9PT0gWC5raW5kID8gKEogPSBbMTI4ICogcy5sYXlvdXQuZ2V0KFwiaWNvbi1zaXplXCIpLmV2YWx1YXRlKGIsIHt9KV0pWzBdID4gMzI2NDAgJiYgQSh0LmxheWVySWRzWzBdICsgJzogVmFsdWUgZm9yIFwiaWNvbi1zaXplXCIgaXMgPj0gMjU1LiBSZWR1Y2UgeW91ciBcImljb24tc2l6ZVwiLicpIDogXCJjb21wb3NpdGVcIiA9PT0gWC5raW5kICYmICgoSiA9IFsxMjggKiB3LmNvbXBvc2l0ZUljb25TaXplc1swXS5ldmFsdWF0ZShiLCB7fSwgUyksIDEyOCAqIHcuY29tcG9zaXRlSWNvblNpemVzWzFdLmV2YWx1YXRlKGIsIHt9LCBTKV0pWzBdID4gMzI2NDAgfHwgSlsxXSA+IDMyNjQwKSAmJiBBKHQubGF5ZXJJZHNbMF0gKyAnOiBWYWx1ZSBmb3IgXCJpY29uLXNpemVcIiBpcyA+PSAyNTUuIFJlZHVjZSB5b3VyIFwiaWNvbi1zaXplXCIuJyksIHQuYWRkU3ltYm9scyh0Lmljb24sIEcsIEosIHgsIGcsIGIsICExLCBlLCBNLmxpbmVTdGFydEluZGV4LCBNLmxpbmVMZW5ndGgsIC0xLCBTKSwgRCA9IHQuaWNvbi5wbGFjZWRTeW1ib2xBcnJheS5sZW5ndGggLSAxLCBaICYmIChUID0gNCAqIFoubGVuZ3RoLCB0LmFkZFN5bWJvbHModC5pY29uLCBaLCBKLCB4LCBnLCBiLCBfdS52ZXJ0aWNhbCwgZSwgTS5saW5lU3RhcnRJbmRleCwgTS5saW5lTGVuZ3RoLCAtMSwgUyksIEwgPSB0Lmljb24ucGxhY2VkU3ltYm9sQXJyYXkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIEggaW4gbi5ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgWSA9IG4uaG9yaXpvbnRhbFtIXTtcbiAgICAgICAgICAgICAgICAgIGlmICgheikge1xuICAgICAgICAgICAgICAgICAgICBPID0gZmEoWS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICQgPSBzLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0ZVwiKS5ldmFsdWF0ZShiLCB7fSwgUyk7XG4gICAgICAgICAgICAgICAgICAgIHogPSBuZXcgUXUodSwgZSwgbCwgcCwgYywgWSwgaCwgZiwgeSwgJCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgVyA9IDEgPT09IFkucG9zaXRpb25lZExpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChWICs9IHVsKHQsIGUsIFksIGEsIHMsIHksIGIsIGQsIE0sIG4udmVydGljYWwgPyBfdS5ob3Jpem9udGFsIDogX3UuaG9yaXpvbnRhbE9ubHksIFcgPyBPYmplY3Qua2V5cyhuLmhvcml6b250YWwpIDogW0hdLCBSLCBELCB3LCBTKSwgVykgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4udmVydGljYWwgJiYgKEYgKz0gdWwodCwgZSwgbi52ZXJ0aWNhbCwgYSwgcywgeSwgYiwgZCwgTSwgX3UudmVydGljYWwsIFtcInZlcnRpY2FsXCJdLCBSLCBMLCB3LCBTKSk7XG4gICAgICAgICAgICAgICAgdmFyIFEgPSB6ID8gei5ib3hTdGFydEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICB0dCA9IHogPyB6LmJveEVuZEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBldCA9IEUgPyBFLmJveFN0YXJ0SW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHJ0ID0gRSA/IEUuYm94RW5kSW5kZXggOiB0LmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIG50ID0gQyA/IEMuYm94U3RhcnRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgaXQgPSBDID8gQy5ib3hFbmRJbmRleCA6IHQuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgYXQgPSBQID8gUC5ib3hTdGFydEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBvdCA9IFAgPyBQLmJveEVuZEluZGV4IDogdC5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBzdCA9IC0xLFxuICAgICAgICAgICAgICAgICAgdXQgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAmJiB0LmNpcmNsZURpYW1ldGVyID8gTWF0aC5tYXgodC5jaXJjbGVEaWFtZXRlciwgZSkgOiBlO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdCA9IHV0KHosIHN0KSwgc3QgPSB1dChFLCBzdCksIHN0ID0gdXQoQywgc3QpO1xuICAgICAgICAgICAgICAgIHZhciBsdCA9IChzdCA9IHV0KFAsIHN0KSkgPiAtMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIGx0ICYmIChzdCAqPSBrIC8gMjQpLCB0LmdseXBoT2Zmc2V0QXJyYXkubGVuZ3RoID49IGdsLk1BWF9HTFlQSFMgJiYgQShcIlRvbyBtYW55IGdseXBocyBiZWluZyByZW5kZXJlZCBpbiBhIHRpbGUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMjkwN1wiKSwgdm9pZCAwICE9PSBiLnNvcnRLZXkgJiYgdC5hZGRUb1NvcnRLZXlSYW5nZXModC5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoLCBiLnNvcnRLZXkpLCB0LnN5bWJvbEluc3RhbmNlcy5lbXBsYWNlQmFjayhlLngsIGUueSwgUi5yaWdodCA+PSAwID8gUi5yaWdodCA6IC0xLCBSLmNlbnRlciA+PSAwID8gUi5jZW50ZXIgOiAtMSwgUi5sZWZ0ID49IDAgPyBSLmxlZnQgOiAtMSwgUi52ZXJ0aWNhbCB8fCAtMSwgRCwgTCwgTywgUSwgdHQsIGV0LCBydCwgbnQsIGl0LCBhdCwgb3QsIGwsIFYsIEYsIEIsIFQsIGx0LCAwLCBoLCBVLCBqLCBzdCk7XG4gICAgICAgICAgICAgIH0odCwgYywgcywgciwgbiwgaSwgaCwgdC5sYXllcnNbMF0sIHQuY29sbGlzaW9uQm94QXJyYXksIGUuaW5kZXgsIGUuc291cmNlTGF5ZXJJbmRleCwgdC5pbmRleCwgdiwgdywgaywgdSwgeCwgXywgSSwgeSwgZSwgYSwgbCwgcCwgbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKFwibGluZVwiID09PSB6KSBmb3IgKHZhciBNID0gMCwgQiA9IFh1KGUuZ2VvbWV0cnksIDAsIDAsIDgxOTIsIDgxOTIpOyBNIDwgQi5sZW5ndGg7IE0gKz0gMSkgZm9yICh2YXIgVCA9IEJbTV0sIFYgPSAwLCBGID0gWnUoVCwgYiwgUywgci52ZXJ0aWNhbCB8fCBkLCBuLCAyNCwgZywgdC5vdmVyc2NhbGluZywgODE5Mik7IFYgPCBGLmxlbmd0aDsgViArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBEID0gRltWXTtcbiAgICAgICAgICAgICAgZCAmJiBwbCh0LCBkLnRleHQsIEMsIEQpIHx8IFAoVCwgRCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwibGluZS1jZW50ZXJcIiA9PT0geikgZm9yICh2YXIgTCA9IDAsIFIgPSBlLmdlb21ldHJ5OyBMIDwgUi5sZW5ndGg7IEwgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgTyA9IFJbTF07XG4gICAgICAgICAgICAgIGlmIChPLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgVSA9IEd1KE8sIFMsIHIudmVydGljYWwgfHwgZCwgbiwgMjQsIGcpO1xuICAgICAgICAgICAgICAgIFUgJiYgUChPLCBVKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIlBvbHlnb25cIiA9PT0gZS50eXBlKSBmb3IgKHZhciBqID0gMCwgcSA9IGlzKGUuZ2VvbWV0cnksIDApOyBqIDwgcS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgTiA9IHFbal0sXG4gICAgICAgICAgICAgICAgSyA9IHJsKE4sIDE2KTtcbiAgICAgICAgICAgICAgUChOWzBdLCBuZXcgRHUoSy54LCBLLnksIDApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJMaW5lU3RyaW5nXCIgPT09IGUudHlwZSkgZm9yICh2YXIgRyA9IDAsIFogPSBlLmdlb21ldHJ5OyBHIDwgWi5sZW5ndGg7IEcgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgWCA9IFpbR107XG4gICAgICAgICAgICAgIFAoWCwgbmV3IER1KFhbMF0ueCwgWFswXS55LCAwKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiUG9pbnRcIiA9PT0gZS50eXBlKSBmb3IgKHZhciBKID0gMCwgSCA9IGUuZ2VvbWV0cnk7IEogPCBILmxlbmd0aDsgSiArPSAxKSBmb3IgKHZhciBZID0gMCwgJCA9IEhbSl07IFkgPCAkLmxlbmd0aDsgWSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBXID0gJFtZXTtcbiAgICAgICAgICAgICAgUChbV10sIG5ldyBEdShXLngsIFcueSwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0odCwgYSwgZiwgTywgbiwgbCwgYywgaCwgdywgVSwgbyk7XG4gICAgICAgIH0sIHggPSAwLCBiID0gdC5mZWF0dXJlczsgeCA8IGIubGVuZ3RoOyB4ICs9IDEpIGcoKTtcbiAgICAgIGEgJiYgdC5nZW5lcmF0ZUNvbGxpc2lvbkRlYnVnQnVmZmVycygpO1xuICAgIH0sIHQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkge1xuICAgICAgdmFyIGEsXG4gICAgICAgIG8gPSAxIC8gTWF0aC50YW4oZSAvIDIpO1xuICAgICAgcmV0dXJuIHRbMF0gPSBvIC8gciwgdFsxXSA9IDAsIHRbMl0gPSAwLCB0WzNdID0gMCwgdFs0XSA9IDAsIHRbNV0gPSBvLCB0WzZdID0gMCwgdFs3XSA9IDAsIHRbOF0gPSAwLCB0WzldID0gMCwgdFsxMV0gPSAtMSwgdFsxMl0gPSAwLCB0WzEzXSA9IDAsIHRbMTVdID0gMCwgbnVsbCAhPSBpICYmIGkgIT09IDEgLyAwID8gKHRbMTBdID0gKGkgKyBuKSAqIChhID0gMSAvIChuIC0gaSkpLCB0WzE0XSA9IDIgKiBpICogbiAqIGEpIDogKHRbMTBdID0gLTEsIHRbMTRdID0gLTIgKiBuKSwgdDtcbiAgICB9LCB0LnBpY2sgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgZm9yICh2YXIgciA9IHt9LCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgdmFyIGkgPSBlW25dO1xuICAgICAgICBpIGluIHQgJiYgKHJbaV0gPSB0W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0sIHQucGx1Z2luID0gc2ksIHQucG9seWdvbkludGVyc2VjdHNQb2x5Z29uID0gS2EsIHQucG9zdE1hcExvYWRFdmVudCA9IG90LCB0LnBvc3RUdXJuc3RpbGVFdmVudCA9IGl0LCB0LnBvdHBhY2sgPSBndSwgdC5yZWZQcm9wZXJ0aWVzID0gW1widHlwZVwiLCBcInNvdXJjZVwiLCBcInNvdXJjZS1sYXllclwiLCBcIm1pbnpvb21cIiwgXCJtYXh6b29tXCIsIFwiZmlsdGVyXCIsIFwibGF5b3V0XCJdLCB0LnJlZ2lzdGVyID0gT24sIHQucmVnaXN0ZXJGb3JQbHVnaW5TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCh7XG4gICAgICAgIHBsdWdpblN0YXR1czogdGksXG4gICAgICAgIHBsdWdpblVSTDogZWlcbiAgICAgIH0pLCBpaS5vbihcInBsdWdpblN0YXRlQ2hhbmdlXCIsIHQpLCB0O1xuICAgIH0sIHQucmVuZGVyQ29sb3JSYW1wID0gX28sIHQucm90YXRlID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHZhciBuID0gZVswXSxcbiAgICAgICAgaSA9IGVbMV0sXG4gICAgICAgIGEgPSBlWzJdLFxuICAgICAgICBvID0gZVszXSxcbiAgICAgICAgcyA9IE1hdGguc2luKHIpLFxuICAgICAgICB1ID0gTWF0aC5jb3Mocik7XG4gICAgICByZXR1cm4gdFswXSA9IG4gKiB1ICsgYSAqIHMsIHRbMV0gPSBpICogdSArIG8gKiBzLCB0WzJdID0gbiAqIC1zICsgYSAqIHUsIHRbM10gPSBpICogLXMgKyBvICogdSwgdDtcbiAgICB9LCB0LnJvdGF0ZVggPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBNYXRoLnNpbihyKSxcbiAgICAgICAgaSA9IE1hdGguY29zKHIpLFxuICAgICAgICBhID0gZVs0XSxcbiAgICAgICAgbyA9IGVbNV0sXG4gICAgICAgIHMgPSBlWzZdLFxuICAgICAgICB1ID0gZVs3XSxcbiAgICAgICAgbCA9IGVbOF0sXG4gICAgICAgIHAgPSBlWzldLFxuICAgICAgICBjID0gZVsxMF0sXG4gICAgICAgIGggPSBlWzExXTtcbiAgICAgIHJldHVybiBlICE9PSB0ICYmICh0WzBdID0gZVswXSwgdFsxXSA9IGVbMV0sIHRbMl0gPSBlWzJdLCB0WzNdID0gZVszXSwgdFsxMl0gPSBlWzEyXSwgdFsxM10gPSBlWzEzXSwgdFsxNF0gPSBlWzE0XSwgdFsxNV0gPSBlWzE1XSksIHRbNF0gPSBhICogaSArIGwgKiBuLCB0WzVdID0gbyAqIGkgKyBwICogbiwgdFs2XSA9IHMgKiBpICsgYyAqIG4sIHRbN10gPSB1ICogaSArIGggKiBuLCB0WzhdID0gbCAqIGkgLSBhICogbiwgdFs5XSA9IHAgKiBpIC0gbyAqIG4sIHRbMTBdID0gYyAqIGkgLSBzICogbiwgdFsxMV0gPSBoICogaSAtIHUgKiBuLCB0O1xuICAgIH0sIHQucm90YXRlWiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IE1hdGguc2luKHIpLFxuICAgICAgICBpID0gTWF0aC5jb3MociksXG4gICAgICAgIGEgPSBlWzBdLFxuICAgICAgICBvID0gZVsxXSxcbiAgICAgICAgcyA9IGVbMl0sXG4gICAgICAgIHUgPSBlWzNdLFxuICAgICAgICBsID0gZVs0XSxcbiAgICAgICAgcCA9IGVbNV0sXG4gICAgICAgIGMgPSBlWzZdLFxuICAgICAgICBoID0gZVs3XTtcbiAgICAgIHJldHVybiBlICE9PSB0ICYmICh0WzhdID0gZVs4XSwgdFs5XSA9IGVbOV0sIHRbMTBdID0gZVsxMF0sIHRbMTFdID0gZVsxMV0sIHRbMTJdID0gZVsxMl0sIHRbMTNdID0gZVsxM10sIHRbMTRdID0gZVsxNF0sIHRbMTVdID0gZVsxNV0pLCB0WzBdID0gYSAqIGkgKyBsICogbiwgdFsxXSA9IG8gKiBpICsgcCAqIG4sIHRbMl0gPSBzICogaSArIGMgKiBuLCB0WzNdID0gdSAqIGkgKyBoICogbiwgdFs0XSA9IGwgKiBpIC0gYSAqIG4sIHRbNV0gPSBwICogaSAtIG8gKiBuLCB0WzZdID0gYyAqIGkgLSBzICogbiwgdFs3XSA9IGggKiBpIC0gdSAqIG4sIHQ7XG4gICAgfSwgdC5zY2FsZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICB2YXIgbiA9IHJbMF0sXG4gICAgICAgIGkgPSByWzFdLFxuICAgICAgICBhID0gclsyXTtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSAqIG4sIHRbMV0gPSBlWzFdICogbiwgdFsyXSA9IGVbMl0gKiBuLCB0WzNdID0gZVszXSAqIG4sIHRbNF0gPSBlWzRdICogaSwgdFs1XSA9IGVbNV0gKiBpLCB0WzZdID0gZVs2XSAqIGksIHRbN10gPSBlWzddICogaSwgdFs4XSA9IGVbOF0gKiBhLCB0WzldID0gZVs5XSAqIGEsIHRbMTBdID0gZVsxMF0gKiBhLCB0WzExXSA9IGVbMTFdICogYSwgdFsxMl0gPSBlWzEyXSwgdFsxM10gPSBlWzEzXSwgdFsxNF0gPSBlWzE0XSwgdFsxNV0gPSBlWzE1XSwgdDtcbiAgICB9LCB0LnNjYWxlJDEgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRbMF0gPSBlWzBdICogciwgdFsxXSA9IGVbMV0gKiByLCB0WzJdID0gZVsyXSAqIHIsIHRbM10gPSBlWzNdICogciwgdDtcbiAgICB9LCB0LnNjYWxlJDIgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgcmV0dXJuIHRbMF0gPSBlWzBdICogciwgdFsxXSA9IGVbMV0gKiByLCB0WzJdID0gZVsyXSAqIHIsIHQ7XG4gICAgfSwgdC5zZXRDYWNoZUxpbWl0cyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBzdCA9IHQsIHV0ID0gZTtcbiAgICB9LCB0LnNldFJUTFRleHRQbHVnaW4gPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gciAmJiAociA9ICExKSwgXCJkZWZlcnJlZFwiID09PSB0aSB8fCBcImxvYWRpbmdcIiA9PT0gdGkgfHwgXCJsb2FkZWRcIiA9PT0gdGkpIHRocm93IG5ldyBFcnJvcihcInNldFJUTFRleHRQbHVnaW4gY2Fubm90IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cIik7XG4gICAgICBlaSA9IFIucmVzb2x2ZVVSTCh0KSwgdGkgPSBcImRlZmVycmVkXCIsIFFuID0gZSwgbmkoKSwgciB8fCBvaSgpO1xuICAgIH0sIHQuc3BoZXJpY2FsVG9DYXJ0ZXNpYW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0WzBdLFxuICAgICAgICByID0gdFsxXSxcbiAgICAgICAgbiA9IHRbMl07XG4gICAgICByZXR1cm4gciArPSA5MCwgciAqPSBNYXRoLlBJIC8gMTgwLCBuICo9IE1hdGguUEkgLyAxODAsIHtcbiAgICAgICAgeDogZSAqIE1hdGguY29zKHIpICogTWF0aC5zaW4obiksXG4gICAgICAgIHk6IGUgKiBNYXRoLnNpbihyKSAqIE1hdGguc2luKG4pLFxuICAgICAgICB6OiBlICogTWF0aC5jb3MobilcbiAgICAgIH07XG4gICAgfSwgdC5zcXJMZW4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0WzBdLFxuICAgICAgICByID0gdFsxXTtcbiAgICAgIHJldHVybiBlICogZSArIHIgKiByO1xuICAgIH0sIHQuc3R5bGVTcGVjID0gUHQsIHQuc3ViID0gZnVuY3Rpb24gKHQsIGUsIHIpIHtcbiAgICAgIHJldHVybiB0WzBdID0gZVswXSAtIHJbMF0sIHRbMV0gPSBlWzFdIC0gclsxXSwgdFsyXSA9IGVbMl0gLSByWzJdLCB0O1xuICAgIH0sIHQuc3ltYm9sU2l6ZSA9IFV1LCB0LnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4gPSBlWzBdLFxuICAgICAgICBpID0gZVsxXSxcbiAgICAgICAgYSA9IGVbMl07XG4gICAgICByZXR1cm4gdFswXSA9IG4gKiByWzBdICsgaSAqIHJbM10gKyBhICogcls2XSwgdFsxXSA9IG4gKiByWzFdICsgaSAqIHJbNF0gKyBhICogcls3XSwgdFsyXSA9IG4gKiByWzJdICsgaSAqIHJbNV0gKyBhICogcls4XSwgdDtcbiAgICB9LCB0LnRyYW5zZm9ybU1hdDQgPSBjbywgdC50cmFuc2xhdGUgPSBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdmFyIG4sXG4gICAgICAgIGksXG4gICAgICAgIGEsXG4gICAgICAgIG8sXG4gICAgICAgIHMsXG4gICAgICAgIHUsXG4gICAgICAgIGwsXG4gICAgICAgIHAsXG4gICAgICAgIGMsXG4gICAgICAgIGgsXG4gICAgICAgIGYsXG4gICAgICAgIHksXG4gICAgICAgIGQgPSByWzBdLFxuICAgICAgICBtID0gclsxXSxcbiAgICAgICAgdiA9IHJbMl07XG4gICAgICByZXR1cm4gZSA9PT0gdCA/ICh0WzEyXSA9IGVbMF0gKiBkICsgZVs0XSAqIG0gKyBlWzhdICogdiArIGVbMTJdLCB0WzEzXSA9IGVbMV0gKiBkICsgZVs1XSAqIG0gKyBlWzldICogdiArIGVbMTNdLCB0WzE0XSA9IGVbMl0gKiBkICsgZVs2XSAqIG0gKyBlWzEwXSAqIHYgKyBlWzE0XSwgdFsxNV0gPSBlWzNdICogZCArIGVbN10gKiBtICsgZVsxMV0gKiB2ICsgZVsxNV0pIDogKGkgPSBlWzFdLCBhID0gZVsyXSwgbyA9IGVbM10sIHMgPSBlWzRdLCB1ID0gZVs1XSwgbCA9IGVbNl0sIHAgPSBlWzddLCBjID0gZVs4XSwgaCA9IGVbOV0sIGYgPSBlWzEwXSwgeSA9IGVbMTFdLCB0WzBdID0gbiA9IGVbMF0sIHRbMV0gPSBpLCB0WzJdID0gYSwgdFszXSA9IG8sIHRbNF0gPSBzLCB0WzVdID0gdSwgdFs2XSA9IGwsIHRbN10gPSBwLCB0WzhdID0gYywgdFs5XSA9IGgsIHRbMTBdID0gZiwgdFsxMV0gPSB5LCB0WzEyXSA9IG4gKiBkICsgcyAqIG0gKyBjICogdiArIGVbMTJdLCB0WzEzXSA9IGkgKiBkICsgdSAqIG0gKyBoICogdiArIGVbMTNdLCB0WzE0XSA9IGEgKiBkICsgbCAqIG0gKyBmICogdiArIGVbMTRdLCB0WzE1XSA9IG8gKiBkICsgcCAqIG0gKyB5ICogdiArIGVbMTVdKSwgdDtcbiAgICB9LCB0LnRyaWdnZXJQbHVnaW5Db21wbGV0aW9uRXZlbnQgPSByaSwgdC51bmlxdWVJZCA9IHksIHQudmFsaWRhdGVDdXN0b21TdHlsZUxheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gW10sXG4gICAgICAgIHIgPSB0LmlkO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gciAmJiBlLnB1c2goe1xuICAgICAgICBtZXNzYWdlOiBcImxheWVycy5cIiArIHIgKyAnOiBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwiaWRcIidcbiAgICAgIH0pLCB2b2lkIDAgPT09IHQucmVuZGVyICYmIGUucHVzaCh7XG4gICAgICAgIG1lc3NhZ2U6IFwibGF5ZXJzLlwiICsgciArICc6IG1pc3NpbmcgcmVxdWlyZWQgbWV0aG9kIFwicmVuZGVyXCInXG4gICAgICB9KSwgdC5yZW5kZXJpbmdNb2RlICYmIFwiMmRcIiAhPT0gdC5yZW5kZXJpbmdNb2RlICYmIFwiM2RcIiAhPT0gdC5yZW5kZXJpbmdNb2RlICYmIGUucHVzaCh7XG4gICAgICAgIG1lc3NhZ2U6IFwibGF5ZXJzLlwiICsgciArICc6IHByb3BlcnR5IFwicmVuZGVyaW5nTW9kZVwiIG11c3QgYmUgZWl0aGVyIFwiMmRcIiBvciBcIjNkXCInXG4gICAgICB9KSwgZTtcbiAgICB9LCB0LnZhbGlkYXRlTGlnaHQgPSBQbiwgdC52YWxpZGF0ZVN0eWxlID0gRW4sIHQudmFsdWVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gW107XG4gICAgICBmb3IgKHZhciByIGluIHQpIGUucHVzaCh0W3JdKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH0sIHQudmVjdG9yVGlsZSA9IHdzLCB0LnZlcnNpb24gPSBcIjEuMTUuM1wiLCB0Lndhcm5PbmNlID0gQSwgdC53ZWJwU3VwcG9ydGVkID0gVSwgdC53aW5kb3cgPSBvLCB0LndyYXAgPSBjO1xuICB9KTtcbiAgZGVmaW5lKFtcIi4vc2hhcmVkXCJdLCBmdW5jdGlvbiAoZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gdChlKSB7XG4gICAgICB2YXIgciA9IHR5cGVvZiBlO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHIgfHwgXCJib29sZWFuXCIgPT09IHIgfHwgXCJzdHJpbmdcIiA9PT0gciB8fCBudWxsID09IGUpIHJldHVybiBKU09OLnN0cmluZ2lmeShlKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBcIltcIiwgbyA9IDAsIG4gPSBlOyBvIDwgbi5sZW5ndGg7IG8gKz0gMSkgaSArPSB0KG5bb10pICsgXCIsXCI7XG4gICAgICAgIHJldHVybiBpICsgXCJdXCI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBzID0gT2JqZWN0LmtleXMoZSkuc29ydCgpLCBhID0gXCJ7XCIsIGwgPSAwOyBsIDwgcy5sZW5ndGg7IGwrKykgYSArPSBKU09OLnN0cmluZ2lmeShzW2xdKSArIFwiOlwiICsgdChlW3NbbF1dKSArIFwiLFwiO1xuICAgICAgcmV0dXJuIGEgKyBcIn1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcihyKSB7XG4gICAgICBmb3IgKHZhciBpID0gXCJcIiwgbyA9IDAsIG4gPSBlLnJlZlByb3BlcnRpZXM7IG8gPCBuLmxlbmd0aDsgbyArPSAxKSBpICs9IFwiL1wiICsgdChyW25bb11dKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB2YXIgaSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLmtleUNhY2hlID0ge30sIGUgJiYgdGhpcy5yZXBsYWNlKGUpO1xuICAgIH07XG4gICAgaS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9sYXllckNvbmZpZ3MgPSB7fSwgdGhpcy5fbGF5ZXJzID0ge30sIHRoaXMudXBkYXRlKGUsIFtdKTtcbiAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodCwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IHRoaXMsIG4gPSAwLCBzID0gdDsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBzW25dO1xuICAgICAgICB0aGlzLl9sYXllckNvbmZpZ3NbYS5pZF0gPSBhO1xuICAgICAgICB2YXIgbCA9IHRoaXMuX2xheWVyc1thLmlkXSA9IGUuY3JlYXRlU3R5bGVMYXllcihhKTtcbiAgICAgICAgbC5fZmVhdHVyZUZpbHRlciA9IGUuZmVhdHVyZUZpbHRlcihsLmZpbHRlciksIHRoaXMua2V5Q2FjaGVbYS5pZF0gJiYgZGVsZXRlIHRoaXMua2V5Q2FjaGVbYS5pZF07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB1ID0gMCwgaCA9IGk7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gaFt1XTtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5Q2FjaGVbY10sIGRlbGV0ZSB0aGlzLl9sYXllckNvbmZpZ3NbY10sIGRlbGV0ZSB0aGlzLl9sYXllcnNbY107XG4gICAgICB9XG4gICAgICB0aGlzLmZhbWlsaWVzQnlTb3VyY2UgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgPSAwLCBmID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0ge30sIG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgdmFyIG4gPSB0ICYmIHRbZVtvXS5pZF0gfHwgcihlW29dKTtcbiAgICAgICAgICAgIHQgJiYgKHRbZVtvXS5pZF0gPSBuKTtcbiAgICAgICAgICAgIHZhciBzID0gaVtuXTtcbiAgICAgICAgICAgIHMgfHwgKHMgPSBpW25dID0gW10pLCBzLnB1c2goZVtvXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBpKSBhLnB1c2goaVtsXSk7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0oZS52YWx1ZXModGhpcy5fbGF5ZXJDb25maWdzKSwgdGhpcy5rZXlDYWNoZSk7IHAgPCBmLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgIHZhciBkID0gZltwXS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvLl9sYXllcnNbZS5pZF07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZyA9IGRbMF07XG4gICAgICAgIGlmIChcIm5vbmVcIiAhPT0gZy52aXNpYmlsaXR5KSB7XG4gICAgICAgICAgdmFyIHYgPSBnLnNvdXJjZSB8fCBcIlwiLFxuICAgICAgICAgICAgbSA9IHRoaXMuZmFtaWxpZXNCeVNvdXJjZVt2XTtcbiAgICAgICAgICBtIHx8IChtID0gdGhpcy5mYW1pbGllc0J5U291cmNlW3ZdID0ge30pO1xuICAgICAgICAgIHZhciB5ID0gZy5zb3VyY2VMYXllciB8fCBcIl9nZW9qc29uVGlsZUxheWVyXCIsXG4gICAgICAgICAgICB4ID0gbVt5XTtcbiAgICAgICAgICB4IHx8ICh4ID0gbVt5XSA9IFtdKSwgeC5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgciA9IHt9LFxuICAgICAgICBpID0gW107XG4gICAgICBmb3IgKHZhciBvIGluIHQpIHtcbiAgICAgICAgdmFyIG4gPSB0W29dLFxuICAgICAgICAgIHMgPSByW29dID0ge307XG4gICAgICAgIGZvciAodmFyIGEgaW4gbikge1xuICAgICAgICAgIHZhciBsID0gblsrYV07XG4gICAgICAgICAgaWYgKGwgJiYgMCAhPT0gbC5iaXRtYXAud2lkdGggJiYgMCAhPT0gbC5iaXRtYXAuaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgdSA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgdzogbC5iaXRtYXAud2lkdGggKyAyLFxuICAgICAgICAgICAgICBoOiBsLmJpdG1hcC5oZWlnaHQgKyAyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaS5wdXNoKHUpLCBzW2FdID0ge1xuICAgICAgICAgICAgICByZWN0OiB1LFxuICAgICAgICAgICAgICBtZXRyaWNzOiBsLm1ldHJpY3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaCA9IGUucG90cGFjayhpKSxcbiAgICAgICAgYyA9IG5ldyBlLkFscGhhSW1hZ2Uoe1xuICAgICAgICAgIHdpZHRoOiBoLncgfHwgMSxcbiAgICAgICAgICBoZWlnaHQ6IGguaCB8fCAxXG4gICAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgcCBpbiB0KSB7XG4gICAgICAgIHZhciBmID0gdFtwXTtcbiAgICAgICAgZm9yICh2YXIgZCBpbiBmKSB7XG4gICAgICAgICAgdmFyIGcgPSBmWytkXTtcbiAgICAgICAgICBpZiAoZyAmJiAwICE9PSBnLmJpdG1hcC53aWR0aCAmJiAwICE9PSBnLmJpdG1hcC5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciB2ID0gcltwXVtkXS5yZWN0O1xuICAgICAgICAgICAgZS5BbHBoYUltYWdlLmNvcHkoZy5iaXRtYXAsIGMsIHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB4OiB2LnggKyAxLFxuICAgICAgICAgICAgICB5OiB2LnkgKyAxXG4gICAgICAgICAgICB9LCBnLmJpdG1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmltYWdlID0gYywgdGhpcy5wb3NpdGlvbnMgPSByO1xuICAgIH07XG4gICAgZS5yZWdpc3RlcihcIkdseXBoQXRsYXNcIiwgbyk7XG4gICAgdmFyIG4gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy50aWxlSUQgPSBuZXcgZS5PdmVyc2NhbGVkVGlsZUlEKHQudGlsZUlELm92ZXJzY2FsZWRaLCB0LnRpbGVJRC53cmFwLCB0LnRpbGVJRC5jYW5vbmljYWwueiwgdC50aWxlSUQuY2Fub25pY2FsLngsIHQudGlsZUlELmNhbm9uaWNhbC55KSwgdGhpcy51aWQgPSB0LnVpZCwgdGhpcy56b29tID0gdC56b29tLCB0aGlzLnBpeGVsUmF0aW8gPSB0LnBpeGVsUmF0aW8sIHRoaXMudGlsZVNpemUgPSB0LnRpbGVTaXplLCB0aGlzLnNvdXJjZSA9IHQuc291cmNlLCB0aGlzLm92ZXJzY2FsaW5nID0gdGhpcy50aWxlSUQub3ZlcnNjYWxlRmFjdG9yKCksIHRoaXMuc2hvd0NvbGxpc2lvbkJveGVzID0gdC5zaG93Q29sbGlzaW9uQm94ZXMsIHRoaXMuY29sbGVjdFJlc291cmNlVGltaW5nID0gISF0LmNvbGxlY3RSZXNvdXJjZVRpbWluZywgdGhpcy5yZXR1cm5EZXBlbmRlbmNpZXMgPSAhIXQucmV0dXJuRGVwZW5kZW5jaWVzLCB0aGlzLnByb21vdGVJZCA9IHQucHJvbW90ZUlkO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcyh0LCByLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gbmV3IGUuRXZhbHVhdGlvblBhcmFtZXRlcnMociksIG4gPSAwLCBzID0gdDsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHNbbl0ucmVjYWxjdWxhdGUobywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEodCwgcikge1xuICAgICAgdmFyIGkgPSBlLmdldEFycmF5QnVmZmVyKHQucmVxdWVzdCwgZnVuY3Rpb24gKHQsIGksIG8sIG4pIHtcbiAgICAgICAgdCA/IHIodCkgOiBpICYmIHIobnVsbCwge1xuICAgICAgICAgIHZlY3RvclRpbGU6IG5ldyBlLnZlY3RvclRpbGUuVmVjdG9yVGlsZShuZXcgZS5wYmYoaSkpLFxuICAgICAgICAgIHJhd0RhdGE6IGksXG4gICAgICAgICAgY2FjaGVDb250cm9sOiBvLFxuICAgICAgICAgIGV4cGlyZXM6IG5cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGkuY2FuY2VsKCksIHIoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIG4ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHQsIHIsIGksIG4sIGEpIHtcbiAgICAgIHZhciBsID0gdGhpcztcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJwYXJzaW5nXCIsIHRoaXMuZGF0YSA9IHQsIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBuZXcgZS5Db2xsaXNpb25Cb3hBcnJheSgpO1xuICAgICAgdmFyIHUgPSBuZXcgZS5EaWN0aW9uYXJ5Q29kZXIoT2JqZWN0LmtleXModC5sYXllcnMpLnNvcnQoKSksXG4gICAgICAgIGggPSBuZXcgZS5GZWF0dXJlSW5kZXgodGhpcy50aWxlSUQsIHRoaXMucHJvbW90ZUlkKTtcbiAgICAgIGguYnVja2V0TGF5ZXJJRHMgPSBbXTtcbiAgICAgIHZhciBjLFxuICAgICAgICBwLFxuICAgICAgICBmLFxuICAgICAgICBkLFxuICAgICAgICBnID0ge30sXG4gICAgICAgIHYgPSB7XG4gICAgICAgICAgZmVhdHVyZUluZGV4OiBoLFxuICAgICAgICAgIGljb25EZXBlbmRlbmNpZXM6IHt9LFxuICAgICAgICAgIHBhdHRlcm5EZXBlbmRlbmNpZXM6IHt9LFxuICAgICAgICAgIGdseXBoRGVwZW5kZW5jaWVzOiB7fSxcbiAgICAgICAgICBhdmFpbGFibGVJbWFnZXM6IGlcbiAgICAgICAgfSxcbiAgICAgICAgbSA9IHIuZmFtaWxpZXNCeVNvdXJjZVt0aGlzLnNvdXJjZV07XG4gICAgICBmb3IgKHZhciB5IGluIG0pIHtcbiAgICAgICAgdmFyIHggPSB0LmxheWVyc1t5XTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAxID09PSB4LnZlcnNpb24gJiYgZS53YXJuT25jZSgnVmVjdG9yIHRpbGUgc291cmNlIFwiJyArIHRoaXMuc291cmNlICsgJ1wiIGxheWVyIFwiJyArIHkgKyAnXCIgZG9lcyBub3QgdXNlIHZlY3RvciB0aWxlIHNwZWMgdjIgYW5kIHRoZXJlZm9yZSBtYXkgaGF2ZSBzb21lIHJlbmRlcmluZyBlcnJvcnMuJyk7XG4gICAgICAgICAgZm9yICh2YXIgdyA9IHUuZW5jb2RlKHkpLCBTID0gW10sIEkgPSAwOyBJIDwgeC5sZW5ndGg7IEkrKykge1xuICAgICAgICAgICAgdmFyIE0gPSB4LmZlYXR1cmUoSSksXG4gICAgICAgICAgICAgIGIgPSBoLmdldElkKE0sIHkpO1xuICAgICAgICAgICAgUy5wdXNoKHtcbiAgICAgICAgICAgICAgZmVhdHVyZTogTSxcbiAgICAgICAgICAgICAgaWQ6IGIsXG4gICAgICAgICAgICAgIGluZGV4OiBJLFxuICAgICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiB3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgXyA9IDAsIGsgPSBtW3ldOyBfIDwgay5sZW5ndGg7IF8gKz0gMSkge1xuICAgICAgICAgICAgdmFyIFAgPSBrW19dLFxuICAgICAgICAgICAgICBUID0gUFswXTtcbiAgICAgICAgICAgIFQubWluem9vbSAmJiB0aGlzLnpvb20gPCBNYXRoLmZsb29yKFQubWluem9vbSkgfHwgVC5tYXh6b29tICYmIHRoaXMuem9vbSA+PSBULm1heHpvb20gfHwgXCJub25lXCIgIT09IFQudmlzaWJpbGl0eSAmJiAocyhQLCB0aGlzLnpvb20sIGkpLCAoZ1tULmlkXSA9IFQuY3JlYXRlQnVja2V0KHtcbiAgICAgICAgICAgICAgaW5kZXg6IGguYnVja2V0TGF5ZXJJRHMubGVuZ3RoLFxuICAgICAgICAgICAgICBsYXllcnM6IFAsXG4gICAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICBvdmVyc2NhbGluZzogdGhpcy5vdmVyc2NhbGluZyxcbiAgICAgICAgICAgICAgY29sbGlzaW9uQm94QXJyYXk6IHRoaXMuY29sbGlzaW9uQm94QXJyYXksXG4gICAgICAgICAgICAgIHNvdXJjZUxheWVySW5kZXg6IHcsXG4gICAgICAgICAgICAgIHNvdXJjZUlEOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgfSkpLnBvcHVsYXRlKFMsIHYsIHRoaXMudGlsZUlELmNhbm9uaWNhbCksIGguYnVja2V0TGF5ZXJJRHMucHVzaChQLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZS5pZDtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgQyA9IGUubWFwT2JqZWN0KHYuZ2x5cGhEZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5tYXAoTnVtYmVyKTtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXMoQykubGVuZ3RoID8gbi5zZW5kKFwiZ2V0R2x5cGhzXCIsIHtcbiAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgc3RhY2tzOiBDXG4gICAgICB9LCBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBjIHx8IChjID0gZSwgcCA9IHQsIHouY2FsbChsKSk7XG4gICAgICB9KSA6IHAgPSB7fTtcbiAgICAgIHZhciBEID0gT2JqZWN0LmtleXModi5pY29uRGVwZW5kZW5jaWVzKTtcbiAgICAgIEQubGVuZ3RoID8gbi5zZW5kKFwiZ2V0SW1hZ2VzXCIsIHtcbiAgICAgICAgaWNvbnM6IEQsXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHRpbGVJRDogdGhpcy50aWxlSUQsXG4gICAgICAgIHR5cGU6IFwiaWNvbnNcIlxuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYyB8fCAoYyA9IGUsIGYgPSB0LCB6LmNhbGwobCkpO1xuICAgICAgfSkgOiBmID0ge307XG4gICAgICB2YXIgTCA9IE9iamVjdC5rZXlzKHYucGF0dGVybkRlcGVuZGVuY2llcyk7XG4gICAgICBmdW5jdGlvbiB6KCkge1xuICAgICAgICBpZiAoYykgcmV0dXJuIGEoYyk7XG4gICAgICAgIGlmIChwICYmIGYgJiYgZCkge1xuICAgICAgICAgIHZhciB0ID0gbmV3IG8ocCksXG4gICAgICAgICAgICByID0gbmV3IGUuSW1hZ2VBdGxhcyhmLCBkKTtcbiAgICAgICAgICBmb3IgKHZhciBuIGluIGcpIHtcbiAgICAgICAgICAgIHZhciBsID0gZ1tuXTtcbiAgICAgICAgICAgIGwgaW5zdGFuY2VvZiBlLlN5bWJvbEJ1Y2tldCA/IChzKGwubGF5ZXJzLCB0aGlzLnpvb20sIGkpLCBlLnBlcmZvcm1TeW1ib2xMYXlvdXQobCwgcCwgdC5wb3NpdGlvbnMsIGYsIHIuaWNvblBvc2l0aW9ucywgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMsIHRoaXMudGlsZUlELmNhbm9uaWNhbCkpIDogbC5oYXNQYXR0ZXJuICYmIChsIGluc3RhbmNlb2YgZS5MaW5lQnVja2V0IHx8IGwgaW5zdGFuY2VvZiBlLkZpbGxCdWNrZXQgfHwgbCBpbnN0YW5jZW9mIGUuRmlsbEV4dHJ1c2lvbkJ1Y2tldCkgJiYgKHMobC5sYXllcnMsIHRoaXMuem9vbSwgaSksIGwuYWRkRmVhdHVyZXModiwgdGhpcy50aWxlSUQuY2Fub25pY2FsLCByLnBhdHRlcm5Qb3NpdGlvbnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcImRvbmVcIiwgYShudWxsLCB7XG4gICAgICAgICAgICBidWNrZXRzOiBlLnZhbHVlcyhnKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFlLmlzRW1wdHkoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmVhdHVyZUluZGV4OiBoLFxuICAgICAgICAgICAgY29sbGlzaW9uQm94QXJyYXk6IHRoaXMuY29sbGlzaW9uQm94QXJyYXksXG4gICAgICAgICAgICBnbHlwaEF0bGFzSW1hZ2U6IHQuaW1hZ2UsXG4gICAgICAgICAgICBpbWFnZUF0bGFzOiByLFxuICAgICAgICAgICAgZ2x5cGhNYXA6IHRoaXMucmV0dXJuRGVwZW5kZW5jaWVzID8gcCA6IG51bGwsXG4gICAgICAgICAgICBpY29uTWFwOiB0aGlzLnJldHVybkRlcGVuZGVuY2llcyA/IGYgOiBudWxsLFxuICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnM6IHRoaXMucmV0dXJuRGVwZW5kZW5jaWVzID8gdC5wb3NpdGlvbnMgOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEwubGVuZ3RoID8gbi5zZW5kKFwiZ2V0SW1hZ2VzXCIsIHtcbiAgICAgICAgaWNvbnM6IEwsXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHRpbGVJRDogdGhpcy50aWxlSUQsXG4gICAgICAgIHR5cGU6IFwicGF0dGVybnNcIlxuICAgICAgfSwgZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgYyB8fCAoYyA9IGUsIGQgPSB0LCB6LmNhbGwobCkpO1xuICAgICAgfSkgOiBkID0ge30sIHouY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHZhciBsID0gZnVuY3Rpb24gKGUsIHQsIHIsIGkpIHtcbiAgICAgIHRoaXMuYWN0b3IgPSBlLCB0aGlzLmxheWVySW5kZXggPSB0LCB0aGlzLmF2YWlsYWJsZUltYWdlcyA9IHIsIHRoaXMubG9hZFZlY3RvckRhdGEgPSBpIHx8IGEsIHRoaXMubG9hZGluZyA9IHt9LCB0aGlzLmxvYWRlZCA9IHt9O1xuICAgIH07XG4gICAgbC5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgcikge1xuICAgICAgdmFyIGkgPSB0aGlzLFxuICAgICAgICBvID0gdC51aWQ7XG4gICAgICB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHt9KTtcbiAgICAgIHZhciBzID0gISEodCAmJiB0LnJlcXVlc3QgJiYgdC5yZXF1ZXN0LmNvbGxlY3RSZXNvdXJjZVRpbWluZykgJiYgbmV3IGUuUmVxdWVzdFBlcmZvcm1hbmNlKHQucmVxdWVzdCksXG4gICAgICAgIGEgPSB0aGlzLmxvYWRpbmdbb10gPSBuZXcgbih0KTtcbiAgICAgIGEuYWJvcnQgPSB0aGlzLmxvYWRWZWN0b3JEYXRhKHQsIGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgIGlmIChkZWxldGUgaS5sb2FkaW5nW29dLCB0IHx8ICFuKSByZXR1cm4gYS5zdGF0dXMgPSBcImRvbmVcIiwgaS5sb2FkZWRbb10gPSBhLCByKHQpO1xuICAgICAgICB2YXIgbCA9IG4ucmF3RGF0YSxcbiAgICAgICAgICB1ID0ge307XG4gICAgICAgIG4uZXhwaXJlcyAmJiAodS5leHBpcmVzID0gbi5leHBpcmVzKSwgbi5jYWNoZUNvbnRyb2wgJiYgKHUuY2FjaGVDb250cm9sID0gbi5jYWNoZUNvbnRyb2wpO1xuICAgICAgICB2YXIgaCA9IHt9O1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgIHZhciBjID0gcy5maW5pc2goKTtcbiAgICAgICAgICBjICYmIChoLnJlc291cmNlVGltaW5nID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSkpO1xuICAgICAgICB9XG4gICAgICAgIGEudmVjdG9yVGlsZSA9IG4udmVjdG9yVGlsZSwgYS5wYXJzZShuLnZlY3RvclRpbGUsIGkubGF5ZXJJbmRleCwgaS5hdmFpbGFibGVJbWFnZXMsIGkuYWN0b3IsIGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgICAgaWYgKHQgfHwgIWkpIHJldHVybiByKHQpO1xuICAgICAgICAgIHIobnVsbCwgZS5leHRlbmQoe1xuICAgICAgICAgICAgcmF3VGlsZURhdGE6IGwuc2xpY2UoMClcbiAgICAgICAgICB9LCBpLCB1LCBoKSk7XG4gICAgICAgIH0pLCBpLmxvYWRlZCA9IGkubG9hZGVkIHx8IHt9LCBpLmxvYWRlZFtvXSA9IGE7XG4gICAgICB9KTtcbiAgICB9LCBsLnByb3RvdHlwZS5yZWxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgaSA9IHRoaXMubG9hZGVkLFxuICAgICAgICBvID0gZS51aWQsXG4gICAgICAgIG4gPSB0aGlzO1xuICAgICAgaWYgKGkgJiYgaVtvXSkge1xuICAgICAgICB2YXIgcyA9IGlbb107XG4gICAgICAgIHMuc2hvd0NvbGxpc2lvbkJveGVzID0gZS5zaG93Q29sbGlzaW9uQm94ZXM7XG4gICAgICAgIHZhciBhID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHMucmVsb2FkQ2FsbGJhY2s7XG4gICAgICAgICAgbyAmJiAoZGVsZXRlIHMucmVsb2FkQ2FsbGJhY2ssIHMucGFyc2Uocy52ZWN0b3JUaWxlLCBuLmxheWVySW5kZXgsIHIuYXZhaWxhYmxlSW1hZ2VzLCBuLmFjdG9yLCBvKSksIHQoZSwgaSk7XG4gICAgICAgIH07XG4gICAgICAgIFwicGFyc2luZ1wiID09PSBzLnN0YXR1cyA/IHMucmVsb2FkQ2FsbGJhY2sgPSBhIDogXCJkb25lXCIgPT09IHMuc3RhdHVzICYmIChzLnZlY3RvclRpbGUgPyBzLnBhcnNlKHMudmVjdG9yVGlsZSwgdGhpcy5sYXllckluZGV4LCB0aGlzLmF2YWlsYWJsZUltYWdlcywgdGhpcy5hY3RvciwgYSkgOiBhKCkpO1xuICAgICAgfVxuICAgIH0sIGwucHJvdG90eXBlLmFib3J0VGlsZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB2YXIgciA9IHRoaXMubG9hZGluZyxcbiAgICAgICAgaSA9IGUudWlkO1xuICAgICAgciAmJiByW2ldICYmIHJbaV0uYWJvcnQgJiYgKHJbaV0uYWJvcnQoKSwgZGVsZXRlIHJbaV0pLCB0KCk7XG4gICAgfSwgbC5wcm90b3R5cGUucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB2YXIgciA9IHRoaXMubG9hZGVkLFxuICAgICAgICBpID0gZS51aWQ7XG4gICAgICByICYmIHJbaV0gJiYgZGVsZXRlIHJbaV0sIHQoKTtcbiAgICB9O1xuICAgIHZhciB1ID0gZS53aW5kb3cuSW1hZ2VCaXRtYXAsXG4gICAgICBoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvYWRlZCA9IHt9O1xuICAgICAgfTtcbiAgICBmdW5jdGlvbiBjKGUsIHQpIHtcbiAgICAgIGlmICgwICE9PSBlLmxlbmd0aCkge1xuICAgICAgICBwKGVbMF0sIHQpO1xuICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IGUubGVuZ3RoOyByKyspIHAoZVtyXSwgIXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgPSAwLCBpID0gMCwgbyA9IGUubGVuZ3RoLCBuID0gbyAtIDE7IGkgPCBvOyBuID0gaSsrKSByICs9IChlW2ldWzBdIC0gZVtuXVswXSkgKiAoZVtuXVsxXSArIGVbaV1bMV0pO1xuICAgICAgciA+PSAwICE9ICEhdCAmJiBlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgaC5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgcikge1xuICAgICAgdmFyIGkgPSB0LnVpZCxcbiAgICAgICAgbyA9IHQuZW5jb2RpbmcsXG4gICAgICAgIG4gPSB0LnJhd0ltYWdlRGF0YSxcbiAgICAgICAgcyA9IHUgJiYgbiBpbnN0YW5jZW9mIHUgPyB0aGlzLmdldEltYWdlRGF0YShuKSA6IG4sXG4gICAgICAgIGEgPSBuZXcgZS5ERU1EYXRhKGksIHMsIG8pO1xuICAgICAgdGhpcy5sb2FkZWQgPSB0aGlzLmxvYWRlZCB8fCB7fSwgdGhpcy5sb2FkZWRbaV0gPSBhLCByKG51bGwsIGEpO1xuICAgIH0sIGgucHJvdG90eXBlLmdldEltYWdlRGF0YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcyAmJiB0aGlzLm9mZnNjcmVlbkNhbnZhc0NvbnRleHQgfHwgKHRoaXMub2Zmc2NyZWVuQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0LndpZHRoLCB0LmhlaWdodCksIHRoaXMub2Zmc2NyZWVuQ2FudmFzQ29udGV4dCA9IHRoaXMub2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSksIHRoaXMub2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gdC53aWR0aCwgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0ID0gdC5oZWlnaHQsIHRoaXMub2Zmc2NyZWVuQ2FudmFzQ29udGV4dC5kcmF3SW1hZ2UodCwgMCwgMCwgdC53aWR0aCwgdC5oZWlnaHQpO1xuICAgICAgdmFyIHIgPSB0aGlzLm9mZnNjcmVlbkNhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKC0xLCAtMSwgdC53aWR0aCArIDIsIHQuaGVpZ2h0ICsgMik7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzY3JlZW5DYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLm9mZnNjcmVlbkNhbnZhcy53aWR0aCwgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0KSwgbmV3IGUuUkdCQUltYWdlKHtcbiAgICAgICAgd2lkdGg6IHIud2lkdGgsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH0sIHIuZGF0YSk7XG4gICAgfSwgaC5wcm90b3R5cGUucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMubG9hZGVkLFxuICAgICAgICByID0gZS51aWQ7XG4gICAgICB0ICYmIHRbcl0gJiYgZGVsZXRlIHRbcl07XG4gICAgfTtcbiAgICB2YXIgZiA9IGUudmVjdG9yVGlsZS5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OLFxuICAgICAgZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmUgPSB0LCB0aGlzLmV4dGVudCA9IGUuRVhURU5ULCB0aGlzLnR5cGUgPSB0LnR5cGUsIHRoaXMucHJvcGVydGllcyA9IHQudGFncywgXCJpZFwiIGluIHQgJiYgIWlzTmFOKHQuaWQpICYmICh0aGlzLmlkID0gcGFyc2VJbnQodC5pZCwgMTApKTtcbiAgICAgIH07XG4gICAgZC5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKDEgPT09IHRoaXMuX2ZlYXR1cmUudHlwZSkge1xuICAgICAgICBmb3IgKHZhciB0ID0gW10sIHIgPSAwLCBpID0gdGhpcy5fZmVhdHVyZS5nZW9tZXRyeTsgciA8IGkubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICB2YXIgbyA9IGlbcl07XG4gICAgICAgICAgdC5wdXNoKFtuZXcgZS5Qb2ludCQxKG9bMF0sIG9bMV0pXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuID0gW10sIHMgPSAwLCBhID0gdGhpcy5fZmVhdHVyZS5nZW9tZXRyeTsgcyA8IGEubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IFtdLCB1ID0gMCwgaCA9IGFbc107IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgICAgdmFyIGMgPSBoW3VdO1xuICAgICAgICAgIGwucHVzaChuZXcgZS5Qb2ludCQxKGNbMF0sIGNbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICBuLnB1c2gobCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9LCBkLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgcmV0dXJuIGYuY2FsbCh0aGlzLCBlLCB0LCByKTtcbiAgICB9O1xuICAgIHZhciBnID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMubGF5ZXJzID0ge1xuICAgICAgICBfZ2VvanNvblRpbGVMYXllcjogdGhpc1xuICAgICAgfSwgdGhpcy5uYW1lID0gXCJfZ2VvanNvblRpbGVMYXllclwiLCB0aGlzLmV4dGVudCA9IGUuRVhURU5ULCB0aGlzLmxlbmd0aCA9IHQubGVuZ3RoLCB0aGlzLl9mZWF0dXJlcyA9IHQ7XG4gICAgfTtcbiAgICBnLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBuZXcgZCh0aGlzLl9mZWF0dXJlc1tlXSk7XG4gICAgfTtcbiAgICB2YXIgdiA9IGUudmVjdG9yVGlsZS5WZWN0b3JUaWxlRmVhdHVyZSxcbiAgICAgIG0gPSB5O1xuICAgIGZ1bmN0aW9uIHkoZSwgdCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gdCB8fCB7fSwgdGhpcy5mZWF0dXJlcyA9IGUsIHRoaXMubGVuZ3RoID0gZS5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgoZSwgdCkge1xuICAgICAgdGhpcy5pZCA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIGUuaWQgPyBlLmlkIDogdm9pZCAwLCB0aGlzLnR5cGUgPSBlLnR5cGUsIHRoaXMucmF3R2VvbWV0cnkgPSAxID09PSBlLnR5cGUgPyBbZS5nZW9tZXRyeV0gOiBlLmdlb21ldHJ5LCB0aGlzLnByb3BlcnRpZXMgPSBlLnRhZ3MsIHRoaXMuZXh0ZW50ID0gdCB8fCA0MDk2O1xuICAgIH1cbiAgICB5LnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBuZXcgeCh0aGlzLmZlYXR1cmVzW2VdLCB0aGlzLm9wdGlvbnMuZXh0ZW50KTtcbiAgICB9LCB4LnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMucmF3R2VvbWV0cnk7XG4gICAgICB0aGlzLmdlb21ldHJ5ID0gW107XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRbcl0sIG8gPSBbXSwgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKSBvLnB1c2gobmV3IGUuUG9pbnQkMShpW25dWzBdLCBpW25dWzFdKSk7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkucHVzaChvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5O1xuICAgIH0sIHgucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5IHx8IHRoaXMubG9hZEdlb21ldHJ5KCk7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5nZW9tZXRyeSwgdCA9IDEgLyAwLCByID0gLTEgLyAwLCBpID0gMSAvIDAsIG8gPSAtMSAvIDAsIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykgZm9yICh2YXIgcyA9IGVbbl0sIGEgPSAwOyBhIDwgcy5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbCA9IHNbYV07XG4gICAgICAgIHQgPSBNYXRoLm1pbih0LCBsLngpLCByID0gTWF0aC5tYXgociwgbC54KSwgaSA9IE1hdGgubWluKGksIGwueSksIG8gPSBNYXRoLm1heChvLCBsLnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0LCBpLCByLCBvXTtcbiAgICB9LCB4LnByb3RvdHlwZS50b0dlb0pTT04gPSB2LnByb3RvdHlwZS50b0dlb0pTT047XG4gICAgdmFyIHcgPSBJLFxuICAgICAgUyA9IG07XG4gICAgZnVuY3Rpb24gSSh0KSB7XG4gICAgICB2YXIgciA9IG5ldyBlLnBiZigpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIGZvciAodmFyIHIgaW4gZS5sYXllcnMpIHQud3JpdGVNZXNzYWdlKDMsIE0sIGUubGF5ZXJzW3JdKTtcbiAgICAgIH0odCwgciksIHIuZmluaXNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE0oZSwgdCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0LndyaXRlVmFyaW50RmllbGQoMTUsIGUudmVyc2lvbiB8fCAxKSwgdC53cml0ZVN0cmluZ0ZpZWxkKDEsIGUubmFtZSB8fCBcIlwiKSwgdC53cml0ZVZhcmludEZpZWxkKDUsIGUuZXh0ZW50IHx8IDQwOTYpO1xuICAgICAgdmFyIGkgPSB7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICBrZXljYWNoZToge30sXG4gICAgICAgIHZhbHVlY2FjaGU6IHt9XG4gICAgICB9O1xuICAgICAgZm9yIChyID0gMDsgciA8IGUubGVuZ3RoOyByKyspIGkuZmVhdHVyZSA9IGUuZmVhdHVyZShyKSwgdC53cml0ZU1lc3NhZ2UoMiwgYiwgaSk7XG4gICAgICB2YXIgbyA9IGkua2V5cztcbiAgICAgIGZvciAociA9IDA7IHIgPCBvLmxlbmd0aDsgcisrKSB0LndyaXRlU3RyaW5nRmllbGQoMywgb1tyXSk7XG4gICAgICB2YXIgbiA9IGkudmFsdWVzO1xuICAgICAgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIHQud3JpdGVNZXNzYWdlKDQsIEMsIG5bcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKGUsIHQpIHtcbiAgICAgIHZhciByID0gZS5mZWF0dXJlO1xuICAgICAgdm9pZCAwICE9PSByLmlkICYmIHQud3JpdGVWYXJpbnRGaWVsZCgxLCByLmlkKSwgdC53cml0ZU1lc3NhZ2UoMiwgXywgZSksIHQud3JpdGVWYXJpbnRGaWVsZCgzLCByLnR5cGUpLCB0LndyaXRlTWVzc2FnZSg0LCBULCByKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gXyhlLCB0KSB7XG4gICAgICB2YXIgciA9IGUuZmVhdHVyZSxcbiAgICAgICAgaSA9IGUua2V5cyxcbiAgICAgICAgbyA9IGUudmFsdWVzLFxuICAgICAgICBuID0gZS5rZXljYWNoZSxcbiAgICAgICAgcyA9IGUudmFsdWVjYWNoZTtcbiAgICAgIGZvciAodmFyIGEgaW4gci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBsID0gblthXTtcbiAgICAgICAgdm9pZCAwID09PSBsICYmIChpLnB1c2goYSksIG5bYV0gPSBsID0gaS5sZW5ndGggLSAxKSwgdC53cml0ZVZhcmludChsKTtcbiAgICAgICAgdmFyIHUgPSByLnByb3BlcnRpZXNbYV0sXG4gICAgICAgICAgaCA9IHR5cGVvZiB1O1xuICAgICAgICBcInN0cmluZ1wiICE9PSBoICYmIFwiYm9vbGVhblwiICE9PSBoICYmIFwibnVtYmVyXCIgIT09IGggJiYgKHUgPSBKU09OLnN0cmluZ2lmeSh1KSk7XG4gICAgICAgIHZhciBjID0gaCArIFwiOlwiICsgdSxcbiAgICAgICAgICBwID0gc1tjXTtcbiAgICAgICAgdm9pZCAwID09PSBwICYmIChvLnB1c2godSksIHNbY10gPSBwID0gby5sZW5ndGggLSAxKSwgdC53cml0ZVZhcmludChwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gayhlLCB0KSB7XG4gICAgICByZXR1cm4gKHQgPDwgMykgKyAoNyAmIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQKGUpIHtcbiAgICAgIHJldHVybiBlIDw8IDEgXiBlID4+IDMxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgPSBlLmxvYWRHZW9tZXRyeSgpLCBpID0gZS50eXBlLCBvID0gMCwgbiA9IDAsIHMgPSByLmxlbmd0aCwgYSA9IDA7IGEgPCBzOyBhKyspIHtcbiAgICAgICAgdmFyIGwgPSByW2FdLFxuICAgICAgICAgIHUgPSAxO1xuICAgICAgICAxID09PSBpICYmICh1ID0gbC5sZW5ndGgpLCB0LndyaXRlVmFyaW50KGsoMSwgdSkpO1xuICAgICAgICBmb3IgKHZhciBoID0gMyA9PT0gaSA/IGwubGVuZ3RoIC0gMSA6IGwubGVuZ3RoLCBjID0gMDsgYyA8IGg7IGMrKykge1xuICAgICAgICAgIDEgPT09IGMgJiYgMSAhPT0gaSAmJiB0LndyaXRlVmFyaW50KGsoMiwgaCAtIDEpKTtcbiAgICAgICAgICB2YXIgcCA9IGxbY10ueCAtIG8sXG4gICAgICAgICAgICBmID0gbFtjXS55IC0gbjtcbiAgICAgICAgICB0LndyaXRlVmFyaW50KFAocCkpLCB0LndyaXRlVmFyaW50KFAoZikpLCBvICs9IHAsIG4gKz0gZjtcbiAgICAgICAgfVxuICAgICAgICAzID09PSBpICYmIHQud3JpdGVWYXJpbnQoayg3LCAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEMoZSwgdCkge1xuICAgICAgdmFyIHIgPSB0eXBlb2YgZTtcbiAgICAgIFwic3RyaW5nXCIgPT09IHIgPyB0LndyaXRlU3RyaW5nRmllbGQoMSwgZSkgOiBcImJvb2xlYW5cIiA9PT0gciA/IHQud3JpdGVCb29sZWFuRmllbGQoNywgZSkgOiBcIm51bWJlclwiID09PSByICYmIChlICUgMSAhPSAwID8gdC53cml0ZURvdWJsZUZpZWxkKDMsIGUpIDogZSA8IDAgPyB0LndyaXRlU1ZhcmludEZpZWxkKDYsIGUpIDogdC53cml0ZVZhcmludEZpZWxkKDUsIGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRChlLCB0LCByLCBpKSB7XG4gICAgICBMKGUsIHIsIGkpLCBMKHQsIDIgKiByLCAyICogaSksIEwodCwgMiAqIHIgKyAxLCAyICogaSArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gZVt0XTtcbiAgICAgIGVbdF0gPSBlW3JdLCBlW3JdID0gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24geihlLCB0LCByLCBpKSB7XG4gICAgICB2YXIgbyA9IGUgLSByLFxuICAgICAgICBuID0gdCAtIGk7XG4gICAgICByZXR1cm4gbyAqIG8gKyBuICogbjtcbiAgICB9XG4gICAgdy5mcm9tVmVjdG9yVGlsZUpzID0gSSwgdy5mcm9tR2VvanNvblZ0ID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgIHQgPSB0IHx8IHt9O1xuICAgICAgdmFyIHIgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gZSkgcltpXSA9IG5ldyBtKGVbaV0uZmVhdHVyZXMsIHQpLCByW2ldLm5hbWUgPSBpLCByW2ldLnZlcnNpb24gPSB0LnZlcnNpb24sIHJbaV0uZXh0ZW50ID0gdC5leHRlbnQ7XG4gICAgICByZXR1cm4gSSh7XG4gICAgICAgIGxheWVyczogclxuICAgICAgfSk7XG4gICAgfSwgdy5HZW9KU09OV3JhcHBlciA9IFM7XG4gICAgdmFyIE8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZVswXTtcbiAgICAgIH0sXG4gICAgICBFID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGVbMV07XG4gICAgICB9LFxuICAgICAgRiA9IGZ1bmN0aW9uIChlLCB0LCByLCBpLCBvKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IE8pLCB2b2lkIDAgPT09IHIgJiYgKHIgPSBFKSwgdm9pZCAwID09PSBpICYmIChpID0gNjQpLCB2b2lkIDAgPT09IG8gJiYgKG8gPSBGbG9hdDY0QXJyYXkpLCB0aGlzLm5vZGVTaXplID0gaSwgdGhpcy5wb2ludHMgPSBlO1xuICAgICAgICBmb3IgKHZhciBuID0gZS5sZW5ndGggPCA2NTUzNiA/IFVpbnQxNkFycmF5IDogVWludDMyQXJyYXksIHMgPSB0aGlzLmlkcyA9IG5ldyBuKGUubGVuZ3RoKSwgYSA9IHRoaXMuY29vcmRzID0gbmV3IG8oMiAqIGUubGVuZ3RoKSwgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCsrKSBzW2xdID0gbCwgYVsyICogbF0gPSB0KGVbbF0pLCBhWzIgKiBsICsgMV0gPSByKGVbbF0pO1xuICAgICAgICAhZnVuY3Rpb24gZSh0LCByLCBpLCBvLCBuLCBzKSB7XG4gICAgICAgICAgaWYgKCEobiAtIG8gPD0gaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gbyArIG4gPj4gMTtcbiAgICAgICAgICAgICFmdW5jdGlvbiBlKHQsIHIsIGksIG8sIG4sIHMpIHtcbiAgICAgICAgICAgICAgZm9yICg7IG4gPiBvOykge1xuICAgICAgICAgICAgICAgIGlmIChuIC0gbyA+IDYwMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuIC0gbyArIDEsXG4gICAgICAgICAgICAgICAgICAgIGwgPSBpIC0gbyArIDEsXG4gICAgICAgICAgICAgICAgICAgIHUgPSBNYXRoLmxvZyhhKSxcbiAgICAgICAgICAgICAgICAgICAgaCA9IC41ICogTWF0aC5leHAoMiAqIHUgLyAzKSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IC41ICogTWF0aC5zcXJ0KHUgKiBoICogKGEgLSBoKSAvIGEpICogKGwgLSBhIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgZSh0LCByLCBpLCBNYXRoLm1heChvLCBNYXRoLmZsb29yKGkgLSBsICogaCAvIGEgKyBjKSksIE1hdGgubWluKG4sIE1hdGguZmxvb3IoaSArIChhIC0gbCkgKiBoIC8gYSArIGMpKSwgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwID0gclsyICogaSArIHNdLFxuICAgICAgICAgICAgICAgICAgZiA9IG8sXG4gICAgICAgICAgICAgICAgICBkID0gbjtcbiAgICAgICAgICAgICAgICBmb3IgKEQodCwgciwgbywgaSksIHJbMiAqIG4gKyBzXSA+IHAgJiYgRCh0LCByLCBvLCBuKTsgZiA8IGQ7KSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKEQodCwgciwgZiwgZCksIGYrKywgZC0tOyByWzIgKiBmICsgc10gPCBwOykgZisrO1xuICAgICAgICAgICAgICAgICAgZm9yICg7IHJbMiAqIGQgKyBzXSA+IHA7KSBkLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJbMiAqIG8gKyBzXSA9PT0gcCA/IEQodCwgciwgbywgZCkgOiBEKHQsIHIsICsrZCwgbiksIGQgPD0gaSAmJiAobyA9IGQgKyAxKSwgaSA8PSBkICYmIChuID0gZCAtIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KHQsIHIsIGEsIG8sIG4sIHMgJSAyKSwgZSh0LCByLCBpLCBvLCBhIC0gMSwgcyArIDEpLCBlKHQsIHIsIGksIGEgKyAxLCBuLCBzICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KHMsIGEsIGksIDAsIHMubGVuZ3RoIC0gMSwgMCk7XG4gICAgICB9O1xuICAgIEYucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKGUsIHQsIHIsIGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZSwgdCwgciwgaSwgbywgbiwgcykge1xuICAgICAgICBmb3IgKHZhciBhLCBsLCB1ID0gWzAsIGUubGVuZ3RoIC0gMSwgMF0sIGggPSBbXTsgdS5sZW5ndGg7KSB7XG4gICAgICAgICAgdmFyIGMgPSB1LnBvcCgpLFxuICAgICAgICAgICAgcCA9IHUucG9wKCksXG4gICAgICAgICAgICBmID0gdS5wb3AoKTtcbiAgICAgICAgICBpZiAocCAtIGYgPD0gcykgZm9yICh2YXIgZCA9IGY7IGQgPD0gcDsgZCsrKSBsID0gdFsyICogZCArIDFdLCAoYSA9IHRbMiAqIGRdKSA+PSByICYmIGEgPD0gbyAmJiBsID49IGkgJiYgbCA8PSBuICYmIGgucHVzaChlW2RdKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBnID0gTWF0aC5mbG9vcigoZiArIHApIC8gMik7XG4gICAgICAgICAgICBsID0gdFsyICogZyArIDFdLCAoYSA9IHRbMiAqIGddKSA+PSByICYmIGEgPD0gbyAmJiBsID49IGkgJiYgbCA8PSBuICYmIGgucHVzaChlW2ddKTtcbiAgICAgICAgICAgIHZhciB2ID0gKGMgKyAxKSAlIDI7XG4gICAgICAgICAgICAoMCA9PT0gYyA/IHIgPD0gYSA6IGkgPD0gbCkgJiYgKHUucHVzaChmKSwgdS5wdXNoKGcgLSAxKSwgdS5wdXNoKHYpKSwgKDAgPT09IGMgPyBvID49IGEgOiBuID49IGwpICYmICh1LnB1c2goZyArIDEpLCB1LnB1c2gocCksIHUucHVzaCh2KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfSh0aGlzLmlkcywgdGhpcy5jb29yZHMsIGUsIHQsIHIsIGksIHRoaXMubm9kZVNpemUpO1xuICAgIH0sIEYucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IFswLCBlLmxlbmd0aCAtIDEsIDBdLCBhID0gW10sIGwgPSBvICogbzsgcy5sZW5ndGg7KSB7XG4gICAgICAgICAgdmFyIHUgPSBzLnBvcCgpLFxuICAgICAgICAgICAgaCA9IHMucG9wKCksXG4gICAgICAgICAgICBjID0gcy5wb3AoKTtcbiAgICAgICAgICBpZiAoaCAtIGMgPD0gbikgZm9yICh2YXIgcCA9IGM7IHAgPD0gaDsgcCsrKSB6KHRbMiAqIHBdLCB0WzIgKiBwICsgMV0sIHIsIGkpIDw9IGwgJiYgYS5wdXNoKGVbcF0pO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSBNYXRoLmZsb29yKChjICsgaCkgLyAyKSxcbiAgICAgICAgICAgICAgZCA9IHRbMiAqIGZdLFxuICAgICAgICAgICAgICBnID0gdFsyICogZiArIDFdO1xuICAgICAgICAgICAgeihkLCBnLCByLCBpKSA8PSBsICYmIGEucHVzaChlW2ZdKTtcbiAgICAgICAgICAgIHZhciB2ID0gKHUgKyAxKSAlIDI7XG4gICAgICAgICAgICAoMCA9PT0gdSA/IHIgLSBvIDw9IGQgOiBpIC0gbyA8PSBnKSAmJiAocy5wdXNoKGMpLCBzLnB1c2goZiAtIDEpLCBzLnB1c2godikpLCAoMCA9PT0gdSA/IHIgKyBvID49IGQgOiBpICsgbyA+PSBnKSAmJiAocy5wdXNoKGYgKyAxKSwgcy5wdXNoKGgpLCBzLnB1c2godikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0odGhpcy5pZHMsIHRoaXMuY29vcmRzLCBlLCB0LCByLCB0aGlzLm5vZGVTaXplKTtcbiAgICB9O1xuICAgIHZhciBOID0ge1xuICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICBtYXhab29tOiAxNixcbiAgICAgICAgbWluUG9pbnRzOiAyLFxuICAgICAgICByYWRpdXM6IDQwLFxuICAgICAgICBleHRlbnQ6IDUxMixcbiAgICAgICAgbm9kZVNpemU6IDY0LFxuICAgICAgICBsb2c6ICExLFxuICAgICAgICBnZW5lcmF0ZUlkOiAhMSxcbiAgICAgICAgcmVkdWNlOiBudWxsLFxuICAgICAgICBtYXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBKID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gVihPYmplY3QuY3JlYXRlKE4pLCBlKSwgdGhpcy50cmVlcyA9IG5ldyBBcnJheSh0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpO1xuICAgICAgfTtcbiAgICBmdW5jdGlvbiBaKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUsXG4gICAgICAgIHk6IHQsXG4gICAgICAgIHpvb206IDEgLyAwLFxuICAgICAgICBpZDogcixcbiAgICAgICAgcGFyZW50SWQ6IC0xLFxuICAgICAgICBudW1Qb2ludHM6IGksXG4gICAgICAgIHByb3BlcnRpZXM6IG9cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEEoZSwgdCkge1xuICAgICAgdmFyIHIgPSBlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICBpID0gclsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IFkoclswXSksXG4gICAgICAgIHk6IGooaSksXG4gICAgICAgIHpvb206IDEgLyAwLFxuICAgICAgICBpbmRleDogdCxcbiAgICAgICAgcGFyZW50SWQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBCKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBpZDogZS5pZCxcbiAgICAgICAgcHJvcGVydGllczogRyhlKSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFsoaSA9IGUueCwgMzYwICogKGkgLSAuNSkpLCAodCA9IGUueSwgciA9ICgxODAgLSAzNjAgKiB0KSAqIE1hdGguUEkgLyAxODAsIDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cChyKSkgLyBNYXRoLlBJIC0gOTApXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHQsIHIsIGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEcoZSkge1xuICAgICAgdmFyIHQgPSBlLm51bVBvaW50cyxcbiAgICAgICAgciA9IHQgPj0gMWU0ID8gTWF0aC5yb3VuZCh0IC8gMWUzKSArIFwia1wiIDogdCA+PSAxZTMgPyBNYXRoLnJvdW5kKHQgLyAxMDApIC8gMTAgKyBcImtcIiA6IHQ7XG4gICAgICByZXR1cm4gVihWKHt9LCBlLnByb3BlcnRpZXMpLCB7XG4gICAgICAgIGNsdXN0ZXI6ICEwLFxuICAgICAgICBjbHVzdGVyX2lkOiBlLmlkLFxuICAgICAgICBwb2ludF9jb3VudDogdCxcbiAgICAgICAgcG9pbnRfY291bnRfYWJicmV2aWF0ZWQ6IHJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBZKGUpIHtcbiAgICAgIHJldHVybiBlIC8gMzYwICsgLjU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGooZSkge1xuICAgICAgdmFyIHQgPSBNYXRoLnNpbihlICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHIgPSAuNSAtIC4yNSAqIE1hdGgubG9nKCgxICsgdCkgLyAoMSAtIHQpKSAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gciA8IDAgPyAwIDogciA+IDEgPyAxIDogcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVihlLCB0KSB7XG4gICAgICBmb3IgKHZhciByIGluIHQpIGVbcl0gPSB0W3JdO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFgoZSkge1xuICAgICAgcmV0dXJuIGUueDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVyhlKSB7XG4gICAgICByZXR1cm4gZS55O1xuICAgIH1cbiAgICBmdW5jdGlvbiBSKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIHZhciBzID0gbyAtIHIsXG4gICAgICAgIGEgPSBuIC0gaTtcbiAgICAgIGlmICgwICE9PSBzIHx8IDAgIT09IGEpIHtcbiAgICAgICAgdmFyIGwgPSAoKGUgLSByKSAqIHMgKyAodCAtIGkpICogYSkgLyAocyAqIHMgKyBhICogYSk7XG4gICAgICAgIGwgPiAxID8gKHIgPSBvLCBpID0gbikgOiBsID4gMCAmJiAociArPSBzICogbCwgaSArPSBhICogbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHMgPSBlIC0gcikgKiBzICsgKGEgPSB0IC0gaSkgKiBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxKGUsIHQsIHIsIGkpIHtcbiAgICAgIHZhciBvID0ge1xuICAgICAgICBpZDogdm9pZCAwID09PSBlID8gbnVsbCA6IGUsXG4gICAgICAgIHR5cGU6IHQsXG4gICAgICAgIGdlb21ldHJ5OiByLFxuICAgICAgICB0YWdzOiBpLFxuICAgICAgICBtaW5YOiAxIC8gMCxcbiAgICAgICAgbWluWTogMSAvIDAsXG4gICAgICAgIG1heFg6IC0xIC8gMCxcbiAgICAgICAgbWF4WTogLTEgLyAwXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0ID0gZS5nZW9tZXRyeSxcbiAgICAgICAgICByID0gZS50eXBlO1xuICAgICAgICBpZiAoXCJQb2ludFwiID09PSByIHx8IFwiTXVsdGlQb2ludFwiID09PSByIHx8IFwiTGluZVN0cmluZ1wiID09PSByKSBVKGUsIHQpO2Vsc2UgaWYgKFwiUG9seWdvblwiID09PSByIHx8IFwiTXVsdGlMaW5lU3RyaW5nXCIgPT09IHIpIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykgVShlLCB0W2ldKTtlbHNlIGlmIChcIk11bHRpUG9seWdvblwiID09PSByKSBmb3IgKGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykgZm9yICh2YXIgbyA9IDA7IG8gPCB0W2ldLmxlbmd0aDsgbysrKSBVKGUsIHRbaV1bb10pO1xuICAgICAgfShvKSwgbztcbiAgICB9XG4gICAgZnVuY3Rpb24gVShlLCB0KSB7XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHQubGVuZ3RoOyByICs9IDMpIGUubWluWCA9IE1hdGgubWluKGUubWluWCwgdFtyXSksIGUubWluWSA9IE1hdGgubWluKGUubWluWSwgdFtyICsgMV0pLCBlLm1heFggPSBNYXRoLm1heChlLm1heFgsIHRbcl0pLCBlLm1heFkgPSBNYXRoLm1heChlLm1heFksIHRbciArIDFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJChlLCB0LCByLCBpKSB7XG4gICAgICBpZiAodC5nZW9tZXRyeSkge1xuICAgICAgICB2YXIgbyA9IHQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsXG4gICAgICAgICAgbiA9IHQuZ2VvbWV0cnkudHlwZSxcbiAgICAgICAgICBzID0gTWF0aC5wb3coci50b2xlcmFuY2UgLyAoKDEgPDwgci5tYXhab29tKSAqIHIuZXh0ZW50KSwgMiksXG4gICAgICAgICAgYSA9IFtdLFxuICAgICAgICAgIGwgPSB0LmlkO1xuICAgICAgICBpZiAoci5wcm9tb3RlSWQgPyBsID0gdC5wcm9wZXJ0aWVzW3IucHJvbW90ZUlkXSA6IHIuZ2VuZXJhdGVJZCAmJiAobCA9IGkgfHwgMCksIFwiUG9pbnRcIiA9PT0gbikgSChvLCBhKTtlbHNlIGlmIChcIk11bHRpUG9pbnRcIiA9PT0gbikgZm9yICh2YXIgdSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSBIKG9bdV0sIGEpO2Vsc2UgaWYgKFwiTGluZVN0cmluZ1wiID09PSBuKSBLKG8sIGEsIHMsICExKTtlbHNlIGlmIChcIk11bHRpTGluZVN0cmluZ1wiID09PSBuKSB7XG4gICAgICAgICAgaWYgKHIubGluZU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGZvciAodSA9IDA7IHUgPCBvLmxlbmd0aDsgdSsrKSBLKG9bdV0sIGEgPSBbXSwgcywgITEpLCBlLnB1c2gocShsLCBcIkxpbmVTdHJpbmdcIiwgYSwgdC5wcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFEobywgYSwgcywgITEpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiUG9seWdvblwiID09PSBuKSBRKG8sIGEsIHMsICEwKTtlbHNlIHtcbiAgICAgICAgICBpZiAoXCJNdWx0aVBvbHlnb25cIiAhPT0gbikge1xuICAgICAgICAgICAgaWYgKFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgPT09IG4pIHtcbiAgICAgICAgICAgICAgZm9yICh1ID0gMDsgdSA8IHQuZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IHUrKykgJChlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGwsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHQuZ2VvbWV0cnkuZ2VvbWV0cmllc1t1XSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0LnByb3BlcnRpZXNcbiAgICAgICAgICAgICAgfSwgciwgaSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgby5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgdmFyIGggPSBbXTtcbiAgICAgICAgICAgIFEob1t1XSwgaCwgcywgITApLCBhLnB1c2goaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucHVzaChxKGwsIG4sIGEsIHQucHJvcGVydGllcykpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBIKGUsIHQpIHtcbiAgICAgIHQucHVzaChlZShlWzBdKSksIHQucHVzaCh0ZShlWzFdKSksIHQucHVzaCgwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSyhlLCB0LCByLCBpKSB7XG4gICAgICBmb3IgKHZhciBvLCBuLCBzID0gMCwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHZhciBsID0gZWUoZVthXVswXSksXG4gICAgICAgICAgdSA9IHRlKGVbYV1bMV0pO1xuICAgICAgICB0LnB1c2gobCksIHQucHVzaCh1KSwgdC5wdXNoKDApLCBhID4gMCAmJiAocyArPSBpID8gKG8gKiB1IC0gbCAqIG4pIC8gMiA6IE1hdGguc3FydChNYXRoLnBvdyhsIC0gbywgMikgKyBNYXRoLnBvdyh1IC0gbiwgMikpKSwgbyA9IGwsIG4gPSB1O1xuICAgICAgfVxuICAgICAgdmFyIGggPSB0Lmxlbmd0aCAtIDM7XG4gICAgICB0WzJdID0gMSwgZnVuY3Rpb24gZSh0LCByLCBpLCBvKSB7XG4gICAgICAgIGZvciAodmFyIG4sIHMgPSBvLCBhID0gaSAtIHIgPj4gMSwgbCA9IGkgLSByLCB1ID0gdFtyXSwgaCA9IHRbciArIDFdLCBjID0gdFtpXSwgcCA9IHRbaSArIDFdLCBmID0gciArIDM7IGYgPCBpOyBmICs9IDMpIHtcbiAgICAgICAgICB2YXIgZCA9IFIodFtmXSwgdFtmICsgMV0sIHUsIGgsIGMsIHApO1xuICAgICAgICAgIGlmIChkID4gcykgbiA9IGYsIHMgPSBkO2Vsc2UgaWYgKGQgPT09IHMpIHtcbiAgICAgICAgICAgIHZhciBnID0gTWF0aC5hYnMoZiAtIGEpO1xuICAgICAgICAgICAgZyA8IGwgJiYgKG4gPSBmLCBsID0gZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHMgPiBvICYmIChuIC0gciA+IDMgJiYgZSh0LCByLCBuLCBvKSwgdFtuICsgMl0gPSBzLCBpIC0gbiA+IDMgJiYgZSh0LCBuLCBpLCBvKSk7XG4gICAgICB9KHQsIDAsIGgsIHIpLCB0W2ggKyAyXSA9IDEsIHQuc2l6ZSA9IE1hdGguYWJzKHMpLCB0LnN0YXJ0ID0gMCwgdC5lbmQgPSB0LnNpemU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFEoZSwgdCwgciwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciBuID0gW107XG4gICAgICAgIEsoZVtvXSwgbiwgciwgaSksIHQucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZWUoZSkge1xuICAgICAgcmV0dXJuIGUgLyAzNjAgKyAuNTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGUoZSkge1xuICAgICAgdmFyIHQgPSBNYXRoLnNpbihlICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHIgPSAuNSAtIC4yNSAqIE1hdGgubG9nKCgxICsgdCkgLyAoMSAtIHQpKSAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gciA8IDAgPyAwIDogciA+IDEgPyAxIDogcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmUoZSwgdCwgciwgaSwgbywgbiwgcywgYSkge1xuICAgICAgaWYgKGkgLz0gdCwgbiA+PSAociAvPSB0KSAmJiBzIDwgaSkgcmV0dXJuIGU7XG4gICAgICBpZiAocyA8IHIgfHwgbiA+PSBpKSByZXR1cm4gbnVsbDtcbiAgICAgIGZvciAodmFyIGwgPSBbXSwgdSA9IDA7IHUgPCBlLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIHZhciBoID0gZVt1XSxcbiAgICAgICAgICBjID0gaC5nZW9tZXRyeSxcbiAgICAgICAgICBwID0gaC50eXBlLFxuICAgICAgICAgIGYgPSAwID09PSBvID8gaC5taW5YIDogaC5taW5ZLFxuICAgICAgICAgIGQgPSAwID09PSBvID8gaC5tYXhYIDogaC5tYXhZO1xuICAgICAgICBpZiAoZiA+PSByICYmIGQgPCBpKSBsLnB1c2goaCk7ZWxzZSBpZiAoIShkIDwgciB8fCBmID49IGkpKSB7XG4gICAgICAgICAgdmFyIGcgPSBbXTtcbiAgICAgICAgICBpZiAoXCJQb2ludFwiID09PSBwIHx8IFwiTXVsdGlQb2ludFwiID09PSBwKSBpZShjLCBnLCByLCBpLCBvKTtlbHNlIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gcCkgb2UoYywgZywgciwgaSwgbywgITEsIGEubGluZU1ldHJpY3MpO2Vsc2UgaWYgKFwiTXVsdGlMaW5lU3RyaW5nXCIgPT09IHApIHNlKGMsIGcsIHIsIGksIG8sICExKTtlbHNlIGlmIChcIlBvbHlnb25cIiA9PT0gcCkgc2UoYywgZywgciwgaSwgbywgITApO2Vsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IHApIGZvciAodmFyIHYgPSAwOyB2IDwgYy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIHNlKGNbdl0sIG0sIHIsIGksIG8sICEwKSwgbS5sZW5ndGggJiYgZy5wdXNoKG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChhLmxpbmVNZXRyaWNzICYmIFwiTGluZVN0cmluZ1wiID09PSBwKSB7XG4gICAgICAgICAgICAgIGZvciAodiA9IDA7IHYgPCBnLmxlbmd0aDsgdisrKSBsLnB1c2gocShoLmlkLCBwLCBnW3ZdLCBoLnRhZ3MpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcIkxpbmVTdHJpbmdcIiAhPT0gcCAmJiBcIk11bHRpTGluZVN0cmluZ1wiICE9PSBwIHx8ICgxID09PSBnLmxlbmd0aCA/IChwID0gXCJMaW5lU3RyaW5nXCIsIGcgPSBnWzBdKSA6IHAgPSBcIk11bHRpTGluZVN0cmluZ1wiKSwgXCJQb2ludFwiICE9PSBwICYmIFwiTXVsdGlQb2ludFwiICE9PSBwIHx8IChwID0gMyA9PT0gZy5sZW5ndGggPyBcIlBvaW50XCIgOiBcIk11bHRpUG9pbnRcIiksIGwucHVzaChxKGguaWQsIHAsIGcsIGgudGFncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGwubGVuZ3RoID8gbCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGllKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4gKz0gMykge1xuICAgICAgICB2YXIgcyA9IGVbbiArIG9dO1xuICAgICAgICBzID49IHIgJiYgcyA8PSBpICYmICh0LnB1c2goZVtuXSksIHQucHVzaChlW24gKyAxXSksIHQucHVzaChlW24gKyAyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvZShlLCB0LCByLCBpLCBvLCBuLCBzKSB7XG4gICAgICBmb3IgKHZhciBhLCBsLCB1ID0gbmUoZSksIGggPSAwID09PSBvID8gbGUgOiB1ZSwgYyA9IGUuc3RhcnQsIHAgPSAwOyBwIDwgZS5sZW5ndGggLSAzOyBwICs9IDMpIHtcbiAgICAgICAgdmFyIGYgPSBlW3BdLFxuICAgICAgICAgIGQgPSBlW3AgKyAxXSxcbiAgICAgICAgICBnID0gZVtwICsgMl0sXG4gICAgICAgICAgdiA9IGVbcCArIDNdLFxuICAgICAgICAgIG0gPSBlW3AgKyA0XSxcbiAgICAgICAgICB5ID0gMCA9PT0gbyA/IGYgOiBkLFxuICAgICAgICAgIHggPSAwID09PSBvID8gdiA6IG0sXG4gICAgICAgICAgdyA9ICExO1xuICAgICAgICBzICYmIChhID0gTWF0aC5zcXJ0KE1hdGgucG93KGYgLSB2LCAyKSArIE1hdGgucG93KGQgLSBtLCAyKSkpLCB5IDwgciA/IHggPiByICYmIChsID0gaCh1LCBmLCBkLCB2LCBtLCByKSwgcyAmJiAodS5zdGFydCA9IGMgKyBhICogbCkpIDogeSA+IGkgPyB4IDwgaSAmJiAobCA9IGgodSwgZiwgZCwgdiwgbSwgaSksIHMgJiYgKHUuc3RhcnQgPSBjICsgYSAqIGwpKSA6IGFlKHUsIGYsIGQsIGcpLCB4IDwgciAmJiB5ID49IHIgJiYgKGwgPSBoKHUsIGYsIGQsIHYsIG0sIHIpLCB3ID0gITApLCB4ID4gaSAmJiB5IDw9IGkgJiYgKGwgPSBoKHUsIGYsIGQsIHYsIG0sIGkpLCB3ID0gITApLCAhbiAmJiB3ICYmIChzICYmICh1LmVuZCA9IGMgKyBhICogbCksIHQucHVzaCh1KSwgdSA9IG5lKGUpKSwgcyAmJiAoYyArPSBhKTtcbiAgICAgIH1cbiAgICAgIHZhciBTID0gZS5sZW5ndGggLSAzO1xuICAgICAgZiA9IGVbU10sIGQgPSBlW1MgKyAxXSwgZyA9IGVbUyArIDJdLCAoeSA9IDAgPT09IG8gPyBmIDogZCkgPj0gciAmJiB5IDw9IGkgJiYgYWUodSwgZiwgZCwgZyksIFMgPSB1Lmxlbmd0aCAtIDMsIG4gJiYgUyA+PSAzICYmICh1W1NdICE9PSB1WzBdIHx8IHVbUyArIDFdICE9PSB1WzFdKSAmJiBhZSh1LCB1WzBdLCB1WzFdLCB1WzJdKSwgdS5sZW5ndGggJiYgdC5wdXNoKHUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZShlKSB7XG4gICAgICB2YXIgdCA9IFtdO1xuICAgICAgcmV0dXJuIHQuc2l6ZSA9IGUuc2l6ZSwgdC5zdGFydCA9IGUuc3RhcnQsIHQuZW5kID0gZS5lbmQsIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgZS5sZW5ndGg7IHMrKykgb2UoZVtzXSwgdCwgciwgaSwgbywgbiwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZShlLCB0LCByLCBpKSB7XG4gICAgICBlLnB1c2godCksIGUucHVzaChyKSwgZS5wdXNoKGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZShlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICB2YXIgcyA9IChuIC0gdCkgLyAoaSAtIHQpO1xuICAgICAgcmV0dXJuIGUucHVzaChuKSwgZS5wdXNoKHIgKyAobyAtIHIpICogcyksIGUucHVzaCgxKSwgcztcbiAgICB9XG4gICAgZnVuY3Rpb24gdWUoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgdmFyIHMgPSAobiAtIHIpIC8gKG8gLSByKTtcbiAgICAgIHJldHVybiBlLnB1c2godCArIChpIC0gdCkgKiBzKSwgZS5wdXNoKG4pLCBlLnB1c2goMSksIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhlKGUsIHQpIHtcbiAgICAgIGZvciAodmFyIHIgPSBbXSwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvLFxuICAgICAgICAgIG4gPSBlW2ldLFxuICAgICAgICAgIHMgPSBuLnR5cGU7XG4gICAgICAgIGlmIChcIlBvaW50XCIgPT09IHMgfHwgXCJNdWx0aVBvaW50XCIgPT09IHMgfHwgXCJMaW5lU3RyaW5nXCIgPT09IHMpIG8gPSBjZShuLmdlb21ldHJ5LCB0KTtlbHNlIGlmIChcIk11bHRpTGluZVN0cmluZ1wiID09PSBzIHx8IFwiUG9seWdvblwiID09PSBzKSB7XG4gICAgICAgICAgbyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbi5nZW9tZXRyeS5sZW5ndGg7IGErKykgby5wdXNoKGNlKG4uZ2VvbWV0cnlbYV0sIHQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIk11bHRpUG9seWdvblwiID09PSBzKSBmb3IgKG8gPSBbXSwgYSA9IDA7IGEgPCBuLmdlb21ldHJ5Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IFtdLCB1ID0gMDsgdSA8IG4uZ2VvbWV0cnlbYV0ubGVuZ3RoOyB1KyspIGwucHVzaChjZShuLmdlb21ldHJ5W2FdW3VdLCB0KSk7XG4gICAgICAgICAgby5wdXNoKGwpO1xuICAgICAgICB9XG4gICAgICAgIHIucHVzaChxKG4uaWQsIHMsIG8sIG4udGFncykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlKGUsIHQpIHtcbiAgICAgIHZhciByID0gW107XG4gICAgICByLnNpemUgPSBlLnNpemUsIHZvaWQgMCAhPT0gZS5zdGFydCAmJiAoci5zdGFydCA9IGUuc3RhcnQsIHIuZW5kID0gZS5lbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSArPSAzKSByLnB1c2goZVtpXSArIHQsIGVbaSArIDFdLCBlW2kgKyAyXSk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGUoZSwgdCkge1xuICAgICAgaWYgKGUudHJhbnNmb3JtZWQpIHJldHVybiBlO1xuICAgICAgdmFyIHIsXG4gICAgICAgIGksXG4gICAgICAgIG8sXG4gICAgICAgIG4gPSAxIDw8IGUueixcbiAgICAgICAgcyA9IGUueCxcbiAgICAgICAgYSA9IGUueTtcbiAgICAgIGZvciAociA9IDA7IHIgPCBlLmZlYXR1cmVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciBsID0gZS5mZWF0dXJlc1tyXSxcbiAgICAgICAgICB1ID0gbC5nZW9tZXRyeSxcbiAgICAgICAgICBoID0gbC50eXBlO1xuICAgICAgICBpZiAobC5nZW9tZXRyeSA9IFtdLCAxID09PSBoKSBmb3IgKGkgPSAwOyBpIDwgdS5sZW5ndGg7IGkgKz0gMikgbC5nZW9tZXRyeS5wdXNoKGZlKHVbaV0sIHVbaSArIDFdLCB0LCBuLCBzLCBhKSk7ZWxzZSBmb3IgKGkgPSAwOyBpIDwgdS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IHVbaV0ubGVuZ3RoOyBvICs9IDIpIGMucHVzaChmZSh1W2ldW29dLCB1W2ldW28gKyAxXSwgdCwgbiwgcywgYSkpO1xuICAgICAgICAgIGwuZ2VvbWV0cnkucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGUudHJhbnNmb3JtZWQgPSAhMCwgZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmUoZSwgdCwgciwgaSwgbywgbikge1xuICAgICAgcmV0dXJuIFtNYXRoLnJvdW5kKHIgKiAoZSAqIGkgLSBvKSksIE1hdGgucm91bmQociAqICh0ICogaSAtIG4pKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIG4gPSB0ID09PSBvLm1heFpvb20gPyAwIDogby50b2xlcmFuY2UgLyAoKDEgPDwgdCkgKiBvLmV4dGVudCksIHMgPSB7XG4gICAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICAgIG51bVBvaW50czogMCxcbiAgICAgICAgICBudW1TaW1wbGlmaWVkOiAwLFxuICAgICAgICAgIG51bUZlYXR1cmVzOiAwLFxuICAgICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgICB4OiByLFxuICAgICAgICAgIHk6IGksXG4gICAgICAgICAgejogdCxcbiAgICAgICAgICB0cmFuc2Zvcm1lZDogITEsXG4gICAgICAgICAgbWluWDogMixcbiAgICAgICAgICBtaW5ZOiAxLFxuICAgICAgICAgIG1heFg6IC0xLFxuICAgICAgICAgIG1heFk6IDBcbiAgICAgICAgfSwgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHMubnVtRmVhdHVyZXMrKywgZ2UocywgZVthXSwgbiwgbyk7XG4gICAgICAgIHZhciBsID0gZVthXS5taW5YLFxuICAgICAgICAgIHUgPSBlW2FdLm1pblksXG4gICAgICAgICAgaCA9IGVbYV0ubWF4WCxcbiAgICAgICAgICBjID0gZVthXS5tYXhZO1xuICAgICAgICBsIDwgcy5taW5YICYmIChzLm1pblggPSBsKSwgdSA8IHMubWluWSAmJiAocy5taW5ZID0gdSksIGggPiBzLm1heFggJiYgKHMubWF4WCA9IGgpLCBjID4gcy5tYXhZICYmIChzLm1heFkgPSBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZShlLCB0LCByLCBpKSB7XG4gICAgICB2YXIgbyA9IHQuZ2VvbWV0cnksXG4gICAgICAgIG4gPSB0LnR5cGUsXG4gICAgICAgIHMgPSBbXTtcbiAgICAgIGlmIChcIlBvaW50XCIgPT09IG4gfHwgXCJNdWx0aVBvaW50XCIgPT09IG4pIGZvciAodmFyIGEgPSAwOyBhIDwgby5sZW5ndGg7IGEgKz0gMykgcy5wdXNoKG9bYV0pLCBzLnB1c2gob1thICsgMV0pLCBlLm51bVBvaW50cysrLCBlLm51bVNpbXBsaWZpZWQrKztlbHNlIGlmIChcIkxpbmVTdHJpbmdcIiA9PT0gbikgdmUocywgbywgZSwgciwgITEsICExKTtlbHNlIGlmIChcIk11bHRpTGluZVN0cmluZ1wiID09PSBuIHx8IFwiUG9seWdvblwiID09PSBuKSBmb3IgKGEgPSAwOyBhIDwgby5sZW5ndGg7IGErKykgdmUocywgb1thXSwgZSwgciwgXCJQb2x5Z29uXCIgPT09IG4sIDAgPT09IGEpO2Vsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IG4pIGZvciAodmFyIGwgPSAwOyBsIDwgby5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgdSA9IG9bbF07XG4gICAgICAgIGZvciAoYSA9IDA7IGEgPCB1Lmxlbmd0aDsgYSsrKSB2ZShzLCB1W2FdLCBlLCByLCAhMCwgMCA9PT0gYSk7XG4gICAgICB9XG4gICAgICBpZiAocy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGggPSB0LnRhZ3MgfHwgbnVsbDtcbiAgICAgICAgaWYgKFwiTGluZVN0cmluZ1wiID09PSBuICYmIGkubGluZU1ldHJpY3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBjIGluIGggPSB7fSwgdC50YWdzKSBoW2NdID0gdC50YWdzW2NdO1xuICAgICAgICAgIGgubWFwYm94X2NsaXBfc3RhcnQgPSBvLnN0YXJ0IC8gby5zaXplLCBoLm1hcGJveF9jbGlwX2VuZCA9IG8uZW5kIC8gby5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0ge1xuICAgICAgICAgIGdlb21ldHJ5OiBzLFxuICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiID09PSBuIHx8IFwiTXVsdGlQb2x5Z29uXCIgPT09IG4gPyAzIDogXCJMaW5lU3RyaW5nXCIgPT09IG4gfHwgXCJNdWx0aUxpbmVTdHJpbmdcIiA9PT0gbiA/IDIgOiAxLFxuICAgICAgICAgIHRhZ3M6IGhcbiAgICAgICAgfTtcbiAgICAgICAgbnVsbCAhPT0gdC5pZCAmJiAocC5pZCA9IHQuaWQpLCBlLmZlYXR1cmVzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZlKGUsIHQsIHIsIGksIG8sIG4pIHtcbiAgICAgIHZhciBzID0gaSAqIGk7XG4gICAgICBpZiAoaSA+IDAgJiYgdC5zaXplIDwgKG8gPyBzIDogaSkpIHIubnVtUG9pbnRzICs9IHQubGVuZ3RoIC8gMztlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IFtdLCBsID0gMDsgbCA8IHQubGVuZ3RoOyBsICs9IDMpICgwID09PSBpIHx8IHRbbCArIDJdID4gcykgJiYgKHIubnVtU2ltcGxpZmllZCsrLCBhLnB1c2godFtsXSksIGEucHVzaCh0W2wgKyAxXSkpLCByLm51bVBvaW50cysrO1xuICAgICAgICBvICYmIGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgZm9yICh2YXIgciA9IDAsIGkgPSAwLCBvID0gZS5sZW5ndGgsIG4gPSBvIC0gMjsgaSA8IG87IG4gPSBpLCBpICs9IDIpIHIgKz0gKGVbaV0gLSBlW25dKSAqIChlW2kgKyAxXSArIGVbbiArIDFdKTtcbiAgICAgICAgICBpZiAociA+IDAgPT09IHQpIGZvciAoaSA9IDAsIG8gPSBlLmxlbmd0aDsgaSA8IG8gLyAyOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBzID0gZVtpXSxcbiAgICAgICAgICAgICAgYSA9IGVbaSArIDFdO1xuICAgICAgICAgICAgZVtpXSA9IGVbbyAtIDIgLSBpXSwgZVtpICsgMV0gPSBlW28gLSAxIC0gaV0sIGVbbyAtIDIgLSBpXSA9IHMsIGVbbyAtIDEgLSBpXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICB9KGEsIG4pLCBlLnB1c2goYSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lKGUsIHQpIHtcbiAgICAgIHZhciByID0gKHQgPSB0aGlzLm9wdGlvbnMgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICBmb3IgKHZhciByIGluIHQpIGVbcl0gPSB0W3JdO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0oT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpLCB0KSkuZGVidWc7XG4gICAgICBpZiAociAmJiBjb25zb2xlLnRpbWUoXCJwcmVwcm9jZXNzIGRhdGFcIiksIHQubWF4Wm9vbSA8IDAgfHwgdC5tYXhab29tID4gMjQpIHRocm93IG5ldyBFcnJvcihcIm1heFpvb20gc2hvdWxkIGJlIGluIHRoZSAwLTI0IHJhbmdlXCIpO1xuICAgICAgaWYgKHQucHJvbW90ZUlkICYmIHQuZ2VuZXJhdGVJZCkgdGhyb3cgbmV3IEVycm9yKFwicHJvbW90ZUlkIGFuZCBnZW5lcmF0ZUlkIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLlwiKTtcbiAgICAgIHZhciBpID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgaWYgKFwiRmVhdHVyZUNvbGxlY3Rpb25cIiA9PT0gZS50eXBlKSBmb3IgKHZhciBpID0gMDsgaSA8IGUuZmVhdHVyZXMubGVuZ3RoOyBpKyspICQociwgZS5mZWF0dXJlc1tpXSwgdCwgaSk7ZWxzZSAkKHIsIFwiRmVhdHVyZVwiID09PSBlLnR5cGUgPyBlIDoge1xuICAgICAgICAgIGdlb21ldHJ5OiBlXG4gICAgICAgIH0sIHQpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0oZSwgdCk7XG4gICAgICB0aGlzLnRpbGVzID0ge30sIHRoaXMudGlsZUNvb3JkcyA9IFtdLCByICYmIChjb25zb2xlLnRpbWVFbmQoXCJwcmVwcm9jZXNzIGRhdGFcIiksIGNvbnNvbGUubG9nKFwiaW5kZXg6IG1heFpvb206ICVkLCBtYXhQb2ludHM6ICVkXCIsIHQuaW5kZXhNYXhab29tLCB0LmluZGV4TWF4UG9pbnRzKSwgY29uc29sZS50aW1lKFwiZ2VuZXJhdGUgdGlsZXNcIiksIHRoaXMuc3RhdHMgPSB7fSwgdGhpcy50b3RhbCA9IDApLCAoaSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgIHZhciByID0gdC5idWZmZXIgLyB0LmV4dGVudCxcbiAgICAgICAgICBpID0gZSxcbiAgICAgICAgICBvID0gcmUoZSwgMSwgLTEgLSByLCByLCAwLCAtMSwgMiwgdCksXG4gICAgICAgICAgbiA9IHJlKGUsIDEsIDEgLSByLCAyICsgciwgMCwgLTEsIDIsIHQpO1xuICAgICAgICByZXR1cm4gKG8gfHwgbikgJiYgKGkgPSByZShlLCAxLCAtciwgMSArIHIsIDAsIC0xLCAyLCB0KSB8fCBbXSwgbyAmJiAoaSA9IGhlKG8sIDEpLmNvbmNhdChpKSksIG4gJiYgKGkgPSBpLmNvbmNhdChoZShuLCAtMSkpKSksIGk7XG4gICAgICB9KGksIHQpKS5sZW5ndGggJiYgdGhpcy5zcGxpdFRpbGUoaSwgMCwgMCwgMCksIHIgJiYgKGkubGVuZ3RoICYmIGNvbnNvbGUubG9nKFwiZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkXCIsIHRoaXMudGlsZXNbMF0ubnVtRmVhdHVyZXMsIHRoaXMudGlsZXNbMF0ubnVtUG9pbnRzKSwgY29uc29sZS50aW1lRW5kKFwiZ2VuZXJhdGUgdGlsZXNcIiksIGNvbnNvbGUubG9nKFwidGlsZXMgZ2VuZXJhdGVkOlwiLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB5ZShlLCB0LCByKSB7XG4gICAgICByZXR1cm4gMzIgKiAoKDEgPDwgZSkgKiByICsgdCkgKyBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4ZShlLCB0KSB7XG4gICAgICB2YXIgciA9IGUudGlsZUlELmNhbm9uaWNhbDtcbiAgICAgIGlmICghdGhpcy5fZ2VvSlNPTkluZGV4KSByZXR1cm4gdChudWxsLCBudWxsKTtcbiAgICAgIHZhciBpID0gdGhpcy5fZ2VvSlNPTkluZGV4LmdldFRpbGUoci56LCByLngsIHIueSk7XG4gICAgICBpZiAoIWkpIHJldHVybiB0KG51bGwsIG51bGwpO1xuICAgICAgdmFyIG8gPSBuZXcgZyhpLmZlYXR1cmVzKSxcbiAgICAgICAgbiA9IHcobyk7XG4gICAgICAwID09PSBuLmJ5dGVPZmZzZXQgJiYgbi5ieXRlTGVuZ3RoID09PSBuLmJ1ZmZlci5ieXRlTGVuZ3RoIHx8IChuID0gbmV3IFVpbnQ4QXJyYXkobikpLCB0KG51bGwsIHtcbiAgICAgICAgdmVjdG9yVGlsZTogbyxcbiAgICAgICAgcmF3RGF0YTogbi5idWZmZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBKLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICByID0gdC5sb2csXG4gICAgICAgIGkgPSB0Lm1pblpvb20sXG4gICAgICAgIG8gPSB0Lm1heFpvb20sXG4gICAgICAgIG4gPSB0Lm5vZGVTaXplO1xuICAgICAgciAmJiBjb25zb2xlLnRpbWUoXCJ0b3RhbCB0aW1lXCIpO1xuICAgICAgdmFyIHMgPSBcInByZXBhcmUgXCIgKyBlLmxlbmd0aCArIFwiIHBvaW50c1wiO1xuICAgICAgciAmJiBjb25zb2xlLnRpbWUocyksIHRoaXMucG9pbnRzID0gZTtcbiAgICAgIGZvciAodmFyIGEgPSBbXSwgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCsrKSBlW2xdLmdlb21ldHJ5ICYmIGEucHVzaChBKGVbbF0sIGwpKTtcbiAgICAgIHRoaXMudHJlZXNbbyArIDFdID0gbmV3IEYoYSwgWCwgVywgbiwgRmxvYXQzMkFycmF5KSwgciAmJiBjb25zb2xlLnRpbWVFbmQocyk7XG4gICAgICBmb3IgKHZhciB1ID0gbzsgdSA+PSBpOyB1LS0pIHtcbiAgICAgICAgdmFyIGggPSArRGF0ZS5ub3coKTtcbiAgICAgICAgYSA9IHRoaXMuX2NsdXN0ZXIoYSwgdSksIHRoaXMudHJlZXNbdV0gPSBuZXcgRihhLCBYLCBXLCBuLCBGbG9hdDMyQXJyYXkpLCByICYmIGNvbnNvbGUubG9nKFwieiVkOiAlZCBjbHVzdGVycyBpbiAlZG1zXCIsIHUsIGEubGVuZ3RoLCArRGF0ZS5ub3coKSAtIGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgJiYgY29uc29sZS50aW1lRW5kKFwidG90YWwgdGltZVwiKSwgdGhpcztcbiAgICB9LCBKLnByb3RvdHlwZS5nZXRDbHVzdGVycyA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB2YXIgciA9ICgoZVswXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwLFxuICAgICAgICBpID0gTWF0aC5tYXgoLTkwLCBNYXRoLm1pbig5MCwgZVsxXSkpLFxuICAgICAgICBvID0gMTgwID09PSBlWzJdID8gMTgwIDogKChlWzJdICsgMTgwKSAlIDM2MCArIDM2MCkgJSAzNjAgLSAxODAsXG4gICAgICAgIG4gPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBlWzNdKSk7XG4gICAgICBpZiAoZVsyXSAtIGVbMF0gPj0gMzYwKSByID0gLTE4MCwgbyA9IDE4MDtlbHNlIGlmIChyID4gbykge1xuICAgICAgICB2YXIgcyA9IHRoaXMuZ2V0Q2x1c3RlcnMoW3IsIGksIDE4MCwgbl0sIHQpLFxuICAgICAgICAgIGEgPSB0aGlzLmdldENsdXN0ZXJzKFstMTgwLCBpLCBvLCBuXSwgdCk7XG4gICAgICAgIHJldHVybiBzLmNvbmNhdChhKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGwgPSB0aGlzLnRyZWVzW3RoaXMuX2xpbWl0Wm9vbSh0KV0sIHUgPSBbXSwgaCA9IDAsIGMgPSBsLnJhbmdlKFkociksIGoobiksIFkobyksIGooaSkpOyBoIDwgYy5sZW5ndGg7IGggKz0gMSkge1xuICAgICAgICB2YXIgcCA9IGwucG9pbnRzW2NbaF1dO1xuICAgICAgICB1LnB1c2gocC5udW1Qb2ludHMgPyBCKHApIDogdGhpcy5wb2ludHNbcC5pbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9nZXRPcmlnaW5JZChlKSxcbiAgICAgICAgciA9IHRoaXMuX2dldE9yaWdpblpvb20oZSksXG4gICAgICAgIGkgPSBcIk5vIGNsdXN0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGlkLlwiLFxuICAgICAgICBvID0gdGhpcy50cmVlc1tyXTtcbiAgICAgIGlmICghbykgdGhyb3cgbmV3IEVycm9yKGkpO1xuICAgICAgdmFyIG4gPSBvLnBvaW50c1t0XTtcbiAgICAgIGlmICghbikgdGhyb3cgbmV3IEVycm9yKGkpO1xuICAgICAgZm9yICh2YXIgcyA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyAodGhpcy5vcHRpb25zLmV4dGVudCAqIE1hdGgucG93KDIsIHIgLSAxKSksIGEgPSBbXSwgbCA9IDAsIHUgPSBvLndpdGhpbihuLngsIG4ueSwgcyk7IGwgPCB1Lmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgIHZhciBoID0gby5wb2ludHNbdVtsXV07XG4gICAgICAgIGgucGFyZW50SWQgPT09IGUgJiYgYS5wdXNoKGgubnVtUG9pbnRzID8gQihoKSA6IHRoaXMucG9pbnRzW2guaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGlmICgwID09PSBhLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGkpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgSi5wcm90b3R5cGUuZ2V0TGVhdmVzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gW107XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kTGVhdmVzKGksIGUsIHQgPSB0IHx8IDEwLCByID0gciB8fCAwLCAwKSwgaTtcbiAgICB9LCBKLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oZSldLFxuICAgICAgICBvID0gTWF0aC5wb3coMiwgZSksXG4gICAgICAgIG4gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHMgPSBuLnJhZGl1cyAvIG4uZXh0ZW50LFxuICAgICAgICBhID0gKHIgLSBzKSAvIG8sXG4gICAgICAgIGwgPSAociArIDEgKyBzKSAvIG8sXG4gICAgICAgIHUgPSB7XG4gICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fYWRkVGlsZUZlYXR1cmVzKGkucmFuZ2UoKHQgLSBzKSAvIG8sIGEsICh0ICsgMSArIHMpIC8gbywgbCksIGkucG9pbnRzLCB0LCByLCBvLCB1KSwgMCA9PT0gdCAmJiB0aGlzLl9hZGRUaWxlRmVhdHVyZXMoaS5yYW5nZSgxIC0gcyAvIG8sIGEsIDEsIGwpLCBpLnBvaW50cywgbywgciwgbywgdSksIHQgPT09IG8gLSAxICYmIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhpLnJhbmdlKDAsIGEsIHMgLyBvLCBsKSwgaS5wb2ludHMsIC0xLCByLCBvLCB1KSwgdS5mZWF0dXJlcy5sZW5ndGggPyB1IDogbnVsbDtcbiAgICB9LCBKLnByb3RvdHlwZS5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gdGhpcy5fZ2V0T3JpZ2luWm9vbShlKSAtIDE7IHQgPD0gdGhpcy5vcHRpb25zLm1heFpvb207KSB7XG4gICAgICAgIHZhciByID0gdGhpcy5nZXRDaGlsZHJlbihlKTtcbiAgICAgICAgaWYgKHQrKywgMSAhPT0gci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBlID0gclswXS5wcm9wZXJ0aWVzLmNsdXN0ZXJfaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9LCBKLnByb3RvdHlwZS5fYXBwZW5kTGVhdmVzID0gZnVuY3Rpb24gKGUsIHQsIHIsIGksIG8pIHtcbiAgICAgIGZvciAodmFyIG4gPSAwLCBzID0gdGhpcy5nZXRDaGlsZHJlbih0KTsgbiA8IHMubGVuZ3RoOyBuICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSBzW25dLFxuICAgICAgICAgIGwgPSBhLnByb3BlcnRpZXM7XG4gICAgICAgIGlmIChsICYmIGwuY2x1c3RlciA/IG8gKyBsLnBvaW50X2NvdW50IDw9IGkgPyBvICs9IGwucG9pbnRfY291bnQgOiBvID0gdGhpcy5fYXBwZW5kTGVhdmVzKGUsIGwuY2x1c3Rlcl9pZCwgciwgaSwgbykgOiBvIDwgaSA/IG8rKyA6IGUucHVzaChhKSwgZS5sZW5ndGggPT09IHIpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSwgSi5wcm90b3R5cGUuX2FkZFRpbGVGZWF0dXJlcyA9IGZ1bmN0aW9uIChlLCB0LCByLCBpLCBvLCBuKSB7XG4gICAgICBmb3IgKHZhciBzID0gMCwgYSA9IGU7IHMgPCBhLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgIHZhciBsID0gdFthW3NdXSxcbiAgICAgICAgICB1ID0gbC5udW1Qb2ludHMsXG4gICAgICAgICAgaCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDEsXG4gICAgICAgICAgICBnZW9tZXRyeTogW1tNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5leHRlbnQgKiAobC54ICogbyAtIHIpKSwgTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuZXh0ZW50ICogKGwueSAqIG8gLSBpKSldXSxcbiAgICAgICAgICAgIHRhZ3M6IHUgPyBHKGwpIDogdGhpcy5wb2ludHNbbC5pbmRleF0ucHJvcGVydGllc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYyA9IHZvaWQgMDtcbiAgICAgICAgdSA/IGMgPSBsLmlkIDogdGhpcy5vcHRpb25zLmdlbmVyYXRlSWQgPyBjID0gbC5pbmRleCA6IHRoaXMucG9pbnRzW2wuaW5kZXhdLmlkICYmIChjID0gdGhpcy5wb2ludHNbbC5pbmRleF0uaWQpLCB2b2lkIDAgIT09IGMgJiYgKGguaWQgPSBjKSwgbi5mZWF0dXJlcy5wdXNoKGgpO1xuICAgICAgfVxuICAgIH0sIEoucHJvdG90eXBlLl9saW1pdFpvb20gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW5ab29tLCBNYXRoLm1pbigrZSwgdGhpcy5vcHRpb25zLm1heFpvb20gKyAxKSk7XG4gICAgfSwgSi5wcm90b3R5cGUuX2NsdXN0ZXIgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgZm9yICh2YXIgciA9IFtdLCBpID0gdGhpcy5vcHRpb25zLCBvID0gaS5yZWR1Y2UsIG4gPSBpLm1pblBvaW50cywgcyA9IGkucmFkaXVzIC8gKGkuZXh0ZW50ICogTWF0aC5wb3coMiwgdCkpLCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgdmFyIGwgPSBlW2FdO1xuICAgICAgICBpZiAoIShsLnpvb20gPD0gdCkpIHtcbiAgICAgICAgICBsLnpvb20gPSB0O1xuICAgICAgICAgIGZvciAodmFyIHUgPSB0aGlzLnRyZWVzW3QgKyAxXSwgaCA9IHUud2l0aGluKGwueCwgbC55LCBzKSwgYyA9IGwubnVtUG9pbnRzIHx8IDEsIHAgPSBjLCBmID0gMCwgZCA9IGg7IGYgPCBkLmxlbmd0aDsgZiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZyA9IHUucG9pbnRzW2RbZl1dO1xuICAgICAgICAgICAgZy56b29tID4gdCAmJiAocCArPSBnLm51bVBvaW50cyB8fCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHAgPj0gbikge1xuICAgICAgICAgICAgZm9yICh2YXIgdiA9IGwueCAqIGMsIG0gPSBsLnkgKiBjLCB5ID0gbyAmJiBjID4gMSA/IHRoaXMuX21hcChsLCAhMCkgOiBudWxsLCB4ID0gKGEgPDwgNSkgKyAodCArIDEpICsgdGhpcy5wb2ludHMubGVuZ3RoLCB3ID0gMCwgUyA9IGg7IHcgPCBTLmxlbmd0aDsgdyArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBJID0gdS5wb2ludHNbU1t3XV07XG4gICAgICAgICAgICAgIGlmICghKEkuem9vbSA8PSB0KSkge1xuICAgICAgICAgICAgICAgIEkuem9vbSA9IHQ7XG4gICAgICAgICAgICAgICAgdmFyIE0gPSBJLm51bVBvaW50cyB8fCAxO1xuICAgICAgICAgICAgICAgIHYgKz0gSS54ICogTSwgbSArPSBJLnkgKiBNLCBJLnBhcmVudElkID0geCwgbyAmJiAoeSB8fCAoeSA9IHRoaXMuX21hcChsLCAhMCkpLCBvKHksIHRoaXMuX21hcChJKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsLnBhcmVudElkID0geCwgci5wdXNoKFoodiAvIHAsIG0gLyBwLCB4LCBwLCB5KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyLnB1c2gobCksIHAgPiAxKSBmb3IgKHZhciBiID0gMCwgXyA9IGg7IGIgPCBfLmxlbmd0aDsgYiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgayA9IHUucG9pbnRzW19bYl1dO1xuICAgICAgICAgICAgay56b29tIDw9IHQgfHwgKGsuem9vbSA9IHQsIHIucHVzaChrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9LCBKLnByb3RvdHlwZS5fZ2V0T3JpZ2luSWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGUgLSB0aGlzLnBvaW50cy5sZW5ndGggPj4gNTtcbiAgICB9LCBKLnByb3RvdHlwZS5fZ2V0T3JpZ2luWm9vbSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gKGUgLSB0aGlzLnBvaW50cy5sZW5ndGgpICUgMzI7XG4gICAgfSwgSi5wcm90b3R5cGUuX21hcCA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICBpZiAoZS5udW1Qb2ludHMpIHJldHVybiB0ID8gVih7fSwgZS5wcm9wZXJ0aWVzKSA6IGUucHJvcGVydGllcztcbiAgICAgIHZhciByID0gdGhpcy5wb2ludHNbZS5pbmRleF0ucHJvcGVydGllcyxcbiAgICAgICAgaSA9IHRoaXMub3B0aW9ucy5tYXAocik7XG4gICAgICByZXR1cm4gdCAmJiBpID09PSByID8gVih7fSwgaSkgOiBpO1xuICAgIH0sIG1lLnByb3RvdHlwZS5vcHRpb25zID0ge1xuICAgICAgbWF4Wm9vbTogMTQsXG4gICAgICBpbmRleE1heFpvb206IDUsXG4gICAgICBpbmRleE1heFBvaW50czogMWU1LFxuICAgICAgdG9sZXJhbmNlOiAzLFxuICAgICAgZXh0ZW50OiA0MDk2LFxuICAgICAgYnVmZmVyOiA2NCxcbiAgICAgIGxpbmVNZXRyaWNzOiAhMSxcbiAgICAgIHByb21vdGVJZDogbnVsbCxcbiAgICAgIGdlbmVyYXRlSWQ6ICExLFxuICAgICAgZGVidWc6IDBcbiAgICB9LCBtZS5wcm90b3R5cGUuc3BsaXRUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIsIGksIG8sIG4sIHMpIHtcbiAgICAgIGZvciAodmFyIGEgPSBbZSwgdCwgciwgaV0sIGwgPSB0aGlzLm9wdGlvbnMsIHUgPSBsLmRlYnVnOyBhLmxlbmd0aDspIHtcbiAgICAgICAgaSA9IGEucG9wKCksIHIgPSBhLnBvcCgpLCB0ID0gYS5wb3AoKSwgZSA9IGEucG9wKCk7XG4gICAgICAgIHZhciBoID0gMSA8PCB0LFxuICAgICAgICAgIGMgPSB5ZSh0LCByLCBpKSxcbiAgICAgICAgICBwID0gdGhpcy50aWxlc1tjXTtcbiAgICAgICAgaWYgKCFwICYmICh1ID4gMSAmJiBjb25zb2xlLnRpbWUoXCJjcmVhdGlvblwiKSwgcCA9IHRoaXMudGlsZXNbY10gPSBkZShlLCB0LCByLCBpLCBsKSwgdGhpcy50aWxlQ29vcmRzLnB1c2goe1xuICAgICAgICAgIHo6IHQsXG4gICAgICAgICAgeDogcixcbiAgICAgICAgICB5OiBpXG4gICAgICAgIH0pLCB1KSkge1xuICAgICAgICAgIHUgPiAxICYmIChjb25zb2xlLmxvZyhcInRpbGUgeiVkLSVkLSVkIChmZWF0dXJlczogJWQsIHBvaW50czogJWQsIHNpbXBsaWZpZWQ6ICVkKVwiLCB0LCByLCBpLCBwLm51bUZlYXR1cmVzLCBwLm51bVBvaW50cywgcC5udW1TaW1wbGlmaWVkKSwgY29uc29sZS50aW1lRW5kKFwiY3JlYXRpb25cIikpO1xuICAgICAgICAgIHZhciBmID0gXCJ6XCIgKyB0O1xuICAgICAgICAgIHRoaXMuc3RhdHNbZl0gPSAodGhpcy5zdGF0c1tmXSB8fCAwKSArIDEsIHRoaXMudG90YWwrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5zb3VyY2UgPSBlLCBvKSB7XG4gICAgICAgICAgaWYgKHQgPT09IGwubWF4Wm9vbSB8fCB0ID09PSBvKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgZCA9IDEgPDwgbyAtIHQ7XG4gICAgICAgICAgaWYgKHIgIT09IE1hdGguZmxvb3IobiAvIGQpIHx8IGkgIT09IE1hdGguZmxvb3IocyAvIGQpKSBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSBsLmluZGV4TWF4Wm9vbSB8fCBwLm51bVBvaW50cyA8PSBsLmluZGV4TWF4UG9pbnRzKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHAuc291cmNlID0gbnVsbCwgMCAhPT0gZS5sZW5ndGgpIHtcbiAgICAgICAgICB1ID4gMSAmJiBjb25zb2xlLnRpbWUoXCJjbGlwcGluZ1wiKTtcbiAgICAgICAgICB2YXIgZyxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgUyA9IC41ICogbC5idWZmZXIgLyBsLmV4dGVudCxcbiAgICAgICAgICAgIEkgPSAuNSAtIFMsXG4gICAgICAgICAgICBNID0gLjUgKyBTLFxuICAgICAgICAgICAgYiA9IDEgKyBTO1xuICAgICAgICAgIGcgPSB2ID0gbSA9IHkgPSBudWxsLCB4ID0gcmUoZSwgaCwgciAtIFMsIHIgKyBNLCAwLCBwLm1pblgsIHAubWF4WCwgbCksIHcgPSByZShlLCBoLCByICsgSSwgciArIGIsIDAsIHAubWluWCwgcC5tYXhYLCBsKSwgZSA9IG51bGwsIHggJiYgKGcgPSByZSh4LCBoLCBpIC0gUywgaSArIE0sIDEsIHAubWluWSwgcC5tYXhZLCBsKSwgdiA9IHJlKHgsIGgsIGkgKyBJLCBpICsgYiwgMSwgcC5taW5ZLCBwLm1heFksIGwpLCB4ID0gbnVsbCksIHcgJiYgKG0gPSByZSh3LCBoLCBpIC0gUywgaSArIE0sIDEsIHAubWluWSwgcC5tYXhZLCBsKSwgeSA9IHJlKHcsIGgsIGkgKyBJLCBpICsgYiwgMSwgcC5taW5ZLCBwLm1heFksIGwpLCB3ID0gbnVsbCksIHUgPiAxICYmIGNvbnNvbGUudGltZUVuZChcImNsaXBwaW5nXCIpLCBhLnB1c2goZyB8fCBbXSwgdCArIDEsIDIgKiByLCAyICogaSksIGEucHVzaCh2IHx8IFtdLCB0ICsgMSwgMiAqIHIsIDIgKiBpICsgMSksIGEucHVzaChtIHx8IFtdLCB0ICsgMSwgMiAqIHIgKyAxLCAyICogaSksIGEucHVzaCh5IHx8IFtdLCB0ICsgMSwgMiAqIHIgKyAxLCAyICogaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgbWUucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdmFyIGkgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIG8gPSBpLmV4dGVudCxcbiAgICAgICAgbiA9IGkuZGVidWc7XG4gICAgICBpZiAoZSA8IDAgfHwgZSA+IDI0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzID0gMSA8PCBlLFxuICAgICAgICBhID0geWUoZSwgdCA9ICh0ICUgcyArIHMpICUgcywgcik7XG4gICAgICBpZiAodGhpcy50aWxlc1thXSkgcmV0dXJuIHBlKHRoaXMudGlsZXNbYV0sIG8pO1xuICAgICAgbiA+IDEgJiYgY29uc29sZS5sb2coXCJkcmlsbGluZyBkb3duIHRvIHolZC0lZC0lZFwiLCBlLCB0LCByKTtcbiAgICAgIGZvciAodmFyIGwsIHUgPSBlLCBoID0gdCwgYyA9IHI7ICFsICYmIHUgPiAwOykgdS0tLCBoID0gTWF0aC5mbG9vcihoIC8gMiksIGMgPSBNYXRoLmZsb29yKGMgLyAyKSwgbCA9IHRoaXMudGlsZXNbeWUodSwgaCwgYyldO1xuICAgICAgcmV0dXJuIGwgJiYgbC5zb3VyY2UgPyAobiA+IDEgJiYgY29uc29sZS5sb2coXCJmb3VuZCBwYXJlbnQgdGlsZSB6JWQtJWQtJWRcIiwgdSwgaCwgYyksIG4gPiAxICYmIGNvbnNvbGUudGltZShcImRyaWxsaW5nIGRvd25cIiksIHRoaXMuc3BsaXRUaWxlKGwuc291cmNlLCB1LCBoLCBjLCBlLCB0LCByKSwgbiA+IDEgJiYgY29uc29sZS50aW1lRW5kKFwiZHJpbGxpbmcgZG93blwiKSwgdGhpcy50aWxlc1thXSA/IHBlKHRoaXMudGlsZXNbYV0sIG8pIDogbnVsbCkgOiBudWxsO1xuICAgIH07XG4gICAgdmFyIHdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gcihlLCByLCBpLCBvKSB7XG4gICAgICAgICAgdC5jYWxsKHRoaXMsIGUsIHIsIGksIHhlKSwgbyAmJiAodGhpcy5sb2FkR2VvSlNPTiA9IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChyLl9fcHJvdG9fXyA9IHQpLCAoci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IHIsIHIucHJvdG90eXBlLmxvYWREYXRhID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgJiYgdGhpcy5fcGVuZGluZ0NhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIGFiYW5kb25lZDogITBcbiAgICAgICAgICB9KSwgdGhpcy5fcGVuZGluZ0NhbGxiYWNrID0gdCwgdGhpcy5fcGVuZGluZ0xvYWREYXRhUGFyYW1zID0gZSwgdGhpcy5fc3RhdGUgJiYgXCJJZGxlXCIgIT09IHRoaXMuX3N0YXRlID8gdGhpcy5fc3RhdGUgPSBcIk5lZWRzTG9hZERhdGFcIiA6ICh0aGlzLl9zdGF0ZSA9IFwiQ29hbGVzY2luZ1wiLCB0aGlzLl9sb2FkRGF0YSgpKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX2xvYWREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NhbGxiYWNrICYmIHRoaXMuX3BlbmRpbmdMb2FkRGF0YVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLl9wZW5kaW5nQ2FsbGJhY2ssXG4gICAgICAgICAgICAgIGkgPSB0aGlzLl9wZW5kaW5nTG9hZERhdGFQYXJhbXM7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ0NhbGxiYWNrLCBkZWxldGUgdGhpcy5fcGVuZGluZ0xvYWREYXRhUGFyYW1zO1xuICAgICAgICAgICAgdmFyIG8gPSAhIShpICYmIGkucmVxdWVzdCAmJiBpLnJlcXVlc3QuY29sbGVjdFJlc291cmNlVGltaW5nKSAmJiBuZXcgZS5SZXF1ZXN0UGVyZm9ybWFuY2UoaS5yZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMubG9hZEdlb0pTT04oaSwgZnVuY3Rpb24gKG4sIHMpIHtcbiAgICAgICAgICAgICAgaWYgKG4gfHwgIXMpIHJldHVybiByKG4pO1xuICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgcykgcmV0dXJuIHIobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBnaXZlbiB0byAnXCIgKyBpLnNvdXJjZSArIFwiJyBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgICAhZnVuY3Rpb24gZSh0LCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICBvID0gdCAmJiB0LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKFwiRmVhdHVyZUNvbGxlY3Rpb25cIiA9PT0gbykgZm9yIChpID0gMDsgaSA8IHQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIGUodC5mZWF0dXJlc1tpXSwgcik7ZWxzZSBpZiAoXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA9PT0gbykgZm9yIChpID0gMDsgaSA8IHQuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykgZSh0Lmdlb21ldHJpZXNbaV0sIHIpO2Vsc2UgaWYgKFwiRmVhdHVyZVwiID09PSBvKSBlKHQuZ2VvbWV0cnksIHIpO2Vsc2UgaWYgKFwiUG9seWdvblwiID09PSBvKSBjKHQuY29vcmRpbmF0ZXMsIHIpO2Vsc2UgaWYgKFwiTXVsdGlQb2x5Z29uXCIgPT09IG8pIGZvciAoaSA9IDA7IGkgPCB0LmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSBjKHQuY29vcmRpbmF0ZXNbaV0sIHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICB9KHMsICEwKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhID0gZS5jcmVhdGVFeHByZXNzaW9uKGkuZmlsdGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiLFxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICExXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChcImVycm9yXCIgPT09IGEucmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYS52YWx1ZS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUua2V5ICsgXCI6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgICAgICAgIHZhciBsID0gcy5mZWF0dXJlcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEudmFsdWUuZXZhbHVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIHpvb206IDBcbiAgICAgICAgICAgICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXM6IGxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQuX2dlb0pTT05JbmRleCA9IGkuY2x1c3RlciA/IG5ldyBKKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IHQuc3VwZXJjbHVzdGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHQuY2x1c3RlclByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICBpZiAoIWkgfHwgIXIpIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbyA9IHt9LCBuID0ge30sIHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgem9vbTogMFxuICAgICAgICAgICAgICAgICAgICB9LCBhID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSwgbCA9IE9iamVjdC5rZXlzKGkpLCB1ID0gMCwgaCA9IGw7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gaFt1XSxcbiAgICAgICAgICAgICAgICAgICAgICBwID0gaVtjXSxcbiAgICAgICAgICAgICAgICAgICAgICBmID0gcFswXSxcbiAgICAgICAgICAgICAgICAgICAgICBkID0gZS5jcmVhdGVFeHByZXNzaW9uKHBbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgIGcgPSBlLmNyZWF0ZUV4cHJlc3Npb24oXCJzdHJpbmdcIiA9PSB0eXBlb2YgZiA/IFtmLCBbXCJhY2N1bXVsYXRlZFwiXSwgW1wiZ2V0XCIsIGNdXSA6IGYpO1xuICAgICAgICAgICAgICAgICAgICBvW2NdID0gZC52YWx1ZSwgbltjXSA9IGcudmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gci5tYXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBhLnByb3BlcnRpZXMgPSBlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0ge30sIHIgPSAwLCBpID0gbDsgciA8IGkubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGlbcl07XG4gICAgICAgICAgICAgICAgICAgICAgdFtuXSA9IG9bbl0uZXZhbHVhdGUocywgYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgICB9LCByLnJlZHVjZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHJvcGVydGllcyA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBpID0gbDsgciA8IGkubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGlbcl07XG4gICAgICAgICAgICAgICAgICAgICAgcy5hY2N1bXVsYXRlZCA9IGVbb10sIGVbb10gPSBuW29dLmV2YWx1YXRlKHMsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCByO1xuICAgICAgICAgICAgICAgIH0oaSkpLmxvYWQocy5mZWF0dXJlcykgOiBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtZShlLCB0KTtcbiAgICAgICAgICAgICAgICB9KHMsIGkuZ2VvanNvblZ0T3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcihuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0LmxvYWRlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgdSA9IHt9O1xuICAgICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgIHZhciBoID0gby5maW5pc2goKTtcbiAgICAgICAgICAgICAgICBoICYmICh1LnJlc291cmNlVGltaW5nID0ge30sIHUucmVzb3VyY2VUaW1pbmdbaS5zb3VyY2VdID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShoKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIobnVsbCwgdSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmNvYWxlc2NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFwiQ29hbGVzY2luZ1wiID09PSB0aGlzLl9zdGF0ZSA/IHRoaXMuX3N0YXRlID0gXCJJZGxlXCIgOiBcIk5lZWRzTG9hZERhdGFcIiA9PT0gdGhpcy5fc3RhdGUgJiYgKHRoaXMuX3N0YXRlID0gXCJDb2FsZXNjaW5nXCIsIHRoaXMuX2xvYWREYXRhKCkpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZWxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMubG9hZGVkO1xuICAgICAgICAgIHJldHVybiBpICYmIGlbZS51aWRdID8gdC5wcm90b3R5cGUucmVsb2FkVGlsZS5jYWxsKHRoaXMsIGUsIHIpIDogdGhpcy5sb2FkVGlsZShlLCByKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUubG9hZEdlb0pTT04gPSBmdW5jdGlvbiAodCwgcikge1xuICAgICAgICAgIGlmICh0LnJlcXVlc3QpIGUuZ2V0SlNPTih0LnJlcXVlc3QsIHIpO2Vsc2Uge1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHQuZGF0YSkgcmV0dXJuIHIobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBnaXZlbiB0byAnXCIgKyB0LnNvdXJjZSArIFwiJyBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIobnVsbCwgSlNPTi5wYXJzZSh0LmRhdGEpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBnaXZlbiB0byAnXCIgKyB0LnNvdXJjZSArIFwiJyBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlU291cmNlID0gZnVuY3Rpb24gKGUsIHQpIHtcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2sgJiYgdGhpcy5fcGVuZGluZ0NhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIGFiYW5kb25lZDogITBcbiAgICAgICAgICB9KSwgdCgpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQobnVsbCwgdGhpcy5fZ2VvSlNPTkluZGV4LmdldENsdXN0ZXJFeHBhbnNpb25ab29tKGUuY2x1c3RlcklkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldENsdXN0ZXJDaGlsZHJlbiA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHQobnVsbCwgdGhpcy5fZ2VvSlNPTkluZGV4LmdldENoaWxkcmVuKGUuY2x1c3RlcklkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldENsdXN0ZXJMZWF2ZXMgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0KG51bGwsIHRoaXMuX2dlb0pTT05JbmRleC5nZXRMZWF2ZXMoZS5jbHVzdGVySWQsIGUubGltaXQsIGUub2Zmc2V0KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHI7XG4gICAgICB9KGwpLFxuICAgICAgU2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgciA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2VsZiA9IHQsIHRoaXMuYWN0b3IgPSBuZXcgZS5BY3Rvcih0LCB0aGlzKSwgdGhpcy5sYXllckluZGV4ZXMgPSB7fSwgdGhpcy5hdmFpbGFibGVJbWFnZXMgPSB7fSwgdGhpcy53b3JrZXJTb3VyY2VUeXBlcyA9IHtcbiAgICAgICAgICB2ZWN0b3I6IGwsXG4gICAgICAgICAgZ2VvanNvbjogd2VcbiAgICAgICAgfSwgdGhpcy53b3JrZXJTb3VyY2VzID0ge30sIHRoaXMuZGVtV29ya2VyU291cmNlcyA9IHt9LCB0aGlzLnNlbGYucmVnaXN0ZXJXb3JrZXJTb3VyY2UgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgICAgIGlmIChyLndvcmtlclNvdXJjZVR5cGVzW2VdKSB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBzb3VyY2Ugd2l0aCBuYW1lIFwiJyArIGUgKyAnXCIgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgICAgICAgIHIud29ya2VyU291cmNlVHlwZXNbZV0gPSB0O1xuICAgICAgICB9LCB0aGlzLnNlbGYucmVnaXN0ZXJSVExUZXh0UGx1Z2luID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoZS5wbHVnaW4uaXNQYXJzZWQoKSkgdGhyb3cgbmV3IEVycm9yKFwiUlRMIHRleHQgcGx1Z2luIGFscmVhZHkgcmVnaXN0ZXJlZC5cIik7XG4gICAgICAgICAgZS5wbHVnaW4uYXBwbHlBcmFiaWNTaGFwaW5nID0gdC5hcHBseUFyYWJpY1NoYXBpbmcsIGUucGx1Z2luLnByb2Nlc3NCaWRpcmVjdGlvbmFsVGV4dCA9IHQucHJvY2Vzc0JpZGlyZWN0aW9uYWxUZXh0LCBlLnBsdWdpbi5wcm9jZXNzU3R5bGVkQmlkaXJlY3Rpb25hbFRleHQgPSB0LnByb2Nlc3NTdHlsZWRCaWRpcmVjdGlvbmFsVGV4dDtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgcmV0dXJuIFNlLnByb3RvdHlwZS5zZXRSZWZlcnJlciA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICB0aGlzLnJlZmVycmVyID0gdDtcbiAgICB9LCBTZS5wcm90b3R5cGUuc2V0SW1hZ2VzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5hdmFpbGFibGVJbWFnZXNbZV0gPSB0LCB0aGlzLndvcmtlclNvdXJjZXNbZV0pIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLndvcmtlclNvdXJjZXNbZV1baV07XG4gICAgICAgIGZvciAodmFyIG4gaW4gbykgb1tuXS5hdmFpbGFibGVJbWFnZXMgPSB0O1xuICAgICAgfVxuICAgICAgcigpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5zZXRMYXllcnMgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRMYXllckluZGV4KGUpLnJlcGxhY2UodCksIHIoKTtcbiAgICB9LCBTZS5wcm90b3R5cGUudXBkYXRlTGF5ZXJzID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0TGF5ZXJJbmRleChlKS51cGRhdGUodC5sYXllcnMsIHQucmVtb3ZlZElkcyksIHIoKTtcbiAgICB9LCBTZS5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRXb3JrZXJTb3VyY2UoZSwgdC50eXBlLCB0LnNvdXJjZSkubG9hZFRpbGUodCwgcik7XG4gICAgfSwgU2UucHJvdG90eXBlLmxvYWRERU1UaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0REVNV29ya2VyU291cmNlKGUsIHQuc291cmNlKS5sb2FkVGlsZSh0LCByKTtcbiAgICB9LCBTZS5wcm90b3R5cGUucmVsb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICB0aGlzLmdldFdvcmtlclNvdXJjZShlLCB0LnR5cGUsIHQuc291cmNlKS5yZWxvYWRUaWxlKHQsIHIpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5hYm9ydFRpbGUgPSBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgICAgdGhpcy5nZXRXb3JrZXJTb3VyY2UoZSwgdC50eXBlLCB0LnNvdXJjZSkuYWJvcnRUaWxlKHQsIHIpO1xuICAgIH0sIFNlLnByb3RvdHlwZS5yZW1vdmVUaWxlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRoaXMuZ2V0V29ya2VyU291cmNlKGUsIHQudHlwZSwgdC5zb3VyY2UpLnJlbW92ZVRpbGUodCwgcik7XG4gICAgfSwgU2UucHJvdG90eXBlLnJlbW92ZURFTVRpbGUgPSBmdW5jdGlvbiAoZSwgdCkge1xuICAgICAgdGhpcy5nZXRERU1Xb3JrZXJTb3VyY2UoZSwgdC5zb3VyY2UpLnJlbW92ZVRpbGUodCk7XG4gICAgfSwgU2UucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgICBpZiAodGhpcy53b3JrZXJTb3VyY2VzW2VdICYmIHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdICYmIHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdW3Quc291cmNlXSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdW3Quc291cmNlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMud29ya2VyU291cmNlc1tlXVt0LnR5cGVdW3Quc291cmNlXSwgdm9pZCAwICE9PSBpLnJlbW92ZVNvdXJjZSA/IGkucmVtb3ZlU291cmNlKHQsIHIpIDogcigpO1xuICAgICAgfVxuICAgIH0sIFNlLnByb3RvdHlwZS5sb2FkV29ya2VyU291cmNlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2VsZi5pbXBvcnRTY3JpcHRzKHQudXJsKSwgcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByKGUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSwgU2UucHJvdG90eXBlLnN5bmNSVExQbHVnaW5TdGF0ZSA9IGZ1bmN0aW9uICh0LCByLCBpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlLnBsdWdpbi5zZXRTdGF0ZShyKTtcbiAgICAgICAgdmFyIG8gPSBlLnBsdWdpbi5nZXRQbHVnaW5VUkwoKTtcbiAgICAgICAgaWYgKGUucGx1Z2luLmlzTG9hZGVkKCkgJiYgIWUucGx1Z2luLmlzUGFyc2VkKCkgJiYgbnVsbCAhPSBvKSB7XG4gICAgICAgICAgdGhpcy5zZWxmLmltcG9ydFNjcmlwdHMobyk7XG4gICAgICAgICAgdmFyIG4gPSBlLnBsdWdpbi5pc1BhcnNlZCgpO1xuICAgICAgICAgIGkobiA/IHZvaWQgMCA6IG5ldyBFcnJvcihcIlJUTCBUZXh0IFBsdWdpbiBmYWlsZWQgdG8gaW1wb3J0IHNjcmlwdHMgZnJvbSBcIiArIG8pLCBuKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpKGUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSwgU2UucHJvdG90eXBlLmdldEF2YWlsYWJsZUltYWdlcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuYXZhaWxhYmxlSW1hZ2VzW2VdO1xuICAgICAgcmV0dXJuIHQgfHwgKHQgPSBbXSksIHQ7XG4gICAgfSwgU2UucHJvdG90eXBlLmdldExheWVySW5kZXggPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLmxheWVySW5kZXhlc1tlXTtcbiAgICAgIHJldHVybiB0IHx8ICh0ID0gdGhpcy5sYXllckluZGV4ZXNbZV0gPSBuZXcgaSgpKSwgdDtcbiAgICB9LCBTZS5wcm90b3R5cGUuZ2V0V29ya2VyU291cmNlID0gZnVuY3Rpb24gKGUsIHQsIHIpIHtcbiAgICAgIHZhciBpID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndvcmtlclNvdXJjZXNbZV0gfHwgKHRoaXMud29ya2VyU291cmNlc1tlXSA9IHt9KSwgdGhpcy53b3JrZXJTb3VyY2VzW2VdW3RdIHx8ICh0aGlzLndvcmtlclNvdXJjZXNbZV1bdF0gPSB7fSksIHRoaXMud29ya2VyU291cmNlc1tlXVt0XVtyXSB8fCAodGhpcy53b3JrZXJTb3VyY2VzW2VdW3RdW3JdID0gbmV3IHRoaXMud29ya2VyU291cmNlVHlwZXNbdF0oe1xuICAgICAgICBzZW5kOiBmdW5jdGlvbiAodCwgciwgbykge1xuICAgICAgICAgIGkuYWN0b3Iuc2VuZCh0LCByLCBvLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5nZXRMYXllckluZGV4KGUpLCB0aGlzLmdldEF2YWlsYWJsZUltYWdlcyhlKSkpLCB0aGlzLndvcmtlclNvdXJjZXNbZV1bdF1bcl07XG4gICAgfSwgU2UucHJvdG90eXBlLmdldERFTVdvcmtlclNvdXJjZSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZW1Xb3JrZXJTb3VyY2VzW2VdIHx8ICh0aGlzLmRlbVdvcmtlclNvdXJjZXNbZV0gPSB7fSksIHRoaXMuZGVtV29ya2VyU291cmNlc1tlXVt0XSB8fCAodGhpcy5kZW1Xb3JrZXJTb3VyY2VzW2VdW3RdID0gbmV3IGgoKSksIHRoaXMuZGVtV29ya2VyU291cmNlc1tlXVt0XTtcbiAgICB9LCBTZS5wcm90b3R5cGUuZW5mb3JjZUNhY2hlU2l6ZUxpbWl0ID0gZnVuY3Rpb24gKHQsIHIpIHtcbiAgICAgIGUuZW5mb3JjZUNhY2hlU2l6ZUxpbWl0KHIpO1xuICAgIH0sIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmIChzZWxmLndvcmtlciA9IG5ldyBTZShzZWxmKSksIFNlO1xuICB9KTtcbiAgZGVmaW5lKFtcIi4vc2hhcmVkXCJdLCBmdW5jdGlvbiAodCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGUgPSB0LmNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUodCkge1xuICAgICAgICAgIHJldHVybiAhaSh0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93IHx8IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGRvY3VtZW50ID8gXCJub3QgYSBicm93c2VyXCIgOiBBcnJheS5wcm90b3R5cGUgJiYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgJiYgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiYgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mICYmIEFycmF5LnByb3RvdHlwZS5tYXAgJiYgQXJyYXkucHJvdG90eXBlLnNvbWUgJiYgQXJyYXkucHJvdG90eXBlLnJlZHVjZSAmJiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiYgQXJyYXkuaXNBcnJheSA/IEZ1bmN0aW9uLnByb3RvdHlwZSAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA/IE9iamVjdC5rZXlzICYmIE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzICYmIE9iamVjdC5pc1NlYWxlZCAmJiBPYmplY3QuaXNGcm96ZW4gJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAmJiBPYmplY3Quc2VhbCAmJiBPYmplY3QuZnJlZXplICYmIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA/IFwiSlNPTlwiIGluIHdpbmRvdyAmJiBcInBhcnNlXCIgaW4gSlNPTiAmJiBcInN0cmluZ2lmeVwiIGluIEpTT04gPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIShcIldvcmtlclwiIGluIHdpbmRvdyAmJiBcIkJsb2JcIiBpbiB3aW5kb3cgJiYgXCJVUkxcIiBpbiB3aW5kb3cpKSByZXR1cm4gITE7XG4gICAgICAgICAgICB2YXIgdCxcbiAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgaSA9IG5ldyBCbG9iKFtcIlwiXSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG8gPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZSA9IG5ldyBXb3JrZXIobyksIHQgPSAhMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdCA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGUgJiYgZS50ZXJtaW5hdGUoKSwgVVJMLnJldm9rZU9iamVjdFVSTChvKSwgdDtcbiAgICAgICAgICB9KCkgPyBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIgaW4gd2luZG93ID8gQXJyYXlCdWZmZXIuaXNWaWV3ID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgdC53aWR0aCA9IHQuaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgIHZhciBlID0gdC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBpZiAoIWUpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHZhciBpID0gZS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gaSAmJiBpLndpZHRoID09PSB0LndpZHRoO1xuICAgICAgICAgIH0oKSA/ICh2b2lkIDAgPT09IG9baSA9IHQgJiYgdC5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XSAmJiAob1tpXSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgICAgICBvID0gT2JqZWN0LmNyZWF0ZShlLndlYkdMQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gby5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID0gdCwgaS5wcm9iYWJseVN1cHBvcnRzQ29udGV4dCA/IGkucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoXCJ3ZWJnbFwiLCBvKSB8fCBpLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIG8pIDogaS5zdXBwb3J0c0NvbnRleHQgPyBpLnN1cHBvcnRzQ29udGV4dChcIndlYmdsXCIsIG8pIHx8IGkuc3VwcG9ydHNDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIG8pIDogaS5nZXRDb250ZXh0KFwid2ViZ2xcIiwgbykgfHwgaS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIG8pO1xuICAgICAgICAgICAgfSh0KTtcbiAgICAgICAgICAgIGlmICghaSkgcmV0dXJuICExO1xuICAgICAgICAgICAgdmFyIG8gPSBpLmNyZWF0ZVNoYWRlcihpLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICAgICAgcmV0dXJuICEoIW8gfHwgaS5pc0NvbnRleHRMb3N0KCkpICYmIChpLnNoYWRlclNvdXJjZShvLCBcInZvaWQgbWFpbigpIHt9XCIpLCBpLmNvbXBpbGVTaGFkZXIobyksICEwID09PSBpLmdldFNoYWRlclBhcmFtZXRlcihvLCBpLkNPTVBJTEVfU1RBVFVTKSk7XG4gICAgICAgICAgfShpKSksIG9baV0gPyB2b2lkIDAgOiBcImluc3VmZmljaWVudCBXZWJHTCBzdXBwb3J0XCIpIDogXCJpbnN1ZmZpY2llbnQgQ2FudmFzL2dldEltYWdlRGF0YSBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBBcnJheUJ1ZmZlciBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBVaW50OENsYW1wZWRBcnJheSBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCB3b3JrZXIgc3VwcG9ydFwiIDogXCJpbnN1ZmZpY2llbnQgSlNPTiBzdXBwb3J0XCIgOiBcImluc3VmZmljaWVudCBPYmplY3Qgc3VwcG9ydFwiIDogXCJpbnN1ZmZpY2llbnQgRnVuY3Rpb24gc3VwcG9ydFwiIDogXCJpbnN1ZmZpY2VudCBBcnJheSBzdXBwb3J0XCI7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgIH1cbiAgICAgICAgdC5leHBvcnRzID8gdC5leHBvcnRzID0gZSA6IHdpbmRvdyAmJiAod2luZG93Lm1hcGJveGdsID0gd2luZG93Lm1hcGJveGdsIHx8IHt9LCB3aW5kb3cubWFwYm94Z2wuc3VwcG9ydGVkID0gZSwgd2luZG93Lm1hcGJveGdsLm5vdFN1cHBvcnRlZFJlYXNvbiA9IGkpO1xuICAgICAgICB2YXIgbyA9IHt9O1xuICAgICAgICBlLndlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgYW50aWFsaWFzOiAhMSxcbiAgICAgICAgICBhbHBoYTogITAsXG4gICAgICAgICAgc3RlbmNpbDogITAsXG4gICAgICAgICAgZGVwdGg6ICEwXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIGkgPSB7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICB2YXIgciA9IHQud2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gaSAmJiAoci5jbGFzc05hbWUgPSBpKSwgbyAmJiBvLmFwcGVuZENoaWxkKHIpLCByO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVOUzogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gdC53aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGUsIGkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbyA9IHQud2luZG93LmRvY3VtZW50ICYmIHQud2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbiAgICBmdW5jdGlvbiByKHQpIHtcbiAgICAgIGlmICghbykgcmV0dXJuIHRbMF07XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQubGVuZ3RoOyBlKyspIGlmICh0W2VdIGluIG8pIHJldHVybiB0W2VdO1xuICAgICAgcmV0dXJuIHRbMF07XG4gICAgfVxuICAgIHZhciBhLFxuICAgICAgbiA9IHIoW1widXNlclNlbGVjdFwiLCBcIk1velVzZXJTZWxlY3RcIiwgXCJXZWJraXRVc2VyU2VsZWN0XCIsIFwibXNVc2VyU2VsZWN0XCJdKTtcbiAgICBpLmRpc2FibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgbyAmJiBuICYmIChhID0gb1tuXSwgb1tuXSA9IFwibm9uZVwiKTtcbiAgICB9LCBpLmVuYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBvICYmIG4gJiYgKG9bbl0gPSBhKTtcbiAgICB9O1xuICAgIHZhciBzID0gcihbXCJ0cmFuc2Zvcm1cIiwgXCJXZWJraXRUcmFuc2Zvcm1cIl0pO1xuICAgIGkuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHQuc3R5bGVbc10gPSBlO1xuICAgIH07XG4gICAgdmFyIGwgPSAhMTtcbiAgICB0cnkge1xuICAgICAgdmFyIGMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGwgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBjLCBjKSwgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgYywgYyk7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgbCA9ICExO1xuICAgIH1cbiAgICBpLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgdm9pZCAwID09PSBvICYmIChvID0ge30pLCB0LmFkZEV2ZW50TGlzdGVuZXIoZSwgaSwgXCJwYXNzaXZlXCIgaW4gbyAmJiBsID8gbyA6IG8uY2FwdHVyZSk7XG4gICAgfSwgaS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGksIFwicGFzc2l2ZVwiIGluIG8gJiYgbCA/IG8gOiBvLmNhcHR1cmUpO1xuICAgIH07XG4gICAgdmFyIHUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCB0LndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdSwgITApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaCh0KSB7XG4gICAgICB2YXIgZSA9IHQudXNlckltYWdlO1xuICAgICAgcmV0dXJuICEhKGUgJiYgZS5yZW5kZXIgJiYgZS5yZW5kZXIoKSkgJiYgKHQuZGF0YS5yZXBsYWNlKG5ldyBVaW50OEFycmF5KGUuZGF0YS5idWZmZXIpKSwgITApO1xuICAgIH1cbiAgICBpLnN1cHByZXNzQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdSwgITApLCB0LndpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHUsICEwKTtcbiAgICAgIH0sIDApO1xuICAgIH0sIGkubW91c2VQb3MgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIG5ldyB0LlBvaW50KGkuY2xpZW50WCAtIG8ubGVmdCAtIGUuY2xpZW50TGVmdCwgaS5jbGllbnRZIC0gby50b3AgLSBlLmNsaWVudFRvcCk7XG4gICAgfSwgaS50b3VjaFBvcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgciA9IFtdLCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHIucHVzaChuZXcgdC5Qb2ludChpW2FdLmNsaWVudFggLSBvLmxlZnQgLSBlLmNsaWVudExlZnQsIGlbYV0uY2xpZW50WSAtIG8udG9wIC0gZS5jbGllbnRUb3ApKTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sIGkubW91c2VCdXR0b24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdC53aW5kb3cuSW5zdGFsbFRyaWdnZXIgJiYgMiA9PT0gZS5idXR0b24gJiYgZS5jdHJsS2V5ICYmIHQud2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXCJNQUNcIikgPj0gMCA/IDAgOiBlLmJ1dHRvbjtcbiAgICB9LCBpLnJlbW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnBhcmVudE5vZGUgJiYgdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpO1xuICAgIH07XG4gICAgdmFyIHAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5pbWFnZXMgPSB7fSwgdGhpcy51cGRhdGVkSW1hZ2VzID0ge30sIHRoaXMuY2FsbGJhY2tEaXNwYXRjaGVkVGhpc0ZyYW1lID0ge30sIHRoaXMubG9hZGVkID0gITEsIHRoaXMucmVxdWVzdG9ycyA9IFtdLCB0aGlzLnBhdHRlcm5zID0ge30sIHRoaXMuYXRsYXNJbWFnZSA9IG5ldyB0LlJHQkFJbWFnZSh7XG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICAgIH0pLCB0aGlzLmRpcnR5ID0gITA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRMb2FkZWQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0aGlzLmxvYWRlZCAhPT0gdCAmJiAodGhpcy5sb2FkZWQgPSB0LCB0KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgZSA9IDAsIGkgPSB0aGlzLnJlcXVlc3RvcnM7IGUgPCBpLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gaVtlXTtcbiAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5KG8uaWRzLCBvLmNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdG9ycyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlc1t0XTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuYWRkSW1hZ2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlKHQsIGUpICYmICh0aGlzLmltYWdlc1t0XSA9IGUpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gITA7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlU3RyZXRjaChpLnN0cmV0Y2hYLCBpLmRhdGEgJiYgaS5kYXRhLndpZHRoKSB8fCAodGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdJbWFnZSBcIicgKyBlICsgJ1wiIGhhcyBpbnZhbGlkIFwic3RyZXRjaFhcIiB2YWx1ZScpKSksIG8gPSAhMSksIHRoaXMuX3ZhbGlkYXRlU3RyZXRjaChpLnN0cmV0Y2hZLCBpLmRhdGEgJiYgaS5kYXRhLmhlaWdodCkgfHwgKHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignSW1hZ2UgXCInICsgZSArICdcIiBoYXMgaW52YWxpZCBcInN0cmV0Y2hZXCIgdmFsdWUnKSkpLCBvID0gITEpLCB0aGlzLl92YWxpZGF0ZUNvbnRlbnQoaS5jb250ZW50LCBpKSB8fCAodGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdJbWFnZSBcIicgKyBlICsgJ1wiIGhhcyBpbnZhbGlkIFwiY29udGVudFwiIHZhbHVlJykpKSwgbyA9ICExKSwgbztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlU3RyZXRjaCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgaWYgKCF0KSByZXR1cm4gITA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG8gPSAwLCByID0gdDsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhID0gcltvXTtcbiAgICAgICAgICAgIGlmIChhWzBdIDwgaSB8fCBhWzFdIDwgYVswXSB8fCBlIDwgYVsxXSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaSA9IGFbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlQ29udGVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuICEodCAmJiAoNCAhPT0gdC5sZW5ndGggfHwgdFswXSA8IDAgfHwgZS5kYXRhLndpZHRoIDwgdFswXSB8fCB0WzFdIDwgMCB8fCBlLmRhdGEuaGVpZ2h0IDwgdFsxXSB8fCB0WzJdIDwgMCB8fCBlLmRhdGEud2lkdGggPCB0WzJdIHx8IHRbM10gPCAwIHx8IGUuZGF0YS5oZWlnaHQgPCB0WzNdIHx8IHRbMl0gPCB0WzBdIHx8IHRbM10gPCB0WzFdKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZUltYWdlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBlLnZlcnNpb24gPSB0aGlzLmltYWdlc1t0XS52ZXJzaW9uICsgMSwgdGhpcy5pbWFnZXNbdF0gPSBlLCB0aGlzLnVwZGF0ZWRJbWFnZXNbdF0gPSAhMDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlSW1hZ2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5pbWFnZXNbdF07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuaW1hZ2VzW3RdLCBkZWxldGUgdGhpcy5wYXR0ZXJuc1t0XSwgZS51c2VySW1hZ2UgJiYgZS51c2VySW1hZ2Uub25SZW1vdmUgJiYgZS51c2VySW1hZ2Uub25SZW1vdmUoKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUubGlzdEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5pbWFnZXMpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRJbWFnZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHZhciBpID0gITA7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKCkpIGZvciAodmFyIG8gPSAwLCByID0gdDsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHRoaXMuaW1hZ2VzW3Jbb11dIHx8IChpID0gITEpO1xuICAgICAgICAgIHRoaXMuaXNMb2FkZWQoKSB8fCBpID8gdGhpcy5fbm90aWZ5KHQsIGUpIDogdGhpcy5yZXF1ZXN0b3JzLnB1c2goe1xuICAgICAgICAgICAgaWRzOiB0LFxuICAgICAgICAgICAgY2FsbGJhY2s6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX25vdGlmeSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgZm9yICh2YXIgbyA9IHt9LCByID0gMCwgYSA9IGU7IHIgPCBhLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGFbcl07XG4gICAgICAgICAgICB0aGlzLmltYWdlc1tuXSB8fCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJzdHlsZWltYWdlbWlzc2luZ1wiLCB7XG4gICAgICAgICAgICAgIGlkOiBuXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuaW1hZ2VzW25dO1xuICAgICAgICAgICAgcyA/IG9bbl0gPSB7XG4gICAgICAgICAgICAgIGRhdGE6IHMuZGF0YS5jbG9uZSgpLFxuICAgICAgICAgICAgICBwaXhlbFJhdGlvOiBzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgIHNkZjogcy5zZGYsXG4gICAgICAgICAgICAgIHZlcnNpb246IHMudmVyc2lvbixcbiAgICAgICAgICAgICAgc3RyZXRjaFg6IHMuc3RyZXRjaFgsXG4gICAgICAgICAgICAgIHN0cmV0Y2hZOiBzLnN0cmV0Y2hZLFxuICAgICAgICAgICAgICBjb250ZW50OiBzLmNvbnRlbnQsXG4gICAgICAgICAgICAgIGhhc1JlbmRlckNhbGxiYWNrOiBCb29sZWFuKHMudXNlckltYWdlICYmIHMudXNlckltYWdlLnJlbmRlcilcbiAgICAgICAgICAgIH0gOiB0Lndhcm5PbmNlKCdJbWFnZSBcIicgKyBuICsgJ1wiIGNvdWxkIG5vdCBiZSBsb2FkZWQuIFBsZWFzZSBtYWtlIHN1cmUgeW91IGhhdmUgYWRkZWQgdGhlIGltYWdlIHdpdGggbWFwLmFkZEltYWdlKCkgb3IgYSBcInNwcml0ZVwiIHByb3BlcnR5IGluIHlvdXIgc3R5bGUuIFlvdSBjYW4gcHJvdmlkZSBtaXNzaW5nIGltYWdlcyBieSBsaXN0ZW5pbmcgZm9yIHRoZSBcInN0eWxlaW1hZ2VtaXNzaW5nXCIgbWFwIGV2ZW50LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpKG51bGwsIG8pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRQaXhlbFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmF0bGFzSW1hZ2U7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0LmhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldFBhdHRlcm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5wYXR0ZXJuc1tlXSxcbiAgICAgICAgICAgIG8gPSB0aGlzLmdldEltYWdlKGUpO1xuICAgICAgICAgIGlmICghbykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKGkgJiYgaS5wb3NpdGlvbi52ZXJzaW9uID09PSBvLnZlcnNpb24pIHJldHVybiBpLnBvc2l0aW9uO1xuICAgICAgICAgIGlmIChpKSBpLnBvc2l0aW9uLnZlcnNpb24gPSBvLnZlcnNpb247ZWxzZSB7XG4gICAgICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICAgICAgICB3OiBvLmRhdGEud2lkdGggKyAyLFxuICAgICAgICAgICAgICAgIGg6IG8uZGF0YS5oZWlnaHQgKyAyLFxuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhID0gbmV3IHQuSW1hZ2VQb3NpdGlvbihyLCBvKTtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybnNbZV0gPSB7XG4gICAgICAgICAgICAgIGJpbjogcixcbiAgICAgICAgICAgICAgcG9zaXRpb246IGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVQYXR0ZXJuQXRsYXMoKSwgdGhpcy5wYXR0ZXJuc1tlXS5wb3NpdGlvbjtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGkgPSBlLmdsO1xuICAgICAgICAgIHRoaXMuYXRsYXNUZXh0dXJlID8gdGhpcy5kaXJ0eSAmJiAodGhpcy5hdGxhc1RleHR1cmUudXBkYXRlKHRoaXMuYXRsYXNJbWFnZSksIHRoaXMuZGlydHkgPSAhMSkgOiB0aGlzLmF0bGFzVGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZSwgdGhpcy5hdGxhc0ltYWdlLCBpLlJHQkEpLCB0aGlzLmF0bGFzVGV4dHVyZS5iaW5kKGkuTElORUFSLCBpLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fdXBkYXRlUGF0dGVybkF0bGFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnBhdHRlcm5zKSBlLnB1c2godGhpcy5wYXR0ZXJuc1tpXS5iaW4pO1xuICAgICAgICAgIHZhciBvID0gdC5wb3RwYWNrKGUpLFxuICAgICAgICAgICAgciA9IG8udyxcbiAgICAgICAgICAgIGEgPSBvLmgsXG4gICAgICAgICAgICBuID0gdGhpcy5hdGxhc0ltYWdlO1xuICAgICAgICAgIGZvciAodmFyIHMgaW4gbi5yZXNpemUoe1xuICAgICAgICAgICAgd2lkdGg6IHIgfHwgMSxcbiAgICAgICAgICAgIGhlaWdodDogYSB8fCAxXG4gICAgICAgICAgfSksIHRoaXMucGF0dGVybnMpIHtcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5wYXR0ZXJuc1tzXS5iaW4sXG4gICAgICAgICAgICAgIGMgPSBsLnggKyAxLFxuICAgICAgICAgICAgICB1ID0gbC55ICsgMSxcbiAgICAgICAgICAgICAgaCA9IHRoaXMuaW1hZ2VzW3NdLmRhdGEsXG4gICAgICAgICAgICAgIHAgPSBoLndpZHRoLFxuICAgICAgICAgICAgICBkID0gaC5oZWlnaHQ7XG4gICAgICAgICAgICB0LlJHQkFJbWFnZS5jb3B5KGgsIG4sIHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB4OiBjLFxuICAgICAgICAgICAgICB5OiB1XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGRcbiAgICAgICAgICAgIH0pLCB0LlJHQkFJbWFnZS5jb3B5KGgsIG4sIHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogZCAtIDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgeDogYyxcbiAgICAgICAgICAgICAgeTogdSAtIDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHAsXG4gICAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICAgICAgfSksIHQuUkdCQUltYWdlLmNvcHkoaCwgbiwge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHg6IGMsXG4gICAgICAgICAgICAgIHk6IHUgKyBkXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgICAgIH0pLCB0LlJHQkFJbWFnZS5jb3B5KGgsIG4sIHtcbiAgICAgICAgICAgICAgeDogcCAtIDEsXG4gICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgeDogYyAtIDEsXG4gICAgICAgICAgICAgIHk6IHVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgIGhlaWdodDogZFxuICAgICAgICAgICAgfSksIHQuUkdCQUltYWdlLmNvcHkoaCwgbiwge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHg6IGMgKyBwLFxuICAgICAgICAgICAgICB5OiB1XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRpcnR5ID0gITA7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmJlZ2luRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja0Rpc3BhdGNoZWRUaGlzRnJhbWUgPSB7fTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZGlzcGF0Y2hSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGZvciAodmFyIGUgPSAwLCBpID0gdDsgZSA8IGkubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBvID0gaVtlXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsYmFja0Rpc3BhdGNoZWRUaGlzRnJhbWVbb10pIHtcbiAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0Rpc3BhdGNoZWRUaGlzRnJhbWVbb10gPSAhMDtcbiAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmltYWdlc1tvXTtcbiAgICAgICAgICAgICAgaChyKSAmJiB0aGlzLnVwZGF0ZUltYWdlKG8sIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgaTtcbiAgICAgIH0odC5FdmVudGVkKSxcbiAgICAgIGQgPSBtLFxuICAgICAgXyA9IG0sXG4gICAgICBmID0gMWUyMDtcbiAgICBmdW5jdGlvbiBtKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHRoaXMuZm9udFNpemUgPSB0IHx8IDI0LCB0aGlzLmJ1ZmZlciA9IHZvaWQgMCA9PT0gZSA/IDMgOiBlLCB0aGlzLmN1dG9mZiA9IG8gfHwgLjI1LCB0aGlzLmZvbnRGYW1pbHkgPSByIHx8IFwic2Fucy1zZXJpZlwiLCB0aGlzLmZvbnRXZWlnaHQgPSBhIHx8IFwibm9ybWFsXCIsIHRoaXMucmFkaXVzID0gaSB8fCA4O1xuICAgICAgdmFyIG4gPSB0aGlzLnNpemUgPSB0aGlzLmZvbnRTaXplICsgMiAqIHRoaXMuYnVmZmVyO1xuICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IG4sIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0aGlzLmN0eC5mb250ID0gdGhpcy5mb250V2VpZ2h0ICsgXCIgXCIgKyB0aGlzLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuZm9udEZhbWlseSwgdGhpcy5jdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgdGhpcy5jdHguZmlsbFN0eWxlID0gXCJibGFja1wiLCB0aGlzLmdyaWRPdXRlciA9IG5ldyBGbG9hdDY0QXJyYXkobiAqIG4pLCB0aGlzLmdyaWRJbm5lciA9IG5ldyBGbG9hdDY0QXJyYXkobiAqIG4pLCB0aGlzLmYgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLCB0aGlzLmQgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLCB0aGlzLnogPSBuZXcgRmxvYXQ2NEFycmF5KG4gKyAxKSwgdGhpcy52ID0gbmV3IEludDE2QXJyYXkobiksIHRoaXMubWlkZGxlID0gTWF0aC5yb3VuZChuIC8gMiAqIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJHZWNrby9cIikgPj0gMCA/IDEuMiA6IDEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZyh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IGU7IHMrKykge1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGk7IGwrKykgb1tsXSA9IHRbbCAqIGUgKyBzXTtcbiAgICAgICAgZm9yICh2KG8sIHIsIGEsIG4sIGkpLCBsID0gMDsgbCA8IGk7IGwrKykgdFtsICogZSArIHNdID0gcltsXTtcbiAgICAgIH1cbiAgICAgIGZvciAobCA9IDA7IGwgPCBpOyBsKyspIHtcbiAgICAgICAgZm9yIChzID0gMDsgcyA8IGU7IHMrKykgb1tzXSA9IHRbbCAqIGUgKyBzXTtcbiAgICAgICAgZm9yICh2KG8sIHIsIGEsIG4sIGUpLCBzID0gMDsgcyA8IGU7IHMrKykgdFtsICogZSArIHNdID0gTWF0aC5zcXJ0KHJbc10pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB2KHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIGlbMF0gPSAwLCBvWzBdID0gLWYsIG9bMV0gPSArZjtcbiAgICAgIGZvciAodmFyIGEgPSAxLCBuID0gMDsgYSA8IHI7IGErKykge1xuICAgICAgICBmb3IgKHZhciBzID0gKHRbYV0gKyBhICogYSAtICh0W2lbbl1dICsgaVtuXSAqIGlbbl0pKSAvICgyICogYSAtIDIgKiBpW25dKTsgcyA8PSBvW25dOykgbi0tLCBzID0gKHRbYV0gKyBhICogYSAtICh0W2lbbl1dICsgaVtuXSAqIGlbbl0pKSAvICgyICogYSAtIDIgKiBpW25dKTtcbiAgICAgICAgaVsrK25dID0gYSwgb1tuXSA9IHMsIG9bbiArIDFdID0gK2Y7XG4gICAgICB9XG4gICAgICBmb3IgKGEgPSAwLCBuID0gMDsgYSA8IHI7IGErKykge1xuICAgICAgICBmb3IgKDsgb1tuICsgMV0gPCBhOykgbisrO1xuICAgICAgICBlW2FdID0gKGEgLSBpW25dKSAqIChhIC0gaVtuXSkgKyB0W2lbbl1dO1xuICAgICAgfVxuICAgIH1cbiAgICBtLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnNpemUsIHRoaXMuc2l6ZSksIHRoaXMuY3R4LmZpbGxUZXh0KHQsIHRoaXMuYnVmZmVyLCB0aGlzLm1pZGRsZSk7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuc2l6ZSwgdGhpcy5zaXplKSwgaSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLnNpemUgKiB0aGlzLnNpemUpLCBvID0gMDsgbyA8IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTsgbysrKSB7XG4gICAgICAgIHZhciByID0gZS5kYXRhWzQgKiBvICsgM10gLyAyNTU7XG4gICAgICAgIHRoaXMuZ3JpZE91dGVyW29dID0gMSA9PT0gciA/IDAgOiAwID09PSByID8gZiA6IE1hdGgucG93KE1hdGgubWF4KDAsIC41IC0gciksIDIpLCB0aGlzLmdyaWRJbm5lcltvXSA9IDEgPT09IHIgPyBmIDogMCA9PT0gciA/IDAgOiBNYXRoLnBvdyhNYXRoLm1heCgwLCByIC0gLjUpLCAyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoZyh0aGlzLmdyaWRPdXRlciwgdGhpcy5zaXplLCB0aGlzLnNpemUsIHRoaXMuZiwgdGhpcy5kLCB0aGlzLnYsIHRoaXMueiksIGcodGhpcy5ncmlkSW5uZXIsIHRoaXMuc2l6ZSwgdGhpcy5zaXplLCB0aGlzLmYsIHRoaXMuZCwgdGhpcy52LCB0aGlzLnopLCBvID0gMDsgbyA8IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTsgbysrKSBpW29dID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKDI1NSAtIDI1NSAqICgodGhpcy5ncmlkT3V0ZXJbb10gLSB0aGlzLmdyaWRJbm5lcltvXSkgLyB0aGlzLnJhZGl1cyArIHRoaXMuY3V0b2ZmKSkpKTtcbiAgICAgIHJldHVybiBpO1xuICAgIH0sIGQuZGVmYXVsdCA9IF87XG4gICAgdmFyIHkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IHQsIHRoaXMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5ID0gZSwgdGhpcy5lbnRyaWVzID0ge307XG4gICAgfTtcbiAgICB5LnByb3RvdHlwZS5zZXRVUkwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy51cmwgPSB0O1xuICAgIH0sIHkucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMsXG4gICAgICAgIHIgPSBbXTtcbiAgICAgIGZvciAodmFyIGEgaW4gZSkgZm9yICh2YXIgbiA9IDAsIHMgPSBlW2FdOyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkgci5wdXNoKHtcbiAgICAgICAgc3RhY2s6IGEsXG4gICAgICAgIGlkOiBzW25dXG4gICAgICB9KTtcbiAgICAgIHQuYXN5bmNBbGwociwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0LnN0YWNrLFxuICAgICAgICAgIHIgPSB0LmlkLFxuICAgICAgICAgIGEgPSBvLmVudHJpZXNbaV07XG4gICAgICAgIGEgfHwgKGEgPSBvLmVudHJpZXNbaV0gPSB7XG4gICAgICAgICAgZ2x5cGhzOiB7fSxcbiAgICAgICAgICByZXF1ZXN0czoge30sXG4gICAgICAgICAgcmFuZ2VzOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG4gPSBhLmdseXBoc1tyXTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgICAgICAgIGlmIChuID0gby5fdGlueVNERihhLCBpLCByKSkgcmV0dXJuIGEuZ2x5cGhzW3JdID0gbiwgdm9pZCBlKG51bGwsIHtcbiAgICAgICAgICAgIHN0YWNrOiBpLFxuICAgICAgICAgICAgaWQ6IHIsXG4gICAgICAgICAgICBnbHlwaDogblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzID0gTWF0aC5mbG9vcihyIC8gMjU2KTtcbiAgICAgICAgICBpZiAoMjU2ICogcyA+IDY1NTM1KSBlKG5ldyBFcnJvcihcImdseXBocyA+IDY1NTM1IG5vdCBzdXBwb3J0ZWRcIikpO2Vsc2UgaWYgKGEucmFuZ2VzW3NdKSBlKG51bGwsIHtcbiAgICAgICAgICAgIHN0YWNrOiBpLFxuICAgICAgICAgICAgaWQ6IHIsXG4gICAgICAgICAgICBnbHlwaDogblxuICAgICAgICAgIH0pO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGwgPSBhLnJlcXVlc3RzW3NdO1xuICAgICAgICAgICAgbCB8fCAobCA9IGEucmVxdWVzdHNbc10gPSBbXSwgeS5sb2FkR2x5cGhSYW5nZShpLCBzLCBvLnVybCwgby5yZXF1ZXN0TWFuYWdlciwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGUpIG8uX2RvZXNDaGFyU3VwcG9ydExvY2FsR2x5cGgoK2kpIHx8IChhLmdseXBoc1sraV0gPSBlWytpXSk7XG4gICAgICAgICAgICAgICAgYS5yYW5nZXNbc10gPSAhMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgbiA9IGw7IHIgPCBuLmxlbmd0aDsgciArPSAxKSAoMCwgbltyXSkodCwgZSk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhLnJlcXVlc3RzW3NdO1xuICAgICAgICAgICAgfSkpLCBsLnB1c2goZnVuY3Rpb24gKHQsIG8pIHtcbiAgICAgICAgICAgICAgdCA/IGUodCkgOiBvICYmIGUobnVsbCwge1xuICAgICAgICAgICAgICAgIHN0YWNrOiBpLFxuICAgICAgICAgICAgICAgIGlkOiByLFxuICAgICAgICAgICAgICAgIGdseXBoOiBvW3JdIHx8IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBlKG51bGwsIHtcbiAgICAgICAgICBzdGFjazogaSxcbiAgICAgICAgICBpZDogcixcbiAgICAgICAgICBnbHlwaDogblxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGlmICh0KSBpKHQpO2Vsc2UgaWYgKGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0ge30sIHIgPSAwLCBhID0gZTsgciA8IGEubGVuZ3RoOyByICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuID0gYVtyXSxcbiAgICAgICAgICAgICAgcyA9IG4uc3RhY2ssXG4gICAgICAgICAgICAgIGwgPSBuLmlkLFxuICAgICAgICAgICAgICBjID0gbi5nbHlwaDtcbiAgICAgICAgICAgIChvW3NdIHx8IChvW3NdID0ge30pKVtsXSA9IGMgJiYge1xuICAgICAgICAgICAgICBpZDogYy5pZCxcbiAgICAgICAgICAgICAgYml0bWFwOiBjLmJpdG1hcC5jbG9uZSgpLFxuICAgICAgICAgICAgICBtZXRyaWNzOiBjLm1ldHJpY3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGkobnVsbCwgbyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHkucHJvdG90eXBlLl9kb2VzQ2hhclN1cHBvcnRMb2NhbEdseXBoID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5ICYmICh0LmlzQ2hhcltcIkNKSyBVbmlmaWVkIElkZW9ncmFwaHNcIl0oZSkgfHwgdC5pc0NoYXJbXCJIYW5ndWwgU3lsbGFibGVzXCJdKGUpIHx8IHQuaXNDaGFyLkhpcmFnYW5hKGUpIHx8IHQuaXNDaGFyLkthdGFrYW5hKGUpKTtcbiAgICB9LCB5LnByb3RvdHlwZS5fdGlueVNERiA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXMubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5O1xuICAgICAgaWYgKHIgJiYgdGhpcy5fZG9lc0NoYXJTdXBwb3J0TG9jYWxHbHlwaChvKSkge1xuICAgICAgICB2YXIgYSA9IGUudGlueVNERjtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgdmFyIG4gPSBcIjQwMFwiO1xuICAgICAgICAgIC9ib2xkL2kudGVzdChpKSA/IG4gPSBcIjkwMFwiIDogL21lZGl1bS9pLnRlc3QoaSkgPyBuID0gXCI1MDBcIiA6IC9saWdodC9pLnRlc3QoaSkgJiYgKG4gPSBcIjIwMFwiKSwgYSA9IGUudGlueVNERiA9IG5ldyB5LlRpbnlTREYoMjQsIDMsIDgsIC4yNSwgciwgbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogbyxcbiAgICAgICAgICBiaXRtYXA6IG5ldyB0LkFscGhhSW1hZ2Uoe1xuICAgICAgICAgICAgd2lkdGg6IDMwLFxuICAgICAgICAgICAgaGVpZ2h0OiAzMFxuICAgICAgICAgIH0sIGEuZHJhdyhTdHJpbmcuZnJvbUNoYXJDb2RlKG8pKSksXG4gICAgICAgICAgbWV0cmljczoge1xuICAgICAgICAgICAgd2lkdGg6IDI0LFxuICAgICAgICAgICAgaGVpZ2h0OiAyNCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IC04LFxuICAgICAgICAgICAgYWR2YW5jZTogMjRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgeS5sb2FkR2x5cGhSYW5nZSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IDI1NiAqIGksXG4gICAgICAgIHMgPSBuICsgMjU1LFxuICAgICAgICBsID0gci50cmFuc2Zvcm1SZXF1ZXN0KHIubm9ybWFsaXplR2x5cGhzVVJMKG8pLnJlcGxhY2UoXCJ7Zm9udHN0YWNrfVwiLCBlKS5yZXBsYWNlKFwie3JhbmdlfVwiLCBuICsgXCItXCIgKyBzKSwgdC5SZXNvdXJjZVR5cGUuR2x5cGhzKTtcbiAgICAgIHQuZ2V0QXJyYXlCdWZmZXIobCwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgaWYgKGUpIGEoZSk7ZWxzZSBpZiAoaSkge1xuICAgICAgICAgIGZvciAodmFyIG8gPSB7fSwgciA9IDAsIG4gPSB0LnBhcnNlR2x5cGhQQkYoaSk7IHIgPCBuLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG5bcl07XG4gICAgICAgICAgICBvW3MuaWRdID0gcztcbiAgICAgICAgICB9XG4gICAgICAgICAgYShudWxsLCBvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgeS5UaW55U0RGID0gZDtcbiAgICB2YXIgeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHQuc3R5bGVTcGVjLmxpZ2h0LnBvc2l0aW9uO1xuICAgIH07XG4gICAgeC5wcm90b3R5cGUucG9zc2libHlFdmFsdWF0ZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICByZXR1cm4gdC5zcGhlcmljYWxUb0NhcnRlc2lhbihlLmV4cHJlc3Npb24uZXZhbHVhdGUoaSkpO1xuICAgIH0sIHgucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHQubnVtYmVyKGUueCwgaS54LCBvKSxcbiAgICAgICAgeTogdC5udW1iZXIoZS55LCBpLnksIG8pLFxuICAgICAgICB6OiB0Lm51bWJlcihlLnosIGkueiwgbylcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYiA9IG5ldyB0LlByb3BlcnRpZXMoe1xuICAgICAgICBhbmNob3I6IG5ldyB0LkRhdGFDb25zdGFudFByb3BlcnR5KHQuc3R5bGVTcGVjLmxpZ2h0LmFuY2hvciksXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgeCgpLFxuICAgICAgICBjb2xvcjogbmV3IHQuRGF0YUNvbnN0YW50UHJvcGVydHkodC5zdHlsZVNwZWMubGlnaHQuY29sb3IpLFxuICAgICAgICBpbnRlbnNpdHk6IG5ldyB0LkRhdGFDb25zdGFudFByb3BlcnR5KHQuc3R5bGVTcGVjLmxpZ2h0LmludGVuc2l0eSlcbiAgICAgIH0pLFxuICAgICAgdyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkoaSkge1xuICAgICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5fdHJhbnNpdGlvbmFibGUgPSBuZXcgdC5UcmFuc2l0aW9uYWJsZShiKSwgdGhpcy5zZXRMaWdodChpKSwgdGhpcy5fdHJhbnNpdGlvbmluZyA9IHRoaXMuX3RyYW5zaXRpb25hYmxlLnVudHJhbnNpdGlvbmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0TGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25hYmxlLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRMaWdodCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgIXRoaXMuX3ZhbGlkYXRlKHQudmFsaWRhdGVMaWdodCwgZSwgaSkpIGZvciAodmFyIG8gaW4gZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBlW29dO1xuICAgICAgICAgICAgdC5lbmRzV2l0aChvLCBcIi10cmFuc2l0aW9uXCIpID8gdGhpcy5fdHJhbnNpdGlvbmFibGUuc2V0VHJhbnNpdGlvbihvLnNsaWNlKDAsIC1cIi10cmFuc2l0aW9uXCIubGVuZ3RoKSwgcikgOiB0aGlzLl90cmFuc2l0aW9uYWJsZS5zZXRWYWx1ZShvLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uaW5nID0gdGhpcy5fdHJhbnNpdGlvbmFibGUudHJhbnNpdGlvbmVkKHQsIHRoaXMuX3RyYW5zaXRpb25pbmcpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uaW5nLmhhc1RyYW5zaXRpb24oKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHRoaXMuX3RyYW5zaXRpb25pbmcucG9zc2libHlFdmFsdWF0ZSh0KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICByZXR1cm4gKCFvIHx8ICExICE9PSBvLnZhbGlkYXRlKSAmJiB0LmVtaXRWYWxpZGF0aW9uRXJyb3JzKHRoaXMsIGUuY2FsbCh0LnZhbGlkYXRlU3R5bGUsIHQuZXh0ZW5kKHtcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgZ2x5cGhzOiAhMCxcbiAgICAgICAgICAgICAgc3ByaXRlOiAhMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogdC5zdHlsZVNwZWNcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9LCBpO1xuICAgICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgVCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0LCB0aGlzLmhlaWdodCA9IGUsIHRoaXMubmV4dFJvdyA9IDAsIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCksIHRoaXMuZGFzaEVudHJ5ID0ge307XG4gICAgICB9O1xuICAgIFQucHJvdG90eXBlLmdldERhc2ggPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0LmpvaW4oXCIsXCIpICsgU3RyaW5nKGUpO1xuICAgICAgcmV0dXJuIHRoaXMuZGFzaEVudHJ5W2ldIHx8ICh0aGlzLmRhc2hFbnRyeVtpXSA9IHRoaXMuYWRkRGFzaCh0LCBlKSksIHRoaXMuZGFzaEVudHJ5W2ldO1xuICAgIH0sIFQucHJvdG90eXBlLmdldERhc2hSYW5nZXMgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSBbXSxcbiAgICAgICAgciA9IHQubGVuZ3RoICUgMiA9PSAxID8gLXRbdC5sZW5ndGggLSAxXSAqIGkgOiAwLFxuICAgICAgICBhID0gdFswXSAqIGksXG4gICAgICAgIG4gPSAhMDtcbiAgICAgIG8ucHVzaCh7XG4gICAgICAgIGxlZnQ6IHIsXG4gICAgICAgIHJpZ2h0OiBhLFxuICAgICAgICBpc0Rhc2g6IG4sXG4gICAgICAgIHplcm9MZW5ndGg6IDAgPT09IHRbMF1cbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgcyA9IHRbMF0sIGwgPSAxOyBsIDwgdC5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgYyA9IHRbbF07XG4gICAgICAgIG8ucHVzaCh7XG4gICAgICAgICAgbGVmdDogciA9IHMgKiBpLFxuICAgICAgICAgIHJpZ2h0OiBhID0gKHMgKz0gYykgKiBpLFxuICAgICAgICAgIGlzRGFzaDogbiA9ICFuLFxuICAgICAgICAgIHplcm9MZW5ndGg6IDAgPT09IGNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LCBULnByb3RvdHlwZS5hZGRSb3VuZERhc2ggPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgZm9yICh2YXIgbyA9IGUgLyAyLCByID0gLWk7IHIgPD0gaTsgcisrKSBmb3IgKHZhciBhID0gdGhpcy53aWR0aCAqICh0aGlzLm5leHRSb3cgKyBpICsgciksIG4gPSAwLCBzID0gdFtuXSwgbCA9IDA7IGwgPCB0aGlzLndpZHRoOyBsKyspIHtcbiAgICAgICAgbCAvIHMucmlnaHQgPiAxICYmIChzID0gdFsrK25dKTtcbiAgICAgICAgdmFyIGMgPSBNYXRoLmFicyhsIC0gcy5sZWZ0KSxcbiAgICAgICAgICB1ID0gTWF0aC5hYnMobCAtIHMucmlnaHQpLFxuICAgICAgICAgIGggPSBNYXRoLm1pbihjLCB1KSxcbiAgICAgICAgICBwID0gdm9pZCAwLFxuICAgICAgICAgIGQgPSByIC8gaSAqIChvICsgMSk7XG4gICAgICAgIGlmIChzLmlzRGFzaCkge1xuICAgICAgICAgIHZhciBfID0gbyAtIE1hdGguYWJzKGQpO1xuICAgICAgICAgIHAgPSBNYXRoLnNxcnQoaCAqIGggKyBfICogXyk7XG4gICAgICAgIH0gZWxzZSBwID0gbyAtIE1hdGguc3FydChoICogaCArIGQgKiBkKTtcbiAgICAgICAgdGhpcy5kYXRhW2EgKyBsXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcCArIDEyOCkpO1xuICAgICAgfVxuICAgIH0sIFQucHJvdG90eXBlLmFkZFJlZ3VsYXJEYXNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSB0Lmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgIHZhciBpID0gdFtlXSxcbiAgICAgICAgICBvID0gdFtlICsgMV07XG4gICAgICAgIGkuemVyb0xlbmd0aCA/IHQuc3BsaWNlKGUsIDEpIDogbyAmJiBvLmlzRGFzaCA9PT0gaS5pc0Rhc2ggJiYgKG8ubGVmdCA9IGkubGVmdCwgdC5zcGxpY2UoZSwgMSkpO1xuICAgICAgfVxuICAgICAgdmFyIHIgPSB0WzBdLFxuICAgICAgICBhID0gdFt0Lmxlbmd0aCAtIDFdO1xuICAgICAgci5pc0Rhc2ggPT09IGEuaXNEYXNoICYmIChyLmxlZnQgPSBhLmxlZnQgLSB0aGlzLndpZHRoLCBhLnJpZ2h0ID0gci5yaWdodCArIHRoaXMud2lkdGgpO1xuICAgICAgZm9yICh2YXIgbiA9IHRoaXMud2lkdGggKiB0aGlzLm5leHRSb3csIHMgPSAwLCBsID0gdFtzXSwgYyA9IDA7IGMgPCB0aGlzLndpZHRoOyBjKyspIHtcbiAgICAgICAgYyAvIGwucmlnaHQgPiAxICYmIChsID0gdFsrK3NdKTtcbiAgICAgICAgdmFyIHUgPSBNYXRoLmFicyhjIC0gbC5sZWZ0KSxcbiAgICAgICAgICBoID0gTWF0aC5hYnMoYyAtIGwucmlnaHQpLFxuICAgICAgICAgIHAgPSBNYXRoLm1pbih1LCBoKTtcbiAgICAgICAgdGhpcy5kYXRhW24gKyBjXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgKGwuaXNEYXNoID8gcCA6IC1wKSArIDEyOCkpO1xuICAgICAgfVxuICAgIH0sIFQucHJvdG90eXBlLmFkZERhc2ggPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdmFyIG8gPSBpID8gNyA6IDAsXG4gICAgICAgIHIgPSAyICogbyArIDE7XG4gICAgICBpZiAodGhpcy5uZXh0Um93ICsgciA+IHRoaXMuaGVpZ2h0KSByZXR1cm4gdC53YXJuT25jZShcIkxpbmVBdGxhcyBvdXQgb2Ygc3BhY2VcIiksIG51bGw7XG4gICAgICBmb3IgKHZhciBhID0gMCwgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSBhICs9IGVbbl07XG4gICAgICBpZiAoMCAhPT0gYSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMud2lkdGggLyBhLFxuICAgICAgICAgIGwgPSB0aGlzLmdldERhc2hSYW5nZXMoZSwgdGhpcy53aWR0aCwgcyk7XG4gICAgICAgIGkgPyB0aGlzLmFkZFJvdW5kRGFzaChsLCBzLCBvKSA6IHRoaXMuYWRkUmVndWxhckRhc2gobCk7XG4gICAgICB9XG4gICAgICB2YXIgYyA9IHtcbiAgICAgICAgeTogKHRoaXMubmV4dFJvdyArIG8gKyAuNSkgLyB0aGlzLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiAyICogbyAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogYVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRSb3cgKz0gciwgdGhpcy5kaXJ0eSA9ICEwLCBjO1xuICAgIH0sIFQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmdsO1xuICAgICAgdGhpcy50ZXh0dXJlID8gKGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpLCB0aGlzLmRpcnR5ICYmICh0aGlzLmRpcnR5ID0gITEsIGUudGV4U3ViSW1hZ2UyRChlLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBlLkFMUEhBLCBlLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSkpKSA6ICh0aGlzLnRleHR1cmUgPSBlLmNyZWF0ZVRleHR1cmUoKSwgZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSksIGUudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsIGUuVEVYVFVSRV9XUkFQX1MsIGUuUkVQRUFUKSwgZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCwgZS5URVhUVVJFX1dSQVBfVCwgZS5SRVBFQVQpLCBlLnRleFBhcmFtZXRlcmkoZS5URVhUVVJFXzJELCBlLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZS5MSU5FQVIpLCBlLnRleFBhcmFtZXRlcmkoZS5URVhUVVJFXzJELCBlLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZS5MSU5FQVIpLCBlLnRleEltYWdlMkQoZS5URVhUVVJFXzJELCAwLCBlLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZS5BTFBIQSwgZS5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpKTtcbiAgICB9O1xuICAgIHZhciBFID0gZnVuY3Rpb24gZShpLCBvKSB7XG4gICAgICB0aGlzLndvcmtlclBvb2wgPSBpLCB0aGlzLmFjdG9ycyA9IFtdLCB0aGlzLmN1cnJlbnRBY3RvciA9IDAsIHRoaXMuaWQgPSB0LnVuaXF1ZUlkKCk7XG4gICAgICBmb3IgKHZhciByID0gdGhpcy53b3JrZXJQb29sLmFjcXVpcmUodGhpcy5pZCksIGEgPSAwOyBhIDwgci5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbiA9IG5ldyBlLkFjdG9yKHJbYV0sIG8sIHRoaXMuaWQpO1xuICAgICAgICBuLm5hbWUgPSBcIldvcmtlciBcIiArIGEsIHRoaXMuYWN0b3JzLnB1c2gobik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBJKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gZnVuY3Rpb24gKHIsIGEpIHtcbiAgICAgICAgaWYgKHIpIHJldHVybiBvKHIpO1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgIHZhciBuID0gdC5waWNrKHQuZXh0ZW5kKGEsIGUpLCBbXCJ0aWxlc1wiLCBcIm1pbnpvb21cIiwgXCJtYXh6b29tXCIsIFwiYXR0cmlidXRpb25cIiwgXCJtYXBib3hfbG9nb1wiLCBcImJvdW5kc1wiLCBcInNjaGVtZVwiLCBcInRpbGVTaXplXCIsIFwiZW5jb2RpbmdcIl0pO1xuICAgICAgICAgIGEudmVjdG9yX2xheWVycyAmJiAobi52ZWN0b3JMYXllcnMgPSBhLnZlY3Rvcl9sYXllcnMsIG4udmVjdG9yTGF5ZXJJZHMgPSBuLnZlY3RvckxheWVycy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlkO1xuICAgICAgICAgIH0pKSwgbi50aWxlcyA9IGkuY2Fub25pY2FsaXplVGlsZXNldChuLCBlLnVybCksIG8obnVsbCwgbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gZS51cmwgPyB0LmdldEpTT04oaS50cmFuc2Zvcm1SZXF1ZXN0KGkubm9ybWFsaXplU291cmNlVVJMKGUudXJsKSwgdC5SZXNvdXJjZVR5cGUuU291cmNlKSwgcikgOiB0LmJyb3dzZXIuZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcihudWxsLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBFLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdC5hc3luY0FsbCh0aGlzLmFjdG9ycywgZnVuY3Rpb24gKHQsIG8pIHtcbiAgICAgICAgdC5zZW5kKGUsIGksIG8pO1xuICAgICAgfSwgbyA9IG8gfHwgZnVuY3Rpb24gKCkge30pO1xuICAgIH0sIEUucHJvdG90eXBlLmdldEFjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFjdG9yID0gKHRoaXMuY3VycmVudEFjdG9yICsgMSkgJSB0aGlzLmFjdG9ycy5sZW5ndGgsIHRoaXMuYWN0b3JzW3RoaXMuY3VycmVudEFjdG9yXTtcbiAgICB9LCBFLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmFjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHQucmVtb3ZlKCk7XG4gICAgICB9KSwgdGhpcy5hY3RvcnMgPSBbXSwgdGhpcy53b3JrZXJQb29sLnJlbGVhc2UodGhpcy5pZCk7XG4gICAgfSwgRS5BY3RvciA9IHQuQWN0b3I7XG4gICAgdmFyIFAgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdGhpcy5ib3VuZHMgPSB0LkxuZ0xhdEJvdW5kcy5jb252ZXJ0KHRoaXMudmFsaWRhdGVCb3VuZHMoZSkpLCB0aGlzLm1pbnpvb20gPSBpIHx8IDAsIHRoaXMubWF4em9vbSA9IG8gfHwgMjQ7XG4gICAgfTtcbiAgICBQLnByb3RvdHlwZS52YWxpZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSAmJiA0ID09PSB0Lmxlbmd0aCA/IFtNYXRoLm1heCgtMTgwLCB0WzBdKSwgTWF0aC5tYXgoLTkwLCB0WzFdKSwgTWF0aC5taW4oMTgwLCB0WzJdKSwgTWF0aC5taW4oOTAsIHRbM10pXSA6IFstMTgwLCAtOTAsIDE4MCwgOTBdO1xuICAgIH0sIFAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gTWF0aC5wb3coMiwgZS56KSxcbiAgICAgICAgbyA9IE1hdGguZmxvb3IodC5tZXJjYXRvclhmcm9tTG5nKHRoaXMuYm91bmRzLmdldFdlc3QoKSkgKiBpKSxcbiAgICAgICAgciA9IE1hdGguZmxvb3IodC5tZXJjYXRvcllmcm9tTGF0KHRoaXMuYm91bmRzLmdldE5vcnRoKCkpICogaSksXG4gICAgICAgIGEgPSBNYXRoLmNlaWwodC5tZXJjYXRvclhmcm9tTG5nKHRoaXMuYm91bmRzLmdldEVhc3QoKSkgKiBpKSxcbiAgICAgICAgbiA9IE1hdGguY2VpbCh0Lm1lcmNhdG9yWWZyb21MYXQodGhpcy5ib3VuZHMuZ2V0U291dGgoKSkgKiBpKTtcbiAgICAgIHJldHVybiBlLnggPj0gbyAmJiBlLnggPCBhICYmIGUueSA+PSByICYmIGUueSA8IG47XG4gICAgfTtcbiAgICB2YXIgUyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkoaSwgbywgciwgYSkge1xuICAgICAgICAgIGlmIChlLmNhbGwodGhpcyksIHRoaXMuaWQgPSBpLCB0aGlzLmRpc3BhdGNoZXIgPSByLCB0aGlzLnR5cGUgPSBcInZlY3RvclwiLCB0aGlzLm1pbnpvb20gPSAwLCB0aGlzLm1heHpvb20gPSAyMiwgdGhpcy5zY2hlbWUgPSBcInh5elwiLCB0aGlzLnRpbGVTaXplID0gNTEyLCB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkID0gITAsIHRoaXMuaXNUaWxlQ2xpcHBlZCA9ICEwLCB0aGlzLl9sb2FkZWQgPSAhMSwgdC5leHRlbmQodGhpcywgdC5waWNrKG8sIFtcInVybFwiLCBcInNjaGVtZVwiLCBcInRpbGVTaXplXCIsIFwicHJvbW90ZUlkXCJdKSksIHRoaXMuX29wdGlvbnMgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgICB0eXBlOiBcInZlY3RvclwiXG4gICAgICAgICAgfSwgbyksIHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyA9IG8uY29sbGVjdFJlc291cmNlVGltaW5nLCA1MTIgIT09IHRoaXMudGlsZVNpemUpIHRocm93IG5ldyBFcnJvcihcInZlY3RvciB0aWxlIHNvdXJjZXMgbXVzdCBoYXZlIGEgdGlsZVNpemUgb2YgNTEyXCIpO1xuICAgICAgICAgIHRoaXMuc2V0RXZlbnRlZFBhcmVudChhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgICB9KSksIHRoaXMuX3RpbGVKU09OUmVxdWVzdCA9IEkodGhpcy5fb3B0aW9ucywgdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLCBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgICAgZS5fdGlsZUpTT05SZXF1ZXN0ID0gbnVsbCwgZS5fbG9hZGVkID0gITAsIGkgPyBlLmZpcmUobmV3IHQuRXJyb3JFdmVudChpKSkgOiBvICYmICh0LmV4dGVuZChlLCBvKSwgby5ib3VuZHMgJiYgKGUudGlsZUJvdW5kcyA9IG5ldyBQKG8uYm91bmRzLCBlLm1pbnpvb20sIGUubWF4em9vbSkpLCB0LnBvc3RUdXJuc3RpbGVFdmVudChvLnRpbGVzLCBlLm1hcC5fcmVxdWVzdE1hbmFnZXIuX2N1c3RvbUFjY2Vzc1Rva2VuKSwgdC5wb3N0TWFwTG9hZEV2ZW50KG8udGlsZXMsIGUubWFwLl9nZXRNYXBJZCgpLCBlLm1hcC5fcmVxdWVzdE1hbmFnZXIuX3NrdVRva2VuLCBlLm1hcC5fcmVxdWVzdE1hbmFnZXIuX2N1c3RvbUFjY2Vzc1Rva2VuKSwgZS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiXG4gICAgICAgICAgICB9KSksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwiY29udGVudFwiXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuaGFzVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLnRpbGVCb3VuZHMgfHwgdGhpcy50aWxlQm91bmRzLmNvbnRhaW5zKHQuY2Fub25pY2FsKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldFNvdXJjZVByb3BlcnR5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl90aWxlSlNPTlJlcXVlc3QgJiYgdGhpcy5fdGlsZUpTT05SZXF1ZXN0LmNhbmNlbCgpLCB0KCksIHRoaXMubWFwLnN0eWxlLnNvdXJjZUNhY2hlc1t0aGlzLmlkXS5jbGVhclRpbGVzKCksIHRoaXMubG9hZCgpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRUaWxlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldFNvdXJjZVByb3BlcnR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGUuX29wdGlvbnMudGlsZXMgPSB0O1xuICAgICAgICAgIH0pLCB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3VyY2VQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlLnVybCA9IHQsIGUuX29wdGlvbnMudXJsID0gdDtcbiAgICAgICAgICB9KSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fdGlsZUpTT05SZXF1ZXN0ICYmICh0aGlzLl90aWxlSlNPTlJlcXVlc3QuY2FuY2VsKCksIHRoaXMuX3RpbGVKU09OUmVxdWVzdCA9IG51bGwpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLm5vcm1hbGl6ZVRpbGVVUkwoZS50aWxlSUQuY2Fub25pY2FsLnVybCh0aGlzLnRpbGVzLCB0aGlzLnNjaGVtZSkpLFxuICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QobywgdC5SZXNvdXJjZVR5cGUuVGlsZSksXG4gICAgICAgICAgICAgIHVpZDogZS51aWQsXG4gICAgICAgICAgICAgIHRpbGVJRDogZS50aWxlSUQsXG4gICAgICAgICAgICAgIHpvb206IGUudGlsZUlELm92ZXJzY2FsZWRaLFxuICAgICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSAqIGUudGlsZUlELm92ZXJzY2FsZUZhY3RvcigpLFxuICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczogdGhpcy5tYXAuc2hvd0NvbGxpc2lvbkJveGVzLFxuICAgICAgICAgICAgICBwcm9tb3RlSWQ6IHRoaXMucHJvbW90ZUlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGEobywgcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBlLnJlcXVlc3QsIGUuYWJvcnRlZCA/IGkobnVsbCkgOiBvICYmIDQwNCAhPT0gby5zdGF0dXMgPyBpKG8pIDogKHIgJiYgci5yZXNvdXJjZVRpbWluZyAmJiAoZS5yZXNvdXJjZVRpbWluZyA9IHIucmVzb3VyY2VUaW1pbmcpLCB0aGlzLm1hcC5fcmVmcmVzaEV4cGlyZWRUaWxlcyAmJiByICYmIGUuc2V0RXhwaXJ5RGF0YShyKSwgZS5sb2FkVmVjdG9yRGF0YShyLCB0aGlzLm1hcC5wYWludGVyKSwgdC5jYWNoZUVudHJ5UG9zc2libHlBZGRlZCh0aGlzLmRpc3BhdGNoZXIpLCBpKG51bGwpLCB2b2lkIChlLnJlbG9hZENhbGxiYWNrICYmICh0aGlzLmxvYWRUaWxlKGUsIGUucmVsb2FkQ2FsbGJhY2spLCBlLnJlbG9hZENhbGxiYWNrID0gbnVsbCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5yZXF1ZXN0LmNvbGxlY3RSZXNvdXJjZVRpbWluZyA9IHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZywgZS5hY3RvciAmJiBcImV4cGlyZWRcIiAhPT0gZS5zdGF0ZSA/IFwibG9hZGluZ1wiID09PSBlLnN0YXRlID8gZS5yZWxvYWRDYWxsYmFjayA9IGkgOiBlLnJlcXVlc3QgPSBlLmFjdG9yLnNlbmQoXCJyZWxvYWRUaWxlXCIsIHIsIGEuYmluZCh0aGlzKSkgOiAoZS5hY3RvciA9IHRoaXMuZGlzcGF0Y2hlci5nZXRBY3RvcigpLCBlLnJlcXVlc3QgPSBlLmFjdG9yLnNlbmQoXCJsb2FkVGlsZVwiLCByLCBhLmJpbmQodGhpcykpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuYWJvcnRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0LnJlcXVlc3QgJiYgKHQucmVxdWVzdC5jYW5jZWwoKSwgZGVsZXRlIHQucmVxdWVzdCksIHQuYWN0b3IgJiYgdC5hY3Rvci5zZW5kKFwiYWJvcnRUaWxlXCIsIHtcbiAgICAgICAgICAgIHVpZDogdC51aWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS51bmxvYWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0LnVubG9hZFZlY3RvckRhdGEoKSwgdC5hY3RvciAmJiB0LmFjdG9yLnNlbmQoXCJyZW1vdmVUaWxlXCIsIHtcbiAgICAgICAgICAgIHVpZDogdC51aWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgaTtcbiAgICAgIH0odC5FdmVudGVkKSxcbiAgICAgIEMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuaWQgPSBpLCB0aGlzLmRpc3BhdGNoZXIgPSByLCB0aGlzLnNldEV2ZW50ZWRQYXJlbnQoYSksIHRoaXMudHlwZSA9IFwicmFzdGVyXCIsIHRoaXMubWluem9vbSA9IDAsIHRoaXMubWF4em9vbSA9IDIyLCB0aGlzLnJvdW5kWm9vbSA9ICEwLCB0aGlzLnNjaGVtZSA9IFwieHl6XCIsIHRoaXMudGlsZVNpemUgPSA1MTIsIHRoaXMuX2xvYWRlZCA9ICExLCB0aGlzLl9vcHRpb25zID0gdC5leHRlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJyYXN0ZXJcIlxuICAgICAgICAgIH0sIG8pLCB0LmV4dGVuZCh0aGlzLCB0LnBpY2sobywgW1widXJsXCIsIFwic2NoZW1lXCIsIFwidGlsZVNpemVcIl0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgICB9KSksIHRoaXMuX3RpbGVKU09OUmVxdWVzdCA9IEkodGhpcy5fb3B0aW9ucywgdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLCBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgICAgZS5fdGlsZUpTT05SZXF1ZXN0ID0gbnVsbCwgZS5fbG9hZGVkID0gITAsIGkgPyBlLmZpcmUobmV3IHQuRXJyb3JFdmVudChpKSkgOiBvICYmICh0LmV4dGVuZChlLCBvKSwgby5ib3VuZHMgJiYgKGUudGlsZUJvdW5kcyA9IG5ldyBQKG8uYm91bmRzLCBlLm1pbnpvb20sIGUubWF4em9vbSkpLCB0LnBvc3RUdXJuc3RpbGVFdmVudChvLnRpbGVzKSwgdC5wb3N0TWFwTG9hZEV2ZW50KG8udGlsZXMsIGUubWFwLl9nZXRNYXBJZCgpLCBlLm1hcC5fcmVxdWVzdE1hbmFnZXIuX3NrdVRva2VuKSwgZS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiXG4gICAgICAgICAgICB9KSksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwiY29udGVudFwiXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX3RpbGVKU09OUmVxdWVzdCAmJiAodGhpcy5fdGlsZUpTT05SZXF1ZXN0LmNhbmNlbCgpLCB0aGlzLl90aWxlSlNPTlJlcXVlc3QgPSBudWxsKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0LmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RpbGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiAhdGhpcy50aWxlQm91bmRzIHx8IHRoaXMudGlsZUJvdW5kcy5jb250YWlucyh0LmNhbm9uaWNhbCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMsXG4gICAgICAgICAgICByID0gdGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLm5vcm1hbGl6ZVRpbGVVUkwoZS50aWxlSUQuY2Fub25pY2FsLnVybCh0aGlzLnRpbGVzLCB0aGlzLnNjaGVtZSksIHRoaXMudGlsZVNpemUpO1xuICAgICAgICAgIGUucmVxdWVzdCA9IHQuZ2V0SW1hZ2UodGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QociwgdC5SZXNvdXJjZVR5cGUuVGlsZSksIGZ1bmN0aW9uIChyLCBhKSB7XG4gICAgICAgICAgICBpZiAoZGVsZXRlIGUucmVxdWVzdCwgZS5hYm9ydGVkKSBlLnN0YXRlID0gXCJ1bmxvYWRlZFwiLCBpKG51bGwpO2Vsc2UgaWYgKHIpIGUuc3RhdGUgPSBcImVycm9yZWRcIiwgaShyKTtlbHNlIGlmIChhKSB7XG4gICAgICAgICAgICAgIG8ubWFwLl9yZWZyZXNoRXhwaXJlZFRpbGVzICYmIGUuc2V0RXhwaXJ5RGF0YShhKSwgZGVsZXRlIGEuY2FjaGVDb250cm9sLCBkZWxldGUgYS5leHBpcmVzO1xuICAgICAgICAgICAgICB2YXIgbiA9IG8ubWFwLnBhaW50ZXIuY29udGV4dCxcbiAgICAgICAgICAgICAgICBzID0gbi5nbDtcbiAgICAgICAgICAgICAgZS50ZXh0dXJlID0gby5tYXAucGFpbnRlci5nZXRUaWxlVGV4dHVyZShhLndpZHRoKSwgZS50ZXh0dXJlID8gZS50ZXh0dXJlLnVwZGF0ZShhLCB7XG4gICAgICAgICAgICAgICAgdXNlTWlwbWFwOiAhMFxuICAgICAgICAgICAgICB9KSA6IChlLnRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKG4sIGEsIHMuUkdCQSwge1xuICAgICAgICAgICAgICAgIHVzZU1pcG1hcDogITBcbiAgICAgICAgICAgICAgfSksIGUudGV4dHVyZS5iaW5kKHMuTElORUFSLCBzLkNMQU1QX1RPX0VER0UsIHMuTElORUFSX01JUE1BUF9ORUFSRVNUKSwgbi5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMgJiYgcy50ZXhQYXJhbWV0ZXJmKHMuVEVYVFVSRV8yRCwgbi5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIG4uZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljTWF4KSksIGUuc3RhdGUgPSBcImxvYWRlZFwiLCB0LmNhY2hlRW50cnlQb3NzaWJseUFkZGVkKG8uZGlzcGF0Y2hlciksIGkobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmFib3J0VGlsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdC5yZXF1ZXN0ICYmICh0LnJlcXVlc3QuY2FuY2VsKCksIGRlbGV0ZSB0LnJlcXVlc3QpLCBlKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnVubG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHQudGV4dHVyZSAmJiB0aGlzLm1hcC5wYWludGVyLnNhdmVUaWxlVGV4dHVyZSh0LnRleHR1cmUpLCBlKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LCBpO1xuICAgICAgfSh0LkV2ZW50ZWQpLFxuICAgICAgeiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkoaSwgbywgciwgYSkge1xuICAgICAgICAgIGUuY2FsbCh0aGlzLCBpLCBvLCByLCBhKSwgdGhpcy50eXBlID0gXCJyYXN0ZXItZGVtXCIsIHRoaXMubWF4em9vbSA9IDIyLCB0aGlzLl9vcHRpb25zID0gdC5leHRlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJyYXN0ZXItZGVtXCJcbiAgICAgICAgICB9LCBvKSwgdGhpcy5lbmNvZGluZyA9IG8uZW5jb2RpbmcgfHwgXCJtYXBib3hcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFzdGVyLWRlbVwiLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLnRpbGVTaXplLFxuICAgICAgICAgICAgdGlsZXM6IHRoaXMudGlsZXMsXG4gICAgICAgICAgICBib3VuZHM6IHRoaXMuYm91bmRzLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplVGlsZVVSTChlLnRpbGVJRC5jYW5vbmljYWwudXJsKHRoaXMudGlsZXMsIHRoaXMuc2NoZW1lKSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgICAgICAgZnVuY3Rpb24gcih0LCBvKSB7XG4gICAgICAgICAgICB0ICYmIChlLnN0YXRlID0gXCJlcnJvcmVkXCIsIGkodCkpLCBvICYmIChlLmRlbSA9IG8sIGUubmVlZHNIaWxsc2hhZGVQcmVwYXJlID0gITAsIGUuc3RhdGUgPSBcImxvYWRlZFwiLCBpKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5yZXF1ZXN0ID0gdC5nZXRJbWFnZSh0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChvLCB0LlJlc291cmNlVHlwZS5UaWxlKSwgZnVuY3Rpb24gKG8sIGEpIHtcbiAgICAgICAgICAgIGlmIChkZWxldGUgZS5yZXF1ZXN0LCBlLmFib3J0ZWQpIGUuc3RhdGUgPSBcInVubG9hZGVkXCIsIGkobnVsbCk7ZWxzZSBpZiAobykgZS5zdGF0ZSA9IFwiZXJyb3JlZFwiLCBpKG8pO2Vsc2UgaWYgKGEpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYXAuX3JlZnJlc2hFeHBpcmVkVGlsZXMgJiYgZS5zZXRFeHBpcnlEYXRhKGEpLCBkZWxldGUgYS5jYWNoZUNvbnRyb2wsIGRlbGV0ZSBhLmV4cGlyZXM7XG4gICAgICAgICAgICAgIHZhciBuID0gdC53aW5kb3cuSW1hZ2VCaXRtYXAgJiYgYSBpbnN0YW5jZW9mIHQud2luZG93LkltYWdlQml0bWFwICYmIHQub2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkgPyBhIDogdC5icm93c2VyLmdldEltYWdlRGF0YShhLCAxKSxcbiAgICAgICAgICAgICAgICBzID0ge1xuICAgICAgICAgICAgICAgICAgdWlkOiBlLnVpZCxcbiAgICAgICAgICAgICAgICAgIGNvb3JkOiBlLnRpbGVJRCxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgIHJhd0ltYWdlRGF0YTogbixcbiAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiB0aGlzLmVuY29kaW5nXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZS5hY3RvciAmJiBcImV4cGlyZWRcIiAhPT0gZS5zdGF0ZSB8fCAoZS5hY3RvciA9IHRoaXMuZGlzcGF0Y2hlci5nZXRBY3RvcigpLCBlLmFjdG9yLnNlbmQoXCJsb2FkREVNVGlsZVwiLCBzLCByLmJpbmQodGhpcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQodGhpcykpLCBlLm5laWdoYm9yaW5nVGlsZXMgPSB0aGlzLl9nZXROZWlnaGJvcmluZ1RpbGVzKGUudGlsZUlEKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX2dldE5laWdoYm9yaW5nVGlsZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gZS5jYW5vbmljYWwsXG4gICAgICAgICAgICBvID0gTWF0aC5wb3coMiwgaS56KSxcbiAgICAgICAgICAgIHIgPSAoaS54IC0gMSArIG8pICUgbyxcbiAgICAgICAgICAgIGEgPSAwID09PSBpLnggPyBlLndyYXAgLSAxIDogZS53cmFwLFxuICAgICAgICAgICAgbiA9IChpLnggKyAxICsgbykgJSBvLFxuICAgICAgICAgICAgcyA9IGkueCArIDEgPT09IG8gPyBlLndyYXAgKyAxIDogZS53cmFwLFxuICAgICAgICAgICAgbCA9IHt9O1xuICAgICAgICAgIHJldHVybiBsW25ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5vdmVyc2NhbGVkWiwgYSwgaS56LCByLCBpLnkpLmtleV0gPSB7XG4gICAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICAgIH0sIGxbbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLm92ZXJzY2FsZWRaLCBzLCBpLnosIG4sIGkueSkua2V5XSA9IHtcbiAgICAgICAgICAgIGJhY2tmaWxsZWQ6ICExXG4gICAgICAgICAgfSwgaS55ID4gMCAmJiAobFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGEsIGkueiwgciwgaS55IC0gMSkua2V5XSA9IHtcbiAgICAgICAgICAgIGJhY2tmaWxsZWQ6ICExXG4gICAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGUud3JhcCwgaS56LCBpLngsIGkueSAtIDEpLmtleV0gPSB7XG4gICAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICAgIH0sIGxbbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLm92ZXJzY2FsZWRaLCBzLCBpLnosIG4sIGkueSAtIDEpLmtleV0gPSB7XG4gICAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICAgIH0pLCBpLnkgKyAxIDwgbyAmJiAobFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGEsIGkueiwgciwgaS55ICsgMSkua2V5XSA9IHtcbiAgICAgICAgICAgIGJhY2tmaWxsZWQ6ICExXG4gICAgICAgICAgfSwgbFtuZXcgdC5PdmVyc2NhbGVkVGlsZUlEKGUub3ZlcnNjYWxlZFosIGUud3JhcCwgaS56LCBpLngsIGkueSArIDEpLmtleV0gPSB7XG4gICAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICAgIH0sIGxbbmV3IHQuT3ZlcnNjYWxlZFRpbGVJRChlLm92ZXJzY2FsZWRaLCBzLCBpLnosIG4sIGkueSArIDEpLmtleV0gPSB7XG4gICAgICAgICAgICBiYWNrZmlsbGVkOiAhMVxuICAgICAgICAgIH0pLCBsO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS51bmxvYWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0LmRlbVRleHR1cmUgJiYgdGhpcy5tYXAucGFpbnRlci5zYXZlVGlsZVRleHR1cmUodC5kZW1UZXh0dXJlKSwgdC5mYm8gJiYgKHQuZmJvLmRlc3Ryb3koKSwgZGVsZXRlIHQuZmJvKSwgdC5kZW0gJiYgZGVsZXRlIHQuZGVtLCBkZWxldGUgdC5uZWlnaGJvcmluZ1RpbGVzLCB0LnN0YXRlID0gXCJ1bmxvYWRlZFwiLCB0LmFjdG9yICYmIHQuYWN0b3Iuc2VuZChcInJlbW92ZURFTVRpbGVcIiwge1xuICAgICAgICAgICAgdWlkOiB0LnVpZCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpO1xuICAgICAgfShDKSxcbiAgICAgIEQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgICBlLmNhbGwodGhpcyksIHRoaXMuaWQgPSBpLCB0aGlzLnR5cGUgPSBcImdlb2pzb25cIiwgdGhpcy5taW56b29tID0gMCwgdGhpcy5tYXh6b29tID0gMTgsIHRoaXMudGlsZVNpemUgPSA1MTIsIHRoaXMuaXNUaWxlQ2xpcHBlZCA9ICEwLCB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkID0gITAsIHRoaXMuX3JlbW92ZWQgPSAhMSwgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuYWN0b3IgPSByLmdldEFjdG9yKCksIHRoaXMuc2V0RXZlbnRlZFBhcmVudChhKSwgdGhpcy5fZGF0YSA9IG8uZGF0YSwgdGhpcy5fb3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCBvKSwgdGhpcy5fY29sbGVjdFJlc291cmNlVGltaW5nID0gby5jb2xsZWN0UmVzb3VyY2VUaW1pbmcsIHRoaXMuX3Jlc291cmNlVGltaW5nID0gW10sIHZvaWQgMCAhPT0gby5tYXh6b29tICYmICh0aGlzLm1heHpvb20gPSBvLm1heHpvb20pLCBvLnR5cGUgJiYgKHRoaXMudHlwZSA9IG8udHlwZSksIG8uYXR0cmlidXRpb24gJiYgKHRoaXMuYXR0cmlidXRpb24gPSBvLmF0dHJpYnV0aW9uKSwgdGhpcy5wcm9tb3RlSWQgPSBvLnByb21vdGVJZDtcbiAgICAgICAgICB2YXIgbiA9IHQuRVhURU5UIC8gdGhpcy50aWxlU2l6ZTtcbiAgICAgICAgICB0aGlzLndvcmtlck9wdGlvbnMgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBjbHVzdGVyOiBvLmNsdXN0ZXIgfHwgITEsXG4gICAgICAgICAgICBnZW9qc29uVnRPcHRpb25zOiB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogKHZvaWQgMCAhPT0gby5idWZmZXIgPyBvLmJ1ZmZlciA6IDEyOCkgKiBuLFxuICAgICAgICAgICAgICB0b2xlcmFuY2U6ICh2b2lkIDAgIT09IG8udG9sZXJhbmNlID8gby50b2xlcmFuY2UgOiAuMzc1KSAqIG4sXG4gICAgICAgICAgICAgIGV4dGVudDogdC5FWFRFTlQsXG4gICAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbSxcbiAgICAgICAgICAgICAgbGluZU1ldHJpY3M6IG8ubGluZU1ldHJpY3MgfHwgITEsXG4gICAgICAgICAgICAgIGdlbmVyYXRlSWQ6IG8uZ2VuZXJhdGVJZCB8fCAhMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1cGVyY2x1c3Rlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgbWF4Wm9vbTogdm9pZCAwICE9PSBvLmNsdXN0ZXJNYXhab29tID8gTWF0aC5taW4oby5jbHVzdGVyTWF4Wm9vbSwgdGhpcy5tYXh6b29tIC0gMSkgOiB0aGlzLm1heHpvb20gLSAxLFxuICAgICAgICAgICAgICBtaW5Qb2ludHM6IE1hdGgubWF4KDIsIG8uY2x1c3Rlck1pblBvaW50cyB8fCAyKSxcbiAgICAgICAgICAgICAgZXh0ZW50OiB0LkVYVEVOVCxcbiAgICAgICAgICAgICAgcmFkaXVzOiAoby5jbHVzdGVyUmFkaXVzIHx8IDUwKSAqIG4sXG4gICAgICAgICAgICAgIGxvZzogITEsXG4gICAgICAgICAgICAgIGdlbmVyYXRlSWQ6IG8uZ2VuZXJhdGVJZCB8fCAhMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsdXN0ZXJQcm9wZXJ0aWVzOiBvLmNsdXN0ZXJQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZmlsdGVyOiBvLmZpbHRlclxuICAgICAgICAgIH0sIG8ud29ya2VyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgICB9KSksIHRoaXMuX3VwZGF0ZVdvcmtlckRhdGEoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmIChpKSBlLmZpcmUobmV3IHQuRXJyb3JFdmVudChpKSk7ZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcIm1ldGFkYXRhXCJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZS5fY29sbGVjdFJlc291cmNlVGltaW5nICYmIGUuX3Jlc291cmNlVGltaW5nICYmIGUuX3Jlc291cmNlVGltaW5nLmxlbmd0aCA+IDAgJiYgKG8ucmVzb3VyY2VUaW1pbmcgPSBlLl9yZXNvdXJjZVRpbWluZywgZS5fcmVzb3VyY2VUaW1pbmcgPSBbXSksIGUuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhID0gZSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCJcbiAgICAgICAgICB9KSksIHRoaXMuX3VwZGF0ZVdvcmtlckRhdGEoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlKSBpLmZpcmUobmV3IHQuRXJyb3JFdmVudChlKSk7ZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcImNvbnRlbnRcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpLl9jb2xsZWN0UmVzb3VyY2VUaW1pbmcgJiYgaS5fcmVzb3VyY2VUaW1pbmcgJiYgaS5fcmVzb3VyY2VUaW1pbmcubGVuZ3RoID4gMCAmJiAoby5yZXNvdXJjZVRpbWluZyA9IGkuX3Jlc291cmNlVGltaW5nLCBpLl9yZXNvdXJjZVRpbWluZyA9IFtdKSwgaS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHRoaXM7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldENsdXN0ZXJFeHBhbnNpb25ab29tID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rvci5zZW5kKFwiZ2VvanNvbi5nZXRDbHVzdGVyRXhwYW5zaW9uWm9vbVwiLCB7XG4gICAgICAgICAgICBjbHVzdGVySWQ6IHQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgICB9LCBlKSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0Q2x1c3RlckNoaWxkcmVuID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rvci5zZW5kKFwiZ2VvanNvbi5nZXRDbHVzdGVyQ2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgY2x1c3RlcklkOiB0LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkXG4gICAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldENsdXN0ZXJMZWF2ZXMgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFjdG9yLnNlbmQoXCJnZW9qc29uLmdldENsdXN0ZXJMZWF2ZXNcIiwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgY2x1c3RlcklkOiB0LFxuICAgICAgICAgICAgbGltaXQ6IGUsXG4gICAgICAgICAgICBvZmZzZXQ6IGlcbiAgICAgICAgICB9LCBvKSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVdvcmtlckRhdGEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMTtcbiAgICAgICAgICB2YXIgbyA9IHQuZXh0ZW5kKHt9LCB0aGlzLndvcmtlck9wdGlvbnMpLFxuICAgICAgICAgICAgciA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgciA/IChvLnJlcXVlc3QgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdCh0LmJyb3dzZXIucmVzb2x2ZVVSTChyKSwgdC5SZXNvdXJjZVR5cGUuU291cmNlKSwgby5yZXF1ZXN0LmNvbGxlY3RSZXNvdXJjZVRpbWluZyA9IHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZykgOiBvLmRhdGEgPSBKU09OLnN0cmluZ2lmeShyKSwgdGhpcy5hY3Rvci5zZW5kKHRoaXMudHlwZSArIFwiLmxvYWREYXRhXCIsIG8sIGZ1bmN0aW9uICh0LCByKSB7XG4gICAgICAgICAgICBpLl9yZW1vdmVkIHx8IHIgJiYgci5hYmFuZG9uZWQgfHwgKGkuX2xvYWRlZCA9ICEwLCByICYmIHIucmVzb3VyY2VUaW1pbmcgJiYgci5yZXNvdXJjZVRpbWluZ1tpLmlkXSAmJiAoaS5fcmVzb3VyY2VUaW1pbmcgPSByLnJlc291cmNlVGltaW5nW2kuaWRdLnNsaWNlKDApKSwgaS5hY3Rvci5zZW5kKGkudHlwZSArIFwiLmNvYWxlc2NlXCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiBvLnNvdXJjZVxuICAgICAgICAgICAgfSwgbnVsbCksIGUodCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUubG9hZFRpbGUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgICAgIHIgPSBlLmFjdG9yID8gXCJyZWxvYWRUaWxlXCIgOiBcImxvYWRUaWxlXCI7XG4gICAgICAgICAgZS5hY3RvciA9IHRoaXMuYWN0b3IsIGUucmVxdWVzdCA9IHRoaXMuYWN0b3Iuc2VuZChyLCB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1aWQ6IGUudWlkLFxuICAgICAgICAgICAgdGlsZUlEOiBlLnRpbGVJRCxcbiAgICAgICAgICAgIHpvb206IGUudGlsZUlELm92ZXJzY2FsZWRaLFxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczogdGhpcy5tYXAuc2hvd0NvbGxpc2lvbkJveGVzLFxuICAgICAgICAgICAgcHJvbW90ZUlkOiB0aGlzLnByb21vdGVJZFxuICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIGUucmVxdWVzdCwgZS51bmxvYWRWZWN0b3JEYXRhKCksIGUuYWJvcnRlZCA/IGkobnVsbCkgOiB0ID8gaSh0KSA6IChlLmxvYWRWZWN0b3JEYXRhKGEsIG8ubWFwLnBhaW50ZXIsIFwicmVsb2FkVGlsZVwiID09PSByKSwgaShudWxsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmFib3J0VGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC5yZXF1ZXN0ICYmICh0LnJlcXVlc3QuY2FuY2VsKCksIGRlbGV0ZSB0LnJlcXVlc3QpLCB0LmFib3J0ZWQgPSAhMDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUudW5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC51bmxvYWRWZWN0b3JEYXRhKCksIHRoaXMuYWN0b3Iuc2VuZChcInJlbW92ZVRpbGVcIiwge1xuICAgICAgICAgICAgdWlkOiB0LnVpZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVkID0gITAsIHRoaXMuYWN0b3Iuc2VuZChcInJlbW92ZVNvdXJjZVwiLCB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0LmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgaTtcbiAgICAgIH0odC5FdmVudGVkKSxcbiAgICAgIEEgPSB0LmNyZWF0ZUxheW91dChbe1xuICAgICAgICBuYW1lOiBcImFfcG9zXCIsXG4gICAgICAgIHR5cGU6IFwiSW50MTZcIixcbiAgICAgICAgY29tcG9uZW50czogMlxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiBcImFfdGV4dHVyZV9wb3NcIixcbiAgICAgICAgdHlwZTogXCJJbnQxNlwiLFxuICAgICAgICBjb21wb25lbnRzOiAyXG4gICAgICB9XSksXG4gICAgICBNID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZnVuY3Rpb24gaSh0LCBpLCBvLCByKSB7XG4gICAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLmlkID0gdCwgdGhpcy5kaXNwYXRjaGVyID0gbywgdGhpcy5jb29yZGluYXRlcyA9IGkuY29vcmRpbmF0ZXMsIHRoaXMudHlwZSA9IFwiaW1hZ2VcIiwgdGhpcy5taW56b29tID0gMCwgdGhpcy5tYXh6b29tID0gMjIsIHRoaXMudGlsZVNpemUgPSA1MTIsIHRoaXMudGlsZXMgPSB7fSwgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuc2V0RXZlbnRlZFBhcmVudChyKSwgdGhpcy5vcHRpb25zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbG9hZGVkID0gITEsIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiXG4gICAgICAgICAgfSkpLCB0aGlzLnVybCA9IHRoaXMub3B0aW9ucy51cmwsIHQuZ2V0SW1hZ2UodGhpcy5tYXAuX3JlcXVlc3RNYW5hZ2VyLnRyYW5zZm9ybVJlcXVlc3QodGhpcy51cmwsIHQuUmVzb3VyY2VUeXBlLkltYWdlKSwgZnVuY3Rpb24gKHIsIGEpIHtcbiAgICAgICAgICAgIG8uX2xvYWRlZCA9ICEwLCByID8gby5maXJlKG5ldyB0LkVycm9yRXZlbnQocikpIDogYSAmJiAoby5pbWFnZSA9IGEsIGUgJiYgKG8uY29vcmRpbmF0ZXMgPSBlKSwgaSAmJiBpKCksIG8uX2ZpbmlzaExvYWRpbmcoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGVJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlICYmIHQudXJsID8gKHRoaXMub3B0aW9ucy51cmwgPSB0LnVybCwgdGhpcy5sb2FkKHQuY29vcmRpbmF0ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGUudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgfSksIHRoaXMpIDogdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX2ZpbmlzaExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5tYXAgJiYgKHRoaXMuc2V0Q29vcmRpbmF0ZXModGhpcy5jb29yZGluYXRlcyksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VEYXRhVHlwZTogXCJtZXRhZGF0YVwiXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMubWFwID0gdCwgdGhpcy5sb2FkKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGU7XG4gICAgICAgICAgdmFyIG8gPSBlLm1hcCh0Lk1lcmNhdG9yQ29vcmRpbmF0ZS5mcm9tTG5nTGF0KTtcbiAgICAgICAgICB0aGlzLnRpbGVJRCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSAvIDAsIG8gPSAxIC8gMCwgciA9IC0xIC8gMCwgYSA9IC0xIC8gMCwgbiA9IDAsIHMgPSBlOyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgbCA9IHNbbl07XG4gICAgICAgICAgICAgIGkgPSBNYXRoLm1pbihpLCBsLngpLCBvID0gTWF0aC5taW4obywgbC55KSwgciA9IE1hdGgubWF4KHIsIGwueCksIGEgPSBNYXRoLm1heChhLCBsLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLm1heChyIC0gaSwgYSAtIG8pLFxuICAgICAgICAgICAgICB1ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcigtTWF0aC5sb2coYykgLyBNYXRoLkxOMikpLFxuICAgICAgICAgICAgICBoID0gTWF0aC5wb3coMiwgdSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHQuQ2Fub25pY2FsVGlsZUlEKHUsIE1hdGguZmxvb3IoKGkgKyByKSAvIDIgKiBoKSwgTWF0aC5mbG9vcigobyArIGEpIC8gMiAqIGgpKTtcbiAgICAgICAgICB9KG8pLCB0aGlzLm1pbnpvb20gPSB0aGlzLm1heHpvb20gPSB0aGlzLnRpbGVJRC56O1xuICAgICAgICAgIHZhciByID0gby5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpLnRpbGVJRC5nZXRUaWxlUG9pbnQodCkuX3JvdW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kc0FycmF5ID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQ0aTgoKSwgdGhpcy5fYm91bmRzQXJyYXkuZW1wbGFjZUJhY2soclswXS54LCByWzBdLnksIDAsIDApLCB0aGlzLl9ib3VuZHNBcnJheS5lbXBsYWNlQmFjayhyWzFdLngsIHJbMV0ueSwgdC5FWFRFTlQsIDApLCB0aGlzLl9ib3VuZHNBcnJheS5lbXBsYWNlQmFjayhyWzNdLngsIHJbM10ueSwgMCwgdC5FWFRFTlQpLCB0aGlzLl9ib3VuZHNBcnJheS5lbXBsYWNlQmFjayhyWzJdLngsIHJbMl0ueSwgdC5FWFRFTlQsIHQuRVhURU5UKSwgdGhpcy5ib3VuZHNCdWZmZXIgJiYgKHRoaXMuYm91bmRzQnVmZmVyLmRlc3Ryb3koKSwgZGVsZXRlIHRoaXMuYm91bmRzQnVmZmVyKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcImNvbnRlbnRcIlxuICAgICAgICAgIH0pKSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoMCAhPT0gT2JqZWN0LmtleXModGhpcy50aWxlcykubGVuZ3RoICYmIHRoaXMuaW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5tYXAucGFpbnRlci5jb250ZXh0LFxuICAgICAgICAgICAgICBpID0gZS5nbDtcbiAgICAgICAgICAgIGZvciAodmFyIG8gaW4gdGhpcy5ib3VuZHNCdWZmZXIgfHwgKHRoaXMuYm91bmRzQnVmZmVyID0gZS5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5fYm91bmRzQXJyYXksIEEubWVtYmVycykpLCB0aGlzLmJvdW5kc1NlZ21lbnRzIHx8ICh0aGlzLmJvdW5kc1NlZ21lbnRzID0gdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMCwgNCwgMikpLCB0aGlzLnRleHR1cmUgfHwgKHRoaXMudGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZSwgdGhpcy5pbWFnZSwgaS5SR0JBKSwgdGhpcy50ZXh0dXJlLmJpbmQoaS5MSU5FQVIsIGkuQ0xBTVBfVE9fRURHRSkpLCB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICAgIHZhciByID0gdGhpcy50aWxlc1tvXTtcbiAgICAgICAgICAgICAgXCJsb2FkZWRcIiAhPT0gci5zdGF0ZSAmJiAoci5zdGF0ZSA9IFwibG9hZGVkXCIsIHIudGV4dHVyZSA9IHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5sb2FkVGlsZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdGhpcy50aWxlSUQgJiYgdGhpcy50aWxlSUQuZXF1YWxzKHQudGlsZUlELmNhbm9uaWNhbCkgPyAodGhpcy50aWxlc1tTdHJpbmcodC50aWxlSUQud3JhcCldID0gdCwgdC5idWNrZXRzID0ge30sIGUobnVsbCkpIDogKHQuc3RhdGUgPSBcImVycm9yZWRcIiwgZShudWxsKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgdXJsOiB0aGlzLm9wdGlvbnMudXJsLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHRoaXMuY29vcmRpbmF0ZXNcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgaTtcbiAgICAgIH0odC5FdmVudGVkKSxcbiAgICAgIEwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmdW5jdGlvbiBpKHQsIGksIG8sIHIpIHtcbiAgICAgICAgICBlLmNhbGwodGhpcywgdCwgaSwgbywgciksIHRoaXMucm91bmRab29tID0gITAsIHRoaXMudHlwZSA9IFwidmlkZW9cIiwgdGhpcy5vcHRpb25zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSAmJiAoaS5fX3Byb3RvX18gPSBlKSwgKGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBpLCBpLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9sb2FkZWQgPSAhMTtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICB0aGlzLnVybHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBvID0gMCwgciA9IGkudXJsczsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHRoaXMudXJscy5wdXNoKHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KHJbb10sIHQuUmVzb3VyY2VUeXBlLlNvdXJjZSkudXJsKTtcbiAgICAgICAgICB0LmdldFZpZGVvKHRoaXMudXJscywgZnVuY3Rpb24gKGksIG8pIHtcbiAgICAgICAgICAgIGUuX2xvYWRlZCA9ICEwLCBpID8gZS5maXJlKG5ldyB0LkVycm9yRXZlbnQoaSkpIDogbyAmJiAoZS52aWRlbyA9IG8sIGUudmlkZW8ubG9vcCA9ICEwLCBlLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZS5tYXAudHJpZ2dlclJlcGFpbnQoKTtcbiAgICAgICAgICAgIH0pLCBlLm1hcCAmJiBlLnZpZGVvLnBsYXkoKSwgZS5fZmluaXNoTG9hZGluZygpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52aWRlbyAmJiB0aGlzLnZpZGVvLnBhdXNlKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52aWRlbyAmJiB0aGlzLnZpZGVvLnBsYXkoKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy52aWRlby5zZWVrYWJsZTtcbiAgICAgICAgICAgIGUgPCBpLnN0YXJ0KDApIHx8IGUgPiBpLmVuZCgwKSA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyB0aGlzLmlkLCBudWxsLCBcIlBsYXliYWNrIGZvciB0aGlzIHZpZGVvIGNhbiBiZSBzZXQgb25seSBiZXR3ZWVuIHRoZSBcIiArIGkuc3RhcnQoMCkgKyBcIiBhbmQgXCIgKyBpLmVuZCgwKSArIFwiLXNlY29uZCBtYXJrLlwiKSkpIDogdGhpcy52aWRlby5jdXJyZW50VGltZSA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRWaWRlbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aWRlbztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMubWFwIHx8ICh0aGlzLm1hcCA9IHQsIHRoaXMubG9hZCgpLCB0aGlzLnZpZGVvICYmICh0aGlzLnZpZGVvLnBsYXkoKSwgdGhpcy5zZXRDb29yZGluYXRlcyh0aGlzLmNvb3JkaW5hdGVzKSkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghKDAgPT09IE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aCB8fCB0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPCAyKSkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm1hcC5wYWludGVyLmNvbnRleHQsXG4gICAgICAgICAgICAgIGkgPSBlLmdsO1xuICAgICAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLmJvdW5kc0J1ZmZlciB8fCAodGhpcy5ib3VuZHNCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLl9ib3VuZHNBcnJheSwgQS5tZW1iZXJzKSksIHRoaXMuYm91bmRzU2VnbWVudHMgfHwgKHRoaXMuYm91bmRzU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKSksIHRoaXMudGV4dHVyZSA/IHRoaXMudmlkZW8ucGF1c2VkIHx8ICh0aGlzLnRleHR1cmUuYmluZChpLkxJTkVBUiwgaS5DTEFNUF9UT19FREdFKSwgaS50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV8yRCwgMCwgMCwgMCwgaS5SR0JBLCBpLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pKSA6ICh0aGlzLnRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKGUsIHRoaXMudmlkZW8sIGkuUkdCQSksIHRoaXMudGV4dHVyZS5iaW5kKGkuTElORUFSLCBpLkNMQU1QX1RPX0VER0UpKSwgdGhpcy50aWxlcykge1xuICAgICAgICAgICAgICB2YXIgciA9IHRoaXMudGlsZXNbb107XG4gICAgICAgICAgICAgIFwibG9hZGVkXCIgIT09IHIuc3RhdGUgJiYgKHIuc3RhdGUgPSBcImxvYWRlZFwiLCByLnRleHR1cmUgPSB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInZpZGVvXCIsXG4gICAgICAgICAgICB1cmxzOiB0aGlzLnVybHMsXG4gICAgICAgICAgICBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlc1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW8gJiYgIXRoaXMudmlkZW8ucGF1c2VkO1xuICAgICAgICB9LCBpO1xuICAgICAgfShNKSxcbiAgICAgIFIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmdW5jdGlvbiBpKGksIG8sIHIsIGEpIHtcbiAgICAgICAgICBlLmNhbGwodGhpcywgaSwgbywgciwgYSksIG8uY29vcmRpbmF0ZXMgPyBBcnJheS5pc0FycmF5KG8uY29vcmRpbmF0ZXMpICYmIDQgPT09IG8uY29vcmRpbmF0ZXMubGVuZ3RoICYmICFvLmNvb3JkaW5hdGVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheSh0KSB8fCAyICE9PSB0Lmxlbmd0aCB8fCB0LnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT0gdHlwZW9mIHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSB8fCB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgdC5WYWxpZGF0aW9uRXJyb3IoXCJzb3VyY2VzLlwiICsgaSwgbnVsbCwgJ1wiY29vcmRpbmF0ZXNcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5IG9mIDQgbG9uZ2l0dWRlL2xhdGl0dWRlIGFycmF5IHBhaXJzJykpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcImNvb3JkaW5hdGVzXCInKSkpLCBvLmFuaW1hdGUgJiYgXCJib29sZWFuXCIgIT0gdHlwZW9mIG8uYW5pbWF0ZSAmJiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgdC5WYWxpZGF0aW9uRXJyb3IoXCJzb3VyY2VzLlwiICsgaSwgbnVsbCwgJ29wdGlvbmFsIFwiYW5pbWF0ZVwiIHByb3BlcnR5IG11c3QgYmUgYSBib29sZWFuIHZhbHVlJykpKSwgby5jYW52YXMgPyBcInN0cmluZ1wiID09IHR5cGVvZiBvLmNhbnZhcyB8fCBvLmNhbnZhcyBpbnN0YW5jZW9mIHQud2luZG93LkhUTUxDYW52YXNFbGVtZW50IHx8IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnXCJjYW52YXNcIiBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIElEIG9mIHRoZSBjYW52YXMgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQsIG9yIGFuIEhUTUxDYW52YXNFbGVtZW50IGluc3RhbmNlJykpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyB0LlZhbGlkYXRpb25FcnJvcihcInNvdXJjZXMuXCIgKyBpLCBudWxsLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcImNhbnZhc1wiJykpKSwgdGhpcy5vcHRpb25zID0gbywgdGhpcy5hbmltYXRlID0gdm9pZCAwID09PSBvLmFuaW1hdGUgfHwgby5hbmltYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlICYmIChpLl9fcHJvdG9fXyA9IGUpLCAoaS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGksIGkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fbG9hZGVkID0gITAsIHRoaXMuY2FudmFzIHx8ICh0aGlzLmNhbnZhcyA9IHRoaXMub3B0aW9ucy5jYW52YXMgaW5zdGFuY2VvZiB0LndpbmRvdy5IVE1MQ2FudmFzRWxlbWVudCA/IHRoaXMub3B0aW9ucy5jYW52YXMgOiB0LndpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm9wdGlvbnMuY2FudmFzKSksIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQsIHRoaXMuX2hhc0ludmFsaWREaW1lbnNpb25zKCkgPyB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJDYW52YXMgZGltZW5zaW9ucyBjYW5ub3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXCIpKSkgOiAodGhpcy5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWluZyA9ICEwLCB0aGlzLm1hcC50cmlnZ2VyUmVwYWludCgpO1xuICAgICAgICAgIH0sIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5aW5nICYmICh0aGlzLnByZXBhcmUoKSwgdGhpcy5fcGxheWluZyA9ICExKTtcbiAgICAgICAgICB9LCB0aGlzLl9maW5pc2hMb2FkaW5nKCkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5tYXAgPSB0LCB0aGlzLmxvYWQoKSwgdGhpcy5jYW52YXMgJiYgdGhpcy5hbmltYXRlICYmIHRoaXMucGxheSgpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGUgPSAhMTtcbiAgICAgICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggIT09IHRoaXMud2lkdGggJiYgKHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCwgZSA9ICEwKSwgdGhpcy5jYW52YXMuaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCAmJiAodGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQsIGUgPSAhMCksICF0aGlzLl9oYXNJbnZhbGlkRGltZW5zaW9ucygpICYmIDAgIT09IE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm1hcC5wYWludGVyLmNvbnRleHQsXG4gICAgICAgICAgICAgIG8gPSBpLmdsO1xuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLmJvdW5kc0J1ZmZlciB8fCAodGhpcy5ib3VuZHNCdWZmZXIgPSBpLmNyZWF0ZVZlcnRleEJ1ZmZlcih0aGlzLl9ib3VuZHNBcnJheSwgQS5tZW1iZXJzKSksIHRoaXMuYm91bmRzU2VnbWVudHMgfHwgKHRoaXMuYm91bmRzU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKSksIHRoaXMudGV4dHVyZSA/IChlIHx8IHRoaXMuX3BsYXlpbmcpICYmIHRoaXMudGV4dHVyZS51cGRhdGUodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgcHJlbXVsdGlwbHk6ICEwXG4gICAgICAgICAgICB9KSA6IHRoaXMudGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoaSwgdGhpcy5jYW52YXMsIG8uUkdCQSwge1xuICAgICAgICAgICAgICBwcmVtdWx0aXBseTogITBcbiAgICAgICAgICAgIH0pLCB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gdGhpcy50aWxlc1tyXTtcbiAgICAgICAgICAgICAgXCJsb2FkZWRcIiAhPT0gYS5zdGF0ZSAmJiAoYS5zdGF0ZSA9IFwibG9hZGVkXCIsIGEudGV4dHVyZSA9IHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2FudmFzXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlc1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9oYXNJbnZhbGlkRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMCwgZSA9IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XTsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBpID0gZVt0XTtcbiAgICAgICAgICAgIGlmIChpc05hTihpKSB8fCBpIDw9IDApIHJldHVybiAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LCBpO1xuICAgICAgfShNKSxcbiAgICAgIGsgPSB7XG4gICAgICAgIHZlY3RvcjogUyxcbiAgICAgICAgcmFzdGVyOiBDLFxuICAgICAgICBcInJhc3Rlci1kZW1cIjogeixcbiAgICAgICAgZ2VvanNvbjogRCxcbiAgICAgICAgdmlkZW86IEwsXG4gICAgICAgIGltYWdlOiBNLFxuICAgICAgICBjYW52YXM6IFJcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gQihlLCBpKSB7XG4gICAgICB2YXIgbyA9IHQuaWRlbnRpdHkoW10pO1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlKG8sIG8sIFsxLCAxLCAwXSksIHQuc2NhbGUobywgbywgWy41ICogZS53aWR0aCwgLjUgKiBlLmhlaWdodCwgMV0pLCB0Lm11bHRpcGx5KG8sIG8sIGUuY2FsY3VsYXRlUG9zTWF0cml4KGkudG9VbndyYXBwZWQoKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICBpZiAodCkgZm9yICh2YXIgbyA9IDAsIHIgPSB0OyBvIDwgci5sZW5ndGg7IG8gKz0gMSkge1xuICAgICAgICAgICAgdmFyIGEgPSBlW3Jbb11dO1xuICAgICAgICAgICAgaWYgKGEgJiYgYS5zb3VyY2UgPT09IGkgJiYgXCJmaWxsLWV4dHJ1c2lvblwiID09PSBhLnR5cGUpIHJldHVybiAhMDtcbiAgICAgICAgICB9IGVsc2UgZm9yICh2YXIgbiBpbiBlKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGVbbl07XG4gICAgICAgICAgICBpZiAocy5zb3VyY2UgPT09IGkgJiYgXCJmaWxsLWV4dHJ1c2lvblwiID09PSBzLnR5cGUpIHJldHVybiAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9KHIgJiYgci5sYXllcnMsIGUsIHQuaWQpLFxuICAgICAgICBzID0gYS5tYXhQaXRjaFNjYWxlRmFjdG9yKCksXG4gICAgICAgIGwgPSB0LnRpbGVzSW4obywgcywgbik7XG4gICAgICBsLnNvcnQoRik7XG4gICAgICBmb3IgKHZhciBjID0gW10sIHUgPSAwLCBoID0gbDsgdSA8IGgubGVuZ3RoOyB1ICs9IDEpIHtcbiAgICAgICAgdmFyIHAgPSBoW3VdO1xuICAgICAgICBjLnB1c2goe1xuICAgICAgICAgIHdyYXBwZWRUaWxlSUQ6IHAudGlsZUlELndyYXBwZWQoKS5rZXksXG4gICAgICAgICAgcXVlcnlSZXN1bHRzOiBwLnRpbGUucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGUsIGksIHQuX3N0YXRlLCBwLnF1ZXJ5R2VvbWV0cnksIHAuY2FtZXJhUXVlcnlHZW9tZXRyeSwgcC5zY2FsZSwgciwgYSwgcywgQih0LnRyYW5zZm9ybSwgcC50aWxlSUQpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHt9LCBpID0ge30sIG8gPSAwLCByID0gdDsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHJbb10sXG4gICAgICAgICAgICBuID0gYS5xdWVyeVJlc3VsdHMsXG4gICAgICAgICAgICBzID0gYS53cmFwcGVkVGlsZUlELFxuICAgICAgICAgICAgbCA9IGlbc10gPSBpW3NdIHx8IHt9O1xuICAgICAgICAgIGZvciAodmFyIGMgaW4gbikgZm9yICh2YXIgdSA9IG5bY10sIGggPSBsW2NdID0gbFtjXSB8fCB7fSwgcCA9IGVbY10gPSBlW2NdIHx8IFtdLCBkID0gMCwgXyA9IHU7IGQgPCBfLmxlbmd0aDsgZCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZiA9IF9bZF07XG4gICAgICAgICAgICBoW2YuZmVhdHVyZUluZGV4XSB8fCAoaFtmLmZlYXR1cmVJbmRleF0gPSAhMCwgcC5wdXNoKGYpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KGMpO1xuICAgICAgZm9yICh2YXIgXyBpbiBkKSBkW19dLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSBlLmZlYXR1cmUsXG4gICAgICAgICAgbyA9IHQuZ2V0RmVhdHVyZVN0YXRlKGkubGF5ZXJbXCJzb3VyY2UtbGF5ZXJcIl0sIGkuaWQpO1xuICAgICAgICBpLnNvdXJjZSA9IGkubGF5ZXIuc291cmNlLCBpLmxheWVyW1wic291cmNlLWxheWVyXCJdICYmIChpLnNvdXJjZUxheWVyID0gaS5sYXllcltcInNvdXJjZS1sYXllclwiXSksIGkuc3RhdGUgPSBvO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRih0LCBlKSB7XG4gICAgICB2YXIgaSA9IHQudGlsZUlELFxuICAgICAgICBvID0gZS50aWxlSUQ7XG4gICAgICByZXR1cm4gaS5vdmVyc2NhbGVkWiAtIG8ub3ZlcnNjYWxlZFogfHwgaS5jYW5vbmljYWwueSAtIG8uY2Fub25pY2FsLnkgfHwgaS53cmFwIC0gby53cmFwIHx8IGkuY2Fub25pY2FsLnggLSBvLmNhbm9uaWNhbC54O1xuICAgIH1cbiAgICB2YXIgVSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLm1heCA9IHQsIHRoaXMub25SZW1vdmUgPSBlLCB0aGlzLnJlc2V0KCk7XG4gICAgfTtcbiAgICBVLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5kYXRhKSBmb3IgKHZhciBlID0gMCwgaSA9IHRoaXMuZGF0YVt0XTsgZSA8IGkubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBpW2VdO1xuICAgICAgICBvLnRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KG8udGltZW91dCksIHRoaXMub25SZW1vdmUoby52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kYXRhID0ge30sIHRoaXMub3JkZXIgPSBbXSwgdGhpcztcbiAgICB9LCBVLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLFxuICAgICAgICByID0gdC53cmFwcGVkKCkua2V5O1xuICAgICAgdm9pZCAwID09PSB0aGlzLmRhdGFbcl0gJiYgKHRoaXMuZGF0YVtyXSA9IFtdKTtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgdGltZW91dDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgaWYgKHZvaWQgMCAhPT0gaSAmJiAoYS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG8ucmVtb3ZlKHQsIGEpO1xuICAgICAgfSwgaSkpLCB0aGlzLmRhdGFbcl0ucHVzaChhKSwgdGhpcy5vcmRlci5wdXNoKHIpLCB0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5fZ2V0QW5kUmVtb3ZlQnlLZXkodGhpcy5vcmRlclswXSk7XG4gICAgICAgIG4gJiYgdGhpcy5vblJlbW92ZShuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIFUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC53cmFwcGVkKCkua2V5IGluIHRoaXMuZGF0YTtcbiAgICB9LCBVLnByb3RvdHlwZS5nZXRBbmRSZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHQpID8gdGhpcy5fZ2V0QW5kUmVtb3ZlQnlLZXkodC53cmFwcGVkKCkua2V5KSA6IG51bGw7XG4gICAgfSwgVS5wcm90b3R5cGUuX2dldEFuZFJlbW92ZUJ5S2V5ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5kYXRhW3RdLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gZS50aW1lb3V0ICYmIGNsZWFyVGltZW91dChlLnRpbWVvdXQpLCAwID09PSB0aGlzLmRhdGFbdF0ubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmRhdGFbdF0sIHRoaXMub3JkZXIuc3BsaWNlKHRoaXMub3JkZXIuaW5kZXhPZih0KSwgMSksIGUudmFsdWU7XG4gICAgfSwgVS5wcm90b3R5cGUuZ2V0QnlLZXkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmRhdGFbdF07XG4gICAgICByZXR1cm4gZSA/IGVbMF0udmFsdWUgOiBudWxsO1xuICAgIH0sIFUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModCkgPyB0aGlzLmRhdGFbdC53cmFwcGVkKCkua2V5XVswXS52YWx1ZSA6IG51bGw7XG4gICAgfSwgVS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModCkpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGkgPSB0LndyYXBwZWQoKS5rZXksXG4gICAgICAgIG8gPSB2b2lkIDAgPT09IGUgPyAwIDogdGhpcy5kYXRhW2ldLmluZGV4T2YoZSksXG4gICAgICAgIHIgPSB0aGlzLmRhdGFbaV1bb107XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW2ldLnNwbGljZShvLCAxKSwgci50aW1lb3V0ICYmIGNsZWFyVGltZW91dChyLnRpbWVvdXQpLCAwID09PSB0aGlzLmRhdGFbaV0ubGVuZ3RoICYmIGRlbGV0ZSB0aGlzLmRhdGFbaV0sIHRoaXMub25SZW1vdmUoci52YWx1ZSksIHRoaXMub3JkZXIuc3BsaWNlKHRoaXMub3JkZXIuaW5kZXhPZihpKSwgMSksIHRoaXM7XG4gICAgfSwgVS5wcm90b3R5cGUuc2V0TWF4U2l6ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHRoaXMubWF4ID0gdDsgdGhpcy5vcmRlci5sZW5ndGggPiB0aGlzLm1heDspIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9nZXRBbmRSZW1vdmVCeUtleSh0aGlzLm9yZGVyWzBdKTtcbiAgICAgICAgZSAmJiB0aGlzLm9uUmVtb3ZlKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgVS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gW107XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuZGF0YSkgZm9yICh2YXIgbyA9IDAsIHIgPSB0aGlzLmRhdGFbaV07IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgIHZhciBhID0gcltvXTtcbiAgICAgICAgdChhLnZhbHVlKSB8fCBlLnB1c2goYSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuID0gMCwgcyA9IGU7IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBsID0gc1tuXTtcbiAgICAgICAgdGhpcy5yZW1vdmUobC52YWx1ZS50aWxlSUQsIGwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIE4gPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gdDtcbiAgICAgIHZhciBvID0gdC5nbDtcbiAgICAgIHRoaXMuYnVmZmVyID0gby5jcmVhdGVCdWZmZXIoKSwgdGhpcy5keW5hbWljRHJhdyA9IEJvb2xlYW4oaSksIHRoaXMuY29udGV4dC51bmJpbmRWQU8oKSwgdC5iaW5kRWxlbWVudEJ1ZmZlci5zZXQodGhpcy5idWZmZXIpLCBvLmJ1ZmZlckRhdGEoby5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZS5hcnJheUJ1ZmZlciwgdGhpcy5keW5hbWljRHJhdyA/IG8uRFlOQU1JQ19EUkFXIDogby5TVEFUSUNfRFJBVyksIHRoaXMuZHluYW1pY0RyYXcgfHwgZGVsZXRlIGUuYXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgICBOLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb250ZXh0LmJpbmRFbGVtZW50QnVmZmVyLnNldCh0aGlzLmJ1ZmZlcik7XG4gICAgfSwgTi5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgIHRoaXMuY29udGV4dC51bmJpbmRWQU8oKSwgdGhpcy5iaW5kKCksIGUuYnVmZmVyU3ViRGF0YShlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCAwLCB0LmFycmF5QnVmZmVyKTtcbiAgICB9LCBOLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5idWZmZXIgJiYgKHRoaXMuY29udGV4dC5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpLCBkZWxldGUgdGhpcy5idWZmZXIpO1xuICAgIH07XG4gICAgdmFyIFogPSB7XG4gICAgICAgIEludDg6IFwiQllURVwiLFxuICAgICAgICBVaW50ODogXCJVTlNJR05FRF9CWVRFXCIsXG4gICAgICAgIEludDE2OiBcIlNIT1JUXCIsXG4gICAgICAgIFVpbnQxNjogXCJVTlNJR05FRF9TSE9SVFwiLFxuICAgICAgICBJbnQzMjogXCJJTlRcIixcbiAgICAgICAgVWludDMyOiBcIlVOU0lHTkVEX0lOVFwiLFxuICAgICAgICBGbG9hdDMyOiBcIkZMT0FUXCJcbiAgICAgIH0sXG4gICAgICBxID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBlLmxlbmd0aCwgdGhpcy5hdHRyaWJ1dGVzID0gaSwgdGhpcy5pdGVtU2l6ZSA9IGUuYnl0ZXNQZXJFbGVtZW50LCB0aGlzLmR5bmFtaWNEcmF3ID0gbywgdGhpcy5jb250ZXh0ID0gdDtcbiAgICAgICAgdmFyIHIgPSB0LmdsO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHIuY3JlYXRlQnVmZmVyKCksIHQuYmluZFZlcnRleEJ1ZmZlci5zZXQodGhpcy5idWZmZXIpLCByLmJ1ZmZlckRhdGEoci5BUlJBWV9CVUZGRVIsIGUuYXJyYXlCdWZmZXIsIHRoaXMuZHluYW1pY0RyYXcgPyByLkRZTkFNSUNfRFJBVyA6IHIuU1RBVElDX0RSQVcpLCB0aGlzLmR5bmFtaWNEcmF3IHx8IGRlbGV0ZSBlLmFycmF5QnVmZmVyO1xuICAgICAgfTtcbiAgICBxLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jb250ZXh0LmJpbmRWZXJ0ZXhCdWZmZXIuc2V0KHRoaXMuYnVmZmVyKTtcbiAgICB9LCBxLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgdGhpcy5iaW5kKCksIGUuYnVmZmVyU3ViRGF0YShlLkFSUkFZX0JVRkZFUiwgMCwgdC5hcnJheUJ1ZmZlcik7XG4gICAgfSwgcS5wcm90b3R5cGUuZW5hYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbyA9IGUuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZV07XG4gICAgICAgIHZvaWQgMCAhPT0gbyAmJiB0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG8pO1xuICAgICAgfVxuICAgIH0sIHEucHJvdG90eXBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5hdHRyaWJ1dGVzW29dLFxuICAgICAgICAgIGEgPSBlLmF0dHJpYnV0ZXNbci5uYW1lXTtcbiAgICAgICAgdm9pZCAwICE9PSBhICYmIHQudmVydGV4QXR0cmliUG9pbnRlcihhLCByLmNvbXBvbmVudHMsIHRbWltyLnR5cGVdXSwgITEsIHRoaXMuaXRlbVNpemUsIHIub2Zmc2V0ICsgdGhpcy5pdGVtU2l6ZSAqIChpIHx8IDApKTtcbiAgICAgIH1cbiAgICB9LCBxLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5idWZmZXIgJiYgKHRoaXMuY29udGV4dC5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpLCBkZWxldGUgdGhpcy5idWZmZXIpO1xuICAgIH07XG4gICAgdmFyIGogPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5nbCA9IHQuZ2wsIHRoaXMuZGVmYXVsdCA9IHRoaXMuZ2V0RGVmYXVsdCgpLCB0aGlzLmN1cnJlbnQgPSB0aGlzLmRlZmF1bHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICB9O1xuICAgIGoucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfSwgai5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHt9LCBqLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdDtcbiAgICB9LCBqLnByb3RvdHlwZS5zZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5kZWZhdWx0KTtcbiAgICB9O1xuICAgIHZhciBWID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdC5Db2xvci50cmFuc3BhcmVudDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAodC5yICE9PSBlLnIgfHwgdC5nICE9PSBlLmcgfHwgdC5iICE9PSBlLmIgfHwgdC5hICE9PSBlLmEgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY2xlYXJDb2xvcih0LnIsIHQuZywgdC5iLCB0LmEpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBpO1xuICAgICAgfShqKSxcbiAgICAgIEcgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY2xlYXJEZXB0aCh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBXID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmNsZWFyU3RlbmNpbCh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBYID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gWyEwLCAhMCwgITAsICEwXTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAodFswXSAhPT0gZVswXSB8fCB0WzFdICE9PSBlWzFdIHx8IHRbMl0gIT09IGVbMl0gfHwgdFszXSAhPT0gZVszXSB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5jb2xvck1hc2sodFswXSwgdFsxXSwgdFsyXSwgdFszXSksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgSCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuZGVwdGhNYXNrKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIEsgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAyNTU7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5zdGVuY2lsTWFzayh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBZID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnVuYzogdGhpcy5nbC5BTFdBWVMsXG4gICAgICAgICAgICByZWY6IDAsXG4gICAgICAgICAgICBtYXNrOiAyNTVcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICh0LmZ1bmMgIT09IGUuZnVuYyB8fCB0LnJlZiAhPT0gZS5yZWYgfHwgdC5tYXNrICE9PSBlLm1hc2sgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuc3RlbmNpbEZ1bmModC5mdW5jLCB0LnJlZiwgdC5tYXNrKSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBKID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2w7XG4gICAgICAgICAgcmV0dXJuIFt0LktFRVAsIHQuS0VFUCwgdC5LRUVQXTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAodFswXSAhPT0gZVswXSB8fCB0WzFdICE9PSBlWzFdIHx8IHRbMl0gIT09IGVbMl0gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuc3RlbmNpbE9wKHRbMF0sIHRbMV0sIHRbMl0pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIFEgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHQgPyBlLmVuYWJsZShlLlNURU5DSUxfVEVTVCkgOiBlLmRpc2FibGUoZS5TVEVOQ0lMX1RFU1QpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgICQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgKHRbMF0gIT09IGVbMF0gfHwgdFsxXSAhPT0gZVsxXSB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC5kZXB0aFJhbmdlKHRbMF0sIHRbMV0pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIHR0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgICB0ID8gZS5lbmFibGUoZS5ERVBUSF9URVNUKSA6IGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIGV0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nbC5MRVNTO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuZGVwdGhGdW5jKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIGl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgICB0ID8gZS5lbmFibGUoZS5CTEVORCkgOiBlLmRpc2FibGUoZS5CTEVORCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgb3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5nbDtcbiAgICAgICAgICByZXR1cm4gW3QuT05FLCB0LlpFUk9dO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICh0WzBdICE9PSBlWzBdIHx8IHRbMV0gIT09IGVbMV0gfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuYmxlbmRGdW5jKHRbMF0sIHRbMV0pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIHJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgICBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdC5Db2xvci50cmFuc3BhcmVudDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAodC5yICE9PSBlLnIgfHwgdC5nICE9PSBlLmcgfHwgdC5iICE9PSBlLmIgfHwgdC5hICE9PSBlLmEgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuYmxlbmRDb2xvcih0LnIsIHQuZywgdC5iLCB0LmEpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBpO1xuICAgICAgfShqKSxcbiAgICAgIGF0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nbC5GVU5DX0FERDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmJsZW5kRXF1YXRpb24odCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHQgPyBlLmVuYWJsZShlLkNVTExfRkFDRSkgOiBlLmRpc2FibGUoZS5DVUxMX0ZBQ0UpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIHN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nbC5CQUNLO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkgJiYgKHRoaXMuZ2wuY3VsbEZhY2UodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgbHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdsLkNDVztcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmZyb250RmFjZSh0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBjdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy5nbC51c2VQcm9ncmFtKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIHV0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nbC5URVhUVVJFMDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLmFjdGl2ZVRleHR1cmUodCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMSk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgaHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5nbDtcbiAgICAgICAgICByZXR1cm4gWzAsIDAsIHQuZHJhd2luZ0J1ZmZlcldpZHRoLCB0LmRyYXdpbmdCdWZmZXJIZWlnaHRdO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICh0WzBdICE9PSBlWzBdIHx8IHRbMV0gIT09IGVbMV0gfHwgdFsyXSAhPT0gZVsyXSB8fCB0WzNdICE9PSBlWzNdIHx8IHRoaXMuZGlydHkpICYmICh0aGlzLmdsLnZpZXdwb3J0KHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIHB0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIGR0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGUuYmluZFJlbmRlcmJ1ZmZlcihlLlJFTkRFUkJVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgX3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsIHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIGZ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgbXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICBlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBndCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSkge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlKSwgdGhpcy52YW8gPSBlLmV4dFZlcnRleEFycmF5T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy52YW8gJiYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSAmJiAodGhpcy52YW8uYmluZFZlcnRleEFycmF5T0VTKHQpLCB0aGlzLmN1cnJlbnQgPSB0LCB0aGlzLmRpcnR5ID0gITEpO1xuICAgICAgICB9LCBlO1xuICAgICAgfShqKSxcbiAgICAgIHZ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuZ2V0RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGUucGl4ZWxTdG9yZWkoZS5VTlBBQ0tfQUxJR05NRU5ULCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICB5dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0ICE9PSB0aGlzLmN1cnJlbnQgfHwgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmdsO1xuICAgICAgICAgICAgZS5waXhlbFN0b3JlaShlLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgeHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGUucGl4ZWxTdG9yZWkoZS5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0KSwgdGhpcy5jdXJyZW50ID0gdCwgdGhpcy5kaXJ0eSA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZTtcbiAgICAgIH0oaiksXG4gICAgICBidCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoZSwgaSkge1xuICAgICAgICAgIHQuY2FsbCh0aGlzLCBlKSwgdGhpcy5jb250ZXh0ID0gZSwgdGhpcy5wYXJlbnQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGopLFxuICAgICAgd3QgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gITA7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHQgIT09IHRoaXMuY3VycmVudCB8fCB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuYmluZEZyYW1lYnVmZmVyLnNldCh0aGlzLnBhcmVudCk7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2w7XG4gICAgICAgICAgICBlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsIGUuQ09MT1JfQVRUQUNITUVOVDAsIGUuVEVYVFVSRV8yRCwgdCwgMCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGJ0KSxcbiAgICAgIFR0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodCAhPT0gdGhpcy5jdXJyZW50IHx8IHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5iaW5kRnJhbWVidWZmZXIuc2V0KHRoaXMucGFyZW50KTtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5nbDtcbiAgICAgICAgICAgIGUuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZS5GUkFNRUJVRkZFUiwgZS5ERVBUSF9BVFRBQ0hNRU5ULCBlLlJFTkRFUkJVRkZFUiwgdCksIHRoaXMuY3VycmVudCA9IHQsIHRoaXMuZGlydHkgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGU7XG4gICAgICB9KGJ0KSxcbiAgICAgIEV0ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdCwgdGhpcy53aWR0aCA9IGUsIHRoaXMuaGVpZ2h0ID0gaTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmZyYW1lYnVmZmVyID0gdC5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmNvbG9yQXR0YWNobWVudCA9IG5ldyB3dCh0LCByKSwgbyAmJiAodGhpcy5kZXB0aEF0dGFjaG1lbnQgPSBuZXcgVHQodCwgcikpO1xuICAgICAgfTtcbiAgICBFdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jb250ZXh0LmdsLFxuICAgICAgICBlID0gdGhpcy5jb2xvckF0dGFjaG1lbnQuZ2V0KCk7XG4gICAgICBpZiAoZSAmJiB0LmRlbGV0ZVRleHR1cmUoZSksIHRoaXMuZGVwdGhBdHRhY2htZW50KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5kZXB0aEF0dGFjaG1lbnQuZ2V0KCk7XG4gICAgICAgIGkgJiYgdC5kZWxldGVSZW5kZXJidWZmZXIoaSk7XG4gICAgICB9XG4gICAgICB0LmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIH07XG4gICAgdmFyIEl0ID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuZnVuYyA9IHQsIHRoaXMubWFzayA9IGUsIHRoaXMucmFuZ2UgPSBpO1xuICAgIH07XG4gICAgSXQuUmVhZE9ubHkgPSAhMSwgSXQuUmVhZFdyaXRlID0gITAsIEl0LmRpc2FibGVkID0gbmV3IEl0KDUxOSwgSXQuUmVhZE9ubHksIFswLCAxXSk7XG4gICAgdmFyIFB0ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHRoaXMudGVzdCA9IHQsIHRoaXMucmVmID0gZSwgdGhpcy5tYXNrID0gaSwgdGhpcy5mYWlsID0gbywgdGhpcy5kZXB0aEZhaWwgPSByLCB0aGlzLnBhc3MgPSBhO1xuICAgIH07XG4gICAgUHQuZGlzYWJsZWQgPSBuZXcgUHQoe1xuICAgICAgZnVuYzogNTE5LFxuICAgICAgbWFzazogMFxuICAgIH0sIDAsIDAsIDc2ODAsIDc2ODAsIDc2ODApO1xuICAgIHZhciBTdCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLmJsZW5kRnVuY3Rpb24gPSB0LCB0aGlzLmJsZW5kQ29sb3IgPSBlLCB0aGlzLm1hc2sgPSBpO1xuICAgIH07XG4gICAgU3QuZGlzYWJsZWQgPSBuZXcgU3QoU3QuUmVwbGFjZSA9IFsxLCAwXSwgdC5Db2xvci50cmFuc3BhcmVudCwgWyExLCAhMSwgITEsICExXSksIFN0LnVuYmxlbmRlZCA9IG5ldyBTdChTdC5SZXBsYWNlLCB0LkNvbG9yLnRyYW5zcGFyZW50LCBbITAsICEwLCAhMCwgITBdKSwgU3QuYWxwaGFCbGVuZGVkID0gbmV3IFN0KFsxLCA3NzFdLCB0LkNvbG9yLnRyYW5zcGFyZW50LCBbITAsICEwLCAhMCwgITBdKTtcbiAgICB2YXIgQ3QgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5lbmFibGUgPSB0LCB0aGlzLm1vZGUgPSBlLCB0aGlzLmZyb250RmFjZSA9IGk7XG4gICAgfTtcbiAgICBDdC5kaXNhYmxlZCA9IG5ldyBDdCghMSwgMTAyOSwgMjMwNSksIEN0LmJhY2tDQ1cgPSBuZXcgQ3QoITAsIDEwMjksIDIzMDUpO1xuICAgIHZhciB6dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmdsID0gdCwgdGhpcy5leHRWZXJ0ZXhBcnJheU9iamVjdCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiksIHRoaXMuY2xlYXJDb2xvciA9IG5ldyBWKHRoaXMpLCB0aGlzLmNsZWFyRGVwdGggPSBuZXcgRyh0aGlzKSwgdGhpcy5jbGVhclN0ZW5jaWwgPSBuZXcgVyh0aGlzKSwgdGhpcy5jb2xvck1hc2sgPSBuZXcgWCh0aGlzKSwgdGhpcy5kZXB0aE1hc2sgPSBuZXcgSCh0aGlzKSwgdGhpcy5zdGVuY2lsTWFzayA9IG5ldyBLKHRoaXMpLCB0aGlzLnN0ZW5jaWxGdW5jID0gbmV3IFkodGhpcyksIHRoaXMuc3RlbmNpbE9wID0gbmV3IEoodGhpcyksIHRoaXMuc3RlbmNpbFRlc3QgPSBuZXcgUSh0aGlzKSwgdGhpcy5kZXB0aFJhbmdlID0gbmV3ICQodGhpcyksIHRoaXMuZGVwdGhUZXN0ID0gbmV3IHR0KHRoaXMpLCB0aGlzLmRlcHRoRnVuYyA9IG5ldyBldCh0aGlzKSwgdGhpcy5ibGVuZCA9IG5ldyBpdCh0aGlzKSwgdGhpcy5ibGVuZEZ1bmMgPSBuZXcgb3QodGhpcyksIHRoaXMuYmxlbmRDb2xvciA9IG5ldyBydCh0aGlzKSwgdGhpcy5ibGVuZEVxdWF0aW9uID0gbmV3IGF0KHRoaXMpLCB0aGlzLmN1bGxGYWNlID0gbmV3IG50KHRoaXMpLCB0aGlzLmN1bGxGYWNlU2lkZSA9IG5ldyBzdCh0aGlzKSwgdGhpcy5mcm9udEZhY2UgPSBuZXcgbHQodGhpcyksIHRoaXMucHJvZ3JhbSA9IG5ldyBjdCh0aGlzKSwgdGhpcy5hY3RpdmVUZXh0dXJlID0gbmV3IHV0KHRoaXMpLCB0aGlzLnZpZXdwb3J0ID0gbmV3IGh0KHRoaXMpLCB0aGlzLmJpbmRGcmFtZWJ1ZmZlciA9IG5ldyBwdCh0aGlzKSwgdGhpcy5iaW5kUmVuZGVyYnVmZmVyID0gbmV3IGR0KHRoaXMpLCB0aGlzLmJpbmRUZXh0dXJlID0gbmV3IF90KHRoaXMpLCB0aGlzLmJpbmRWZXJ0ZXhCdWZmZXIgPSBuZXcgZnQodGhpcyksIHRoaXMuYmluZEVsZW1lbnRCdWZmZXIgPSBuZXcgbXQodGhpcyksIHRoaXMuYmluZFZlcnRleEFycmF5T0VTID0gdGhpcy5leHRWZXJ0ZXhBcnJheU9iamVjdCAmJiBuZXcgZ3QodGhpcyksIHRoaXMucGl4ZWxTdG9yZVVucGFjayA9IG5ldyB2dCh0aGlzKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrUHJlbXVsdGlwbHlBbHBoYSA9IG5ldyB5dCh0aGlzKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrRmxpcFkgPSBuZXcgeHQodGhpcyksIHRoaXMuZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljID0gdC5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikgfHwgdC5nZXRFeHRlbnNpb24oXCJNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpIHx8IHQuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSwgdGhpcy5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMgJiYgKHRoaXMuZXh0VGV4dHVyZUZpbHRlckFuaXNvdHJvcGljTWF4ID0gdC5nZXRQYXJhbWV0ZXIodGhpcy5leHRUZXh0dXJlRmlsdGVyQW5pc290cm9waWMuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKSksIHRoaXMuZXh0VGV4dHVyZUhhbGZGbG9hdCA9IHQuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSwgdGhpcy5leHRUZXh0dXJlSGFsZkZsb2F0ICYmICh0LmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpLCB0aGlzLmV4dFJlbmRlclRvVGV4dHVyZUhhbGZGbG9hdCA9IHQuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKSwgdGhpcy5leHRUaW1lclF1ZXJ5ID0gdC5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIiksIHRoaXMubWF4VGV4dHVyZVNpemUgPSB0LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICAgIH07XG4gICAgenQucHJvdG90eXBlLnNldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnVuYmluZFZBTygpLCB0aGlzLmNsZWFyQ29sb3Iuc2V0RGVmYXVsdCgpLCB0aGlzLmNsZWFyRGVwdGguc2V0RGVmYXVsdCgpLCB0aGlzLmNsZWFyU3RlbmNpbC5zZXREZWZhdWx0KCksIHRoaXMuY29sb3JNYXNrLnNldERlZmF1bHQoKSwgdGhpcy5kZXB0aE1hc2suc2V0RGVmYXVsdCgpLCB0aGlzLnN0ZW5jaWxNYXNrLnNldERlZmF1bHQoKSwgdGhpcy5zdGVuY2lsRnVuYy5zZXREZWZhdWx0KCksIHRoaXMuc3RlbmNpbE9wLnNldERlZmF1bHQoKSwgdGhpcy5zdGVuY2lsVGVzdC5zZXREZWZhdWx0KCksIHRoaXMuZGVwdGhSYW5nZS5zZXREZWZhdWx0KCksIHRoaXMuZGVwdGhUZXN0LnNldERlZmF1bHQoKSwgdGhpcy5kZXB0aEZ1bmMuc2V0RGVmYXVsdCgpLCB0aGlzLmJsZW5kLnNldERlZmF1bHQoKSwgdGhpcy5ibGVuZEZ1bmMuc2V0RGVmYXVsdCgpLCB0aGlzLmJsZW5kQ29sb3Iuc2V0RGVmYXVsdCgpLCB0aGlzLmJsZW5kRXF1YXRpb24uc2V0RGVmYXVsdCgpLCB0aGlzLmN1bGxGYWNlLnNldERlZmF1bHQoKSwgdGhpcy5jdWxsRmFjZVNpZGUuc2V0RGVmYXVsdCgpLCB0aGlzLmZyb250RmFjZS5zZXREZWZhdWx0KCksIHRoaXMucHJvZ3JhbS5zZXREZWZhdWx0KCksIHRoaXMuYWN0aXZlVGV4dHVyZS5zZXREZWZhdWx0KCksIHRoaXMuYmluZEZyYW1lYnVmZmVyLnNldERlZmF1bHQoKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrLnNldERlZmF1bHQoKSwgdGhpcy5waXhlbFN0b3JlVW5wYWNrUHJlbXVsdGlwbHlBbHBoYS5zZXREZWZhdWx0KCksIHRoaXMucGl4ZWxTdG9yZVVucGFja0ZsaXBZLnNldERlZmF1bHQoKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuc2V0RGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNsZWFyQ29sb3IuZGlydHkgPSAhMCwgdGhpcy5jbGVhckRlcHRoLmRpcnR5ID0gITAsIHRoaXMuY2xlYXJTdGVuY2lsLmRpcnR5ID0gITAsIHRoaXMuY29sb3JNYXNrLmRpcnR5ID0gITAsIHRoaXMuZGVwdGhNYXNrLmRpcnR5ID0gITAsIHRoaXMuc3RlbmNpbE1hc2suZGlydHkgPSAhMCwgdGhpcy5zdGVuY2lsRnVuYy5kaXJ0eSA9ICEwLCB0aGlzLnN0ZW5jaWxPcC5kaXJ0eSA9ICEwLCB0aGlzLnN0ZW5jaWxUZXN0LmRpcnR5ID0gITAsIHRoaXMuZGVwdGhSYW5nZS5kaXJ0eSA9ICEwLCB0aGlzLmRlcHRoVGVzdC5kaXJ0eSA9ICEwLCB0aGlzLmRlcHRoRnVuYy5kaXJ0eSA9ICEwLCB0aGlzLmJsZW5kLmRpcnR5ID0gITAsIHRoaXMuYmxlbmRGdW5jLmRpcnR5ID0gITAsIHRoaXMuYmxlbmRDb2xvci5kaXJ0eSA9ICEwLCB0aGlzLmJsZW5kRXF1YXRpb24uZGlydHkgPSAhMCwgdGhpcy5jdWxsRmFjZS5kaXJ0eSA9ICEwLCB0aGlzLmN1bGxGYWNlU2lkZS5kaXJ0eSA9ICEwLCB0aGlzLmZyb250RmFjZS5kaXJ0eSA9ICEwLCB0aGlzLnByb2dyYW0uZGlydHkgPSAhMCwgdGhpcy5hY3RpdmVUZXh0dXJlLmRpcnR5ID0gITAsIHRoaXMudmlld3BvcnQuZGlydHkgPSAhMCwgdGhpcy5iaW5kRnJhbWVidWZmZXIuZGlydHkgPSAhMCwgdGhpcy5iaW5kUmVuZGVyYnVmZmVyLmRpcnR5ID0gITAsIHRoaXMuYmluZFRleHR1cmUuZGlydHkgPSAhMCwgdGhpcy5iaW5kVmVydGV4QnVmZmVyLmRpcnR5ID0gITAsIHRoaXMuYmluZEVsZW1lbnRCdWZmZXIuZGlydHkgPSAhMCwgdGhpcy5leHRWZXJ0ZXhBcnJheU9iamVjdCAmJiAodGhpcy5iaW5kVmVydGV4QXJyYXlPRVMuZGlydHkgPSAhMCksIHRoaXMucGl4ZWxTdG9yZVVucGFjay5kaXJ0eSA9ICEwLCB0aGlzLnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhLmRpcnR5ID0gITAsIHRoaXMucGl4ZWxTdG9yZVVucGFja0ZsaXBZLmRpcnR5ID0gITA7XG4gICAgfSwgenQucHJvdG90eXBlLmNyZWF0ZUluZGV4QnVmZmVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiBuZXcgTih0aGlzLCB0LCBlKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuY3JlYXRlVmVydGV4QnVmZmVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiBuZXcgcSh0aGlzLCB0LCBlLCBpKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuY3JlYXRlUmVuZGVyYnVmZmVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5nbCxcbiAgICAgICAgciA9IG8uY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5iaW5kUmVuZGVyYnVmZmVyLnNldChyKSwgby5yZW5kZXJidWZmZXJTdG9yYWdlKG8uUkVOREVSQlVGRkVSLCB0LCBlLCBpKSwgdGhpcy5iaW5kUmVuZGVyYnVmZmVyLnNldChudWxsKSwgcjtcbiAgICB9LCB6dC5wcm90b3R5cGUuY3JlYXRlRnJhbWVidWZmZXIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIG5ldyBFdCh0aGlzLCB0LCBlLCBpKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmNvbG9yLFxuICAgICAgICBpID0gdC5kZXB0aCxcbiAgICAgICAgbyA9IHRoaXMuZ2wsXG4gICAgICAgIHIgPSAwO1xuICAgICAgZSAmJiAociB8PSBvLkNPTE9SX0JVRkZFUl9CSVQsIHRoaXMuY2xlYXJDb2xvci5zZXQoZSksIHRoaXMuY29sb3JNYXNrLnNldChbITAsICEwLCAhMCwgITBdKSksIHZvaWQgMCAhPT0gaSAmJiAociB8PSBvLkRFUFRIX0JVRkZFUl9CSVQsIHRoaXMuZGVwdGhSYW5nZS5zZXQoWzAsIDFdKSwgdGhpcy5jbGVhckRlcHRoLnNldChpKSwgdGhpcy5kZXB0aE1hc2suc2V0KCEwKSksIG8uY2xlYXIocik7XG4gICAgfSwgenQucHJvdG90eXBlLnNldEN1bGxGYWNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICExID09PSB0LmVuYWJsZSA/IHRoaXMuY3VsbEZhY2Uuc2V0KCExKSA6ICh0aGlzLmN1bGxGYWNlLnNldCghMCksIHRoaXMuY3VsbEZhY2VTaWRlLnNldCh0Lm1vZGUpLCB0aGlzLmZyb250RmFjZS5zZXQodC5mcm9udEZhY2UpKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuc2V0RGVwdGhNb2RlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQuZnVuYyAhPT0gdGhpcy5nbC5BTFdBWVMgfHwgdC5tYXNrID8gKHRoaXMuZGVwdGhUZXN0LnNldCghMCksIHRoaXMuZGVwdGhGdW5jLnNldCh0LmZ1bmMpLCB0aGlzLmRlcHRoTWFzay5zZXQodC5tYXNrKSwgdGhpcy5kZXB0aFJhbmdlLnNldCh0LnJhbmdlKSkgOiB0aGlzLmRlcHRoVGVzdC5zZXQoITEpO1xuICAgIH0sIHp0LnByb3RvdHlwZS5zZXRTdGVuY2lsTW9kZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnRlc3QuZnVuYyAhPT0gdGhpcy5nbC5BTFdBWVMgfHwgdC5tYXNrID8gKHRoaXMuc3RlbmNpbFRlc3Quc2V0KCEwKSwgdGhpcy5zdGVuY2lsTWFzay5zZXQodC5tYXNrKSwgdGhpcy5zdGVuY2lsT3Auc2V0KFt0LmZhaWwsIHQuZGVwdGhGYWlsLCB0LnBhc3NdKSwgdGhpcy5zdGVuY2lsRnVuYy5zZXQoe1xuICAgICAgICBmdW5jOiB0LnRlc3QuZnVuYyxcbiAgICAgICAgcmVmOiB0LnJlZixcbiAgICAgICAgbWFzazogdC50ZXN0Lm1hc2tcbiAgICAgIH0pKSA6IHRoaXMuc3RlbmNpbFRlc3Quc2V0KCExKTtcbiAgICB9LCB6dC5wcm90b3R5cGUuc2V0Q29sb3JNb2RlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHQuZGVlcEVxdWFsKGUuYmxlbmRGdW5jdGlvbiwgU3QuUmVwbGFjZSkgPyB0aGlzLmJsZW5kLnNldCghMSkgOiAodGhpcy5ibGVuZC5zZXQoITApLCB0aGlzLmJsZW5kRnVuYy5zZXQoZS5ibGVuZEZ1bmN0aW9uKSwgdGhpcy5ibGVuZENvbG9yLnNldChlLmJsZW5kQ29sb3IpKSwgdGhpcy5jb2xvck1hc2suc2V0KGUubWFzayk7XG4gICAgfSwgenQucHJvdG90eXBlLnVuYmluZFZBTyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZXh0VmVydGV4QXJyYXlPYmplY3QgJiYgdGhpcy5iaW5kVmVydGV4QXJyYXlPRVMuc2V0KG51bGwpO1xuICAgIH07XG4gICAgdmFyIER0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZ1bmN0aW9uIGkoaSwgbywgcikge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5pZCA9IGksIHRoaXMuZGlzcGF0Y2hlciA9IHIsIHRoaXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgXCJzb3VyY2VcIiA9PT0gdC5kYXRhVHlwZSAmJiBcIm1ldGFkYXRhXCIgPT09IHQuc291cmNlRGF0YVR5cGUgJiYgKGEuX3NvdXJjZUxvYWRlZCA9ICEwKSwgYS5fc291cmNlTG9hZGVkICYmICFhLl9wYXVzZWQgJiYgXCJzb3VyY2VcIiA9PT0gdC5kYXRhVHlwZSAmJiBcImNvbnRlbnRcIiA9PT0gdC5zb3VyY2VEYXRhVHlwZSAmJiAoYS5yZWxvYWQoKSwgYS50cmFuc2Zvcm0gJiYgYS51cGRhdGUoYS50cmFuc2Zvcm0pKTtcbiAgICAgICAgfSksIHRoaXMub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5fc291cmNlRXJyb3JlZCA9ICEwO1xuICAgICAgICB9KSwgdGhpcy5fc291cmNlID0gZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgICB2YXIgYSA9IG5ldyBrW2kudHlwZV0oZSwgaSwgbywgcik7XG4gICAgICAgICAgaWYgKGEuaWQgIT09IGUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFNvdXJjZSBpZCB0byBiZSBcIiArIGUgKyBcIiBpbnN0ZWFkIG9mIFwiICsgYS5pZCk7XG4gICAgICAgICAgcmV0dXJuIHQuYmluZEFsbChbXCJsb2FkXCIsIFwiYWJvcnRcIiwgXCJ1bmxvYWRcIiwgXCJzZXJpYWxpemVcIiwgXCJwcmVwYXJlXCJdLCBhKSwgYTtcbiAgICAgICAgfShpLCBvLCByLCB0aGlzKSwgdGhpcy5fdGlsZXMgPSB7fSwgdGhpcy5fY2FjaGUgPSBuZXcgVSgwLCB0aGlzLl91bmxvYWRUaWxlLmJpbmQodGhpcykpLCB0aGlzLl90aW1lcnMgPSB7fSwgdGhpcy5fY2FjaGVUaW1lcnMgPSB7fSwgdGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSA9IG51bGwsIHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzID0ge30sIHRoaXMuX2NvdmVyZWRUaWxlcyA9IHt9LCB0aGlzLl9zdGF0ZSA9IG5ldyB0LlNvdXJjZUZlYXR1cmVTdGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLm1hcCA9IHQsIHRoaXMuX21heFRpbGVDYWNoZVNpemUgPSB0ID8gdC5fbWF4VGlsZUNhY2hlU2l6ZSA6IG51bGwsIHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2Uub25BZGQgJiYgdGhpcy5fc291cmNlLm9uQWRkKHQpO1xuICAgICAgfSwgaS5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLm9uUmVtb3ZlICYmIHRoaXMuX3NvdXJjZS5vblJlbW92ZSh0KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZUVycm9yZWQpIHJldHVybiAhMDtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VMb2FkZWQpIHJldHVybiAhMTtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2UubG9hZGVkKCkpIHJldHVybiAhMTtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgICAgaWYgKFwibG9hZGVkXCIgIT09IGUuc3RhdGUgJiYgXCJlcnJvcmVkXCIgIT09IGUuc3RhdGUpIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gITA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgICAgICB2YXIgdCA9IHRoaXMuX3Nob3VsZFJlbG9hZE9uUmVzdW1lO1xuICAgICAgICAgIHRoaXMuX3BhdXNlZCA9ICExLCB0aGlzLl9zaG91bGRSZWxvYWRPblJlc3VtZSA9ICExLCB0ICYmIHRoaXMucmVsb2FkKCksIHRoaXMudHJhbnNmb3JtICYmIHRoaXMudXBkYXRlKHRoaXMudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuX2xvYWRUaWxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb2FkVGlsZSh0LCBlKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl91bmxvYWRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZS51bmxvYWRUaWxlKSByZXR1cm4gdGhpcy5fc291cmNlLnVubG9hZFRpbGUodCwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2Fib3J0VGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2UuYWJvcnRUaWxlKSByZXR1cm4gdGhpcy5fc291cmNlLmFib3J0VGlsZSh0LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc2VyaWFsaXplKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLl9zb3VyY2UucHJlcGFyZSAmJiB0aGlzLl9zb3VyY2UucHJlcGFyZSgpLCB0aGlzLl9zdGF0ZS5jb2FsZXNjZUNoYW5nZXModGhpcy5fdGlsZXMsIHRoaXMubWFwID8gdGhpcy5tYXAucGFpbnRlciA6IG51bGwpLCB0aGlzLl90aWxlcykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fdGlsZXNbZV07XG4gICAgICAgICAgaS51cGxvYWQodCksIGkucHJlcGFyZSh0aGlzLm1hcC5zdHlsZS5pbWFnZU1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlcyh0aGlzLl90aWxlcykubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQudGlsZUlEO1xuICAgICAgICB9KS5zb3J0KEF0KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5rZXk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UmVuZGVyYWJsZUlkcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcyxcbiAgICAgICAgICBvID0gW107XG4gICAgICAgIGZvciAodmFyIHIgaW4gdGhpcy5fdGlsZXMpIHRoaXMuX2lzSWRSZW5kZXJhYmxlKHIsIGUpICYmIG8ucHVzaCh0aGlzLl90aWxlc1tyXSk7XG4gICAgICAgIHJldHVybiBlID8gby5zb3J0KGZ1bmN0aW9uIChlLCBvKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLnRpbGVJRCxcbiAgICAgICAgICAgIGEgPSBvLnRpbGVJRCxcbiAgICAgICAgICAgIG4gPSBuZXcgdC5Qb2ludChyLmNhbm9uaWNhbC54LCByLmNhbm9uaWNhbC55KS5fcm90YXRlKGkudHJhbnNmb3JtLmFuZ2xlKSxcbiAgICAgICAgICAgIHMgPSBuZXcgdC5Qb2ludChhLmNhbm9uaWNhbC54LCBhLmNhbm9uaWNhbC55KS5fcm90YXRlKGkudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgICByZXR1cm4gci5vdmVyc2NhbGVkWiAtIGEub3ZlcnNjYWxlZFogfHwgcy55IC0gbi55IHx8IHMueCAtIG4ueDtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQudGlsZUlELmtleTtcbiAgICAgICAgfSkgOiBvLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnRpbGVJRDtcbiAgICAgICAgfSkuc29ydChBdCkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQua2V5O1xuICAgICAgICB9KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1JlbmRlcmFibGVQYXJlbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZmluZExvYWRlZFBhcmVudCh0LCAwKTtcbiAgICAgICAgcmV0dXJuICEhZSAmJiB0aGlzLl9pc0lkUmVuZGVyYWJsZShlLnRpbGVJRC5rZXkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2lzSWRSZW5kZXJhYmxlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzW3RdICYmIHRoaXMuX3RpbGVzW3RdLmhhc0RhdGEoKSAmJiAhdGhpcy5fY292ZXJlZFRpbGVzW3RdICYmIChlIHx8ICF0aGlzLl90aWxlc1t0XS5ob2xkaW5nRm9yRmFkZSgpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdXNlZCkgdGhpcy5fc2hvdWxkUmVsb2FkT25SZXN1bWUgPSAhMDtlbHNlIGZvciAodmFyIHQgaW4gdGhpcy5fY2FjaGUucmVzZXQoKSwgdGhpcy5fdGlsZXMpIFwiZXJyb3JlZFwiICE9PSB0aGlzLl90aWxlc1t0XS5zdGF0ZSAmJiB0aGlzLl9yZWxvYWRUaWxlKHQsIFwicmVsb2FkaW5nXCIpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbG9hZFRpbGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX3RpbGVzW3RdO1xuICAgICAgICBpICYmIChcImxvYWRpbmdcIiAhPT0gaS5zdGF0ZSAmJiAoaS5zdGF0ZSA9IGUpLCB0aGlzLl9sb2FkVGlsZShpLCB0aGlzLl90aWxlTG9hZGVkLmJpbmQodGhpcywgaSwgdCwgZSkpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl90aWxlTG9hZGVkID0gZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgaWYgKHIpIHJldHVybiBlLnN0YXRlID0gXCJlcnJvcmVkXCIsIHZvaWQgKDQwNCAhPT0gci5zdGF0dXMgPyB0aGlzLl9zb3VyY2UuZmlyZShuZXcgdC5FcnJvckV2ZW50KHIsIHtcbiAgICAgICAgICB0aWxlOiBlXG4gICAgICAgIH0pKSA6IHRoaXMudXBkYXRlKHRoaXMudHJhbnNmb3JtKSk7XG4gICAgICAgIGUudGltZUFkZGVkID0gdC5icm93c2VyLm5vdygpLCBcImV4cGlyZWRcIiA9PT0gbyAmJiAoZS5yZWZyZXNoZWRVcG9uRXhwaXJhdGlvbiA9ICEwKSwgdGhpcy5fc2V0VGlsZVJlbG9hZFRpbWVyKGksIGUpLCBcInJhc3Rlci1kZW1cIiA9PT0gdGhpcy5nZXRTb3VyY2UoKS50eXBlICYmIGUuZGVtICYmIHRoaXMuX2JhY2tmaWxsREVNKGUpLCB0aGlzLl9zdGF0ZS5pbml0aWFsaXplVGlsZVN0YXRlKGUsIHRoaXMubWFwID8gdGhpcy5tYXAucGFpbnRlciA6IG51bGwpLCB0aGlzLl9zb3VyY2UuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgIHRpbGU6IGUsXG4gICAgICAgICAgY29vcmQ6IGUudGlsZUlEXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9iYWNrZmlsbERFTSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGUgPSB0aGlzLmdldFJlbmRlcmFibGVJZHMoKSwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG8gPSBlW2ldO1xuICAgICAgICAgIGlmICh0Lm5laWdoYm9yaW5nVGlsZXMgJiYgdC5uZWlnaGJvcmluZ1RpbGVzW29dKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0VGlsZUJ5SUQobyk7XG4gICAgICAgICAgICBhKHQsIHIpLCBhKHIsIHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhKHQsIGUpIHtcbiAgICAgICAgICB0Lm5lZWRzSGlsbHNoYWRlUHJlcGFyZSA9ICEwO1xuICAgICAgICAgIHZhciBpID0gZS50aWxlSUQuY2Fub25pY2FsLnggLSB0LnRpbGVJRC5jYW5vbmljYWwueCxcbiAgICAgICAgICAgIG8gPSBlLnRpbGVJRC5jYW5vbmljYWwueSAtIHQudGlsZUlELmNhbm9uaWNhbC55LFxuICAgICAgICAgICAgciA9IE1hdGgucG93KDIsIHQudGlsZUlELmNhbm9uaWNhbC56KSxcbiAgICAgICAgICAgIGEgPSBlLnRpbGVJRC5rZXk7XG4gICAgICAgICAgMCA9PT0gaSAmJiAwID09PSBvIHx8IE1hdGguYWJzKG8pID4gMSB8fCAoTWF0aC5hYnMoaSkgPiAxICYmICgxID09PSBNYXRoLmFicyhpICsgcikgPyBpICs9IHIgOiAxID09PSBNYXRoLmFicyhpIC0gcikgJiYgKGkgLT0gcikpLCBlLmRlbSAmJiB0LmRlbSAmJiAodC5kZW0uYmFja2ZpbGxCb3JkZXIoZS5kZW0sIGksIG8pLCB0Lm5laWdoYm9yaW5nVGlsZXMgJiYgdC5uZWlnaGJvcmluZ1RpbGVzW2FdICYmICh0Lm5laWdoYm9yaW5nVGlsZXNbYV0uYmFja2ZpbGxlZCA9ICEwKSkpO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUJ5SUQodC5rZXkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VGlsZUJ5SUQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbdF07XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcmV0YWluTG9hZGVkQ2hpbGRyZW4gPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICBmb3IgKHZhciByIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLl90aWxlc1tyXTtcbiAgICAgICAgICBpZiAoIShvW3JdIHx8ICFhLmhhc0RhdGEoKSB8fCBhLnRpbGVJRC5vdmVyc2NhbGVkWiA8PSBlIHx8IGEudGlsZUlELm92ZXJzY2FsZWRaID4gaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSBhLnRpbGVJRDsgYSAmJiBhLnRpbGVJRC5vdmVyc2NhbGVkWiA+IGUgKyAxOykge1xuICAgICAgICAgICAgICB2YXIgcyA9IGEudGlsZUlELnNjYWxlZFRvKGEudGlsZUlELm92ZXJzY2FsZWRaIC0gMSk7XG4gICAgICAgICAgICAgIChhID0gdGhpcy5fdGlsZXNbcy5rZXldKSAmJiBhLmhhc0RhdGEoKSAmJiAobiA9IHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IG47IGwub3ZlcnNjYWxlZFogPiBlOykgaWYgKHRbKGwgPSBsLnNjYWxlZFRvKGwub3ZlcnNjYWxlZFogLSAxKSkua2V5XSkge1xuICAgICAgICAgICAgICBvW24ua2V5XSA9IG47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUuZmluZExvYWRlZFBhcmVudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGlmICh0LmtleSBpbiB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlcykge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fbG9hZGVkUGFyZW50VGlsZXNbdC5rZXldO1xuICAgICAgICAgIHJldHVybiBpICYmIGkudGlsZUlELm92ZXJzY2FsZWRaID49IGUgPyBpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBvID0gdC5vdmVyc2NhbGVkWiAtIDE7IG8gPj0gZTsgby0tKSB7XG4gICAgICAgICAgdmFyIHIgPSB0LnNjYWxlZFRvKG8pLFxuICAgICAgICAgICAgYSA9IHRoaXMuX2dldExvYWRlZFRpbGUocik7XG4gICAgICAgICAgaWYgKGEpIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZ2V0TG9hZGVkVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fdGlsZXNbdC5rZXldO1xuICAgICAgICByZXR1cm4gZSAmJiBlLmhhc0RhdGEoKSA/IGUgOiB0aGlzLl9jYWNoZS5nZXRCeUtleSh0LndyYXBwZWQoKS5rZXkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudXBkYXRlQ2FjaGVTaXplID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSBNYXRoLmNlaWwodC53aWR0aCAvIHRoaXMuX3NvdXJjZS50aWxlU2l6ZSkgKyAxLFxuICAgICAgICAgIGkgPSBNYXRoLmNlaWwodC5oZWlnaHQgLyB0aGlzLl9zb3VyY2UudGlsZVNpemUpICsgMSxcbiAgICAgICAgICBvID0gTWF0aC5mbG9vcihlICogaSAqIDUpLFxuICAgICAgICAgIHIgPSBcIm51bWJlclwiID09IHR5cGVvZiB0aGlzLl9tYXhUaWxlQ2FjaGVTaXplID8gTWF0aC5taW4odGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSwgbykgOiBvO1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXRNYXhTaXplKHIpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaGFuZGxlV3JhcEp1bXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IE1hdGgucm91bmQoKHQgLSAodm9pZCAwID09PSB0aGlzLl9wcmV2TG5nID8gdCA6IHRoaXMuX3ByZXZMbmcpKSAvIDM2MCk7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2TG5nID0gdCwgZSkge1xuICAgICAgICAgIHZhciBpID0ge307XG4gICAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLl90aWxlcykge1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLl90aWxlc1tvXTtcbiAgICAgICAgICAgIHIudGlsZUlEID0gci50aWxlSUQudW53cmFwVG8oci50aWxlSUQud3JhcCArIGUpLCBpW3IudGlsZUlELmtleV0gPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBhIGluIHRoaXMuX3RpbGVzID0gaSwgdGhpcy5fdGltZXJzKSBjbGVhclRpbWVvdXQodGhpcy5fdGltZXJzW2FdKSwgZGVsZXRlIHRoaXMuX3RpbWVyc1thXTtcbiAgICAgICAgICBmb3IgKHZhciBuIGluIHRoaXMuX3RpbGVzKSB0aGlzLl9zZXRUaWxlUmVsb2FkVGltZXIobiwgdGhpcy5fdGlsZXNbbl0pO1xuICAgICAgICB9XG4gICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybSA9IGUsIHRoaXMuX3NvdXJjZUxvYWRlZCAmJiAhdGhpcy5fcGF1c2VkKSB7XG4gICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWNoZVNpemUoZSksIHRoaXMuaGFuZGxlV3JhcEp1bXAodGhpcy50cmFuc2Zvcm0uY2VudGVyLmxuZyksIHRoaXMuX2NvdmVyZWRUaWxlcyA9IHt9LCB0aGlzLnVzZWQgPyB0aGlzLl9zb3VyY2UudGlsZUlEID8gciA9IGUuZ2V0VmlzaWJsZVVud3JhcHBlZENvb3JkaW5hdGVzKHRoaXMuX3NvdXJjZS50aWxlSUQpLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZS5jYW5vbmljYWwueiwgZS53cmFwLCBlLmNhbm9uaWNhbC56LCBlLmNhbm9uaWNhbC54LCBlLmNhbm9uaWNhbC55KTtcbiAgICAgICAgICB9KSA6IChyID0gZS5jb3ZlcmluZ1RpbGVzKHtcbiAgICAgICAgICAgIHRpbGVTaXplOiB0aGlzLl9zb3VyY2UudGlsZVNpemUsXG4gICAgICAgICAgICBtaW56b29tOiB0aGlzLl9zb3VyY2UubWluem9vbSxcbiAgICAgICAgICAgIG1heHpvb206IHRoaXMuX3NvdXJjZS5tYXh6b29tLFxuICAgICAgICAgICAgcm91bmRab29tOiB0aGlzLl9zb3VyY2Uucm91bmRab29tLFxuICAgICAgICAgICAgcmVwYXJzZU92ZXJzY2FsZWQ6IHRoaXMuX3NvdXJjZS5yZXBhcnNlT3ZlcnNjYWxlZFxuICAgICAgICAgIH0pLCB0aGlzLl9zb3VyY2UuaGFzVGlsZSAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gby5fc291cmNlLmhhc1RpbGUodCk7XG4gICAgICAgICAgfSkpKSA6IHIgPSBbXTtcbiAgICAgICAgICB2YXIgYSA9IGUuY292ZXJpbmdab29tTGV2ZWwodGhpcy5fc291cmNlKSxcbiAgICAgICAgICAgIG4gPSBNYXRoLm1heChhIC0gaS5tYXhPdmVyem9vbWluZywgdGhpcy5fc291cmNlLm1pbnpvb20pLFxuICAgICAgICAgICAgcyA9IE1hdGgubWF4KGEgKyBpLm1heFVuZGVyem9vbWluZywgdGhpcy5fc291cmNlLm1pbnpvb20pLFxuICAgICAgICAgICAgbCA9IHRoaXMuX3VwZGF0ZVJldGFpbmVkVGlsZXMociwgYSk7XG4gICAgICAgICAgaWYgKE10KHRoaXMuX3NvdXJjZS50eXBlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IHt9LCB1ID0ge30sIGggPSAwLCBwID0gT2JqZWN0LmtleXMobCk7IGggPCBwLmxlbmd0aDsgaCArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gcFtoXSxcbiAgICAgICAgICAgICAgICBfID0gbFtkXSxcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fdGlsZXNbZF07XG4gICAgICAgICAgICAgIGlmIChmICYmICEoZi5mYWRlRW5kVGltZSAmJiBmLmZhZGVFbmRUaW1lIDw9IHQuYnJvd3Nlci5ub3coKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMuZmluZExvYWRlZFBhcmVudChfLCBuKTtcbiAgICAgICAgICAgICAgICBtICYmICh0aGlzLl9hZGRUaWxlKG0udGlsZUlEKSwgY1ttLnRpbGVJRC5rZXldID0gbS50aWxlSUQpLCB1W2RdID0gXztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgZyBpbiB0aGlzLl9yZXRhaW5Mb2FkZWRDaGlsZHJlbih1LCBhLCBzLCBsKSwgYykgbFtnXSB8fCAodGhpcy5fY292ZXJlZFRpbGVzW2ddID0gITAsIGxbZ10gPSBjW2ddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgdiBpbiBsKSB0aGlzLl90aWxlc1t2XS5jbGVhckZhZGVIb2xkKCk7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IDAsIHggPSB0LmtleXNEaWZmZXJlbmNlKHRoaXMuX3RpbGVzLCBsKTsgeSA8IHgubGVuZ3RoOyB5ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBiID0geFt5XSxcbiAgICAgICAgICAgICAgdyA9IHRoaXMuX3RpbGVzW2JdO1xuICAgICAgICAgICAgdy5oYXNTeW1ib2xCdWNrZXRzICYmICF3LmhvbGRpbmdGb3JGYWRlKCkgPyB3LnNldEhvbGREdXJhdGlvbih0aGlzLm1hcC5fZmFkZUR1cmF0aW9uKSA6IHcuaGFzU3ltYm9sQnVja2V0cyAmJiAhdy5zeW1ib2xGYWRlRmluaXNoZWQoKSB8fCB0aGlzLl9yZW1vdmVUaWxlKGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl91cGRhdGVMb2FkZWRQYXJlbnRUaWxlQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgaS5wcm90b3R5cGUucmVsZWFzZVN5bWJvbEZhZGVUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90aWxlcykgdGhpcy5fdGlsZXNbdF0uaG9sZGluZ0ZvckZhZGUoKSAmJiB0aGlzLl9yZW1vdmVUaWxlKHQpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVJldGFpbmVkVGlsZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBmb3IgKHZhciBvID0ge30sIHIgPSB7fSwgYSA9IE1hdGgubWF4KGUgLSBpLm1heE92ZXJ6b29taW5nLCB0aGlzLl9zb3VyY2UubWluem9vbSksIG4gPSBNYXRoLm1heChlICsgaS5tYXhVbmRlcnpvb21pbmcsIHRoaXMuX3NvdXJjZS5taW56b29tKSwgcyA9IHt9LCBsID0gMCwgYyA9IHQ7IGwgPCBjLmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgICAgdmFyIHUgPSBjW2xdLFxuICAgICAgICAgICAgaCA9IHRoaXMuX2FkZFRpbGUodSk7XG4gICAgICAgICAgb1t1LmtleV0gPSB1LCBoLmhhc0RhdGEoKSB8fCBlIDwgdGhpcy5fc291cmNlLm1heHpvb20gJiYgKHNbdS5rZXldID0gdSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmV0YWluTG9hZGVkQ2hpbGRyZW4ocywgZSwgbiwgbyk7XG4gICAgICAgIGZvciAodmFyIHAgPSAwLCBkID0gdDsgcCA8IGQubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgICB2YXIgXyA9IGRbcF0sXG4gICAgICAgICAgICBmID0gdGhpcy5fdGlsZXNbXy5rZXldO1xuICAgICAgICAgIGlmICghZi5oYXNEYXRhKCkpIHtcbiAgICAgICAgICAgIGlmIChlICsgMSA+IHRoaXMuX3NvdXJjZS5tYXh6b29tKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gXy5jaGlsZHJlbih0aGlzLl9zb3VyY2UubWF4em9vbSlbMF0sXG4gICAgICAgICAgICAgICAgZyA9IHRoaXMuZ2V0VGlsZShtKTtcbiAgICAgICAgICAgICAgaWYgKGcgJiYgZy5oYXNEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICBvW20ua2V5XSA9IG07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gXy5jaGlsZHJlbih0aGlzLl9zb3VyY2UubWF4em9vbSk7XG4gICAgICAgICAgICAgIGlmIChvW3ZbMF0ua2V5XSAmJiBvW3ZbMV0ua2V5XSAmJiBvW3ZbMl0ua2V5XSAmJiBvW3ZbM10ua2V5XSkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gZi53YXNSZXF1ZXN0ZWQoKSwgeCA9IF8ub3ZlcnNjYWxlZFogLSAxOyB4ID49IGE7IC0teCkge1xuICAgICAgICAgICAgICB2YXIgYiA9IF8uc2NhbGVkVG8oeCk7XG4gICAgICAgICAgICAgIGlmIChyW2Iua2V5XSkgYnJlYWs7XG4gICAgICAgICAgICAgIGlmIChyW2Iua2V5XSA9ICEwLCAhKGYgPSB0aGlzLmdldFRpbGUoYikpICYmIHkgJiYgKGYgPSB0aGlzLl9hZGRUaWxlKGIpKSwgZiAmJiAob1tiLmtleV0gPSBiLCB5ID0gZi53YXNSZXF1ZXN0ZWQoKSwgZi5oYXNEYXRhKCkpKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdXBkYXRlTG9hZGVkUGFyZW50VGlsZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuX2xvYWRlZFBhcmVudFRpbGVzID0ge30sIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IFtdLCBpID0gdm9pZCAwLCBvID0gdGhpcy5fdGlsZXNbdF0udGlsZUlEOyBvLm92ZXJzY2FsZWRaID4gMDspIHtcbiAgICAgICAgICAgIGlmIChvLmtleSBpbiB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlcykge1xuICAgICAgICAgICAgICBpID0gdGhpcy5fbG9hZGVkUGFyZW50VGlsZXNbby5rZXldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHVzaChvLmtleSk7XG4gICAgICAgICAgICB2YXIgciA9IG8uc2NhbGVkVG8oby5vdmVyc2NhbGVkWiAtIDEpO1xuICAgICAgICAgICAgaWYgKGkgPSB0aGlzLl9nZXRMb2FkZWRUaWxlKHIpKSBicmVhaztcbiAgICAgICAgICAgIG8gPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBhID0gMCwgbiA9IGU7IGEgPCBuLmxlbmd0aDsgYSArPSAxKSB0aGlzLl9sb2FkZWRQYXJlbnRUaWxlc1tuW2FdXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0sIGkucHJvdG90eXBlLl9hZGRUaWxlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl90aWxlc1tlLmtleV07XG4gICAgICAgIGlmIChpKSByZXR1cm4gaTtcbiAgICAgICAgKGkgPSB0aGlzLl9jYWNoZS5nZXRBbmRSZW1vdmUoZSkpICYmICh0aGlzLl9zZXRUaWxlUmVsb2FkVGltZXIoZS5rZXksIGkpLCBpLnRpbGVJRCA9IGUsIHRoaXMuX3N0YXRlLmluaXRpYWxpemVUaWxlU3RhdGUoaSwgdGhpcy5tYXAgPyB0aGlzLm1hcC5wYWludGVyIDogbnVsbCksIHRoaXMuX2NhY2hlVGltZXJzW2Uua2V5XSAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX2NhY2hlVGltZXJzW2Uua2V5XSksIGRlbGV0ZSB0aGlzLl9jYWNoZVRpbWVyc1tlLmtleV0sIHRoaXMuX3NldFRpbGVSZWxvYWRUaW1lcihlLmtleSwgaSkpKTtcbiAgICAgICAgdmFyIG8gPSBCb29sZWFuKGkpO1xuICAgICAgICByZXR1cm4gbyB8fCAoaSA9IG5ldyB0LlRpbGUoZSwgdGhpcy5fc291cmNlLnRpbGVTaXplICogZS5vdmVyc2NhbGVGYWN0b3IoKSksIHRoaXMuX2xvYWRUaWxlKGksIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCBpLCBlLmtleSwgaS5zdGF0ZSkpKSwgaSA/IChpLnVzZXMrKywgdGhpcy5fdGlsZXNbZS5rZXldID0gaSwgbyB8fCB0aGlzLl9zb3VyY2UuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICB0aWxlOiBpLFxuICAgICAgICAgIGNvb3JkOiBpLnRpbGVJRCxcbiAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIlxuICAgICAgICB9KSksIGkpIDogbnVsbDtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9zZXRUaWxlUmVsb2FkVGltZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgIHQgaW4gdGhpcy5fdGltZXJzICYmIChjbGVhclRpbWVvdXQodGhpcy5fdGltZXJzW3RdKSwgZGVsZXRlIHRoaXMuX3RpbWVyc1t0XSk7XG4gICAgICAgIHZhciBvID0gZS5nZXRFeHBpcnlUaW1lb3V0KCk7XG4gICAgICAgIG8gJiYgKHRoaXMuX3RpbWVyc1t0XSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGkuX3JlbG9hZFRpbGUodCwgXCJleHBpcmVkXCIpLCBkZWxldGUgaS5fdGltZXJzW3RdO1xuICAgICAgICB9LCBvKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fcmVtb3ZlVGlsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgIGUgJiYgKGUudXNlcy0tLCBkZWxldGUgdGhpcy5fdGlsZXNbdF0sIHRoaXMuX3RpbWVyc1t0XSAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyc1t0XSksIGRlbGV0ZSB0aGlzLl90aW1lcnNbdF0pLCBlLnVzZXMgPiAwIHx8IChlLmhhc0RhdGEoKSAmJiBcInJlbG9hZGluZ1wiICE9PSBlLnN0YXRlID8gdGhpcy5fY2FjaGUuYWRkKGUudGlsZUlELCBlLCBlLmdldEV4cGlyeVRpbWVvdXQoKSkgOiAoZS5hYm9ydGVkID0gITAsIHRoaXMuX2Fib3J0VGlsZShlKSwgdGhpcy5fdW5sb2FkVGlsZShlKSkpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmNsZWFyVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fc2hvdWxkUmVsb2FkT25SZXN1bWUgPSAhMSwgdGhpcy5fcGF1c2VkID0gITEsIHRoaXMuX3RpbGVzKSB0aGlzLl9yZW1vdmVUaWxlKHQpO1xuICAgICAgICB0aGlzLl9jYWNoZS5yZXNldCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudGlsZXNJbiA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgICBhID0gW10sXG4gICAgICAgICAgbiA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIW4pIHJldHVybiBhO1xuICAgICAgICBmb3IgKHZhciBzID0gbyA/IG4uZ2V0Q2FtZXJhUXVlcnlHZW9tZXRyeShlKSA6IGUsIGwgPSBlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIG4ucG9pbnRDb29yZGluYXRlKHQpO1xuICAgICAgICAgIH0pLCBjID0gcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuLnBvaW50Q29vcmRpbmF0ZSh0KTtcbiAgICAgICAgICB9KSwgdSA9IHRoaXMuZ2V0SWRzKCksIGggPSAxIC8gMCwgcCA9IDEgLyAwLCBkID0gLTEgLyAwLCBfID0gLTEgLyAwLCBmID0gMCwgbSA9IGM7IGYgPCBtLmxlbmd0aDsgZiArPSAxKSB7XG4gICAgICAgICAgdmFyIGcgPSBtW2ZdO1xuICAgICAgICAgIGggPSBNYXRoLm1pbihoLCBnLngpLCBwID0gTWF0aC5taW4ocCwgZy55KSwgZCA9IE1hdGgubWF4KGQsIGcueCksIF8gPSBNYXRoLm1heChfLCBnLnkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHYgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG8gPSByLl90aWxlc1t1W2VdXTtcbiAgICAgICAgICAgIGlmICghby5ob2xkaW5nRm9yRmFkZSgpKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gby50aWxlSUQsXG4gICAgICAgICAgICAgICAgZiA9IE1hdGgucG93KDIsIG4uem9vbSAtIG8udGlsZUlELm92ZXJzY2FsZWRaKSxcbiAgICAgICAgICAgICAgICBtID0gaSAqIG8ucXVlcnlQYWRkaW5nICogdC5FWFRFTlQgLyBvLnRpbGVTaXplIC8gZixcbiAgICAgICAgICAgICAgICBnID0gW3MuZ2V0VGlsZVBvaW50KG5ldyB0Lk1lcmNhdG9yQ29vcmRpbmF0ZShoLCBwKSksIHMuZ2V0VGlsZVBvaW50KG5ldyB0Lk1lcmNhdG9yQ29vcmRpbmF0ZShkLCBfKSldO1xuICAgICAgICAgICAgICBpZiAoZ1swXS54IC0gbSA8IHQuRVhURU5UICYmIGdbMF0ueSAtIG0gPCB0LkVYVEVOVCAmJiBnWzFdLnggKyBtID49IDAgJiYgZ1sxXS55ICsgbSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5nZXRUaWxlUG9pbnQodCk7XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHkgPSBjLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5nZXRUaWxlUG9pbnQodCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdGlsZTogbyxcbiAgICAgICAgICAgICAgICAgIHRpbGVJRDogcyxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5R2VvbWV0cnk6IHYsXG4gICAgICAgICAgICAgICAgICBjYW1lcmFRdWVyeUdlb21ldHJ5OiB5LFxuICAgICAgICAgICAgICAgICAgc2NhbGU6IGZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHkgPSAwOyB5IDwgdS5sZW5ndGg7IHkrKykgdih5KTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRWaXNpYmxlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBlID0gdGhpcywgaSA9IHRoaXMuZ2V0UmVuZGVyYWJsZUlkcyh0KS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLl90aWxlc1t0XS50aWxlSUQ7XG4gICAgICAgICAgfSksIG8gPSAwLCByID0gaTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgICB2YXIgYSA9IHJbb107XG4gICAgICAgICAgYS5wb3NNYXRyaXggPSB0aGlzLnRyYW5zZm9ybS5jYWxjdWxhdGVQb3NNYXRyaXgoYS50b1Vud3JhcHBlZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2UuaGFzVHJhbnNpdGlvbigpKSByZXR1cm4gITA7XG4gICAgICAgIGlmIChNdCh0aGlzLl9zb3VyY2UudHlwZSkpIGZvciAodmFyIGUgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuX3RpbGVzW2VdO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IGkuZmFkZUVuZFRpbWUgJiYgaS5mYWRlRW5kVGltZSA+PSB0LmJyb3dzZXIubm93KCkpIHJldHVybiAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB0aGlzLl9zdGF0ZS51cGRhdGVTdGF0ZSh0ID0gdCB8fCBcIl9nZW9qc29uVGlsZUxheWVyXCIsIGUsIGkpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUucmVtb3ZlRmVhdHVyZVN0YXRlKHQgPSB0IHx8IFwiX2dlb2pzb25UaWxlTGF5ZXJcIiwgZSwgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5nZXRGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0U3RhdGUodCA9IHQgfHwgXCJfZ2VvanNvblRpbGVMYXllclwiLCBlKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgIG8gJiYgby5zZXREZXBlbmRlbmNpZXMoZSwgaSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWxvYWRUaWxlc0ZvckRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHRoaXMuX3RpbGVzW2ldLmhhc0RlcGVuZGVuY3kodCwgZSkgJiYgdGhpcy5fcmVsb2FkVGlsZShpLCBcInJlbG9hZGluZ1wiKTtcbiAgICAgICAgdGhpcy5fY2FjaGUuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuICFpLmhhc0RlcGVuZGVuY3kodCwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgaTtcbiAgICB9KHQuRXZlbnRlZCk7XG4gICAgZnVuY3Rpb24gQXQodCwgZSkge1xuICAgICAgdmFyIGkgPSBNYXRoLmFicygyICogdC53cmFwKSAtICsodC53cmFwIDwgMCksXG4gICAgICAgIG8gPSBNYXRoLmFicygyICogZS53cmFwKSAtICsoZS53cmFwIDwgMCk7XG4gICAgICByZXR1cm4gdC5vdmVyc2NhbGVkWiAtIGUub3ZlcnNjYWxlZFogfHwgbyAtIGkgfHwgZS5jYW5vbmljYWwueSAtIHQuY2Fub25pY2FsLnkgfHwgZS5jYW5vbmljYWwueCAtIHQuY2Fub25pY2FsLng7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE10KHQpIHtcbiAgICAgIHJldHVybiBcInJhc3RlclwiID09PSB0IHx8IFwiaW1hZ2VcIiA9PT0gdCB8fCBcInZpZGVvXCIgPT09IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEx0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0LndpbmRvdy5Xb3JrZXIoS3Iud29ya2VyVXJsKTtcbiAgICB9XG4gICAgRHQubWF4T3Zlcnpvb21pbmcgPSAxMCwgRHQubWF4VW5kZXJ6b29taW5nID0gMztcbiAgICB2YXIgUnQgPSBcIm1hcGJveGdsX3ByZWxvYWRlZF93b3JrZXJfcG9vbFwiLFxuICAgICAga3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlID0ge307XG4gICAgICB9O1xuICAgIGt0LnByb3RvdHlwZS5hY3F1aXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICghdGhpcy53b3JrZXJzKSBmb3IgKHRoaXMud29ya2VycyA9IFtdOyB0aGlzLndvcmtlcnMubGVuZ3RoIDwga3Qud29ya2VyQ291bnQ7KSB0aGlzLndvcmtlcnMucHVzaChuZXcgTHQoKSk7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVbdF0gPSAhMCwgdGhpcy53b3JrZXJzLnNsaWNlKCk7XG4gICAgfSwga3QucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlW3RdLCAwID09PSB0aGlzLm51bUFjdGl2ZSgpICYmICh0aGlzLndvcmtlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LnRlcm1pbmF0ZSgpO1xuICAgICAgfSksIHRoaXMud29ya2VycyA9IG51bGwpO1xuICAgIH0sIGt0LnByb3RvdHlwZS5pc1ByZWxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuYWN0aXZlW1J0XTtcbiAgICB9LCBrdC5wcm90b3R5cGUubnVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlKS5sZW5ndGg7XG4gICAgfTtcbiAgICB2YXIgQnQsXG4gICAgICBPdCA9IE1hdGguZmxvb3IodC5icm93c2VyLmhhcmR3YXJlQ29uY3VycmVuY3kgLyAyKTtcbiAgICBmdW5jdGlvbiBGdCgpIHtcbiAgICAgIHJldHVybiBCdCB8fCAoQnQgPSBuZXcga3QoKSksIEJ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBVdChlLCBpKSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZm9yICh2YXIgciBpbiBlKSBcInJlZlwiICE9PSByICYmIChvW3JdID0gZVtyXSk7XG4gICAgICByZXR1cm4gdC5yZWZQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdCBpbiBpICYmIChvW3RdID0gaVt0XSk7XG4gICAgICB9KSwgbztcbiAgICB9XG4gICAgZnVuY3Rpb24gTnQodCkge1xuICAgICAgdCA9IHQuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGUgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIGVbdFtpXS5pZF0gPSB0W2ldO1xuICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSBcInJlZlwiIGluIHRbb10gJiYgKHRbb10gPSBVdCh0W29dLCBlW3Rbb10ucmVmXSkpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIGt0LndvcmtlckNvdW50ID0gTWF0aC5tYXgoTWF0aC5taW4oT3QsIDYpLCAxKTtcbiAgICB2YXIgWnQgPSB7XG4gICAgICBzZXRTdHlsZTogXCJzZXRTdHlsZVwiLFxuICAgICAgYWRkTGF5ZXI6IFwiYWRkTGF5ZXJcIixcbiAgICAgIHJlbW92ZUxheWVyOiBcInJlbW92ZUxheWVyXCIsXG4gICAgICBzZXRQYWludFByb3BlcnR5OiBcInNldFBhaW50UHJvcGVydHlcIixcbiAgICAgIHNldExheW91dFByb3BlcnR5OiBcInNldExheW91dFByb3BlcnR5XCIsXG4gICAgICBzZXRGaWx0ZXI6IFwic2V0RmlsdGVyXCIsXG4gICAgICBhZGRTb3VyY2U6IFwiYWRkU291cmNlXCIsXG4gICAgICByZW1vdmVTb3VyY2U6IFwicmVtb3ZlU291cmNlXCIsXG4gICAgICBzZXRHZW9KU09OU291cmNlRGF0YTogXCJzZXRHZW9KU09OU291cmNlRGF0YVwiLFxuICAgICAgc2V0TGF5ZXJab29tUmFuZ2U6IFwic2V0TGF5ZXJab29tUmFuZ2VcIixcbiAgICAgIHNldExheWVyUHJvcGVydHk6IFwic2V0TGF5ZXJQcm9wZXJ0eVwiLFxuICAgICAgc2V0Q2VudGVyOiBcInNldENlbnRlclwiLFxuICAgICAgc2V0Wm9vbTogXCJzZXRab29tXCIsXG4gICAgICBzZXRCZWFyaW5nOiBcInNldEJlYXJpbmdcIixcbiAgICAgIHNldFBpdGNoOiBcInNldFBpdGNoXCIsXG4gICAgICBzZXRTcHJpdGU6IFwic2V0U3ByaXRlXCIsXG4gICAgICBzZXRHbHlwaHM6IFwic2V0R2x5cGhzXCIsXG4gICAgICBzZXRUcmFuc2l0aW9uOiBcInNldFRyYW5zaXRpb25cIixcbiAgICAgIHNldExpZ2h0OiBcInNldExpZ2h0XCJcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHF0KHQsIGUsIGkpIHtcbiAgICAgIGkucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IFp0LmFkZFNvdXJjZSxcbiAgICAgICAgYXJnczogW3QsIGVbdF1dXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganQodCwgZSwgaSkge1xuICAgICAgZS5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlU291cmNlLFxuICAgICAgICBhcmdzOiBbdF1cbiAgICAgIH0pLCBpW3RdID0gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZ0KHQsIGUsIGksIG8pIHtcbiAgICAgIGp0KHQsIGksIG8pLCBxdCh0LCBlLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gR3QoZSwgaSwgbykge1xuICAgICAgdmFyIHI7XG4gICAgICBmb3IgKHIgaW4gZVtvXSkgaWYgKGVbb10uaGFzT3duUHJvcGVydHkocikgJiYgXCJkYXRhXCIgIT09IHIgJiYgIXQuZGVlcEVxdWFsKGVbb11bcl0sIGlbb11bcl0pKSByZXR1cm4gITE7XG4gICAgICBmb3IgKHIgaW4gaVtvXSkgaWYgKGlbb10uaGFzT3duUHJvcGVydHkocikgJiYgXCJkYXRhXCIgIT09IHIgJiYgIXQuZGVlcEVxdWFsKGVbb11bcl0sIGlbb11bcl0pKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFd0KGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzO1xuICAgICAgZm9yIChzIGluIGkgPSBpIHx8IHt9LCBlID0gZSB8fCB7fSkgZS5oYXNPd25Qcm9wZXJ0eShzKSAmJiAodC5kZWVwRXF1YWwoZVtzXSwgaVtzXSkgfHwgby5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogbixcbiAgICAgICAgYXJnczogW3IsIHMsIGlbc10sIGFdXG4gICAgICB9KSk7XG4gICAgICBmb3IgKHMgaW4gaSkgaS5oYXNPd25Qcm9wZXJ0eShzKSAmJiAhZS5oYXNPd25Qcm9wZXJ0eShzKSAmJiAodC5kZWVwRXF1YWwoZVtzXSwgaVtzXSkgfHwgby5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogbixcbiAgICAgICAgYXJnczogW3IsIHMsIGlbc10sIGFdXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFh0KHQpIHtcbiAgICAgIHJldHVybiB0LmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBIdCh0LCBlKSB7XG4gICAgICByZXR1cm4gdFtlLmlkXSA9IGUsIHQ7XG4gICAgfVxuICAgIHZhciBLdCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLnJlc2V0KHQsIGUpO1xuICAgIH07XG4gICAgS3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucG9pbnRzID0gdCB8fCBbXSwgdGhpcy5fZGlzdGFuY2VzID0gWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykgdGhpcy5fZGlzdGFuY2VzW2ldID0gdGhpcy5fZGlzdGFuY2VzW2kgLSAxXSArIHRoaXMucG9pbnRzW2ldLmRpc3QodGhpcy5wb2ludHNbaSAtIDFdKTtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZGlzdGFuY2VzW3RoaXMuX2Rpc3RhbmNlcy5sZW5ndGggLSAxXSwgdGhpcy5wYWRkaW5nID0gTWF0aC5taW4oZSB8fCAwLCAuNSAqIHRoaXMubGVuZ3RoKSwgdGhpcy5wYWRkZWRMZW5ndGggPSB0aGlzLmxlbmd0aCAtIDIgKiB0aGlzLnBhZGRpbmc7XG4gICAgfSwgS3QucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKDEgPT09IHRoaXMucG9pbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMucG9pbnRzWzBdO1xuICAgICAgZSA9IHQuY2xhbXAoZSwgMCwgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbyA9IHRoaXMuX2Rpc3RhbmNlc1tpXSwgciA9IGUgKiB0aGlzLnBhZGRlZExlbmd0aCArIHRoaXMucGFkZGluZzsgbyA8IHIgJiYgaSA8IHRoaXMuX2Rpc3RhbmNlcy5sZW5ndGg7KSBvID0gdGhpcy5fZGlzdGFuY2VzWysraV07XG4gICAgICB2YXIgYSA9IGkgLSAxLFxuICAgICAgICBuID0gdGhpcy5fZGlzdGFuY2VzW2FdLFxuICAgICAgICBzID0gbyAtIG4sXG4gICAgICAgIGwgPSBzID4gMCA/IChyIC0gbikgLyBzIDogMDtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50c1thXS5tdWx0KDEgLSBsKS5hZGQodGhpcy5wb2ludHNbaV0ubXVsdChsKSk7XG4gICAgfTtcbiAgICB2YXIgWXQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSB0aGlzLmJveENlbGxzID0gW10sXG4gICAgICAgIHIgPSB0aGlzLmNpcmNsZUNlbGxzID0gW107XG4gICAgICB0aGlzLnhDZWxsQ291bnQgPSBNYXRoLmNlaWwodCAvIGkpLCB0aGlzLnlDZWxsQ291bnQgPSBNYXRoLmNlaWwoZSAvIGkpO1xuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCB0aGlzLnhDZWxsQ291bnQgKiB0aGlzLnlDZWxsQ291bnQ7IGErKykgby5wdXNoKFtdKSwgci5wdXNoKFtdKTtcbiAgICAgIHRoaXMuY2lyY2xlS2V5cyA9IFtdLCB0aGlzLmJveEtleXMgPSBbXSwgdGhpcy5iYm94ZXMgPSBbXSwgdGhpcy5jaXJjbGVzID0gW10sIHRoaXMud2lkdGggPSB0LCB0aGlzLmhlaWdodCA9IGUsIHRoaXMueFNjYWxlID0gdGhpcy54Q2VsbENvdW50IC8gdCwgdGhpcy55U2NhbGUgPSB0aGlzLnlDZWxsQ291bnQgLyBlLCB0aGlzLmJveFVpZCA9IDAsIHRoaXMuY2lyY2xlVWlkID0gMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEp0KGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gdC5jcmVhdGUoKTtcbiAgICAgIHJldHVybiBpID8gKHQuc2NhbGUobiwgbiwgWzEgLyBhLCAxIC8gYSwgMV0pLCBvIHx8IHQucm90YXRlWihuLCBuLCByLmFuZ2xlKSkgOiB0Lm11bHRpcGx5KG4sIHIubGFiZWxQbGFuZU1hdHJpeCwgZSksIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFF0KGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIHZhciBuID0gdC5jbG9uZShlKTtcbiAgICAgICAgcmV0dXJuIHQuc2NhbGUobiwgbiwgW2EsIGEsIDFdKSwgbyB8fCB0LnJvdGF0ZVoobiwgbiwgLXIuYW5nbGUpLCBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIuZ2xDb29yZE1hdHJpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gJHQoZSwgaSkge1xuICAgICAgdmFyIG8gPSBbZS54LCBlLnksIDAsIDFdO1xuICAgICAgdWUobywgbywgaSk7XG4gICAgICB2YXIgciA9IG9bM107XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogbmV3IHQuUG9pbnQob1swXSAvIHIsIG9bMV0gLyByKSxcbiAgICAgICAgc2lnbmVkRGlzdGFuY2VGcm9tQ2FtZXJhOiByXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZSh0LCBlKSB7XG4gICAgICByZXR1cm4gLjUgKyB0IC8gZSAqIC41O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlZSh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHRbMF0gLyB0WzNdLFxuICAgICAgICBvID0gdFsxXSAvIHRbM107XG4gICAgICByZXR1cm4gaSA+PSAtZVswXSAmJiBpIDw9IGVbMF0gJiYgbyA+PSAtZVsxXSAmJiBvIDw9IGVbMV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGllKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwpIHtcbiAgICAgIHZhciBjID0gciA/IGUudGV4dFNpemVEYXRhIDogZS5pY29uU2l6ZURhdGEsXG4gICAgICAgIHUgPSB0LmV2YWx1YXRlU2l6ZUZvclpvb20oYywgby50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgIGggPSBbMjU2IC8gby53aWR0aCAqIDIgKyAxLCAyNTYgLyBvLmhlaWdodCAqIDIgKyAxXSxcbiAgICAgICAgcCA9IHIgPyBlLnRleHQuZHluYW1pY0xheW91dFZlcnRleEFycmF5IDogZS5pY29uLmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheTtcbiAgICAgIHAuY2xlYXIoKTtcbiAgICAgIGZvciAodmFyIGQgPSBlLmxpbmVWZXJ0ZXhBcnJheSwgXyA9IHIgPyBlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkgOiBlLmljb24ucGxhY2VkU3ltYm9sQXJyYXksIGYgPSBvLnRyYW5zZm9ybS53aWR0aCAvIG8udHJhbnNmb3JtLmhlaWdodCwgbSA9ICExLCBnID0gMDsgZyA8IF8ubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgdmFyIHYgPSBfLmdldChnKTtcbiAgICAgICAgaWYgKHYuaGlkZGVuIHx8IHYud3JpdGluZ01vZGUgPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgJiYgIW0pIGNlKHYubnVtR2x5cGhzLCBwKTtlbHNlIHtcbiAgICAgICAgICBtID0gITE7XG4gICAgICAgICAgdmFyIHkgPSBbdi5hbmNob3JYLCB2LmFuY2hvclksIDAsIDFdO1xuICAgICAgICAgIGlmICh0LnRyYW5zZm9ybU1hdDQoeSwgeSwgaSksIGVlKHksIGgpKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRlKG8udHJhbnNmb3JtLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsIHlbM10pLFxuICAgICAgICAgICAgICBiID0gdC5ldmFsdWF0ZVNpemVGb3JGZWF0dXJlKGMsIHUsIHYpLFxuICAgICAgICAgICAgICB3ID0gcyA/IGIgLyB4IDogYiAqIHgsXG4gICAgICAgICAgICAgIFQgPSBuZXcgdC5Qb2ludCh2LmFuY2hvclgsIHYuYW5jaG9yWSksXG4gICAgICAgICAgICAgIEUgPSAkdChULCBhKS5wb2ludCxcbiAgICAgICAgICAgICAgSSA9IHt9LFxuICAgICAgICAgICAgICBQID0gYWUodiwgdywgITEsIGwsIGksIGEsIG4sIGUuZ2x5cGhPZmZzZXRBcnJheSwgZCwgcCwgRSwgVCwgSSwgZik7XG4gICAgICAgICAgICBtID0gUC51c2VWZXJ0aWNhbCwgKFAubm90RW5vdWdoUm9vbSB8fCBtIHx8IFAubmVlZHNGbGlwcGluZyAmJiBhZSh2LCB3LCAhMCwgbCwgaSwgYSwgbiwgZS5nbHlwaE9mZnNldEFycmF5LCBkLCBwLCBFLCBULCBJLCBmKS5ub3RFbm91Z2hSb29tKSAmJiBjZSh2Lm51bUdseXBocywgcCk7XG4gICAgICAgICAgfSBlbHNlIGNlKHYubnVtR2x5cGhzLCBwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA/IGUudGV4dC5keW5hbWljTGF5b3V0VmVydGV4QnVmZmVyLnVwZGF0ZURhdGEocCkgOiBlLmljb24uZHluYW1pY0xheW91dFZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKHApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvZSh0LCBlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1KSB7XG4gICAgICB2YXIgaCA9IHMuZ2x5cGhTdGFydEluZGV4ICsgcy5udW1HbHlwaHMsXG4gICAgICAgIHAgPSBzLmxpbmVTdGFydEluZGV4LFxuICAgICAgICBkID0gcy5saW5lU3RhcnRJbmRleCArIHMubGluZUxlbmd0aCxcbiAgICAgICAgXyA9IGUuZ2V0b2Zmc2V0WChzLmdseXBoU3RhcnRJbmRleCksXG4gICAgICAgIGYgPSBlLmdldG9mZnNldFgoaCAtIDEpLFxuICAgICAgICBtID0gc2UodCAqIF8sIGksIG8sIHIsIGEsIG4sIHMuc2VnbWVudCwgcCwgZCwgbCwgYywgdSk7XG4gICAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuICAgICAgdmFyIGcgPSBzZSh0ICogZiwgaSwgbywgciwgYSwgbiwgcy5zZWdtZW50LCBwLCBkLCBsLCBjLCB1KTtcbiAgICAgIHJldHVybiBnID8ge1xuICAgICAgICBmaXJzdDogbSxcbiAgICAgICAgbGFzdDogZ1xuICAgICAgfSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlKGUsIGksIG8sIHIpIHtcbiAgICAgIHJldHVybiBlID09PSB0LldyaXRpbmdNb2RlLmhvcml6b250YWwgJiYgTWF0aC5hYnMoby55IC0gaS55KSA+IE1hdGguYWJzKG8ueCAtIGkueCkgKiByID8ge1xuICAgICAgICB1c2VWZXJ0aWNhbDogITBcbiAgICAgIH0gOiAoZSA9PT0gdC5Xcml0aW5nTW9kZS52ZXJ0aWNhbCA/IGkueSA8IG8ueSA6IGkueCA+IG8ueCkgPyB7XG4gICAgICAgIG5lZWRzRmxpcHBpbmc6ICEwXG4gICAgICB9IDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWUoZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSwgaCwgcCwgZCwgXykge1xuICAgICAgdmFyIGYsXG4gICAgICAgIG0gPSBpIC8gMjQsXG4gICAgICAgIGcgPSBlLmxpbmVPZmZzZXRYICogbSxcbiAgICAgICAgdiA9IGUubGluZU9mZnNldFkgKiBtO1xuICAgICAgaWYgKGUubnVtR2x5cGhzID4gMSkge1xuICAgICAgICB2YXIgeSA9IGUuZ2x5cGhTdGFydEluZGV4ICsgZS5udW1HbHlwaHMsXG4gICAgICAgICAgeCA9IGUubGluZVN0YXJ0SW5kZXgsXG4gICAgICAgICAgYiA9IGUubGluZVN0YXJ0SW5kZXggKyBlLmxpbmVMZW5ndGgsXG4gICAgICAgICAgdyA9IG9lKG0sIGwsIGcsIHYsIG8sIGgsIHAsIGUsIGMsIG4sIGQpO1xuICAgICAgICBpZiAoIXcpIHJldHVybiB7XG4gICAgICAgICAgbm90RW5vdWdoUm9vbTogITBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFQgPSAkdCh3LmZpcnN0LnBvaW50LCBzKS5wb2ludCxcbiAgICAgICAgICBFID0gJHQody5sYXN0LnBvaW50LCBzKS5wb2ludDtcbiAgICAgICAgaWYgKHIgJiYgIW8pIHtcbiAgICAgICAgICB2YXIgSSA9IHJlKGUud3JpdGluZ01vZGUsIFQsIEUsIF8pO1xuICAgICAgICAgIGlmIChJKSByZXR1cm4gSTtcbiAgICAgICAgfVxuICAgICAgICBmID0gW3cuZmlyc3RdO1xuICAgICAgICBmb3IgKHZhciBQID0gZS5nbHlwaFN0YXJ0SW5kZXggKyAxOyBQIDwgeSAtIDE7IFArKykgZi5wdXNoKHNlKG0gKiBsLmdldG9mZnNldFgoUCksIGcsIHYsIG8sIGgsIHAsIGUuc2VnbWVudCwgeCwgYiwgYywgbiwgZCkpO1xuICAgICAgICBmLnB1c2gody5sYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyICYmICFvKSB7XG4gICAgICAgICAgdmFyIFMgPSAkdChwLCBhKS5wb2ludCxcbiAgICAgICAgICAgIEMgPSBlLmxpbmVTdGFydEluZGV4ICsgZS5zZWdtZW50ICsgMSxcbiAgICAgICAgICAgIHogPSBuZXcgdC5Qb2ludChjLmdldHgoQyksIGMuZ2V0eShDKSksXG4gICAgICAgICAgICBEID0gJHQoeiwgYSksXG4gICAgICAgICAgICBBID0gRC5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEgPiAwID8gRC5wb2ludCA6IG5lKHAsIHosIFMsIDEsIGEpLFxuICAgICAgICAgICAgTSA9IHJlKGUud3JpdGluZ01vZGUsIFMsIEEsIF8pO1xuICAgICAgICAgIGlmIChNKSByZXR1cm4gTTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgTCA9IHNlKG0gKiBsLmdldG9mZnNldFgoZS5nbHlwaFN0YXJ0SW5kZXgpLCBnLCB2LCBvLCBoLCBwLCBlLnNlZ21lbnQsIGUubGluZVN0YXJ0SW5kZXgsIGUubGluZVN0YXJ0SW5kZXggKyBlLmxpbmVMZW5ndGgsIGMsIG4sIGQpO1xuICAgICAgICBpZiAoIUwpIHJldHVybiB7XG4gICAgICAgICAgbm90RW5vdWdoUm9vbTogITBcbiAgICAgICAgfTtcbiAgICAgICAgZiA9IFtMXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIFIgPSAwLCBrID0gZjsgUiA8IGsubGVuZ3RoOyBSICs9IDEpIHtcbiAgICAgICAgdmFyIEIgPSBrW1JdO1xuICAgICAgICB0LmFkZER5bmFtaWNBdHRyaWJ1dGVzKHUsIEIucG9pbnQsIEIuYW5nbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSA9ICR0KHQuYWRkKHQuc3ViKGUpLl91bml0KCkpLCByKS5wb2ludCxcbiAgICAgICAgbiA9IGkuc3ViKGEpO1xuICAgICAgcmV0dXJuIGkuYWRkKG4uX211bHQobyAvIG4ubWFnKCkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2UoZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSwgaCwgcCkge1xuICAgICAgdmFyIGQgPSByID8gZSAtIGkgOiBlICsgaSxcbiAgICAgICAgXyA9IGQgPiAwID8gMSA6IC0xLFxuICAgICAgICBmID0gMDtcbiAgICAgIHIgJiYgKF8gKj0gLTEsIGYgPSBNYXRoLlBJKSwgXyA8IDAgJiYgKGYgKz0gTWF0aC5QSSk7XG4gICAgICBmb3IgKHZhciBtID0gXyA+IDAgPyBsICsgcyA6IGwgKyBzICsgMSwgZyA9IGEsIHYgPSBhLCB5ID0gMCwgeCA9IDAsIGIgPSBNYXRoLmFicyhkKSwgdyA9IFtdOyB5ICsgeCA8PSBiOykge1xuICAgICAgICBpZiAoKG0gKz0gXykgPCBsIHx8IG0gPj0gYykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh2ID0gZywgdy5wdXNoKGcpLCB2b2lkIDAgPT09IChnID0gcFttXSkpIHtcbiAgICAgICAgICB2YXIgVCA9IG5ldyB0LlBvaW50KHUuZ2V0eChtKSwgdS5nZXR5KG0pKSxcbiAgICAgICAgICAgIEUgPSAkdChULCBoKTtcbiAgICAgICAgICBpZiAoRS5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEgPiAwKSBnID0gcFttXSA9IEUucG9pbnQ7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgSSA9IG0gLSBfO1xuICAgICAgICAgICAgZyA9IG5lKDAgPT09IHkgPyBuIDogbmV3IHQuUG9pbnQodS5nZXR4KEkpLCB1LmdldHkoSSkpLCBULCB2LCBiIC0geSArIDEsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5ICs9IHgsIHggPSB2LmRpc3QoZyk7XG4gICAgICB9XG4gICAgICB2YXIgUCA9IChiIC0geSkgLyB4LFxuICAgICAgICBTID0gZy5zdWIodiksXG4gICAgICAgIEMgPSBTLm11bHQoUCkuX2FkZCh2KTtcbiAgICAgIEMuX2FkZChTLl91bml0KCkuX3BlcnAoKS5fbXVsdChvICogXykpO1xuICAgICAgdmFyIHogPSBmICsgTWF0aC5hdGFuMihnLnkgLSB2LnksIGcueCAtIHYueCk7XG4gICAgICByZXR1cm4gdy5wdXNoKEMpLCB7XG4gICAgICAgIHBvaW50OiBDLFxuICAgICAgICBhbmdsZTogeixcbiAgICAgICAgcGF0aDogd1xuICAgICAgfTtcbiAgICB9XG4gICAgWXQucHJvdG90eXBlLmtleXNMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3hLZXlzLmxlbmd0aCArIHRoaXMuY2lyY2xlS2V5cy5sZW5ndGg7XG4gICAgfSwgWXQucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB0aGlzLl9mb3JFYWNoQ2VsbChlLCBpLCBvLCByLCB0aGlzLl9pbnNlcnRCb3hDZWxsLCB0aGlzLmJveFVpZCsrKSwgdGhpcy5ib3hLZXlzLnB1c2godCksIHRoaXMuYmJveGVzLnB1c2goZSksIHRoaXMuYmJveGVzLnB1c2goaSksIHRoaXMuYmJveGVzLnB1c2gobyksIHRoaXMuYmJveGVzLnB1c2gocik7XG4gICAgfSwgWXQucHJvdG90eXBlLmluc2VydENpcmNsZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICB0aGlzLl9mb3JFYWNoQ2VsbChlIC0gbywgaSAtIG8sIGUgKyBvLCBpICsgbywgdGhpcy5faW5zZXJ0Q2lyY2xlQ2VsbCwgdGhpcy5jaXJjbGVVaWQrKyksIHRoaXMuY2lyY2xlS2V5cy5wdXNoKHQpLCB0aGlzLmNpcmNsZXMucHVzaChlKSwgdGhpcy5jaXJjbGVzLnB1c2goaSksIHRoaXMuY2lyY2xlcy5wdXNoKG8pO1xuICAgIH0sIFl0LnByb3RvdHlwZS5faW5zZXJ0Qm94Q2VsbCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhKSB7XG4gICAgICB0aGlzLmJveENlbGxzW3JdLnB1c2goYSk7XG4gICAgfSwgWXQucHJvdG90eXBlLl9pbnNlcnRDaXJjbGVDZWxsID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHRoaXMuY2lyY2xlQ2VsbHNbcl0ucHVzaChhKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX3F1ZXJ5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIGlmIChpIDwgMCB8fCB0ID4gdGhpcy53aWR0aCB8fCBvIDwgMCB8fCBlID4gdGhpcy5oZWlnaHQpIHJldHVybiAhciAmJiBbXTtcbiAgICAgIHZhciBuID0gW107XG4gICAgICBpZiAodCA8PSAwICYmIGUgPD0gMCAmJiB0aGlzLndpZHRoIDw9IGkgJiYgdGhpcy5oZWlnaHQgPD0gbykge1xuICAgICAgICBpZiAocikgcmV0dXJuICEwO1xuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRoaXMuYm94S2V5cy5sZW5ndGg7IHMrKykgbi5wdXNoKHtcbiAgICAgICAgICBrZXk6IHRoaXMuYm94S2V5c1tzXSxcbiAgICAgICAgICB4MTogdGhpcy5iYm94ZXNbNCAqIHNdLFxuICAgICAgICAgIHkxOiB0aGlzLmJib3hlc1s0ICogcyArIDFdLFxuICAgICAgICAgIHgyOiB0aGlzLmJib3hlc1s0ICogcyArIDJdLFxuICAgICAgICAgIHkyOiB0aGlzLmJib3hlc1s0ICogcyArIDNdXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoaXMuY2lyY2xlS2V5cy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5jaXJjbGVzWzMgKiBsXSxcbiAgICAgICAgICAgIHUgPSB0aGlzLmNpcmNsZXNbMyAqIGwgKyAxXSxcbiAgICAgICAgICAgIGggPSB0aGlzLmNpcmNsZXNbMyAqIGwgKyAyXTtcbiAgICAgICAgICBuLnB1c2goe1xuICAgICAgICAgICAga2V5OiB0aGlzLmNpcmNsZUtleXNbbF0sXG4gICAgICAgICAgICB4MTogYyAtIGgsXG4gICAgICAgICAgICB5MTogdSAtIGgsXG4gICAgICAgICAgICB4MjogYyArIGgsXG4gICAgICAgICAgICB5MjogdSArIGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSA/IG4uZmlsdGVyKGEpIDogbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9mb3JFYWNoQ2VsbCh0LCBlLCBpLCBvLCB0aGlzLl9xdWVyeUNlbGwsIG4sIHtcbiAgICAgICAgaGl0VGVzdDogcixcbiAgICAgICAgc2VlblVpZHM6IHtcbiAgICAgICAgICBib3g6IHt9LFxuICAgICAgICAgIGNpcmNsZToge31cbiAgICAgICAgfVxuICAgICAgfSwgYSksIHIgPyBuLmxlbmd0aCA+IDAgOiBuO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fcXVlcnlDaXJjbGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSB0IC0gaSxcbiAgICAgICAgbiA9IHQgKyBpLFxuICAgICAgICBzID0gZSAtIGksXG4gICAgICAgIGwgPSBlICsgaTtcbiAgICAgIGlmIChuIDwgMCB8fCBhID4gdGhpcy53aWR0aCB8fCBsIDwgMCB8fCBzID4gdGhpcy5oZWlnaHQpIHJldHVybiAhbyAmJiBbXTtcbiAgICAgIHZhciBjID0gW107XG4gICAgICByZXR1cm4gdGhpcy5fZm9yRWFjaENlbGwoYSwgcywgbiwgbCwgdGhpcy5fcXVlcnlDZWxsQ2lyY2xlLCBjLCB7XG4gICAgICAgIGhpdFRlc3Q6IG8sXG4gICAgICAgIGNpcmNsZToge1xuICAgICAgICAgIHg6IHQsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICByYWRpdXM6IGlcbiAgICAgICAgfSxcbiAgICAgICAgc2VlblVpZHM6IHtcbiAgICAgICAgICBib3g6IHt9LFxuICAgICAgICAgIGNpcmNsZToge31cbiAgICAgICAgfVxuICAgICAgfSwgciksIG8gPyBjLmxlbmd0aCA+IDAgOiBjO1xuICAgIH0sIFl0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcXVlcnkodCwgZSwgaSwgbywgITEsIHIpO1xuICAgIH0sIFl0LnByb3RvdHlwZS5oaXRUZXN0ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWVyeSh0LCBlLCBpLCBvLCAhMCwgcik7XG4gICAgfSwgWXQucHJvdG90eXBlLmhpdFRlc3RDaXJjbGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q2lyY2xlKHQsIGUsIGksICEwLCBvKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX3F1ZXJ5Q2VsbCA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzKSB7XG4gICAgICB2YXIgbCA9IG4uc2VlblVpZHMsXG4gICAgICAgIGMgPSB0aGlzLmJveENlbGxzW3JdO1xuICAgICAgaWYgKG51bGwgIT09IGMpIGZvciAodmFyIHUgPSB0aGlzLmJib3hlcywgaCA9IDAsIHAgPSBjOyBoIDwgcC5sZW5ndGg7IGggKz0gMSkge1xuICAgICAgICB2YXIgZCA9IHBbaF07XG4gICAgICAgIGlmICghbC5ib3hbZF0pIHtcbiAgICAgICAgICBsLmJveFtkXSA9ICEwO1xuICAgICAgICAgIHZhciBfID0gNCAqIGQ7XG4gICAgICAgICAgaWYgKHQgPD0gdVtfICsgMl0gJiYgZSA8PSB1W18gKyAzXSAmJiBpID49IHVbXyArIDBdICYmIG8gPj0gdVtfICsgMV0gJiYgKCFzIHx8IHModGhpcy5ib3hLZXlzW2RdKSkpIHtcbiAgICAgICAgICAgIGlmIChuLmhpdFRlc3QpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgICAgIGEucHVzaCh7XG4gICAgICAgICAgICAgIGtleTogdGhpcy5ib3hLZXlzW2RdLFxuICAgICAgICAgICAgICB4MTogdVtfXSxcbiAgICAgICAgICAgICAgeTE6IHVbXyArIDFdLFxuICAgICAgICAgICAgICB4MjogdVtfICsgMl0sXG4gICAgICAgICAgICAgIHkyOiB1W18gKyAzXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZiA9IHRoaXMuY2lyY2xlQ2VsbHNbcl07XG4gICAgICBpZiAobnVsbCAhPT0gZikgZm9yICh2YXIgbSA9IHRoaXMuY2lyY2xlcywgZyA9IDAsIHYgPSBmOyBnIDwgdi5sZW5ndGg7IGcgKz0gMSkge1xuICAgICAgICB2YXIgeSA9IHZbZ107XG4gICAgICAgIGlmICghbC5jaXJjbGVbeV0pIHtcbiAgICAgICAgICBsLmNpcmNsZVt5XSA9ICEwO1xuICAgICAgICAgIHZhciB4ID0gMyAqIHk7XG4gICAgICAgICAgaWYgKHRoaXMuX2NpcmNsZUFuZFJlY3RDb2xsaWRlKG1beF0sIG1beCArIDFdLCBtW3ggKyAyXSwgdCwgZSwgaSwgbykgJiYgKCFzIHx8IHModGhpcy5jaXJjbGVLZXlzW3ldKSkpIHtcbiAgICAgICAgICAgIGlmIChuLmhpdFRlc3QpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgICAgIHZhciBiID0gbVt4XSxcbiAgICAgICAgICAgICAgdyA9IG1beCArIDFdLFxuICAgICAgICAgICAgICBUID0gbVt4ICsgMl07XG4gICAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IHRoaXMuY2lyY2xlS2V5c1t5XSxcbiAgICAgICAgICAgICAgeDE6IGIgLSBULFxuICAgICAgICAgICAgICB5MTogdyAtIFQsXG4gICAgICAgICAgICAgIHgyOiBiICsgVCxcbiAgICAgICAgICAgICAgeTI6IHcgKyBUXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBZdC5wcm90b3R5cGUuX3F1ZXJ5Q2VsbENpcmNsZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzKSB7XG4gICAgICB2YXIgbCA9IG4uY2lyY2xlLFxuICAgICAgICBjID0gbi5zZWVuVWlkcyxcbiAgICAgICAgdSA9IHRoaXMuYm94Q2VsbHNbcl07XG4gICAgICBpZiAobnVsbCAhPT0gdSkgZm9yICh2YXIgaCA9IHRoaXMuYmJveGVzLCBwID0gMCwgZCA9IHU7IHAgPCBkLmxlbmd0aDsgcCArPSAxKSB7XG4gICAgICAgIHZhciBfID0gZFtwXTtcbiAgICAgICAgaWYgKCFjLmJveFtfXSkge1xuICAgICAgICAgIGMuYm94W19dID0gITA7XG4gICAgICAgICAgdmFyIGYgPSA0ICogXztcbiAgICAgICAgICBpZiAodGhpcy5fY2lyY2xlQW5kUmVjdENvbGxpZGUobC54LCBsLnksIGwucmFkaXVzLCBoW2YgKyAwXSwgaFtmICsgMV0sIGhbZiArIDJdLCBoW2YgKyAzXSkgJiYgKCFzIHx8IHModGhpcy5ib3hLZXlzW19dKSkpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG0gPSB0aGlzLmNpcmNsZUNlbGxzW3JdO1xuICAgICAgaWYgKG51bGwgIT09IG0pIGZvciAodmFyIGcgPSB0aGlzLmNpcmNsZXMsIHYgPSAwLCB5ID0gbTsgdiA8IHkubGVuZ3RoOyB2ICs9IDEpIHtcbiAgICAgICAgdmFyIHggPSB5W3ZdO1xuICAgICAgICBpZiAoIWMuY2lyY2xlW3hdKSB7XG4gICAgICAgICAgYy5jaXJjbGVbeF0gPSAhMDtcbiAgICAgICAgICB2YXIgYiA9IDMgKiB4O1xuICAgICAgICAgIGlmICh0aGlzLl9jaXJjbGVzQ29sbGlkZShnW2JdLCBnW2IgKyAxXSwgZ1tiICsgMl0sIGwueCwgbC55LCBsLnJhZGl1cykgJiYgKCFzIHx8IHModGhpcy5jaXJjbGVLZXlzW3hdKSkpIHJldHVybiBhLnB1c2goITApLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFl0LnByb3RvdHlwZS5fZm9yRWFjaENlbGwgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgZm9yICh2YXIgbCA9IHRoaXMuX2NvbnZlcnRUb1hDZWxsQ29vcmQodCksIGMgPSB0aGlzLl9jb252ZXJ0VG9ZQ2VsbENvb3JkKGUpLCB1ID0gdGhpcy5fY29udmVydFRvWENlbGxDb29yZChpKSwgaCA9IHRoaXMuX2NvbnZlcnRUb1lDZWxsQ29vcmQobyksIHAgPSBsOyBwIDw9IHU7IHArKykgZm9yICh2YXIgZCA9IGM7IGQgPD0gaDsgZCsrKSBpZiAoci5jYWxsKHRoaXMsIHQsIGUsIGksIG8sIHRoaXMueENlbGxDb3VudCAqIGQgKyBwLCBhLCBuLCBzKSkgcmV0dXJuO1xuICAgIH0sIFl0LnByb3RvdHlwZS5fY29udmVydFRvWENlbGxDb29yZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy54Q2VsbENvdW50IC0gMSwgTWF0aC5mbG9vcih0ICogdGhpcy54U2NhbGUpKSk7XG4gICAgfSwgWXQucHJvdG90eXBlLl9jb252ZXJ0VG9ZQ2VsbENvb3JkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnlDZWxsQ291bnQgLSAxLCBNYXRoLmZsb29yKHQgKiB0aGlzLnlTY2FsZSkpKTtcbiAgICB9LCBZdC5wcm90b3R5cGUuX2NpcmNsZXNDb2xsaWRlID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIHZhciBuID0gbyAtIHQsXG4gICAgICAgIHMgPSByIC0gZSxcbiAgICAgICAgbCA9IGkgKyBhO1xuICAgICAgcmV0dXJuIGwgKiBsID4gbiAqIG4gKyBzICogcztcbiAgICB9LCBZdC5wcm90b3R5cGUuX2NpcmNsZUFuZFJlY3RDb2xsaWRlID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gKGEgLSBvKSAvIDIsXG4gICAgICAgIGwgPSBNYXRoLmFicyh0IC0gKG8gKyBzKSk7XG4gICAgICBpZiAobCA+IHMgKyBpKSByZXR1cm4gITE7XG4gICAgICB2YXIgYyA9IChuIC0gcikgLyAyLFxuICAgICAgICB1ID0gTWF0aC5hYnMoZSAtIChyICsgYykpO1xuICAgICAgaWYgKHUgPiBjICsgaSkgcmV0dXJuICExO1xuICAgICAgaWYgKGwgPD0gcyB8fCB1IDw9IGMpIHJldHVybiAhMDtcbiAgICAgIHZhciBoID0gbCAtIHMsXG4gICAgICAgIHAgPSB1IC0gYztcbiAgICAgIHJldHVybiBoICogaCArIHAgKiBwIDw9IGkgKiBpO1xuICAgIH07XG4gICAgdmFyIGxlID0gbmV3IEZsb2F0MzJBcnJheShbLTEgLyAwLCAtMSAvIDAsIDAsIC0xIC8gMCwgLTEgLyAwLCAwLCAtMSAvIDAsIC0xIC8gMCwgMCwgLTEgLyAwLCAtMSAvIDAsIDBdKTtcbiAgICBmdW5jdGlvbiBjZSh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7IGkrKykge1xuICAgICAgICB2YXIgbyA9IGUubGVuZ3RoO1xuICAgICAgICBlLnJlc2l6ZShvICsgNCksIGUuZmxvYXQzMi5zZXQobGUsIDMgKiBvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdWUodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSBlWzBdLFxuICAgICAgICByID0gZVsxXTtcbiAgICAgIHJldHVybiB0WzBdID0gaVswXSAqIG8gKyBpWzRdICogciArIGlbMTJdLCB0WzFdID0gaVsxXSAqIG8gKyBpWzVdICogciArIGlbMTNdLCB0WzNdID0gaVszXSAqIG8gKyBpWzddICogciArIGlbMTVdLCB0O1xuICAgIH1cbiAgICB2YXIgaGUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdm9pZCAwID09PSBlICYmIChlID0gbmV3IFl0KHQud2lkdGggKyAyMDAsIHQuaGVpZ2h0ICsgMjAwLCAyNSkpLCB2b2lkIDAgPT09IGkgJiYgKGkgPSBuZXcgWXQodC53aWR0aCArIDIwMCwgdC5oZWlnaHQgKyAyMDAsIDI1KSksIHRoaXMudHJhbnNmb3JtID0gdCwgdGhpcy5ncmlkID0gZSwgdGhpcy5pZ25vcmVkR3JpZCA9IGksIHRoaXMucGl0Y2hmYWN0b3IgPSBNYXRoLmNvcyh0Ll9waXRjaCkgKiB0LmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsIHRoaXMuc2NyZWVuUmlnaHRCb3VuZGFyeSA9IHQud2lkdGggKyAxMDAsIHRoaXMuc2NyZWVuQm90dG9tQm91bmRhcnkgPSB0LmhlaWdodCArIDEwMCwgdGhpcy5ncmlkUmlnaHRCb3VuZGFyeSA9IHQud2lkdGggKyAyMDAsIHRoaXMuZ3JpZEJvdHRvbUJvdW5kYXJ5ID0gdC5oZWlnaHQgKyAyMDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwZShlLCBpLCBvKSB7XG4gICAgICByZXR1cm4gaSAqICh0LkVYVEVOVCAvIChlLnRpbGVTaXplICogTWF0aC5wb3coMiwgbyAtIGUudGlsZUlELm92ZXJzY2FsZWRaKSkpO1xuICAgIH1cbiAgICBoZS5wcm90b3R5cGUucGxhY2VDb2xsaXNpb25Cb3ggPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgdmFyIGEgPSB0aGlzLnByb2plY3RBbmRHZXRQZXJzcGVjdGl2ZVJhdGlvKG8sIHQuYW5jaG9yUG9pbnRYLCB0LmFuY2hvclBvaW50WSksXG4gICAgICAgIG4gPSBpICogYS5wZXJzcGVjdGl2ZVJhdGlvLFxuICAgICAgICBzID0gdC54MSAqIG4gKyBhLnBvaW50LngsXG4gICAgICAgIGwgPSB0LnkxICogbiArIGEucG9pbnQueSxcbiAgICAgICAgYyA9IHQueDIgKiBuICsgYS5wb2ludC54LFxuICAgICAgICB1ID0gdC55MiAqIG4gKyBhLnBvaW50Lnk7XG4gICAgICByZXR1cm4gIXRoaXMuaXNJbnNpZGVHcmlkKHMsIGwsIGMsIHUpIHx8ICFlICYmIHRoaXMuZ3JpZC5oaXRUZXN0KHMsIGwsIGMsIHUsIHIpID8ge1xuICAgICAgICBib3g6IFtdLFxuICAgICAgICBvZmZzY3JlZW46ICExXG4gICAgICB9IDoge1xuICAgICAgICBib3g6IFtzLCBsLCBjLCB1XSxcbiAgICAgICAgb2Zmc2NyZWVuOiB0aGlzLmlzT2Zmc2NyZWVuKHMsIGwsIGMsIHUpXG4gICAgICB9O1xuICAgIH0sIGhlLnByb3RvdHlwZS5wbGFjZUNvbGxpc2lvbkNpcmNsZXMgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYywgdSwgaCwgcCwgZCkge1xuICAgICAgdmFyIF8gPSBbXSxcbiAgICAgICAgZiA9IG5ldyB0LlBvaW50KGkuYW5jaG9yWCwgaS5hbmNob3JZKSxcbiAgICAgICAgbSA9ICR0KGYsIG4pLFxuICAgICAgICBnID0gdGUodGhpcy50cmFuc2Zvcm0uY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSwgbS5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEpLFxuICAgICAgICB2ID0gKHUgPyBhIC8gZyA6IGEgKiBnKSAvIHQuT05FX0VNLFxuICAgICAgICB5ID0gJHQoZiwgcykucG9pbnQsXG4gICAgICAgIHggPSBvZSh2LCByLCBpLmxpbmVPZmZzZXRYICogdiwgaS5saW5lT2Zmc2V0WSAqIHYsICExLCB5LCBmLCBpLCBvLCBzLCB7fSksXG4gICAgICAgIGIgPSAhMSxcbiAgICAgICAgdyA9ICExLFxuICAgICAgICBUID0gITA7XG4gICAgICBpZiAoeCkge1xuICAgICAgICBmb3IgKHZhciBFID0gLjUgKiBwICogZyArIGQsIEkgPSBuZXcgdC5Qb2ludCgtMTAwLCAtMTAwKSwgUCA9IG5ldyB0LlBvaW50KHRoaXMuc2NyZWVuUmlnaHRCb3VuZGFyeSwgdGhpcy5zY3JlZW5Cb3R0b21Cb3VuZGFyeSksIFMgPSBuZXcgS3QoKSwgQyA9IHguZmlyc3QsIHogPSB4Lmxhc3QsIEQgPSBbXSwgQSA9IEMucGF0aC5sZW5ndGggLSAxOyBBID49IDE7IEEtLSkgRC5wdXNoKEMucGF0aFtBXSk7XG4gICAgICAgIGZvciAodmFyIE0gPSAxOyBNIDwgei5wYXRoLmxlbmd0aDsgTSsrKSBELnB1c2goei5wYXRoW01dKTtcbiAgICAgICAgdmFyIEwgPSAyLjUgKiBFO1xuICAgICAgICBpZiAobCkge1xuICAgICAgICAgIHZhciBSID0gRC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAkdCh0LCBsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBEID0gUi5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEgPD0gMDtcbiAgICAgICAgICB9KSA/IFtdIDogUi5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnBvaW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gW107XG4gICAgICAgIGlmIChELmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBCID0gRFswXS5jbG9uZSgpLCBPID0gRFswXS5jbG9uZSgpLCBGID0gMTsgRiA8IEQubGVuZ3RoOyBGKyspIEIueCA9IE1hdGgubWluKEIueCwgRFtGXS54KSwgQi55ID0gTWF0aC5taW4oQi55LCBEW0ZdLnkpLCBPLnggPSBNYXRoLm1heChPLngsIERbRl0ueCksIE8ueSA9IE1hdGgubWF4KE8ueSwgRFtGXS55KTtcbiAgICAgICAgICBrID0gQi54ID49IEkueCAmJiBPLnggPD0gUC54ICYmIEIueSA+PSBJLnkgJiYgTy55IDw9IFAueSA/IFtEXSA6IE8ueCA8IEkueCB8fCBCLnggPiBQLnggfHwgTy55IDwgSS55IHx8IEIueSA+IFAueSA/IFtdIDogdC5jbGlwTGluZShbRF0sIEkueCwgSS55LCBQLngsIFAueSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgVSA9IDAsIE4gPSBrOyBVIDwgTi5sZW5ndGg7IFUgKz0gMSkge1xuICAgICAgICAgIHZhciBaO1xuICAgICAgICAgIFMucmVzZXQoTltVXSwgLjI1ICogRSksIFogPSBTLmxlbmd0aCA8PSAuNSAqIEUgPyAxIDogTWF0aC5jZWlsKFMucGFkZGVkTGVuZ3RoIC8gTCkgKyAxO1xuICAgICAgICAgIGZvciAodmFyIHEgPSAwOyBxIDwgWjsgcSsrKSB7XG4gICAgICAgICAgICB2YXIgaiA9IHEgLyBNYXRoLm1heChaIC0gMSwgMSksXG4gICAgICAgICAgICAgIFYgPSBTLmxlcnAoaiksXG4gICAgICAgICAgICAgIEcgPSBWLnggKyAxMDAsXG4gICAgICAgICAgICAgIFcgPSBWLnkgKyAxMDA7XG4gICAgICAgICAgICBfLnB1c2goRywgVywgRSwgMCk7XG4gICAgICAgICAgICB2YXIgWCA9IEcgLSBFLFxuICAgICAgICAgICAgICBIID0gVyAtIEUsXG4gICAgICAgICAgICAgIEsgPSBHICsgRSxcbiAgICAgICAgICAgICAgWSA9IFcgKyBFO1xuICAgICAgICAgICAgaWYgKFQgPSBUICYmIHRoaXMuaXNPZmZzY3JlZW4oWCwgSCwgSywgWSksIHcgPSB3IHx8IHRoaXMuaXNJbnNpZGVHcmlkKFgsIEgsIEssIFkpLCAhZSAmJiB0aGlzLmdyaWQuaGl0VGVzdENpcmNsZShHLCBXLCBFLCBoKSAmJiAoYiA9ICEwLCAhYykpIHJldHVybiB7XG4gICAgICAgICAgICAgIGNpcmNsZXM6IFtdLFxuICAgICAgICAgICAgICBvZmZzY3JlZW46ICExLFxuICAgICAgICAgICAgICBjb2xsaXNpb25EZXRlY3RlZDogYlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNpcmNsZXM6ICFjICYmIGIgfHwgIXcgPyBbXSA6IF8sXG4gICAgICAgIG9mZnNjcmVlbjogVCxcbiAgICAgICAgY29sbGlzaW9uRGV0ZWN0ZWQ6IGJcbiAgICAgIH07XG4gICAgfSwgaGUucHJvdG90eXBlLnF1ZXJ5UmVuZGVyZWRTeW1ib2xzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICgwID09PSBlLmxlbmd0aCB8fCAwID09PSB0aGlzLmdyaWQua2V5c0xlbmd0aCgpICYmIDAgPT09IHRoaXMuaWdub3JlZEdyaWQua2V5c0xlbmd0aCgpKSByZXR1cm4ge307XG4gICAgICBmb3IgKHZhciBpID0gW10sIG8gPSAxIC8gMCwgciA9IDEgLyAwLCBhID0gLTEgLyAwLCBuID0gLTEgLyAwLCBzID0gMCwgbCA9IGU7IHMgPCBsLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgIHZhciBjID0gbFtzXSxcbiAgICAgICAgICB1ID0gbmV3IHQuUG9pbnQoYy54ICsgMTAwLCBjLnkgKyAxMDApO1xuICAgICAgICBvID0gTWF0aC5taW4obywgdS54KSwgciA9IE1hdGgubWluKHIsIHUueSksIGEgPSBNYXRoLm1heChhLCB1LngpLCBuID0gTWF0aC5tYXgobiwgdS55KSwgaS5wdXNoKHUpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaCA9IHt9LCBwID0ge30sIGQgPSAwLCBfID0gdGhpcy5ncmlkLnF1ZXJ5KG8sIHIsIGEsIG4pLmNvbmNhdCh0aGlzLmlnbm9yZWRHcmlkLnF1ZXJ5KG8sIHIsIGEsIG4pKTsgZCA8IF8ubGVuZ3RoOyBkICs9IDEpIHtcbiAgICAgICAgdmFyIGYgPSBfW2RdLFxuICAgICAgICAgIG0gPSBmLmtleTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gaFttLmJ1Y2tldEluc3RhbmNlSWRdICYmIChoW20uYnVja2V0SW5zdGFuY2VJZF0gPSB7fSksICFoW20uYnVja2V0SW5zdGFuY2VJZF1bbS5mZWF0dXJlSW5kZXhdKSB7XG4gICAgICAgICAgdmFyIGcgPSBbbmV3IHQuUG9pbnQoZi54MSwgZi55MSksIG5ldyB0LlBvaW50KGYueDIsIGYueTEpLCBuZXcgdC5Qb2ludChmLngyLCBmLnkyKSwgbmV3IHQuUG9pbnQoZi54MSwgZi55MildO1xuICAgICAgICAgIHQucG9seWdvbkludGVyc2VjdHNQb2x5Z29uKGksIGcpICYmIChoW20uYnVja2V0SW5zdGFuY2VJZF1bbS5mZWF0dXJlSW5kZXhdID0gITAsIHZvaWQgMCA9PT0gcFttLmJ1Y2tldEluc3RhbmNlSWRdICYmIChwW20uYnVja2V0SW5zdGFuY2VJZF0gPSBbXSksIHBbbS5idWNrZXRJbnN0YW5jZUlkXS5wdXNoKG0uZmVhdHVyZUluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sIGhlLnByb3RvdHlwZS5pbnNlcnRDb2xsaXNpb25Cb3ggPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgKGUgPyB0aGlzLmlnbm9yZWRHcmlkIDogdGhpcy5ncmlkKS5pbnNlcnQoe1xuICAgICAgICBidWNrZXRJbnN0YW5jZUlkOiBpLFxuICAgICAgICBmZWF0dXJlSW5kZXg6IG8sXG4gICAgICAgIGNvbGxpc2lvbkdyb3VwSUQ6IHJcbiAgICAgIH0sIHRbMF0sIHRbMV0sIHRbMl0sIHRbM10pO1xuICAgIH0sIGhlLnByb3RvdHlwZS5pbnNlcnRDb2xsaXNpb25DaXJjbGVzID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIGZvciAodmFyIGEgPSBlID8gdGhpcy5pZ25vcmVkR3JpZCA6IHRoaXMuZ3JpZCwgbiA9IHtcbiAgICAgICAgICBidWNrZXRJbnN0YW5jZUlkOiBpLFxuICAgICAgICAgIGZlYXR1cmVJbmRleDogbyxcbiAgICAgICAgICBjb2xsaXNpb25Hcm91cElEOiByXG4gICAgICAgIH0sIHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMgKz0gNCkgYS5pbnNlcnRDaXJjbGUobiwgdFtzXSwgdFtzICsgMV0sIHRbcyArIDJdKTtcbiAgICB9LCBoZS5wcm90b3R5cGUucHJvamVjdEFuZEdldFBlcnNwZWN0aXZlUmF0aW8gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBbaSwgbywgMCwgMV07XG4gICAgICByZXR1cm4gdWUociwgciwgZSksIHtcbiAgICAgICAgcG9pbnQ6IG5ldyB0LlBvaW50KChyWzBdIC8gclszXSArIDEpIC8gMiAqIHRoaXMudHJhbnNmb3JtLndpZHRoICsgMTAwLCAoLXJbMV0gLyByWzNdICsgMSkgLyAyICogdGhpcy50cmFuc2Zvcm0uaGVpZ2h0ICsgMTAwKSxcbiAgICAgICAgcGVyc3BlY3RpdmVSYXRpbzogLjUgKyB0aGlzLnRyYW5zZm9ybS5jYW1lcmFUb0NlbnRlckRpc3RhbmNlIC8gclszXSAqIC41XG4gICAgICB9O1xuICAgIH0sIGhlLnByb3RvdHlwZS5pc09mZnNjcmVlbiA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICByZXR1cm4gaSA8IDEwMCB8fCB0ID49IHRoaXMuc2NyZWVuUmlnaHRCb3VuZGFyeSB8fCBvIDwgMTAwIHx8IGUgPiB0aGlzLnNjcmVlbkJvdHRvbUJvdW5kYXJ5O1xuICAgIH0sIGhlLnByb3RvdHlwZS5pc0luc2lkZUdyaWQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgcmV0dXJuIGkgPj0gMCAmJiB0IDwgdGhpcy5ncmlkUmlnaHRCb3VuZGFyeSAmJiBvID49IDAgJiYgZSA8IHRoaXMuZ3JpZEJvdHRvbUJvdW5kYXJ5O1xuICAgIH0sIGhlLnByb3RvdHlwZS5nZXRWaWV3cG9ydE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdC5pZGVudGl0eShbXSk7XG4gICAgICByZXR1cm4gdC50cmFuc2xhdGUoZSwgZSwgWy0xMDAsIC0xMDAsIDBdKSwgZTtcbiAgICB9O1xuICAgIHZhciBkZSA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICB0aGlzLm9wYWNpdHkgPSB0ID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdC5vcGFjaXR5ICsgKHQucGxhY2VkID8gZSA6IC1lKSkpIDogbyAmJiBpID8gMSA6IDAsIHRoaXMucGxhY2VkID0gaTtcbiAgICB9O1xuICAgIGRlLnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAwID09PSB0aGlzLm9wYWNpdHkgJiYgIXRoaXMucGxhY2VkO1xuICAgIH07XG4gICAgdmFyIF9lID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgIHRoaXMudGV4dCA9IG5ldyBkZSh0ID8gdC50ZXh0IDogbnVsbCwgZSwgaSwgciksIHRoaXMuaWNvbiA9IG5ldyBkZSh0ID8gdC5pY29uIDogbnVsbCwgZSwgbywgcik7XG4gICAgfTtcbiAgICBfZS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0LmlzSGlkZGVuKCkgJiYgdGhpcy5pY29uLmlzSGlkZGVuKCk7XG4gICAgfTtcbiAgICB2YXIgZmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB0aGlzLnRleHQgPSB0LCB0aGlzLmljb24gPSBlLCB0aGlzLnNraXBGYWRlID0gaTtcbiAgICAgIH0sXG4gICAgICBtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnZQcm9qTWF0cml4ID0gdC5jcmVhdGUoKSwgdGhpcy52aWV3cG9ydE1hdHJpeCA9IHQuY3JlYXRlKCksIHRoaXMuY2lyY2xlcyA9IFtdO1xuICAgICAgfSxcbiAgICAgIGdlID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIpIHtcbiAgICAgICAgdGhpcy5idWNrZXRJbnN0YW5jZUlkID0gdCwgdGhpcy5mZWF0dXJlSW5kZXggPSBlLCB0aGlzLnNvdXJjZUxheWVySW5kZXggPSBpLCB0aGlzLmJ1Y2tldEluZGV4ID0gbywgdGhpcy50aWxlSUQgPSByO1xuICAgICAgfSxcbiAgICAgIHZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5jcm9zc1NvdXJjZUNvbGxpc2lvbnMgPSB0LCB0aGlzLm1heEdyb3VwSUQgPSAwLCB0aGlzLmNvbGxpc2lvbkdyb3VwcyA9IHt9O1xuICAgICAgfTtcbiAgICBmdW5jdGlvbiB5ZShlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IHQuZ2V0QW5jaG9yQWxpZ25tZW50KGUpLFxuICAgICAgICBzID0gLShuLmhvcml6b250YWxBbGlnbiAtIC41KSAqIGksXG4gICAgICAgIGwgPSAtKG4udmVydGljYWxBbGlnbiAtIC41KSAqIG8sXG4gICAgICAgIGMgPSB0LmV2YWx1YXRlVmFyaWFibGVPZmZzZXQoZSwgcik7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQocyArIGNbMF0gKiBhLCBsICsgY1sxXSAqIGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4ZShlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyA9IGUueDEsXG4gICAgICAgIGwgPSBlLngyLFxuICAgICAgICBjID0gZS55MSxcbiAgICAgICAgdSA9IGUueTIsXG4gICAgICAgIGggPSBlLmFuY2hvclBvaW50WCxcbiAgICAgICAgcCA9IGUuYW5jaG9yUG9pbnRZLFxuICAgICAgICBkID0gbmV3IHQuUG9pbnQoaSwgbyk7XG4gICAgICByZXR1cm4gciAmJiBkLl9yb3RhdGUoYSA/IG4gOiAtbiksIHtcbiAgICAgICAgeDE6IHMgKyBkLngsXG4gICAgICAgIHkxOiBjICsgZC55LFxuICAgICAgICB4MjogbCArIGQueCxcbiAgICAgICAgeTI6IHUgKyBkLnksXG4gICAgICAgIGFuY2hvclBvaW50WDogaCxcbiAgICAgICAgYW5jaG9yUG9pbnRZOiBwXG4gICAgICB9O1xuICAgIH1cbiAgICB2ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICh0aGlzLmNyb3NzU291cmNlQ29sbGlzaW9ucykgcmV0dXJuIHtcbiAgICAgICAgSUQ6IDAsXG4gICAgICAgIHByZWRpY2F0ZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICghdGhpcy5jb2xsaXNpb25Hcm91cHNbdF0pIHtcbiAgICAgICAgdmFyIGUgPSArK3RoaXMubWF4R3JvdXBJRDtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHNbdF0gPSB7XG4gICAgICAgICAgSUQ6IGUsXG4gICAgICAgICAgcHJlZGljYXRlOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuY29sbGlzaW9uR3JvdXBJRCA9PT0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25Hcm91cHNbdF07XG4gICAgfTtcbiAgICB2YXIgYmUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0LmNsb25lKCksIHRoaXMuY29sbGlzaW9uSW5kZXggPSBuZXcgaGUodGhpcy50cmFuc2Zvcm0pLCB0aGlzLnBsYWNlbWVudHMgPSB7fSwgdGhpcy5vcGFjaXRpZXMgPSB7fSwgdGhpcy52YXJpYWJsZU9mZnNldHMgPSB7fSwgdGhpcy5zdGFsZSA9ICExLCB0aGlzLmNvbW1pdFRpbWUgPSAwLCB0aGlzLmZhZGVEdXJhdGlvbiA9IGUsIHRoaXMucmV0YWluZWRRdWVyeURhdGEgPSB7fSwgdGhpcy5jb2xsaXNpb25Hcm91cHMgPSBuZXcgdmUoaSksIHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzID0ge30sIHRoaXMucHJldlBsYWNlbWVudCA9IG8sIG8gJiYgKG8ucHJldlBsYWNlbWVudCA9IHZvaWQgMCksIHRoaXMucGxhY2VkT3JpZW50YXRpb25zID0ge307XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3ZSh0LCBlLCBpLCBvLCByKSB7XG4gICAgICB0LmVtcGxhY2VCYWNrKGUgPyAxIDogMCwgaSA/IDEgOiAwLCBvIHx8IDAsIHIgfHwgMCksIHQuZW1wbGFjZUJhY2soZSA/IDEgOiAwLCBpID8gMSA6IDAsIG8gfHwgMCwgciB8fCAwKSwgdC5lbXBsYWNlQmFjayhlID8gMSA6IDAsIGkgPyAxIDogMCwgbyB8fCAwLCByIHx8IDApLCB0LmVtcGxhY2VCYWNrKGUgPyAxIDogMCwgaSA/IDEgOiAwLCBvIHx8IDAsIHIgfHwgMCk7XG4gICAgfVxuICAgIGJlLnByb3RvdHlwZS5nZXRCdWNrZXRQYXJ0cyA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYSA9IG8uZ2V0QnVja2V0KGkpLFxuICAgICAgICBuID0gby5sYXRlc3RGZWF0dXJlSW5kZXg7XG4gICAgICBpZiAoYSAmJiBuICYmIGkuaWQgPT09IGEubGF5ZXJJZHNbMF0pIHtcbiAgICAgICAgdmFyIHMgPSBvLmNvbGxpc2lvbkJveEFycmF5LFxuICAgICAgICAgIGwgPSBhLmxheWVyc1swXS5sYXlvdXQsXG4gICAgICAgICAgYyA9IE1hdGgucG93KDIsIHRoaXMudHJhbnNmb3JtLnpvb20gLSBvLnRpbGVJRC5vdmVyc2NhbGVkWiksXG4gICAgICAgICAgdSA9IG8udGlsZVNpemUgLyB0LkVYVEVOVCxcbiAgICAgICAgICBoID0gdGhpcy50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KG8udGlsZUlELnRvVW53cmFwcGVkKCkpLFxuICAgICAgICAgIHAgPSBcIm1hcFwiID09PSBsLmdldChcInRleHQtcGl0Y2gtYWxpZ25tZW50XCIpLFxuICAgICAgICAgIGQgPSBcIm1hcFwiID09PSBsLmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpLFxuICAgICAgICAgIF8gPSBwZShvLCAxLCB0aGlzLnRyYW5zZm9ybS56b29tKSxcbiAgICAgICAgICBmID0gSnQoaCwgcCwgZCwgdGhpcy50cmFuc2Zvcm0sIF8pLFxuICAgICAgICAgIG0gPSBudWxsO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIHZhciBnID0gUXQoaCwgcCwgZCwgdGhpcy50cmFuc2Zvcm0sIF8pO1xuICAgICAgICAgIG0gPSB0Lm11bHRpcGx5KFtdLCB0aGlzLnRyYW5zZm9ybS5sYWJlbFBsYW5lTWF0cml4LCBnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldGFpbmVkUXVlcnlEYXRhW2EuYnVja2V0SW5zdGFuY2VJZF0gPSBuZXcgZ2UoYS5idWNrZXRJbnN0YW5jZUlkLCBuLCBhLnNvdXJjZUxheWVySW5kZXgsIGEuaW5kZXgsIG8udGlsZUlEKTtcbiAgICAgICAgdmFyIHYgPSB7XG4gICAgICAgICAgYnVja2V0OiBhLFxuICAgICAgICAgIGxheW91dDogbCxcbiAgICAgICAgICBwb3NNYXRyaXg6IGgsXG4gICAgICAgICAgdGV4dExhYmVsUGxhbmVNYXRyaXg6IGYsXG4gICAgICAgICAgbGFiZWxUb1NjcmVlbk1hdHJpeDogbSxcbiAgICAgICAgICBzY2FsZTogYyxcbiAgICAgICAgICB0ZXh0UGl4ZWxSYXRpbzogdSxcbiAgICAgICAgICBob2xkaW5nRm9yRmFkZTogby5ob2xkaW5nRm9yRmFkZSgpLFxuICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiBzLFxuICAgICAgICAgIHBhcnRpYWxseUV2YWx1YXRlZFRleHRTaXplOiB0LmV2YWx1YXRlU2l6ZUZvclpvb20oYS50ZXh0U2l6ZURhdGEsIHRoaXMudHJhbnNmb3JtLnpvb20pLFxuICAgICAgICAgIGNvbGxpc2lvbkdyb3VwOiB0aGlzLmNvbGxpc2lvbkdyb3Vwcy5nZXQoYS5zb3VyY2VJRClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHIpIGZvciAodmFyIHkgPSAwLCB4ID0gYS5zb3J0S2V5UmFuZ2VzOyB5IDwgeC5sZW5ndGg7IHkgKz0gMSkge1xuICAgICAgICAgIHZhciBiID0geFt5XTtcbiAgICAgICAgICBlLnB1c2goe1xuICAgICAgICAgICAgc29ydEtleTogYi5zb3J0S2V5LFxuICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2VTdGFydDogYi5zeW1ib2xJbnN0YW5jZVN0YXJ0LFxuICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2VFbmQ6IGIuc3ltYm9sSW5zdGFuY2VFbmQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB2XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBlLnB1c2goe1xuICAgICAgICAgIHN5bWJvbEluc3RhbmNlU3RhcnQ6IDAsXG4gICAgICAgICAgc3ltYm9sSW5zdGFuY2VFbmQ6IGEuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aCxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiB2XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIGJlLnByb3RvdHlwZS5hdHRlbXB0QW5jaG9yUGxhY2VtZW50ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgsIHAsIGQsIF8pIHtcbiAgICAgIHZhciBmLFxuICAgICAgICBtID0gW2gudGV4dE9mZnNldDAsIGgudGV4dE9mZnNldDFdLFxuICAgICAgICBnID0geWUodCwgaSwgbywgbSwgciksXG4gICAgICAgIHYgPSB0aGlzLmNvbGxpc2lvbkluZGV4LnBsYWNlQ29sbGlzaW9uQm94KHhlKGUsIGcueCwgZy55LCBhLCBuLCB0aGlzLnRyYW5zZm9ybS5hbmdsZSksIHUsIHMsIGwsIGMucHJlZGljYXRlKTtcbiAgICAgIGlmICghXyB8fCAwICE9PSB0aGlzLmNvbGxpc2lvbkluZGV4LnBsYWNlQ29sbGlzaW9uQm94KHhlKF8sIGcueCwgZy55LCBhLCBuLCB0aGlzLnRyYW5zZm9ybS5hbmdsZSksIHUsIHMsIGwsIGMucHJlZGljYXRlKS5ib3gubGVuZ3RoKSByZXR1cm4gdi5ib3gubGVuZ3RoID4gMCA/ICh0aGlzLnByZXZQbGFjZW1lbnQgJiYgdGhpcy5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1toLmNyb3NzVGlsZUlEXSAmJiB0aGlzLnByZXZQbGFjZW1lbnQucGxhY2VtZW50c1toLmNyb3NzVGlsZUlEXSAmJiB0aGlzLnByZXZQbGFjZW1lbnQucGxhY2VtZW50c1toLmNyb3NzVGlsZUlEXS50ZXh0ICYmIChmID0gdGhpcy5wcmV2UGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0c1toLmNyb3NzVGlsZUlEXS5hbmNob3IpLCB0aGlzLnZhcmlhYmxlT2Zmc2V0c1toLmNyb3NzVGlsZUlEXSA9IHtcbiAgICAgICAgdGV4dE9mZnNldDogbSxcbiAgICAgICAgd2lkdGg6IGksXG4gICAgICAgIGhlaWdodDogbyxcbiAgICAgICAgYW5jaG9yOiB0LFxuICAgICAgICB0ZXh0Qm94U2NhbGU6IHIsXG4gICAgICAgIHByZXZBbmNob3I6IGZcbiAgICAgIH0sIHRoaXMubWFya1VzZWRKdXN0aWZpY2F0aW9uKHAsIHQsIGgsIGQpLCBwLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgKHRoaXMubWFya1VzZWRPcmllbnRhdGlvbihwLCBkLCBoKSwgdGhpcy5wbGFjZWRPcmllbnRhdGlvbnNbaC5jcm9zc1RpbGVJRF0gPSBkKSwge1xuICAgICAgICBzaGlmdDogZyxcbiAgICAgICAgcGxhY2VkR2x5cGhCb3hlczogdlxuICAgICAgfSkgOiB2b2lkIDA7XG4gICAgfSwgYmUucHJvdG90eXBlLnBsYWNlTGF5ZXJCdWNrZXRQYXJ0ID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgYSA9IGUucGFyYW1ldGVycyxcbiAgICAgICAgbiA9IGEuYnVja2V0LFxuICAgICAgICBzID0gYS5sYXlvdXQsXG4gICAgICAgIGwgPSBhLnBvc01hdHJpeCxcbiAgICAgICAgYyA9IGEudGV4dExhYmVsUGxhbmVNYXRyaXgsXG4gICAgICAgIHUgPSBhLmxhYmVsVG9TY3JlZW5NYXRyaXgsXG4gICAgICAgIGggPSBhLnRleHRQaXhlbFJhdGlvLFxuICAgICAgICBwID0gYS5ob2xkaW5nRm9yRmFkZSxcbiAgICAgICAgZCA9IGEuY29sbGlzaW9uQm94QXJyYXksXG4gICAgICAgIF8gPSBhLnBhcnRpYWxseUV2YWx1YXRlZFRleHRTaXplLFxuICAgICAgICBmID0gYS5jb2xsaXNpb25Hcm91cCxcbiAgICAgICAgbSA9IHMuZ2V0KFwidGV4dC1vcHRpb25hbFwiKSxcbiAgICAgICAgZyA9IHMuZ2V0KFwiaWNvbi1vcHRpb25hbFwiKSxcbiAgICAgICAgdiA9IHMuZ2V0KFwidGV4dC1hbGxvdy1vdmVybGFwXCIpLFxuICAgICAgICB5ID0gcy5nZXQoXCJpY29uLWFsbG93LW92ZXJsYXBcIiksXG4gICAgICAgIHggPSBcIm1hcFwiID09PSBzLmdldChcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCIpLFxuICAgICAgICBiID0gXCJtYXBcIiA9PT0gcy5nZXQoXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiKSxcbiAgICAgICAgdyA9IFwibm9uZVwiICE9PSBzLmdldChcImljb24tdGV4dC1maXRcIiksXG4gICAgICAgIFQgPSBcInZpZXdwb3J0LXlcIiA9PT0gcy5nZXQoXCJzeW1ib2wtei1vcmRlclwiKSxcbiAgICAgICAgRSA9IHYgJiYgKHkgfHwgIW4uaGFzSWNvbkRhdGEoKSB8fCBnKSxcbiAgICAgICAgSSA9IHkgJiYgKHYgfHwgIW4uaGFzVGV4dERhdGEoKSB8fCBtKTtcbiAgICAgICFuLmNvbGxpc2lvbkFycmF5cyAmJiBkICYmIG4uZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlcyhkKTtcbiAgICAgIHZhciBQID0gZnVuY3Rpb24gKGUsIGEpIHtcbiAgICAgICAgaWYgKCFpW2UuY3Jvc3NUaWxlSURdKSBpZiAocCkgci5wbGFjZW1lbnRzW2UuY3Jvc3NUaWxlSURdID0gbmV3IGZlKCExLCAhMSwgITEpO2Vsc2Uge1xuICAgICAgICAgIHZhciBkLFxuICAgICAgICAgICAgVCA9ICExLFxuICAgICAgICAgICAgUCA9ICExLFxuICAgICAgICAgICAgUyA9ICEwLFxuICAgICAgICAgICAgQyA9IG51bGwsXG4gICAgICAgICAgICB6ID0ge1xuICAgICAgICAgICAgICBib3g6IG51bGwsXG4gICAgICAgICAgICAgIG9mZnNjcmVlbjogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEQgPSB7XG4gICAgICAgICAgICAgIGJveDogbnVsbCxcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuOiBudWxsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQSA9IG51bGwsXG4gICAgICAgICAgICBNID0gbnVsbCxcbiAgICAgICAgICAgIEwgPSAwLFxuICAgICAgICAgICAgUiA9IDAsXG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICBhLnRleHRGZWF0dXJlSW5kZXggPyBMID0gYS50ZXh0RmVhdHVyZUluZGV4IDogZS51c2VSdW50aW1lQ29sbGlzaW9uQ2lyY2xlcyAmJiAoTCA9IGUuZmVhdHVyZUluZGV4KSwgYS52ZXJ0aWNhbFRleHRGZWF0dXJlSW5kZXggJiYgKFIgPSBhLnZlcnRpY2FsVGV4dEZlYXR1cmVJbmRleCk7XG4gICAgICAgICAgdmFyIEIgPSBhLnRleHRCb3g7XG4gICAgICAgICAgaWYgKEIpIHtcbiAgICAgICAgICAgIHZhciBPID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgICAgICBpZiAobi5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmICFpICYmIHIucHJldlBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGEgPSByLnByZXZQbGFjZW1lbnQucGxhY2VkT3JpZW50YXRpb25zW2UuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgICAgICAgYSAmJiAoci5wbGFjZWRPcmllbnRhdGlvbnNbZS5jcm9zc1RpbGVJRF0gPSBhLCByLm1hcmtVc2VkT3JpZW50YXRpb24obiwgbyA9IGEsIGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIEYgPSBmdW5jdGlvbiAoaSwgbykge1xuICAgICAgICAgICAgICAgIGlmIChuLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgZS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMgPiAwICYmIGEudmVydGljYWxUZXh0Qm94KSBmb3IgKHZhciByID0gMCwgcyA9IG4ud3JpdGluZ01vZGVzOyByIDwgcy5sZW5ndGggJiYgKHNbcl0gPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgPyAoeiA9IG8oKSwgRCA9IHopIDogeiA9IGkoKSwgISh6ICYmIHouYm94ICYmIHouYm94Lmxlbmd0aCkpOyByICs9IDEpO2Vsc2UgeiA9IGkoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpKSB7XG4gICAgICAgICAgICAgIHZhciBVID0gcy5nZXQoXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiKTtcbiAgICAgICAgICAgICAgaWYgKHIucHJldlBsYWNlbWVudCAmJiByLnByZXZQbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzW2UuY3Jvc3NUaWxlSURdKSB7XG4gICAgICAgICAgICAgICAgdmFyIE4gPSByLnByZXZQbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzW2UuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgICAgIFUuaW5kZXhPZihOLmFuY2hvcikgPiAwICYmIChVID0gVS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0ICE9PSBOLmFuY2hvcjtcbiAgICAgICAgICAgICAgICB9KSkudW5zaGlmdChOLmFuY2hvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIFogPSBmdW5jdGlvbiAodCwgaSwgbykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSB0LngyIC0gdC54MSwgcyA9IHQueTIgLSB0LnkxLCBjID0gZS50ZXh0Qm94U2NhbGUsIHUgPSB3ICYmICF5ID8gaSA6IG51bGwsIHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJveDogW10sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbjogITFcbiAgICAgICAgICAgICAgICAgIH0sIGQgPSB2ID8gMiAqIFUubGVuZ3RoIDogVS5sZW5ndGgsIF8gPSAwOyBfIDwgZDsgKytfKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbSA9IHIuYXR0ZW1wdEFuY2hvclBsYWNlbWVudChVW18gJSBVLmxlbmd0aF0sIHQsIGEsIHMsIGMsIHgsIGIsIGgsIGwsIGYsIF8gPj0gVS5sZW5ndGgsIGUsIG4sIG8sIHUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgKHAgPSBtLnBsYWNlZEdseXBoQm94ZXMpICYmIHAuYm94ICYmIHAuYm94Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBUID0gITAsIEMgPSBtLnNoaWZ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIEYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBaKEIsIGEuaWNvbkJveCwgdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsKTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gYS52ZXJ0aWNhbFRleHRCb3g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4uYWxsb3dWZXJ0aWNhbFBsYWNlbWVudCAmJiAhKHogJiYgei5ib3ggJiYgei5ib3gubGVuZ3RoKSAmJiBlLm51bVZlcnRpY2FsR2x5cGhWZXJ0aWNlcyA+IDAgJiYgaSA/IFooaSwgYS52ZXJ0aWNhbEljb25Cb3gsIHQuV3JpdGluZ01vZGUudmVydGljYWwpIDoge1xuICAgICAgICAgICAgICAgICAgYm94OiBudWxsLFxuICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSksIHogJiYgKFQgPSB6LmJveCwgUyA9IHoub2Zmc2NyZWVuKTtcbiAgICAgICAgICAgICAgdmFyIHEgPSBPKHogJiYgei5ib3gpO1xuICAgICAgICAgICAgICBpZiAoIVQgJiYgci5wcmV2UGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSByLnByZXZQbGFjZW1lbnQudmFyaWFibGVPZmZzZXRzW2UuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgICAgIGogJiYgKHIudmFyaWFibGVPZmZzZXRzW2UuY3Jvc3NUaWxlSURdID0gaiwgci5tYXJrVXNlZEp1c3RpZmljYXRpb24obiwgai5hbmNob3IsIGUsIHEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIFYgPSBmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gci5jb2xsaXNpb25JbmRleC5wbGFjZUNvbGxpc2lvbkJveCh0LCB2LCBoLCBsLCBmLnByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8gJiYgby5ib3ggJiYgby5ib3gubGVuZ3RoICYmIChyLm1hcmtVc2VkT3JpZW50YXRpb24obiwgaSwgZSksIHIucGxhY2VkT3JpZW50YXRpb25zW2UuY3Jvc3NUaWxlSURdID0gaSksIG87XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIEYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBWKEIsIHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGEudmVydGljYWxUZXh0Qm94O1xuICAgICAgICAgICAgICAgIHJldHVybiBuLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgZS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMgPiAwICYmIGkgPyBWKGksIHQuV3JpdGluZ01vZGUudmVydGljYWwpIDoge1xuICAgICAgICAgICAgICAgICAgYm94OiBudWxsLFxuICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSksIE8oeiAmJiB6LmJveCAmJiB6LmJveC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoVCA9IChkID0geikgJiYgZC5ib3ggJiYgZC5ib3gubGVuZ3RoID4gMCwgUyA9IGQgJiYgZC5vZmZzY3JlZW4sIGUudXNlUnVudGltZUNvbGxpc2lvbkNpcmNsZXMpIHtcbiAgICAgICAgICAgIHZhciBHID0gbi50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldChlLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleCksXG4gICAgICAgICAgICAgIFcgPSB0LmV2YWx1YXRlU2l6ZUZvckZlYXR1cmUobi50ZXh0U2l6ZURhdGEsIF8sIEcpLFxuICAgICAgICAgICAgICBYID0gcy5nZXQoXCJ0ZXh0LXBhZGRpbmdcIik7XG4gICAgICAgICAgICBBID0gci5jb2xsaXNpb25JbmRleC5wbGFjZUNvbGxpc2lvbkNpcmNsZXModiwgRywgbi5saW5lVmVydGV4QXJyYXksIG4uZ2x5cGhPZmZzZXRBcnJheSwgVywgbCwgYywgdSwgbywgYiwgZi5wcmVkaWNhdGUsIGUuY29sbGlzaW9uQ2lyY2xlRGlhbWV0ZXIsIFgpLCBUID0gdiB8fCBBLmNpcmNsZXMubGVuZ3RoID4gMCAmJiAhQS5jb2xsaXNpb25EZXRlY3RlZCwgUyA9IFMgJiYgQS5vZmZzY3JlZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhLmljb25GZWF0dXJlSW5kZXggJiYgKGsgPSBhLmljb25GZWF0dXJlSW5kZXgpLCBhLmljb25Cb3gpIHtcbiAgICAgICAgICAgIHZhciBIID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSB3ICYmIEMgPyB4ZSh0LCBDLngsIEMueSwgeCwgYiwgci50cmFuc2Zvcm0uYW5nbGUpIDogdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHIuY29sbGlzaW9uSW5kZXgucGxhY2VDb2xsaXNpb25Cb3goZSwgeSwgaCwgbCwgZi5wcmVkaWNhdGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFAgPSBEICYmIEQuYm94ICYmIEQuYm94Lmxlbmd0aCAmJiBhLnZlcnRpY2FsSWNvbkJveCA/IChNID0gSChhLnZlcnRpY2FsSWNvbkJveCkpLmJveC5sZW5ndGggPiAwIDogKE0gPSBIKGEuaWNvbkJveCkpLmJveC5sZW5ndGggPiAwLCBTID0gUyAmJiBNLm9mZnNjcmVlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEsgPSBtIHx8IDAgPT09IGUubnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXMgJiYgMCA9PT0gZS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMsXG4gICAgICAgICAgICBZID0gZyB8fCAwID09PSBlLm51bUljb25WZXJ0aWNlcztcbiAgICAgICAgICBpZiAoSyB8fCBZID8gWSA/IEsgfHwgKFAgPSBQICYmIFQpIDogVCA9IFAgJiYgVCA6IFAgPSBUID0gUCAmJiBULCBUICYmIGQgJiYgZC5ib3ggJiYgci5jb2xsaXNpb25JbmRleC5pbnNlcnRDb2xsaXNpb25Cb3goZC5ib3gsIHMuZ2V0KFwidGV4dC1pZ25vcmUtcGxhY2VtZW50XCIpLCBuLmJ1Y2tldEluc3RhbmNlSWQsIEQgJiYgRC5ib3ggJiYgUiA/IFIgOiBMLCBmLklEKSwgUCAmJiBNICYmIHIuY29sbGlzaW9uSW5kZXguaW5zZXJ0Q29sbGlzaW9uQm94KE0uYm94LCBzLmdldChcImljb24taWdub3JlLXBsYWNlbWVudFwiKSwgbi5idWNrZXRJbnN0YW5jZUlkLCBrLCBmLklEKSwgQSAmJiAoVCAmJiByLmNvbGxpc2lvbkluZGV4Lmluc2VydENvbGxpc2lvbkNpcmNsZXMoQS5jaXJjbGVzLCBzLmdldChcInRleHQtaWdub3JlLXBsYWNlbWVudFwiKSwgbi5idWNrZXRJbnN0YW5jZUlkLCBMLCBmLklEKSwgbykpIHtcbiAgICAgICAgICAgIHZhciBKID0gbi5idWNrZXRJbnN0YW5jZUlkLFxuICAgICAgICAgICAgICBRID0gci5jb2xsaXNpb25DaXJjbGVBcnJheXNbSl07XG4gICAgICAgICAgICB2b2lkIDAgPT09IFEgJiYgKFEgPSByLmNvbGxpc2lvbkNpcmNsZUFycmF5c1tKXSA9IG5ldyBtZSgpKTtcbiAgICAgICAgICAgIGZvciAodmFyICQgPSAwOyAkIDwgQS5jaXJjbGVzLmxlbmd0aDsgJCArPSA0KSBRLmNpcmNsZXMucHVzaChBLmNpcmNsZXNbJCArIDBdKSwgUS5jaXJjbGVzLnB1c2goQS5jaXJjbGVzWyQgKyAxXSksIFEuY2lyY2xlcy5wdXNoKEEuY2lyY2xlc1skICsgMl0pLCBRLmNpcmNsZXMucHVzaChBLmNvbGxpc2lvbkRldGVjdGVkID8gMSA6IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLnBsYWNlbWVudHNbZS5jcm9zc1RpbGVJRF0gPSBuZXcgZmUoVCB8fCBFLCBQIHx8IEksIFMgfHwgbi5qdXN0UmVsb2FkZWQpLCBpW2UuY3Jvc3NUaWxlSURdID0gITA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoVCkgZm9yICh2YXIgUyA9IG4uZ2V0U29ydGVkU3ltYm9sSW5kZXhlcyh0aGlzLnRyYW5zZm9ybS5hbmdsZSksIEMgPSBTLmxlbmd0aCAtIDE7IEMgPj0gMDsgLS1DKSB7XG4gICAgICAgIHZhciB6ID0gU1tDXTtcbiAgICAgICAgUChuLnN5bWJvbEluc3RhbmNlcy5nZXQoeiksIG4uY29sbGlzaW9uQXJyYXlzW3pdKTtcbiAgICAgIH0gZWxzZSBmb3IgKHZhciBEID0gZS5zeW1ib2xJbnN0YW5jZVN0YXJ0OyBEIDwgZS5zeW1ib2xJbnN0YW5jZUVuZDsgRCsrKSBQKG4uc3ltYm9sSW5zdGFuY2VzLmdldChEKSwgbi5jb2xsaXNpb25BcnJheXNbRF0pO1xuICAgICAgaWYgKG8gJiYgbi5idWNrZXRJbnN0YW5jZUlkIGluIHRoaXMuY29sbGlzaW9uQ2lyY2xlQXJyYXlzKSB7XG4gICAgICAgIHZhciBBID0gdGhpcy5jb2xsaXNpb25DaXJjbGVBcnJheXNbbi5idWNrZXRJbnN0YW5jZUlkXTtcbiAgICAgICAgdC5pbnZlcnQoQS5pbnZQcm9qTWF0cml4LCBsKSwgQS52aWV3cG9ydE1hdHJpeCA9IHRoaXMuY29sbGlzaW9uSW5kZXguZ2V0Vmlld3BvcnRNYXRyaXgoKTtcbiAgICAgIH1cbiAgICAgIG4uanVzdFJlbG9hZGVkID0gITE7XG4gICAgfSwgYmUucHJvdG90eXBlLm1hcmtVc2VkSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIGEgPSByID09PSB0LldyaXRpbmdNb2RlLnZlcnRpY2FsID8gby52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleCA6IHtcbiAgICAgICAgbGVmdDogby5sZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LFxuICAgICAgICBjZW50ZXI6IG8uY2VudGVySnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LFxuICAgICAgICByaWdodDogby5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleFxuICAgICAgfVt0LmdldEFuY2hvckp1c3RpZmljYXRpb24oaSldO1xuICAgICAgZm9yICh2YXIgbiA9IDAsIHMgPSBbby5sZWZ0SnVzdGlmaWVkVGV4dFN5bWJvbEluZGV4LCBvLmNlbnRlckp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby52ZXJ0aWNhbFBsYWNlZFRleHRTeW1ib2xJbmRleF07IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBsID0gc1tuXTtcbiAgICAgICAgbCA+PSAwICYmIChlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGwpLmNyb3NzVGlsZUlEID0gYSA+PSAwICYmIGwgIT09IGEgPyAwIDogby5jcm9zc1RpbGVJRCk7XG4gICAgICB9XG4gICAgfSwgYmUucHJvdG90eXBlLm1hcmtVc2VkT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgZm9yICh2YXIgciA9IGkgPT09IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbCB8fCBpID09PSB0LldyaXRpbmdNb2RlLmhvcml6b250YWxPbmx5ID8gaSA6IDAsIGEgPSBpID09PSB0LldyaXRpbmdNb2RlLnZlcnRpY2FsID8gaSA6IDAsIG4gPSAwLCBzID0gW28ubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgby5jZW50ZXJKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIG8ucmlnaHRKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXhdOyBuIDwgcy5sZW5ndGg7IG4gKz0gMSkgZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldChzW25dKS5wbGFjZWRPcmllbnRhdGlvbiA9IHI7XG4gICAgICBvLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4ICYmIChlLnRleHQucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KG8udmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXgpLnBsYWNlZE9yaWVudGF0aW9uID0gYSk7XG4gICAgfSwgYmUucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNvbW1pdFRpbWUgPSB0LCB0aGlzLnpvb21BdExhc3RSZWNlbmN5Q2hlY2sgPSB0aGlzLnRyYW5zZm9ybS56b29tO1xuICAgICAgdmFyIGUgPSB0aGlzLnByZXZQbGFjZW1lbnQsXG4gICAgICAgIGkgPSAhMTtcbiAgICAgIHRoaXMucHJldlpvb21BZGp1c3RtZW50ID0gZSA/IGUuem9vbUFkanVzdG1lbnQodGhpcy50cmFuc2Zvcm0uem9vbSkgOiAwO1xuICAgICAgdmFyIG8gPSBlID8gZS5zeW1ib2xGYWRlQ2hhbmdlKHQpIDogMSxcbiAgICAgICAgciA9IGUgPyBlLm9wYWNpdGllcyA6IHt9LFxuICAgICAgICBhID0gZSA/IGUudmFyaWFibGVPZmZzZXRzIDoge30sXG4gICAgICAgIG4gPSBlID8gZS5wbGFjZWRPcmllbnRhdGlvbnMgOiB7fTtcbiAgICAgIGZvciAodmFyIHMgaW4gdGhpcy5wbGFjZW1lbnRzKSB7XG4gICAgICAgIHZhciBsID0gdGhpcy5wbGFjZW1lbnRzW3NdLFxuICAgICAgICAgIGMgPSByW3NdO1xuICAgICAgICBjID8gKHRoaXMub3BhY2l0aWVzW3NdID0gbmV3IF9lKGMsIG8sIGwudGV4dCwgbC5pY29uKSwgaSA9IGkgfHwgbC50ZXh0ICE9PSBjLnRleHQucGxhY2VkIHx8IGwuaWNvbiAhPT0gYy5pY29uLnBsYWNlZCkgOiAodGhpcy5vcGFjaXRpZXNbc10gPSBuZXcgX2UobnVsbCwgbywgbC50ZXh0LCBsLmljb24sIGwuc2tpcEZhZGUpLCBpID0gaSB8fCBsLnRleHQgfHwgbC5pY29uKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHUgaW4gcikge1xuICAgICAgICB2YXIgaCA9IHJbdV07XG4gICAgICAgIGlmICghdGhpcy5vcGFjaXRpZXNbdV0pIHtcbiAgICAgICAgICB2YXIgcCA9IG5ldyBfZShoLCBvLCAhMSwgITEpO1xuICAgICAgICAgIHAuaXNIaWRkZW4oKSB8fCAodGhpcy5vcGFjaXRpZXNbdV0gPSBwLCBpID0gaSB8fCBoLnRleHQucGxhY2VkIHx8IGguaWNvbi5wbGFjZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBkIGluIGEpIHRoaXMudmFyaWFibGVPZmZzZXRzW2RdIHx8ICF0aGlzLm9wYWNpdGllc1tkXSB8fCB0aGlzLm9wYWNpdGllc1tkXS5pc0hpZGRlbigpIHx8ICh0aGlzLnZhcmlhYmxlT2Zmc2V0c1tkXSA9IGFbZF0pO1xuICAgICAgZm9yICh2YXIgXyBpbiBuKSB0aGlzLnBsYWNlZE9yaWVudGF0aW9uc1tfXSB8fCAhdGhpcy5vcGFjaXRpZXNbX10gfHwgdGhpcy5vcGFjaXRpZXNbX10uaXNIaWRkZW4oKSB8fCAodGhpcy5wbGFjZWRPcmllbnRhdGlvbnNbX10gPSBuW19dKTtcbiAgICAgIGkgPyB0aGlzLmxhc3RQbGFjZW1lbnRDaGFuZ2VUaW1lID0gdCA6IFwibnVtYmVyXCIgIT0gdHlwZW9mIHRoaXMubGFzdFBsYWNlbWVudENoYW5nZVRpbWUgJiYgKHRoaXMubGFzdFBsYWNlbWVudENoYW5nZVRpbWUgPSBlID8gZS5sYXN0UGxhY2VtZW50Q2hhbmdlVGltZSA6IHQpO1xuICAgIH0sIGJlLnByb3RvdHlwZS51cGRhdGVMYXllck9wYWNpdGllcyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICBmb3IgKHZhciBpID0ge30sIG8gPSAwLCByID0gZTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIHtcbiAgICAgICAgdmFyIGEgPSByW29dLFxuICAgICAgICAgIG4gPSBhLmdldEJ1Y2tldCh0KTtcbiAgICAgICAgbiAmJiBhLmxhdGVzdEZlYXR1cmVJbmRleCAmJiB0LmlkID09PSBuLmxheWVySWRzWzBdICYmIHRoaXMudXBkYXRlQnVja2V0T3BhY2l0aWVzKG4sIGksIGEuY29sbGlzaW9uQm94QXJyYXkpO1xuICAgICAgfVxuICAgIH0sIGJlLnByb3RvdHlwZS51cGRhdGVCdWNrZXRPcGFjaXRpZXMgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgZS5oYXNUZXh0RGF0YSgpICYmIGUudGV4dC5vcGFjaXR5VmVydGV4QXJyYXkuY2xlYXIoKSwgZS5oYXNJY29uRGF0YSgpICYmIGUuaWNvbi5vcGFjaXR5VmVydGV4QXJyYXkuY2xlYXIoKSwgZS5oYXNJY29uQ29sbGlzaW9uQm94RGF0YSgpICYmIGUuaWNvbkNvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheS5jbGVhcigpLCBlLmhhc1RleHRDb2xsaXNpb25Cb3hEYXRhKCkgJiYgZS50ZXh0Q29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5LmNsZWFyKCk7XG4gICAgICB2YXIgYSA9IGUubGF5ZXJzWzBdLmxheW91dCxcbiAgICAgICAgbiA9IG5ldyBfZShudWxsLCAwLCAhMSwgITEsICEwKSxcbiAgICAgICAgcyA9IGEuZ2V0KFwidGV4dC1hbGxvdy1vdmVybGFwXCIpLFxuICAgICAgICBsID0gYS5nZXQoXCJpY29uLWFsbG93LW92ZXJsYXBcIiksXG4gICAgICAgIGMgPSBhLmdldChcInRleHQtdmFyaWFibGUtYW5jaG9yXCIpLFxuICAgICAgICB1ID0gXCJtYXBcIiA9PT0gYS5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSxcbiAgICAgICAgaCA9IFwibWFwXCIgPT09IGEuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksXG4gICAgICAgIHAgPSBcIm5vbmVcIiAhPT0gYS5nZXQoXCJpY29uLXRleHQtZml0XCIpLFxuICAgICAgICBkID0gbmV3IF9lKG51bGwsIDAsIHMgJiYgKGwgfHwgIWUuaGFzSWNvbkRhdGEoKSB8fCBhLmdldChcImljb24tb3B0aW9uYWxcIikpLCBsICYmIChzIHx8ICFlLmhhc1RleHREYXRhKCkgfHwgYS5nZXQoXCJ0ZXh0LW9wdGlvbmFsXCIpKSwgITApO1xuICAgICAgIWUuY29sbGlzaW9uQXJyYXlzICYmIG8gJiYgKGUuaGFzSWNvbkNvbGxpc2lvbkJveERhdGEoKSB8fCBlLmhhc1RleHRDb2xsaXNpb25Cb3hEYXRhKCkpICYmIGUuZGVzZXJpYWxpemVDb2xsaXNpb25Cb3hlcyhvKTtcbiAgICAgIGZvciAodmFyIF8gPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgZSAvIDQ7IG8rKykgdC5vcGFjaXR5VmVydGV4QXJyYXkuZW1wbGFjZUJhY2soaSk7XG4gICAgICAgIH0sIGYgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgIHZhciBhID0gZS5zeW1ib2xJbnN0YW5jZXMuZ2V0KG8pLFxuICAgICAgICAgICAgcyA9IGEubnVtSG9yaXpvbnRhbEdseXBoVmVydGljZXMsXG4gICAgICAgICAgICBsID0gYS5udW1WZXJ0aWNhbEdseXBoVmVydGljZXMsXG4gICAgICAgICAgICBmID0gYS5jcm9zc1RpbGVJRCxcbiAgICAgICAgICAgIG0gPSByLm9wYWNpdGllc1tmXTtcbiAgICAgICAgICBpW2ZdID8gbSA9IG4gOiBtIHx8IChyLm9wYWNpdGllc1tmXSA9IG0gPSBkKSwgaVtmXSA9ICEwO1xuICAgICAgICAgIHZhciBnID0gYS5udW1JY29uVmVydGljZXMgPiAwLFxuICAgICAgICAgICAgdiA9IHIucGxhY2VkT3JpZW50YXRpb25zW2EuY3Jvc3NUaWxlSURdLFxuICAgICAgICAgICAgeSA9IHYgPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwsXG4gICAgICAgICAgICB4ID0gdiA9PT0gdC5Xcml0aW5nTW9kZS5ob3Jpem9udGFsIHx8IHYgPT09IHQuV3JpdGluZ01vZGUuaG9yaXpvbnRhbE9ubHk7XG4gICAgICAgICAgaWYgKHMgPiAwIHx8IGwgPiAwKSB7XG4gICAgICAgICAgICB2YXIgYiA9IERlKG0udGV4dCk7XG4gICAgICAgICAgICBfKGUudGV4dCwgcywgeSA/IEFlIDogYiksIF8oZS50ZXh0LCBsLCB4ID8gQWUgOiBiKTtcbiAgICAgICAgICAgIHZhciB3ID0gbS50ZXh0LmlzSGlkZGVuKCk7XG4gICAgICAgICAgICBbYS5yaWdodEp1c3RpZmllZFRleHRTeW1ib2xJbmRleCwgYS5jZW50ZXJKdXN0aWZpZWRUZXh0U3ltYm9sSW5kZXgsIGEubGVmdEp1c3RpZmllZFRleHRTeW1ib2xJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICB0ID49IDAgJiYgKGUudGV4dC5wbGFjZWRTeW1ib2xBcnJheS5nZXQodCkuaGlkZGVuID0gdyB8fCB5ID8gMSA6IDApO1xuICAgICAgICAgICAgfSksIGEudmVydGljYWxQbGFjZWRUZXh0U3ltYm9sSW5kZXggPj0gMCAmJiAoZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LmdldChhLnZlcnRpY2FsUGxhY2VkVGV4dFN5bWJvbEluZGV4KS5oaWRkZW4gPSB3IHx8IHggPyAxIDogMCk7XG4gICAgICAgICAgICB2YXIgVCA9IHIudmFyaWFibGVPZmZzZXRzW2EuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgVCAmJiByLm1hcmtVc2VkSnVzdGlmaWNhdGlvbihlLCBULmFuY2hvciwgYSwgdik7XG4gICAgICAgICAgICB2YXIgRSA9IHIucGxhY2VkT3JpZW50YXRpb25zW2EuY3Jvc3NUaWxlSURdO1xuICAgICAgICAgICAgRSAmJiAoci5tYXJrVXNlZEp1c3RpZmljYXRpb24oZSwgXCJsZWZ0XCIsIGEsIEUpLCByLm1hcmtVc2VkT3JpZW50YXRpb24oZSwgRSwgYSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgdmFyIEkgPSBEZShtLmljb24pLFxuICAgICAgICAgICAgICBQID0gIShwICYmIGEudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXggJiYgeSk7XG4gICAgICAgICAgICBhLnBsYWNlZEljb25TeW1ib2xJbmRleCA+PSAwICYmIChfKGUuaWNvbiwgYS5udW1JY29uVmVydGljZXMsIFAgPyBJIDogQWUpLCBlLmljb24ucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGEucGxhY2VkSWNvblN5bWJvbEluZGV4KS5oaWRkZW4gPSBtLmljb24uaXNIaWRkZW4oKSksIGEudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXggPj0gMCAmJiAoXyhlLmljb24sIGEubnVtVmVydGljYWxJY29uVmVydGljZXMsIFAgPyBBZSA6IEkpLCBlLmljb24ucGxhY2VkU3ltYm9sQXJyYXkuZ2V0KGEudmVydGljYWxQbGFjZWRJY29uU3ltYm9sSW5kZXgpLmhpZGRlbiA9IG0uaWNvbi5pc0hpZGRlbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuaGFzSWNvbkNvbGxpc2lvbkJveERhdGEoKSB8fCBlLmhhc1RleHRDb2xsaXNpb25Cb3hEYXRhKCkpIHtcbiAgICAgICAgICAgIHZhciBTID0gZS5jb2xsaXNpb25BcnJheXNbb107XG4gICAgICAgICAgICBpZiAoUykge1xuICAgICAgICAgICAgICB2YXIgQyA9IG5ldyB0LlBvaW50KDAsIDApO1xuICAgICAgICAgICAgICBpZiAoUy50ZXh0Qm94IHx8IFMudmVydGljYWxUZXh0Qm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIHogPSAhMDtcbiAgICAgICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgICAgdmFyIEQgPSByLnZhcmlhYmxlT2Zmc2V0c1tmXTtcbiAgICAgICAgICAgICAgICAgIEQgPyAoQyA9IHllKEQuYW5jaG9yLCBELndpZHRoLCBELmhlaWdodCwgRC50ZXh0T2Zmc2V0LCBELnRleHRCb3hTY2FsZSksIHUgJiYgQy5fcm90YXRlKGggPyByLnRyYW5zZm9ybS5hbmdsZSA6IC1yLnRyYW5zZm9ybS5hbmdsZSkpIDogeiA9ICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBTLnRleHRCb3ggJiYgd2UoZS50ZXh0Q29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEFycmF5LCBtLnRleHQucGxhY2VkLCAheiB8fCB5LCBDLngsIEMueSksIFMudmVydGljYWxUZXh0Qm94ICYmIHdlKGUudGV4dENvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheSwgbS50ZXh0LnBsYWNlZCwgIXogfHwgeCwgQy54LCBDLnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBBID0gQm9vbGVhbigheCAmJiBTLnZlcnRpY2FsSWNvbkJveCk7XG4gICAgICAgICAgICAgIFMuaWNvbkJveCAmJiB3ZShlLmljb25Db2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXksIG0uaWNvbi5wbGFjZWQsIEEsIHAgPyBDLnggOiAwLCBwID8gQy55IDogMCksIFMudmVydGljYWxJY29uQm94ICYmIHdlKGUuaWNvbkNvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheSwgbS5pY29uLnBsYWNlZCwgIUEsIHAgPyBDLnggOiAwLCBwID8gQy55IDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBtID0gMDsgbSA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgbSsrKSBmKG0pO1xuICAgICAgaWYgKGUuc29ydEZlYXR1cmVzKHRoaXMudHJhbnNmb3JtLmFuZ2xlKSwgdGhpcy5yZXRhaW5lZFF1ZXJ5RGF0YVtlLmJ1Y2tldEluc3RhbmNlSWRdICYmICh0aGlzLnJldGFpbmVkUXVlcnlEYXRhW2UuYnVja2V0SW5zdGFuY2VJZF0uZmVhdHVyZVNvcnRPcmRlciA9IGUuZmVhdHVyZVNvcnRPcmRlciksIGUuaGFzVGV4dERhdGEoKSAmJiBlLnRleHQub3BhY2l0eVZlcnRleEJ1ZmZlciAmJiBlLnRleHQub3BhY2l0eVZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKGUudGV4dC5vcGFjaXR5VmVydGV4QXJyYXkpLCBlLmhhc0ljb25EYXRhKCkgJiYgZS5pY29uLm9wYWNpdHlWZXJ0ZXhCdWZmZXIgJiYgZS5pY29uLm9wYWNpdHlWZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YShlLmljb24ub3BhY2l0eVZlcnRleEFycmF5KSwgZS5oYXNJY29uQ29sbGlzaW9uQm94RGF0YSgpICYmIGUuaWNvbkNvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIgJiYgZS5pY29uQ29sbGlzaW9uQm94LmNvbGxpc2lvblZlcnRleEJ1ZmZlci51cGRhdGVEYXRhKGUuaWNvbkNvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhBcnJheSksIGUuaGFzVGV4dENvbGxpc2lvbkJveERhdGEoKSAmJiBlLnRleHRDb2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QnVmZmVyICYmIGUudGV4dENvbGxpc2lvbkJveC5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YShlLnRleHRDb2xsaXNpb25Cb3guY29sbGlzaW9uVmVydGV4QXJyYXkpLCBlLmJ1Y2tldEluc3RhbmNlSWQgaW4gdGhpcy5jb2xsaXNpb25DaXJjbGVBcnJheXMpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmNvbGxpc2lvbkNpcmNsZUFycmF5c1tlLmJ1Y2tldEluc3RhbmNlSWRdO1xuICAgICAgICBlLnBsYWNlbWVudEludlByb2pNYXRyaXggPSBnLmludlByb2pNYXRyaXgsIGUucGxhY2VtZW50Vmlld3BvcnRNYXRyaXggPSBnLnZpZXdwb3J0TWF0cml4LCBlLmNvbGxpc2lvbkNpcmNsZUFycmF5ID0gZy5jaXJjbGVzLCBkZWxldGUgdGhpcy5jb2xsaXNpb25DaXJjbGVBcnJheXNbZS5idWNrZXRJbnN0YW5jZUlkXTtcbiAgICAgIH1cbiAgICB9LCBiZS5wcm90b3R5cGUuc3ltYm9sRmFkZUNoYW5nZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gMCA9PT0gdGhpcy5mYWRlRHVyYXRpb24gPyAxIDogKHQgLSB0aGlzLmNvbW1pdFRpbWUpIC8gdGhpcy5mYWRlRHVyYXRpb24gKyB0aGlzLnByZXZab29tQWRqdXN0bWVudDtcbiAgICB9LCBiZS5wcm90b3R5cGUuem9vbUFkanVzdG1lbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsICh0aGlzLnRyYW5zZm9ybS56b29tIC0gdCkgLyAxLjUpO1xuICAgIH0sIGJlLnByb3RvdHlwZS5oYXNUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFsZSB8fCB0IC0gdGhpcy5sYXN0UGxhY2VtZW50Q2hhbmdlVGltZSA8IHRoaXMuZmFkZUR1cmF0aW9uO1xuICAgIH0sIGJlLnByb3RvdHlwZS5zdGlsbFJlY2VudCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuem9vbUF0TGFzdFJlY2VuY3lDaGVjayA9PT0gZSA/IDEgLSB0aGlzLnpvb21BZGp1c3RtZW50KGUpIDogMTtcbiAgICAgIHJldHVybiB0aGlzLnpvb21BdExhc3RSZWNlbmN5Q2hlY2sgPSBlLCB0aGlzLmNvbW1pdFRpbWUgKyB0aGlzLmZhZGVEdXJhdGlvbiAqIGkgPiB0O1xuICAgIH0sIGJlLnByb3RvdHlwZS5zZXRTdGFsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc3RhbGUgPSAhMDtcbiAgICB9O1xuICAgIHZhciBUZSA9IE1hdGgucG93KDIsIDI1KSxcbiAgICAgIEVlID0gTWF0aC5wb3coMiwgMjQpLFxuICAgICAgSWUgPSBNYXRoLnBvdygyLCAxNyksXG4gICAgICBQZSA9IE1hdGgucG93KDIsIDE2KSxcbiAgICAgIFNlID0gTWF0aC5wb3coMiwgOSksXG4gICAgICBDZSA9IE1hdGgucG93KDIsIDgpLFxuICAgICAgemUgPSBNYXRoLnBvdygyLCAxKTtcbiAgICBmdW5jdGlvbiBEZSh0KSB7XG4gICAgICBpZiAoMCA9PT0gdC5vcGFjaXR5ICYmICF0LnBsYWNlZCkgcmV0dXJuIDA7XG4gICAgICBpZiAoMSA9PT0gdC5vcGFjaXR5ICYmIHQucGxhY2VkKSByZXR1cm4gNDI5NDk2NzI5NTtcbiAgICAgIHZhciBlID0gdC5wbGFjZWQgPyAxIDogMCxcbiAgICAgICAgaSA9IE1hdGguZmxvb3IoMTI3ICogdC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBpICogVGUgKyBlICogRWUgKyBpICogSWUgKyBlICogUGUgKyBpICogU2UgKyBlICogQ2UgKyBpICogemUgKyBlO1xuICAgIH1cbiAgICB2YXIgQWUgPSAwLFxuICAgICAgTWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9zb3J0QWNyb3NzVGlsZXMgPSBcInZpZXdwb3J0LXlcIiAhPT0gdC5sYXlvdXQuZ2V0KFwic3ltYm9sLXotb3JkZXJcIikgJiYgIXQubGF5b3V0LmdldChcInN5bWJvbC1zb3J0LWtleVwiKS5pc0NvbnN0YW50KCksIHRoaXMuX2N1cnJlbnRUaWxlSW5kZXggPSAwLCB0aGlzLl9jdXJyZW50UGFydEluZGV4ID0gMCwgdGhpcy5fc2VlbkNyb3NzVGlsZUlEcyA9IHt9LCB0aGlzLl9idWNrZXRQYXJ0cyA9IFtdO1xuICAgICAgfTtcbiAgICBNZS5wcm90b3R5cGUuY29udGludWVQbGFjZW1lbnQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgZm9yICh2YXIgYSA9IHRoaXMuX2J1Y2tldFBhcnRzOyB0aGlzLl9jdXJyZW50VGlsZUluZGV4IDwgdC5sZW5ndGg7KSBpZiAoZS5nZXRCdWNrZXRQYXJ0cyhhLCBvLCB0W3RoaXMuX2N1cnJlbnRUaWxlSW5kZXhdLCB0aGlzLl9zb3J0QWNyb3NzVGlsZXMpLCB0aGlzLl9jdXJyZW50VGlsZUluZGV4KyssIHIoKSkgcmV0dXJuICEwO1xuICAgICAgZm9yICh0aGlzLl9zb3J0QWNyb3NzVGlsZXMgJiYgKHRoaXMuX3NvcnRBY3Jvc3NUaWxlcyA9ICExLCBhLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgcmV0dXJuIHQuc29ydEtleSAtIGUuc29ydEtleTtcbiAgICAgIH0pKTsgdGhpcy5fY3VycmVudFBhcnRJbmRleCA8IGEubGVuZ3RoOykgaWYgKGUucGxhY2VMYXllckJ1Y2tldFBhcnQoYVt0aGlzLl9jdXJyZW50UGFydEluZGV4XSwgdGhpcy5fc2VlbkNyb3NzVGlsZUlEcywgaSksIHRoaXMuX2N1cnJlbnRQYXJ0SW5kZXgrKywgcigpKSByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITE7XG4gICAgfTtcbiAgICB2YXIgTGUgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdGhpcy5wbGFjZW1lbnQgPSBuZXcgYmUodCwgciwgYSwgbiksIHRoaXMuX2N1cnJlbnRQbGFjZW1lbnRJbmRleCA9IGUubGVuZ3RoIC0gMSwgdGhpcy5fZm9yY2VGdWxsUGxhY2VtZW50ID0gaSwgdGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzID0gbywgdGhpcy5fZG9uZSA9ICExO1xuICAgIH07XG4gICAgTGUucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kb25lO1xuICAgIH0sIExlLnByb3RvdHlwZS5jb250aW51ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICBmb3IgKHZhciByID0gdGhpcywgYSA9IHQuYnJvd3Nlci5ub3coKSwgbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZSA9IHQuYnJvd3Nlci5ub3coKSAtIGE7XG4gICAgICAgICAgcmV0dXJuICFyLl9mb3JjZUZ1bGxQbGFjZW1lbnQgJiYgZSA+IDI7XG4gICAgICAgIH07IHRoaXMuX2N1cnJlbnRQbGFjZW1lbnRJbmRleCA+PSAwOykge1xuICAgICAgICB2YXIgcyA9IGlbZVt0aGlzLl9jdXJyZW50UGxhY2VtZW50SW5kZXhdXSxcbiAgICAgICAgICBsID0gdGhpcy5wbGFjZW1lbnQuY29sbGlzaW9uSW5kZXgudHJhbnNmb3JtLnpvb207XG4gICAgICAgIGlmIChcInN5bWJvbFwiID09PSBzLnR5cGUgJiYgKCFzLm1pbnpvb20gfHwgcy5taW56b29tIDw9IGwpICYmICghcy5tYXh6b29tIHx8IHMubWF4em9vbSA+IGwpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2luUHJvZ3Jlc3NMYXllciB8fCAodGhpcy5faW5Qcm9ncmVzc0xheWVyID0gbmV3IE1lKHMpKSwgdGhpcy5faW5Qcm9ncmVzc0xheWVyLmNvbnRpbnVlUGxhY2VtZW50KG9bcy5zb3VyY2VdLCB0aGlzLnBsYWNlbWVudCwgdGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzLCBzLCBuKSkgcmV0dXJuO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pblByb2dyZXNzTGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudFBsYWNlbWVudEluZGV4LS07XG4gICAgICB9XG4gICAgICB0aGlzLl9kb25lID0gITA7XG4gICAgfSwgTGUucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnQuY29tbWl0KHQpLCB0aGlzLnBsYWNlbWVudDtcbiAgICB9O1xuICAgIHZhciBSZSA9IDUxMiAvIHQuRVhURU5UIC8gMixcbiAgICAgIGtlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgdGhpcy50aWxlSUQgPSB0LCB0aGlzLmluZGV4ZWRTeW1ib2xJbnN0YW5jZXMgPSB7fSwgdGhpcy5idWNrZXRJbnN0YW5jZUlkID0gaTtcbiAgICAgICAgZm9yICh2YXIgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgdmFyIHIgPSBlLmdldChvKSxcbiAgICAgICAgICAgIGEgPSByLmtleTtcbiAgICAgICAgICB0aGlzLmluZGV4ZWRTeW1ib2xJbnN0YW5jZXNbYV0gfHwgKHRoaXMuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1thXSA9IFtdKSwgdGhpcy5pbmRleGVkU3ltYm9sSW5zdGFuY2VzW2FdLnB1c2goe1xuICAgICAgICAgICAgY3Jvc3NUaWxlSUQ6IHIuY3Jvc3NUaWxlSUQsXG4gICAgICAgICAgICBjb29yZDogdGhpcy5nZXRTY2FsZWRDb29yZGluYXRlcyhyLCB0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIGtlLnByb3RvdHlwZS5nZXRTY2FsZWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IFJlIC8gTWF0aC5wb3coMiwgaS5jYW5vbmljYWwueiAtIHRoaXMudGlsZUlELmNhbm9uaWNhbC56KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoKGkuY2Fub25pY2FsLnggKiB0LkVYVEVOVCArIGUuYW5jaG9yWCkgKiBvKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcigoaS5jYW5vbmljYWwueSAqIHQuRVhURU5UICsgZS5hbmNob3JZKSAqIG8pXG4gICAgICB9O1xuICAgIH0sIGtlLnByb3RvdHlwZS5maW5kTWF0Y2hlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gdGhpcy50aWxlSUQuY2Fub25pY2FsLnogPCBlLmNhbm9uaWNhbC56ID8gMSA6IE1hdGgucG93KDIsIHRoaXMudGlsZUlELmNhbm9uaWNhbC56IC0gZS5jYW5vbmljYWwueiksIHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgYSA9IHQuZ2V0KHIpO1xuICAgICAgICBpZiAoIWEuY3Jvc3NUaWxlSUQpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1thLmtleV07XG4gICAgICAgICAgaWYgKG4pIGZvciAodmFyIHMgPSB0aGlzLmdldFNjYWxlZENvb3JkaW5hdGVzKGEsIGUpLCBsID0gMCwgYyA9IG47IGwgPCBjLmxlbmd0aDsgbCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGNbbF07XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModS5jb29yZC54IC0gcy54KSA8PSBvICYmIE1hdGguYWJzKHUuY29vcmQueSAtIHMueSkgPD0gbyAmJiAhaVt1LmNyb3NzVGlsZUlEXSkge1xuICAgICAgICAgICAgICBpW3UuY3Jvc3NUaWxlSURdID0gITAsIGEuY3Jvc3NUaWxlSUQgPSB1LmNyb3NzVGlsZUlEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBCZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubWF4Q3Jvc3NUaWxlSUQgPSAwO1xuICAgIH07XG4gICAgQmUucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICsrdGhpcy5tYXhDcm9zc1RpbGVJRDtcbiAgICB9O1xuICAgIHZhciBPZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW5kZXhlcyA9IHt9LCB0aGlzLnVzZWRDcm9zc1RpbGVJRHMgPSB7fSwgdGhpcy5sbmcgPSAwO1xuICAgIH07XG4gICAgT2UucHJvdG90eXBlLmhhbmRsZVdyYXBKdW1wID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gTWF0aC5yb3VuZCgodCAtIHRoaXMubG5nKSAvIDM2MCk7XG4gICAgICBpZiAoMCAhPT0gZSkgZm9yICh2YXIgaSBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmluZGV4ZXNbaV0sXG4gICAgICAgICAgciA9IHt9O1xuICAgICAgICBmb3IgKHZhciBhIGluIG8pIHtcbiAgICAgICAgICB2YXIgbiA9IG9bYV07XG4gICAgICAgICAgbi50aWxlSUQgPSBuLnRpbGVJRC51bndyYXBUbyhuLnRpbGVJRC53cmFwICsgZSksIHJbbi50aWxlSUQua2V5XSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleGVzW2ldID0gcjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG5nID0gdDtcbiAgICB9LCBPZS5wcm90b3R5cGUuYWRkQnVja2V0ID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICh0aGlzLmluZGV4ZXNbdC5vdmVyc2NhbGVkWl0gJiYgdGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdW3Qua2V5XSkge1xuICAgICAgICBpZiAodGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdW3Qua2V5XS5idWNrZXRJbnN0YW5jZUlkID09PSBlLmJ1Y2tldEluc3RhbmNlSWQpIHJldHVybiAhMTtcbiAgICAgICAgdGhpcy5yZW1vdmVCdWNrZXRDcm9zc1RpbGVJRHModC5vdmVyc2NhbGVkWiwgdGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdW3Qua2V5XSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGUuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgbysrKSBlLnN5bWJvbEluc3RhbmNlcy5nZXQobykuY3Jvc3NUaWxlSUQgPSAwO1xuICAgICAgdGhpcy51c2VkQ3Jvc3NUaWxlSURzW3Qub3ZlcnNjYWxlZFpdIHx8ICh0aGlzLnVzZWRDcm9zc1RpbGVJRHNbdC5vdmVyc2NhbGVkWl0gPSB7fSk7XG4gICAgICB2YXIgciA9IHRoaXMudXNlZENyb3NzVGlsZUlEc1t0Lm92ZXJzY2FsZWRaXTtcbiAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5pbmRleGVzW2FdO1xuICAgICAgICBpZiAoTnVtYmVyKGEpID4gdC5vdmVyc2NhbGVkWikgZm9yICh2YXIgcyBpbiBuKSB7XG4gICAgICAgICAgdmFyIGwgPSBuW3NdO1xuICAgICAgICAgIGwudGlsZUlELmlzQ2hpbGRPZih0KSAmJiBsLmZpbmRNYXRjaGVzKGUuc3ltYm9sSW5zdGFuY2VzLCB0LCByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYyA9IG5bdC5zY2FsZWRUbyhOdW1iZXIoYSkpLmtleV07XG4gICAgICAgICAgYyAmJiBjLmZpbmRNYXRjaGVzKGUuc3ltYm9sSW5zdGFuY2VzLCB0LCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBlLnN5bWJvbEluc3RhbmNlcy5sZW5ndGg7IHUrKykge1xuICAgICAgICB2YXIgaCA9IGUuc3ltYm9sSW5zdGFuY2VzLmdldCh1KTtcbiAgICAgICAgaC5jcm9zc1RpbGVJRCB8fCAoaC5jcm9zc1RpbGVJRCA9IGkuZ2VuZXJhdGUoKSwgcltoLmNyb3NzVGlsZUlEXSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgPT09IHRoaXMuaW5kZXhlc1t0Lm92ZXJzY2FsZWRaXSAmJiAodGhpcy5pbmRleGVzW3Qub3ZlcnNjYWxlZFpdID0ge30pLCB0aGlzLmluZGV4ZXNbdC5vdmVyc2NhbGVkWl1bdC5rZXldID0gbmV3IGtlKHQsIGUuc3ltYm9sSW5zdGFuY2VzLCBlLmJ1Y2tldEluc3RhbmNlSWQpLCAhMDtcbiAgICB9LCBPZS5wcm90b3R5cGUucmVtb3ZlQnVja2V0Q3Jvc3NUaWxlSURzID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gZS5pbmRleGVkU3ltYm9sSW5zdGFuY2VzKSBmb3IgKHZhciBvID0gMCwgciA9IGUuaW5kZXhlZFN5bWJvbEluc3RhbmNlc1tpXTsgbyA8IHIubGVuZ3RoOyBvICs9IDEpIGRlbGV0ZSB0aGlzLnVzZWRDcm9zc1RpbGVJRHNbdF1bcltvXS5jcm9zc1RpbGVJRF07XG4gICAgfSwgT2UucHJvdG90eXBlLnJlbW92ZVN0YWxlQnVja2V0cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICExO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLmluZGV4ZXNbaV07XG4gICAgICAgIGZvciAodmFyIHIgaW4gbykgdFtvW3JdLmJ1Y2tldEluc3RhbmNlSWRdIHx8ICh0aGlzLnJlbW92ZUJ1Y2tldENyb3NzVGlsZUlEcyhpLCBvW3JdKSwgZGVsZXRlIG9bcl0sIGUgPSAhMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHZhciBGZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGF5ZXJJbmRleGVzID0ge30sIHRoaXMuY3Jvc3NUaWxlSURzID0gbmV3IEJlKCksIHRoaXMubWF4QnVja2V0SW5zdGFuY2VJZCA9IDAsIHRoaXMuYnVja2V0c0luQ3VycmVudFBsYWNlbWVudCA9IHt9O1xuICAgIH07XG4gICAgRmUucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcy5sYXllckluZGV4ZXNbdC5pZF07XG4gICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB0aGlzLmxheWVySW5kZXhlc1t0LmlkXSA9IG5ldyBPZSgpKTtcbiAgICAgIHZhciByID0gITEsXG4gICAgICAgIGEgPSB7fTtcbiAgICAgIG8uaGFuZGxlV3JhcEp1bXAoaSk7XG4gICAgICBmb3IgKHZhciBuID0gMCwgcyA9IGU7IG4gPCBzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgICAgIHZhciBsID0gc1tuXSxcbiAgICAgICAgICBjID0gbC5nZXRCdWNrZXQodCk7XG4gICAgICAgIGMgJiYgdC5pZCA9PT0gYy5sYXllcklkc1swXSAmJiAoYy5idWNrZXRJbnN0YW5jZUlkIHx8IChjLmJ1Y2tldEluc3RhbmNlSWQgPSArK3RoaXMubWF4QnVja2V0SW5zdGFuY2VJZCksIG8uYWRkQnVja2V0KGwudGlsZUlELCBjLCB0aGlzLmNyb3NzVGlsZUlEcykgJiYgKHIgPSAhMCksIGFbYy5idWNrZXRJbnN0YW5jZUlkXSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvLnJlbW92ZVN0YWxlQnVja2V0cyhhKSAmJiAociA9ICEwKSwgcjtcbiAgICB9LCBGZS5wcm90b3R5cGUucHJ1bmVVbnVzZWRMYXllcnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGVbdF0gPSAhMDtcbiAgICAgIH0pLCB0aGlzLmxheWVySW5kZXhlcykgZVtpXSB8fCBkZWxldGUgdGhpcy5sYXllckluZGV4ZXNbaV07XG4gICAgfTtcbiAgICB2YXIgVWUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICByZXR1cm4gdC5lbWl0VmFsaWRhdGlvbkVycm9ycyhlLCBpICYmIGkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwic291cmNlLmNhbnZhc1wiICE9PSB0LmlkZW50aWZpZXI7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBOZSA9IHQucGljayhadCwgW1wiYWRkTGF5ZXJcIiwgXCJyZW1vdmVMYXllclwiLCBcInNldFBhaW50UHJvcGVydHlcIiwgXCJzZXRMYXlvdXRQcm9wZXJ0eVwiLCBcInNldEZpbHRlclwiLCBcImFkZFNvdXJjZVwiLCBcInJlbW92ZVNvdXJjZVwiLCBcInNldExheWVyWm9vbVJhbmdlXCIsIFwic2V0TGlnaHRcIiwgXCJzZXRUcmFuc2l0aW9uXCIsIFwic2V0R2VvSlNPTlNvdXJjZURhdGFcIl0pLFxuICAgICAgWmUgPSB0LnBpY2soWnQsIFtcInNldENlbnRlclwiLCBcInNldFpvb21cIiwgXCJzZXRCZWFyaW5nXCIsIFwic2V0UGl0Y2hcIl0pLFxuICAgICAgcWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0ge30sXG4gICAgICAgICAgaSA9IHQuc3R5bGVTcGVjLiR2ZXJzaW9uO1xuICAgICAgICBmb3IgKHZhciBvIGluIHQuc3R5bGVTcGVjLiRyb290KSB7XG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICBhID0gdC5zdHlsZVNwZWMuJHJvb3Rbb107XG4gICAgICAgICAgaWYgKGEucmVxdWlyZWQpIG51bGwgIT0gKHIgPSBcInZlcnNpb25cIiA9PT0gbyA/IGkgOiBcImFycmF5XCIgPT09IGEudHlwZSA/IFtdIDoge30pICYmIChlW29dID0gcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KCksXG4gICAgICBqZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkobywgcikge1xuICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIGUuY2FsbCh0aGlzKSwgdGhpcy5tYXAgPSBvLCB0aGlzLmRpc3BhdGNoZXIgPSBuZXcgRShGdCgpLCB0aGlzKSwgdGhpcy5pbWFnZU1hbmFnZXIgPSBuZXcgcCgpLCB0aGlzLmltYWdlTWFuYWdlci5zZXRFdmVudGVkUGFyZW50KHRoaXMpLCB0aGlzLmdseXBoTWFuYWdlciA9IG5ldyB5KG8uX3JlcXVlc3RNYW5hZ2VyLCByLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSksIHRoaXMubGluZUF0bGFzID0gbmV3IFQoMjU2LCA1MTIpLCB0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4ID0gbmV3IEZlKCksIHRoaXMuX2xheWVycyA9IHt9LCB0aGlzLl9zZXJpYWxpemVkTGF5ZXJzID0ge30sIHRoaXMuX29yZGVyID0gW10sIHRoaXMuc291cmNlQ2FjaGVzID0ge30sIHRoaXMuem9vbUhpc3RvcnkgPSBuZXcgdC5ab29tSGlzdG9yeSgpLCB0aGlzLl9sb2FkZWQgPSAhMSwgdGhpcy5fYXZhaWxhYmxlSW1hZ2VzID0gW10sIHRoaXMuX3Jlc2V0VXBkYXRlcygpLCB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0UmVmZXJyZXJcIiwgdC5nZXRSZWZlcnJlcigpKTtcbiAgICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fcnRsVGV4dFBsdWdpbkNhbGxiYWNrID0gaS5yZWdpc3RlckZvclBsdWdpblN0YXRlQ2hhbmdlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBuLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic3luY1JUTFBsdWdpblN0YXRlXCIsIHtcbiAgICAgICAgICAgICAgcGx1Z2luU3RhdHVzOiBlLnBsdWdpblN0YXR1cyxcbiAgICAgICAgICAgICAgcGx1Z2luVVJMOiBlLnBsdWdpblVSTFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgICAgaWYgKHQudHJpZ2dlclBsdWdpbkNvbXBsZXRpb25FdmVudChlKSwgaSAmJiBpLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIH0pKSBmb3IgKHZhciBvIGluIG4uc291cmNlQ2FjaGVzKSBuLnNvdXJjZUNhY2hlc1tvXS5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCB0aGlzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaWYgKFwic291cmNlXCIgPT09IHQuZGF0YVR5cGUgJiYgXCJtZXRhZGF0YVwiID09PSB0LnNvdXJjZURhdGFUeXBlKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gYS5zb3VyY2VDYWNoZXNbdC5zb3VyY2VJZF07XG4gICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpICYmIGkudmVjdG9yTGF5ZXJJZHMpIGZvciAodmFyIG8gaW4gYS5fbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IGEuX2xheWVyc1tvXTtcbiAgICAgICAgICAgICAgICAgIHIuc291cmNlID09PSBpLmlkICYmIGEuX3ZhbGlkYXRlTGF5ZXIocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUubG9hZFVSTCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YWxvYWRpbmdcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgciA9IFwiYm9vbGVhblwiID09IHR5cGVvZiBpLnZhbGlkYXRlID8gaS52YWxpZGF0ZSA6ICF0LmlzTWFwYm94VVJMKGUpO1xuICAgICAgICAgIGUgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplU3R5bGVVUkwoZSwgaS5hY2Nlc3NUb2tlbik7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLm1hcC5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChlLCB0LlJlc291cmNlVHlwZS5TdHlsZSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHQuZ2V0SlNPTihhLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgby5fcmVxdWVzdCA9IG51bGwsIGUgPyBvLmZpcmUobmV3IHQuRXJyb3JFdmVudChlKSkgOiBpICYmIG8uX2xvYWQoaSwgcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmxvYWRKU09OID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgICAgdm9pZCAwID09PSBpICYmIChpID0ge30pLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkYXRhbG9hZGluZ1wiLCB7XG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzdHlsZVwiXG4gICAgICAgICAgfSkpLCB0aGlzLl9yZXF1ZXN0ID0gdC5icm93c2VyLmZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG8uX3JlcXVlc3QgPSBudWxsLCBvLl9sb2FkKGUsICExICE9PSBpLnZhbGlkYXRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUubG9hZEVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFsb2FkaW5nXCIsIHtcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInN0eWxlXCJcbiAgICAgICAgICB9KSksIHRoaXMuX2xvYWQocWUsICExKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGlmICghaSB8fCAhVWUodGhpcywgdC52YWxpZGF0ZVN0eWxlKGUpKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbyBpbiB0aGlzLl9sb2FkZWQgPSAhMCwgdGhpcy5zdHlsZXNoZWV0ID0gZSwgZS5zb3VyY2VzKSB0aGlzLmFkZFNvdXJjZShvLCBlLnNvdXJjZXNbb10sIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGU6ICExXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUuc3ByaXRlID8gdGhpcy5fbG9hZFNwcml0ZShlLnNwcml0ZSkgOiB0aGlzLmltYWdlTWFuYWdlci5zZXRMb2FkZWQoITApLCB0aGlzLmdseXBoTWFuYWdlci5zZXRVUkwoZS5nbHlwaHMpO1xuICAgICAgICAgICAgdmFyIHIgPSBOdCh0aGlzLnN0eWxlc2hlZXQubGF5ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyID0gci5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQuaWQ7XG4gICAgICAgICAgICB9KSwgdGhpcy5fbGF5ZXJzID0ge30sIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gcjsgYSA8IG4ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSBuW2FdO1xuICAgICAgICAgICAgICAocyA9IHQuY3JlYXRlU3R5bGVMYXllcihzKSkuc2V0RXZlbnRlZFBhcmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBzLmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgdGhpcy5fbGF5ZXJzW3MuaWRdID0gcywgdGhpcy5fc2VyaWFsaXplZExheWVyc1tzLmlkXSA9IHMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0TGF5ZXJzXCIsIHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0aGlzLl9vcmRlcikpLCB0aGlzLmxpZ2h0ID0gbmV3IHcodGhpcy5zdHlsZXNoZWV0LmxpZ2h0KSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInN0eWxlXCJcbiAgICAgICAgICAgIH0pKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwic3R5bGUubG9hZFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5fbG9hZFNwcml0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX3Nwcml0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgIHMgPSB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgPyBcIkAyeFwiIDogXCJcIixcbiAgICAgICAgICAgICAgbCA9IHQuZ2V0SlNPTihpLnRyYW5zZm9ybVJlcXVlc3QoaS5ub3JtYWxpemVTcHJpdGVVUkwoZSwgcywgXCIuanNvblwiKSwgdC5SZXNvdXJjZVR5cGUuU3ByaXRlSlNPTiksIGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgICAgbCA9IG51bGwsIG4gfHwgKG4gPSB0LCByID0gZSwgdSgpKTtcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGMgPSB0LmdldEltYWdlKGkudHJhbnNmb3JtUmVxdWVzdChpLm5vcm1hbGl6ZVNwcml0ZVVSTChlLCBzLCBcIi5wbmdcIiksIHQuUmVzb3VyY2VUeXBlLlNwcml0ZUltYWdlKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICBjID0gbnVsbCwgbiB8fCAobiA9IHQsIGEgPSBlLCB1KCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgICAgIGlmIChuKSBvKG4pO2Vsc2UgaWYgKHIgJiYgYSkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdC5icm93c2VyLmdldEltYWdlRGF0YShhKSxcbiAgICAgICAgICAgICAgICAgIGkgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIHIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsID0gcltzXSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IGwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHUgPSBsLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaCA9IGwueCxcbiAgICAgICAgICAgICAgICAgICAgcCA9IGwueSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGwuc2RmLFxuICAgICAgICAgICAgICAgICAgICBfID0gbC5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgICAgICBmID0gbC5zdHJldGNoWCxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGwuc3RyZXRjaFksXG4gICAgICAgICAgICAgICAgICAgIGcgPSBsLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHYgPSBuZXcgdC5SR0JBSW1hZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjLFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHQuUkdCQUltYWdlLmNvcHkoZSwgdiwge1xuICAgICAgICAgICAgICAgICAgICB4OiBoLFxuICAgICAgICAgICAgICAgICAgICB5OiBwXG4gICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGMsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdVxuICAgICAgICAgICAgICAgICAgfSksIGlbc10gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHYsXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IF8sXG4gICAgICAgICAgICAgICAgICAgIHNkZjogZCxcbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaFg6IGYsXG4gICAgICAgICAgICAgICAgICAgIHN0cmV0Y2hZOiBtLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBnXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvKG51bGwsIGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsICYmIChsLmNhbmNlbCgpLCBsID0gbnVsbCksIGMgJiYgKGMuY2FuY2VsKCksIGMgPSBudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KGUsIHRoaXMubWFwLl9yZXF1ZXN0TWFuYWdlciwgZnVuY3Rpb24gKGUsIG8pIHtcbiAgICAgICAgICAgIGlmIChpLl9zcHJpdGVSZXF1ZXN0ID0gbnVsbCwgZSkgaS5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpO2Vsc2UgaWYgKG8pIGZvciAodmFyIHIgaW4gbykgaS5pbWFnZU1hbmFnZXIuYWRkSW1hZ2Uociwgb1tyXSk7XG4gICAgICAgICAgICBpLmltYWdlTWFuYWdlci5zZXRMb2FkZWQoITApLCBpLl9hdmFpbGFibGVJbWFnZXMgPSBpLmltYWdlTWFuYWdlci5saXN0SW1hZ2VzKCksIGkuZGlzcGF0Y2hlci5icm9hZGNhc3QoXCJzZXRJbWFnZXNcIiwgaS5fYXZhaWxhYmxlSW1hZ2VzKSwgaS5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInN0eWxlXCJcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5zb3VyY2VDYWNoZXNbZS5zb3VyY2VdO1xuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGUuc291cmNlTGF5ZXI7XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICB2YXIgciA9IGkuZ2V0U291cmNlKCk7XG4gICAgICAgICAgICAgIChcImdlb2pzb25cIiA9PT0gci50eXBlIHx8IHIudmVjdG9yTGF5ZXJJZHMgJiYgLTEgPT09IHIudmVjdG9yTGF5ZXJJZHMuaW5kZXhPZihvKSkgJiYgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdTb3VyY2UgbGF5ZXIgXCInICsgbyArICdcIiBkb2VzIG5vdCBleGlzdCBvbiBzb3VyY2UgXCInICsgci5pZCArICdcIiBhcyBzcGVjaWZpZWQgYnkgc3R5bGUgbGF5ZXIgXCInICsgZS5pZCArICdcIicpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybiAhMTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fdXBkYXRlZFNvdXJjZXMpLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIGlmICghdGhpcy5zb3VyY2VDYWNoZXNbdF0ubG9hZGVkKCkpIHJldHVybiAhMTtcbiAgICAgICAgICByZXR1cm4gISF0aGlzLmltYWdlTWFuYWdlci5pc0xvYWRlZCgpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fc2VyaWFsaXplTGF5ZXJzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlID0gW10sIGkgPSAwLCBvID0gdDsgaSA8IG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5fbGF5ZXJzW29baV1dO1xuICAgICAgICAgICAgXCJjdXN0b21cIiAhPT0gci50eXBlICYmIGUucHVzaChyLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmhhc1RyYW5zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLmxpZ2h0ICYmIHRoaXMubGlnaHQuaGFzVHJhbnNpdGlvbigpKSByZXR1cm4gITA7XG4gICAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnNvdXJjZUNhY2hlcykgaWYgKHRoaXMuc291cmNlQ2FjaGVzW3RdLmhhc1RyYW5zaXRpb24oKSkgcmV0dXJuICEwO1xuICAgICAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5fbGF5ZXJzKSBpZiAodGhpcy5fbGF5ZXJzW2VdLmhhc1RyYW5zaXRpb24oKSkgcmV0dXJuICEwO1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX2NoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZSBpcyBub3QgZG9uZSBsb2FkaW5nXCIpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fY2hhbmdlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gT2JqZWN0LmtleXModGhpcy5fdXBkYXRlZExheWVycyksXG4gICAgICAgICAgICAgICAgciA9IE9iamVjdC5rZXlzKHRoaXMuX3JlbW92ZWRMYXllcnMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIChvLmxlbmd0aCB8fCByLmxlbmd0aCkgJiYgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKG8sIHIpLCB0aGlzLl91cGRhdGVkU291cmNlcykge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5fdXBkYXRlZFNvdXJjZXNbYV07XG4gICAgICAgICAgICAgICAgXCJyZWxvYWRcIiA9PT0gbiA/IHRoaXMuX3JlbG9hZFNvdXJjZShhKSA6IFwiY2xlYXJcIiA9PT0gbiAmJiB0aGlzLl9jbGVhclNvdXJjZShhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuX3VwZGF0ZVRpbGVzRm9yQ2hhbmdlZEltYWdlcygpLCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wcykgdGhpcy5fbGF5ZXJzW3NdLnVwZGF0ZVRyYW5zaXRpb25zKGUpO1xuICAgICAgICAgICAgICB0aGlzLmxpZ2h0LnVwZGF0ZVRyYW5zaXRpb25zKGUpLCB0aGlzLl9yZXNldFVwZGF0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBjIGluIHRoaXMuc291cmNlQ2FjaGVzKSB7XG4gICAgICAgICAgICAgIHZhciB1ID0gdGhpcy5zb3VyY2VDYWNoZXNbY107XG4gICAgICAgICAgICAgIGxbY10gPSB1LnVzZWQsIHUudXNlZCA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaCA9IDAsIHAgPSB0aGlzLl9vcmRlcjsgaCA8IHAubGVuZ3RoOyBoICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLl9sYXllcnNbcFtoXV07XG4gICAgICAgICAgICAgIGQucmVjYWxjdWxhdGUoZSwgdGhpcy5fYXZhaWxhYmxlSW1hZ2VzKSwgIWQuaXNIaWRkZW4oZS56b29tKSAmJiBkLnNvdXJjZSAmJiAodGhpcy5zb3VyY2VDYWNoZXNbZC5zb3VyY2VdLnVzZWQgPSAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfIGluIGwpIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLnNvdXJjZUNhY2hlc1tfXTtcbiAgICAgICAgICAgICAgbFtfXSAhPT0gZi51c2VkICYmIGYuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZURhdGFUeXBlOiBcInZpc2liaWxpdHlcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogX1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpZ2h0LnJlY2FsY3VsYXRlKGUpLCB0aGlzLnogPSBlLnpvb20sIGkgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZGF0YVwiLCB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlOiBcInN0eWxlXCJcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVUaWxlc0ZvckNoYW5nZWRJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VkSW1hZ2VzKTtcbiAgICAgICAgICBpZiAodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIHRoaXMuc291cmNlQ2FjaGVzW2VdLnJlbG9hZFRpbGVzRm9yRGVwZW5kZW5jaWVzKFtcImljb25zXCIsIFwicGF0dGVybnNcIl0sIHQpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZEltYWdlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVdvcmtlckxheWVycyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChcInVwZGF0ZUxheWVyc1wiLCB7XG4gICAgICAgICAgICBsYXllcnM6IHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0KSxcbiAgICAgICAgICAgIHJlbW92ZWRJZHM6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3Jlc2V0VXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkID0gITEsIHRoaXMuX3VwZGF0ZWRMYXllcnMgPSB7fSwgdGhpcy5fcmVtb3ZlZExheWVycyA9IHt9LCB0aGlzLl91cGRhdGVkU291cmNlcyA9IHt9LCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wcyA9IHt9LCB0aGlzLl9jaGFuZ2VkSW1hZ2VzID0ge307XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoZWNrTG9hZGVkKCksIFVlKHRoaXMsIHQudmFsaWRhdGVTdHlsZShlKSkpIHJldHVybiAhMTtcbiAgICAgICAgICAoZSA9IHQuY2xvbmUkMShlKSkubGF5ZXJzID0gTnQoZS5sYXllcnMpO1xuICAgICAgICAgIHZhciBvID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIGlmICghZSkgcmV0dXJuIFt7XG4gICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldFN0eWxlLFxuICAgICAgICAgICAgICBhcmdzOiBbaV1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgdmFyIG8gPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghdC5kZWVwRXF1YWwoZS52ZXJzaW9uLCBpLnZlcnNpb24pKSByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTdHlsZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbaV1cbiAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgIHQuZGVlcEVxdWFsKGUuY2VudGVyLCBpLmNlbnRlcikgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRDZW50ZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW2kuY2VudGVyXVxuICAgICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS56b29tLCBpLnpvb20pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0Wm9vbSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbaS56b29tXVxuICAgICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5iZWFyaW5nLCBpLmJlYXJpbmcpIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0QmVhcmluZyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbaS5iZWFyaW5nXVxuICAgICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5waXRjaCwgaS5waXRjaCkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRQaXRjaCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbaS5waXRjaF1cbiAgICAgICAgICAgICAgfSksIHQuZGVlcEVxdWFsKGUuc3ByaXRlLCBpLnNwcml0ZSkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRTcHJpdGUsXG4gICAgICAgICAgICAgICAgYXJnczogW2kuc3ByaXRlXVxuICAgICAgICAgICAgICB9KSwgdC5kZWVwRXF1YWwoZS5nbHlwaHMsIGkuZ2x5cGhzKSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldEdseXBocyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbaS5nbHlwaHNdXG4gICAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChlLnRyYW5zaXRpb24sIGkudHJhbnNpdGlvbikgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtpLnRyYW5zaXRpb25dXG4gICAgICAgICAgICAgIH0pLCB0LmRlZXBFcXVhbChlLmxpZ2h0LCBpLmxpZ2h0KSB8fCBvLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldExpZ2h0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtpLmxpZ2h0XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIHIgPSB7fSxcbiAgICAgICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICAgICFmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGZvciAoYSBpbiBpID0gaSB8fCB7fSwgZSA9IGUgfHwge30pIGUuaGFzT3duUHJvcGVydHkoYSkgJiYgKGkuaGFzT3duUHJvcGVydHkoYSkgfHwganQoYSwgbywgcikpO1xuICAgICAgICAgICAgICAgIGZvciAoYSBpbiBpKSBpLmhhc093blByb3BlcnR5KGEpICYmIChlLmhhc093blByb3BlcnR5KGEpID8gdC5kZWVwRXF1YWwoZVthXSwgaVthXSkgfHwgKFwiZ2VvanNvblwiID09PSBlW2FdLnR5cGUgJiYgXCJnZW9qc29uXCIgPT09IGlbYV0udHlwZSAmJiBHdChlLCBpLCBhKSA/IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5zZXRHZW9KU09OU291cmNlRGF0YSxcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFthLCBpW2FdLmRhdGFdXG4gICAgICAgICAgICAgICAgfSkgOiBWdChhLCBpLCBvLCByKSkgOiBxdChhLCBpLCBvKSk7XG4gICAgICAgICAgICAgIH0oZS5zb3VyY2VzLCBpLnNvdXJjZXMsIGEsIHIpO1xuICAgICAgICAgICAgICB2YXIgbiA9IFtdO1xuICAgICAgICAgICAgICBlLmxheWVycyAmJiBlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgclt0LnNvdXJjZV0gPyBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbdC5pZF1cbiAgICAgICAgICAgICAgICB9KSA6IG4ucHVzaCh0KTtcbiAgICAgICAgICAgICAgfSksIG8gPSBvLmNvbmNhdChhKSwgZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICAgICAgICBpID0gaSB8fCBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcixcbiAgICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgdSxcbiAgICAgICAgICAgICAgICAgIGggPSAoZSA9IGUgfHwgW10pLm1hcChYdCksXG4gICAgICAgICAgICAgICAgICBwID0gaS5tYXAoWHQpLFxuICAgICAgICAgICAgICAgICAgZCA9IGUucmVkdWNlKEh0LCB7fSksXG4gICAgICAgICAgICAgICAgICBfID0gaS5yZWR1Y2UoSHQsIHt9KSxcbiAgICAgICAgICAgICAgICAgIGYgPSBoLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICBtID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBhID0gMDsgciA8IGgubGVuZ3RoOyByKyspIF8uaGFzT3duUHJvcGVydHkobiA9IGhbcl0pID8gYSsrIDogKG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuXVxuICAgICAgICAgICAgICAgIH0pLCBmLnNwbGljZShmLmluZGV4T2YobiwgYSksIDEpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBhID0gMDsgciA8IHAubGVuZ3RoOyByKyspIGZbZi5sZW5ndGggLSAxIC0gcl0gIT09IChuID0gcFtwLmxlbmd0aCAtIDEgLSByXSkgJiYgKGQuaGFzT3duUHJvcGVydHkobikgPyAoby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnJlbW92ZUxheWVyLFxuICAgICAgICAgICAgICAgICAgYXJnczogW25dXG4gICAgICAgICAgICAgICAgfSksIGYuc3BsaWNlKGYubGFzdEluZGV4T2YobiwgZi5sZW5ndGggLSBhKSwgMSkpIDogYSsrLCBvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuYWRkTGF5ZXIsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBbX1tuXSwgYyA9IGZbZi5sZW5ndGggLSByXV1cbiAgICAgICAgICAgICAgICB9KSwgZi5zcGxpY2UoZi5sZW5ndGggLSByLCAwLCBuKSwgbVtuXSA9ICEwKTtcbiAgICAgICAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgcC5sZW5ndGg7IHIrKykgaWYgKHMgPSBkW24gPSBwW3JdXSwgbCA9IF9bbl0sICFtW25dICYmICF0LmRlZXBFcXVhbChzLCBsKSkgaWYgKHQuZGVlcEVxdWFsKHMuc291cmNlLCBsLnNvdXJjZSkgJiYgdC5kZWVwRXF1YWwoc1tcInNvdXJjZS1sYXllclwiXSwgbFtcInNvdXJjZS1sYXllclwiXSkgJiYgdC5kZWVwRXF1YWwocy50eXBlLCBsLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHUgaW4gV3Qocy5sYXlvdXQsIGwubGF5b3V0LCBvLCBuLCBudWxsLCBadC5zZXRMYXlvdXRQcm9wZXJ0eSksIFd0KHMucGFpbnQsIGwucGFpbnQsIG8sIG4sIG51bGwsIFp0LnNldFBhaW50UHJvcGVydHkpLCB0LmRlZXBFcXVhbChzLmZpbHRlciwgbC5maWx0ZXIpIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldEZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW24sIGwuZmlsdGVyXVxuICAgICAgICAgICAgICAgICAgfSksIHQuZGVlcEVxdWFsKHMubWluem9vbSwgbC5taW56b29tKSAmJiB0LmRlZXBFcXVhbChzLm1heHpvb20sIGwubWF4em9vbSkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0TGF5ZXJab29tUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuLCBsLm1pbnpvb20sIGwubWF4em9vbV1cbiAgICAgICAgICAgICAgICAgIH0pLCBzKSBzLmhhc093blByb3BlcnR5KHUpICYmIFwibGF5b3V0XCIgIT09IHUgJiYgXCJwYWludFwiICE9PSB1ICYmIFwiZmlsdGVyXCIgIT09IHUgJiYgXCJtZXRhZGF0YVwiICE9PSB1ICYmIFwibWluem9vbVwiICE9PSB1ICYmIFwibWF4em9vbVwiICE9PSB1ICYmICgwID09PSB1LmluZGV4T2YoXCJwYWludC5cIikgPyBXdChzW3VdLCBsW3VdLCBvLCBuLCB1LnNsaWNlKDYpLCBadC5zZXRQYWludFByb3BlcnR5KSA6IHQuZGVlcEVxdWFsKHNbdV0sIGxbdV0pIHx8IG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldExheWVyUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuLCB1LCBsW3VdXVxuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgZm9yICh1IGluIGwpIGwuaGFzT3duUHJvcGVydHkodSkgJiYgIXMuaGFzT3duUHJvcGVydHkodSkgJiYgXCJsYXlvdXRcIiAhPT0gdSAmJiBcInBhaW50XCIgIT09IHUgJiYgXCJmaWx0ZXJcIiAhPT0gdSAmJiBcIm1ldGFkYXRhXCIgIT09IHUgJiYgXCJtaW56b29tXCIgIT09IHUgJiYgXCJtYXh6b29tXCIgIT09IHUgJiYgKDAgPT09IHUuaW5kZXhPZihcInBhaW50LlwiKSA/IFd0KHNbdV0sIGxbdV0sIG8sIG4sIHUuc2xpY2UoNiksIFp0LnNldFBhaW50UHJvcGVydHkpIDogdC5kZWVwRXF1YWwoc1t1XSwgbFt1XSkgfHwgby5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogWnQuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW24sIHUsIGxbdV1dXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5yZW1vdmVMYXllcixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFtuXVxuICAgICAgICAgICAgICAgIH0pLCBjID0gZltmLmxhc3RJbmRleE9mKG4pICsgMV0sIG8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiBadC5hZGRMYXllcixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsLCBjXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KG4sIGkubGF5ZXJzLCBvKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNvbXB1dGUgc3R5bGUgZGlmZjpcIiwgdCksIG8gPSBbe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFp0LnNldFN0eWxlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtpXVxuICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgIH0odGhpcy5zZXJpYWxpemUoKSwgZSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gISh0LmNvbW1hbmQgaW4gWmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICgwID09PSBvLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgICAgIHZhciByID0gby5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHQuY29tbWFuZCBpbiBOZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHIubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZDogXCIgKyByLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQuY29tbWFuZDtcbiAgICAgICAgICB9KS5qb2luKFwiLCBcIikgKyBcIi5cIik7XG4gICAgICAgICAgcmV0dXJuIG8uZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgXCJzZXRUcmFuc2l0aW9uXCIgIT09IHQuY29tbWFuZCAmJiBpW3QuY29tbWFuZF0uYXBwbHkoaSwgdC5hcmdzKTtcbiAgICAgICAgICB9KSwgdGhpcy5zdHlsZXNoZWV0ID0gZSwgITA7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXRJbWFnZShlKSkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkFuIGltYWdlIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKSkpO1xuICAgICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLmFkZEltYWdlKGUsIGkpLCB0aGlzLl9hZnRlckltYWdlVXBkYXRlZChlKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUudXBkYXRlSW1hZ2UgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLnVwZGF0ZUltYWdlKHQsIGUpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VNYW5hZ2VyLmdldEltYWdlKHQpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5yZW1vdmVJbWFnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmdldEltYWdlKGUpKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiTm8gaW1hZ2Ugd2l0aCB0aGlzIG5hbWUgZXhpc3RzLlwiKSkpO1xuICAgICAgICAgIHRoaXMuaW1hZ2VNYW5hZ2VyLnJlbW92ZUltYWdlKGUpLCB0aGlzLl9hZnRlckltYWdlVXBkYXRlZChlKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX2FmdGVySW1hZ2VVcGRhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aGlzLl9hdmFpbGFibGVJbWFnZXMgPSB0aGlzLmltYWdlTWFuYWdlci5saXN0SW1hZ2VzKCksIHRoaXMuX2NoYW5nZWRJbWFnZXNbZV0gPSAhMCwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KFwic2V0SW1hZ2VzXCIsIHRoaXMuX2F2YWlsYWJsZUltYWdlcyksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwic3R5bGVcIlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUubGlzdEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tMb2FkZWQoKSwgdGhpcy5pbWFnZU1hbmFnZXIubGlzdEltYWdlcygpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBvICYmIChvID0ge30pLCB0aGlzLl9jaGVja0xvYWRlZCgpLCB2b2lkIDAgIT09IHRoaXMuc291cmNlQ2FjaGVzW2VdKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhbHJlYWR5IGEgc291cmNlIHdpdGggdGhpcyBJRFwiKTtcbiAgICAgICAgICBpZiAoIWkudHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgcHJvcGVydHkgbXVzdCBiZSBkZWZpbmVkLCBidXQgb25seSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgd2VyZSBnaXZlbjogXCIgKyBPYmplY3Qua2V5cyhpKS5qb2luKFwiLCBcIikgKyBcIi5cIik7XG4gICAgICAgICAgaWYgKCEoW1widmVjdG9yXCIsIFwicmFzdGVyXCIsIFwiZ2VvanNvblwiLCBcInZpZGVvXCIsIFwiaW1hZ2VcIl0uaW5kZXhPZihpLnR5cGUpID49IDAgJiYgdGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLnNvdXJjZSwgXCJzb3VyY2VzLlwiICsgZSwgaSwgbnVsbCwgbykpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCAmJiB0aGlzLm1hcC5fY29sbGVjdFJlc291cmNlVGltaW5nICYmIChpLmNvbGxlY3RSZXNvdXJjZVRpbWluZyA9ICEwKTtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5zb3VyY2VDYWNoZXNbZV0gPSBuZXcgRHQoZSwgaSwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICAgICAgICAgIGEuc3R5bGUgPSB0aGlzLCBhLnNldEV2ZW50ZWRQYXJlbnQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzU291cmNlTG9hZGVkOiByLmxvYWRlZCgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogYS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksIGEub25BZGQodGhpcy5tYXApLCB0aGlzLl9jaGFuZ2VkID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGVja0xvYWRlZCgpLCB2b2lkIDAgPT09IHRoaXMuc291cmNlQ2FjaGVzW2VdKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCB0aGlzIElEXCIpO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSBpZiAodGhpcy5fbGF5ZXJzW2ldLnNvdXJjZSA9PT0gZSkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcignU291cmNlIFwiJyArIGUgKyAnXCIgY2Fubm90IGJlIHJlbW92ZWQgd2hpbGUgbGF5ZXIgXCInICsgaSArICdcIiBpcyB1c2luZyBpdC4nKSkpO1xuICAgICAgICAgIHZhciBvID0gdGhpcy5zb3VyY2VDYWNoZXNbZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlQ2FjaGVzW2VdLCBkZWxldGUgdGhpcy5fdXBkYXRlZFNvdXJjZXNbZV0sIG8uZmlyZShuZXcgdC5FdmVudChcImRhdGFcIiwge1xuICAgICAgICAgICAgc291cmNlRGF0YVR5cGU6IFwibWV0YWRhdGFcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInNvdXJjZVwiLFxuICAgICAgICAgICAgc291cmNlSWQ6IGVcbiAgICAgICAgICB9KSksIG8uc2V0RXZlbnRlZFBhcmVudChudWxsKSwgby5jbGVhclRpbGVzKCksIG8ub25SZW1vdmUgJiYgby5vblJlbW92ZSh0aGlzLm1hcCksIHRoaXMuX2NoYW5nZWQgPSAhMDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0R2VvSlNPTlNvdXJjZURhdGEgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHRoaXMuX2NoZWNrTG9hZGVkKCksIHRoaXMuc291cmNlQ2FjaGVzW3RdLmdldFNvdXJjZSgpLnNldERhdGEoZSksIHRoaXMuX2NoYW5nZWQgPSAhMDtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDYWNoZXNbdF0gJiYgdGhpcy5zb3VyY2VDYWNoZXNbdF0uZ2V0U291cmNlKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSksIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG4gICAgICAgICAgdmFyIHIgPSBlLmlkO1xuICAgICAgICAgIGlmICh0aGlzLmdldExheWVyKHIpKSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ0xheWVyIHdpdGggaWQgXCInICsgciArICdcIiBhbHJlYWR5IGV4aXN0cyBvbiB0aGlzIG1hcCcpKSk7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgYTtcbiAgICAgICAgICAgIGlmIChcImN1c3RvbVwiID09PSBlLnR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKFVlKHRoaXMsIHQudmFsaWRhdGVDdXN0b21TdHlsZUxheWVyKGUpKSkgcmV0dXJuO1xuICAgICAgICAgICAgICBhID0gdC5jcmVhdGVTdHlsZUxheWVyKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUuc291cmNlICYmICh0aGlzLmFkZFNvdXJjZShyLCBlLnNvdXJjZSksIGUgPSB0LmNsb25lJDEoZSksIGUgPSB0LmV4dGVuZChlLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiByXG4gICAgICAgICAgICAgIH0pKSwgdGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLmxheWVyLCBcImxheWVycy5cIiArIHIsIGUsIHtcbiAgICAgICAgICAgICAgICBhcnJheUluZGV4OiAtMVxuICAgICAgICAgICAgICB9LCBvKSkgcmV0dXJuO1xuICAgICAgICAgICAgICBhID0gdC5jcmVhdGVTdHlsZUxheWVyKGUpLCB0aGlzLl92YWxpZGF0ZUxheWVyKGEpLCBhLnNldEV2ZW50ZWRQYXJlbnQodGhpcywge1xuICAgICAgICAgICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgICAgICAgICBpZDogclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnNbYS5pZF0gPSBhLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG4gPSBpID8gdGhpcy5fb3JkZXIuaW5kZXhPZihpKSA6IHRoaXMuX29yZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpICYmIC0xID09PSBuKSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoJ0xheWVyIHdpdGggaWQgXCInICsgaSArICdcIiBkb2VzIG5vdCBleGlzdCBvbiB0aGlzIG1hcC4nKSkpO2Vsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb3JkZXIuc3BsaWNlKG4sIDAsIHIpLCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCA9ICEwLCB0aGlzLl9sYXllcnNbcl0gPSBhLCB0aGlzLl9yZW1vdmVkTGF5ZXJzW3JdICYmIGEuc291cmNlICYmIFwiY3VzdG9tXCIgIT09IGEudHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5fcmVtb3ZlZExheWVyc1tyXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVtb3ZlZExheWVyc1tyXSwgcy50eXBlICE9PSBhLnR5cGUgPyB0aGlzLl91cGRhdGVkU291cmNlc1thLnNvdXJjZV0gPSBcImNsZWFyXCIgOiAodGhpcy5fdXBkYXRlZFNvdXJjZXNbYS5zb3VyY2VdID0gXCJyZWxvYWRcIiwgdGhpcy5zb3VyY2VDYWNoZXNbYS5zb3VyY2VdLnBhdXNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKGEpLCBhLm9uQWRkICYmIGEub25BZGQodGhpcy5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgaS5wcm90b3R5cGUubW92ZUxheWVyID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hlY2tMb2FkZWQoKSwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl9sYXllcnNbZV0pIHtcbiAgICAgICAgICAgIGlmIChlICE9PSBpKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gdGhpcy5fb3JkZXIuaW5kZXhPZihlKTtcbiAgICAgICAgICAgICAgdGhpcy5fb3JkZXIuc3BsaWNlKG8sIDEpO1xuICAgICAgICAgICAgICB2YXIgciA9IGkgPyB0aGlzLl9vcmRlci5pbmRleE9mKGkpIDogdGhpcy5fb3JkZXIubGVuZ3RoO1xuICAgICAgICAgICAgICBpICYmIC0xID09PSByID8gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKCdMYXllciB3aXRoIGlkIFwiJyArIGkgKyAnXCIgZG9lcyBub3QgZXhpc3Qgb24gdGhpcyBtYXAuJykpKSA6ICh0aGlzLl9vcmRlci5zcGxpY2UociwgMCwgZSksIHRoaXMuX2xheWVyT3JkZXJDaGFuZ2VkID0gITApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSBtb3ZlZC5cIikpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9sYXllcnNbZV07XG4gICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGkuc2V0RXZlbnRlZFBhcmVudChudWxsKTtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5fb3JkZXIuaW5kZXhPZihlKTtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyLnNwbGljZShvLCAxKSwgdGhpcy5fbGF5ZXJPcmRlckNoYW5nZWQgPSAhMCwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl9yZW1vdmVkTGF5ZXJzW2VdID0gaSwgZGVsZXRlIHRoaXMuX2xheWVyc1tlXSwgZGVsZXRlIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnNbZV0sIGRlbGV0ZSB0aGlzLl91cGRhdGVkTGF5ZXJzW2VdLCBkZWxldGUgdGhpcy5fdXBkYXRlZFBhaW50UHJvcHNbZV0sIGkub25SZW1vdmUgJiYgaS5vblJlbW92ZSh0aGlzLm1hcCk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIHJlbW92ZWQuXCIpKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW3RdO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5oYXNMYXllciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgaW4gdGhpcy5fbGF5ZXJzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRMYXllclpvb21SYW5nZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgICB2YXIgciA9IHRoaXMuZ2V0TGF5ZXIoZSk7XG4gICAgICAgICAgciA/IHIubWluem9vbSA9PT0gaSAmJiByLm1heHpvb20gPT09IG8gfHwgKG51bGwgIT0gaSAmJiAoci5taW56b29tID0gaSksIG51bGwgIT0gbyAmJiAoci5tYXh6b29tID0gbyksIHRoaXMuX3VwZGF0ZUxheWVyKHIpKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGhhdmUgem9vbSBleHRlbnQuXCIpKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBvICYmIChvID0ge30pLCB0aGlzLl9jaGVja0xvYWRlZCgpO1xuICAgICAgICAgIHZhciByID0gdGhpcy5nZXRMYXllcihlKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgaWYgKCF0LmRlZXBFcXVhbChyLmZpbHRlciwgaSkpIHJldHVybiBudWxsID09IGkgPyAoci5maWx0ZXIgPSB2b2lkIDAsIHZvaWQgdGhpcy5fdXBkYXRlTGF5ZXIocikpIDogdm9pZCAodGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLmZpbHRlciwgXCJsYXllcnMuXCIgKyByLmlkICsgXCIuZmlsdGVyXCIsIGksIG51bGwsIG8pIHx8IChyLmZpbHRlciA9IHQuY2xvbmUkMShpKSwgdGhpcy5fdXBkYXRlTGF5ZXIocikpKTtcbiAgICAgICAgICB9IGVsc2UgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiVGhlIGxheWVyICdcIiArIGUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlIGFuZCBjYW5ub3QgYmUgZmlsdGVyZWQuXCIpKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHQuY2xvbmUkMSh0aGlzLmdldExheWVyKGUpLmZpbHRlcik7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldExheW91dFByb3BlcnR5ID0gZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB7fSksIHRoaXMuX2NoZWNrTG9hZGVkKCk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICAgIGEgPyB0LmRlZXBFcXVhbChhLmdldExheW91dFByb3BlcnR5KGkpLCBvKSB8fCAoYS5zZXRMYXlvdXRQcm9wZXJ0eShpLCBvLCByKSwgdGhpcy5fdXBkYXRlTGF5ZXIoYSkpIDogdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiVGhlIGxheWVyICdcIiArIGUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG1hcCdzIHN0eWxlIGFuZCBjYW5ub3QgYmUgc3R5bGVkLlwiKSkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLmdldExheWVyKGUpO1xuICAgICAgICAgIGlmIChvKSByZXR1cm4gby5nZXRMYXlvdXRQcm9wZXJ0eShpKTtcbiAgICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUuXCIpKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICAgIHZvaWQgMCA9PT0gciAmJiAociA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0TGF5ZXIoZSk7XG4gICAgICAgICAgYSA/IHQuZGVlcEVxdWFsKGEuZ2V0UGFpbnRQcm9wZXJ0eShpKSwgbykgfHwgKGEuc2V0UGFpbnRQcm9wZXJ0eShpLCBvLCByKSAmJiB0aGlzLl91cGRhdGVMYXllcihhKSwgdGhpcy5fY2hhbmdlZCA9ICEwLCB0aGlzLl91cGRhdGVkUGFpbnRQcm9wc1tlXSA9ICEwKSA6IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBsYXllciAnXCIgKyBlICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZSBhbmQgY2Fubm90IGJlIHN0eWxlZC5cIikpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UGFpbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIodCkuZ2V0UGFpbnRQcm9wZXJ0eShlKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpO1xuICAgICAgICAgIHZhciBvID0gZS5zb3VyY2UsXG4gICAgICAgICAgICByID0gZS5zb3VyY2VMYXllcixcbiAgICAgICAgICAgIGEgPSB0aGlzLnNvdXJjZUNhY2hlc1tvXTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBhKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGEuZ2V0U291cmNlKCkudHlwZTtcbiAgICAgICAgICAgIFwiZ2VvanNvblwiID09PSBuICYmIHIgPyB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJHZW9KU09OIHNvdXJjZXMgY2Fubm90IGhhdmUgYSBzb3VyY2VMYXllciBwYXJhbWV0ZXIuXCIpKSkgOiBcInZlY3RvclwiICE9PSBuIHx8IHIgPyAodm9pZCAwID09PSBlLmlkICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBmZWF0dXJlIGlkIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkLlwiKSkpLCBhLnNldEZlYXR1cmVTdGF0ZShyLCBlLmlkLCBpKSkgOiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlTGF5ZXIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZlY3RvciBzb3VyY2UgdHlwZXMuXCIpKSk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2UgJ1wiICsgbyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUuXCIpKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgICB2YXIgbyA9IGUuc291cmNlLFxuICAgICAgICAgICAgciA9IHRoaXMuc291cmNlQ2FjaGVzW29dO1xuICAgICAgICAgIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgICAgICAgIHZhciBhID0gci5nZXRTb3VyY2UoKS50eXBlLFxuICAgICAgICAgICAgICBuID0gXCJ2ZWN0b3JcIiA9PT0gYSA/IGUuc291cmNlTGF5ZXIgOiB2b2lkIDA7XG4gICAgICAgICAgICBcInZlY3RvclwiICE9PSBhIHx8IG4gPyBpICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGUuaWQgJiYgXCJudW1iZXJcIiAhPSB0eXBlb2YgZS5pZCA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkEgZmVhdHVyZSBpZCBpcyByZXF1aXJlZCB0byByZW1vdmUgaXRzIHNwZWNpZmljIHN0YXRlIHByb3BlcnR5LlwiKSkpIDogci5yZW1vdmVGZWF0dXJlU3RhdGUobiwgZS5pZCwgaSkgOiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgc291cmNlTGF5ZXIgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIHZlY3RvciBzb3VyY2UgdHlwZXMuXCIpKSk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2UgJ1wiICsgbyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUuXCIpKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldEZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgICB2YXIgaSA9IGUuc291cmNlLFxuICAgICAgICAgICAgbyA9IGUuc291cmNlTGF5ZXIsXG4gICAgICAgICAgICByID0gdGhpcy5zb3VyY2VDYWNoZXNbaV07XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcikge1xuICAgICAgICAgICAgaWYgKFwidmVjdG9yXCIgIT09IHIuZ2V0U291cmNlKCkudHlwZSB8fCBvKSByZXR1cm4gdm9pZCAwID09PSBlLmlkICYmIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBmZWF0dXJlIGlkIHBhcmFtZXRlciBtdXN0IGJlIHByb3ZpZGVkLlwiKSkpLCByLmdldEZlYXR1cmVTdGF0ZShvLCBlLmlkKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSBzb3VyY2VMYXllciBwYXJhbWV0ZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgdmVjdG9yIHNvdXJjZSB0eXBlcy5cIikpKTtcbiAgICAgICAgICB9IGVsc2UgdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiVGhlIHNvdXJjZSAnXCIgKyBpICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBtYXAncyBzdHlsZS5cIikpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdC5leHRlbmQoe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGRlbGF5OiAwXG4gICAgICAgICAgfSwgdGhpcy5zdHlsZXNoZWV0ICYmIHRoaXMuc3R5bGVzaGVldC50cmFuc2l0aW9uKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0LmZpbHRlck9iamVjdCh7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnN0eWxlc2hlZXQudmVyc2lvbixcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuc3R5bGVzaGVldC5uYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuc3R5bGVzaGVldC5tZXRhZGF0YSxcbiAgICAgICAgICAgIGxpZ2h0OiB0aGlzLnN0eWxlc2hlZXQubGlnaHQsXG4gICAgICAgICAgICBjZW50ZXI6IHRoaXMuc3R5bGVzaGVldC5jZW50ZXIsXG4gICAgICAgICAgICB6b29tOiB0aGlzLnN0eWxlc2hlZXQuem9vbSxcbiAgICAgICAgICAgIGJlYXJpbmc6IHRoaXMuc3R5bGVzaGVldC5iZWFyaW5nLFxuICAgICAgICAgICAgcGl0Y2g6IHRoaXMuc3R5bGVzaGVldC5waXRjaCxcbiAgICAgICAgICAgIHNwcml0ZTogdGhpcy5zdHlsZXNoZWV0LnNwcml0ZSxcbiAgICAgICAgICAgIGdseXBoczogdGhpcy5zdHlsZXNoZWV0LmdseXBocyxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuc3R5bGVzaGVldC50cmFuc2l0aW9uLFxuICAgICAgICAgICAgc291cmNlczogdC5tYXBPYmplY3QodGhpcy5zb3VyY2VDYWNoZXMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0LnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBsYXllcnM6IHRoaXMuX3NlcmlhbGl6ZUxheWVycyh0aGlzLl9vcmRlcilcbiAgICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZUxheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVkTGF5ZXJzW3QuaWRdID0gITAsIHQuc291cmNlICYmICF0aGlzLl91cGRhdGVkU291cmNlc1t0LnNvdXJjZV0gJiYgXCJyYXN0ZXJcIiAhPT0gdGhpcy5zb3VyY2VDYWNoZXNbdC5zb3VyY2VdLmdldFNvdXJjZSgpLnR5cGUgJiYgKHRoaXMuX3VwZGF0ZWRTb3VyY2VzW3Quc291cmNlXSA9IFwicmVsb2FkXCIsIHRoaXMuc291cmNlQ2FjaGVzW3Quc291cmNlXS5wYXVzZSgpKSwgdGhpcy5fY2hhbmdlZCA9ICEwO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fZmxhdHRlbkFuZFNvcnRSZW5kZXJlZEZlYXR1cmVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlID0gdGhpcywgaSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBcImZpbGwtZXh0cnVzaW9uXCIgPT09IGUuX2xheWVyc1t0XS50eXBlO1xuICAgICAgICAgICAgfSwgbyA9IHt9LCByID0gW10sIGEgPSB0aGlzLl9vcmRlci5sZW5ndGggLSAxOyBhID49IDA7IGEtLSkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9vcmRlclthXTtcbiAgICAgICAgICAgIGlmIChpKG4pKSB7XG4gICAgICAgICAgICAgIG9bbl0gPSBhO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMCwgbCA9IHQ7IHMgPCBsLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsW3NdW25dO1xuICAgICAgICAgICAgICAgIGlmIChjKSBmb3IgKHZhciB1ID0gMCwgaCA9IGM7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSByLnB1c2goaFt1XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgci5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5pbnRlcnNlY3Rpb25aIC0gdC5pbnRlcnNlY3Rpb25aO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAodmFyIHAgPSBbXSwgZCA9IHRoaXMuX29yZGVyLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICB2YXIgXyA9IHRoaXMuX29yZGVyW2RdO1xuICAgICAgICAgICAgaWYgKGkoXykpIGZvciAodmFyIGYgPSByLmxlbmd0aCAtIDE7IGYgPj0gMDsgZi0tKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gcltmXS5mZWF0dXJlO1xuICAgICAgICAgICAgICBpZiAob1ttLmxheWVyLmlkXSA8IGQpIGJyZWFrO1xuICAgICAgICAgICAgICBwLnB1c2gobSksIHIucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2UgZm9yICh2YXIgZyA9IDAsIHYgPSB0OyBnIDwgdi5sZW5ndGg7IGcgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgeSA9IHZbZ11bX107XG4gICAgICAgICAgICAgIGlmICh5KSBmb3IgKHZhciB4ID0gMCwgYiA9IHk7IHggPCBiLmxlbmd0aDsgeCArPSAxKSBwLnB1c2goYlt4XS5mZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgaSAmJiBpLmZpbHRlciAmJiB0aGlzLl92YWxpZGF0ZSh0LnZhbGlkYXRlU3R5bGUuZmlsdGVyLCBcInF1ZXJ5UmVuZGVyZWRGZWF0dXJlcy5maWx0ZXJcIiwgaS5maWx0ZXIsIG51bGwsIGkpO1xuICAgICAgICAgIHZhciByID0ge307XG4gICAgICAgICAgaWYgKGkgJiYgaS5sYXllcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpLmxheWVycykpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJwYXJhbWV0ZXJzLmxheWVycyBtdXN0IGJlIGFuIEFycmF5LlwiKSkpLCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gaS5sYXllcnM7IGEgPCBuLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciBzID0gblthXSxcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5fbGF5ZXJzW3NdO1xuICAgICAgICAgICAgICBpZiAoIWwpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGUgbGF5ZXIgJ1wiICsgcyArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbWFwJ3Mgc3R5bGUgYW5kIGNhbm5vdCBiZSBxdWVyaWVkIGZvciBmZWF0dXJlcy5cIikpKSwgW107XG4gICAgICAgICAgICAgIHJbbC5zb3VyY2VdID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgZm9yICh2YXIgdSBpbiBpLmF2YWlsYWJsZUltYWdlcyA9IHRoaXMuX2F2YWlsYWJsZUltYWdlcywgdGhpcy5zb3VyY2VDYWNoZXMpIGkubGF5ZXJzICYmICFyW3VdIHx8IGMucHVzaChPKHRoaXMuc291cmNlQ2FjaGVzW3VdLCB0aGlzLl9sYXllcnMsIHRoaXMuX3NlcmlhbGl6ZWRMYXllcnMsIGUsIGksIG8pKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnQgJiYgYy5wdXNoKGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzID0ge30sIGwgPSBhLnF1ZXJ5UmVuZGVyZWRTeW1ib2xzKG8pLCBjID0gW10sIHUgPSAwLCBoID0gT2JqZWN0LmtleXMobCkubWFwKE51bWJlcik7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSBjLnB1c2gobltoW3VdXSk7XG4gICAgICAgICAgICBjLnNvcnQoRik7XG4gICAgICAgICAgICBmb3IgKHZhciBwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gX1tkXSxcbiAgICAgICAgICAgICAgICAgIG8gPSBpLmZlYXR1cmVJbmRleC5sb29rdXBTeW1ib2xGZWF0dXJlcyhsW2kuYnVja2V0SW5zdGFuY2VJZF0sIGUsIGkuYnVja2V0SW5kZXgsIGkuc291cmNlTGF5ZXJJbmRleCwgci5maWx0ZXIsIHIubGF5ZXJzLCByLmF2YWlsYWJsZUltYWdlcywgdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbiA9IHNbYV0gPSBzW2FdIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBjID0gb1thXTtcbiAgICAgICAgICAgICAgICAgIGMuc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGkuZmVhdHVyZVNvcnRPcmRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG8uaW5kZXhPZih0LmZlYXR1cmVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uaW5kZXhPZihlLmZlYXR1cmVJbmRleCkgLSByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmZlYXR1cmVJbmRleCAtIHQuZmVhdHVyZUluZGV4O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gMCwgaCA9IGM7IHUgPCBoLmxlbmd0aDsgdSArPSAxKSBuLnB1c2goaFt1XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBkID0gMCwgXyA9IGM7IGQgPCBfLmxlbmd0aDsgZCArPSAxKSBwKCk7XG4gICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHNbZV0uZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHZhciByID0gby5mZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgYSA9IGlbdFtlXS5zb3VyY2VdLmdldEZlYXR1cmVTdGF0ZShyLmxheWVyW1wic291cmNlLWxheWVyXCJdLCByLmlkKTtcbiAgICAgICAgICAgICAgICByLnNvdXJjZSA9IHIubGF5ZXIuc291cmNlLCByLmxheWVyW1wic291cmNlLWxheWVyXCJdICYmIChyLnNvdXJjZUxheWVyID0gci5sYXllcltcInNvdXJjZS1sYXllclwiXSksIHIuc3RhdGUgPSBhO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBtIGluIHMpIGYobSk7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9KHRoaXMuX2xheWVycywgdGhpcy5fc2VyaWFsaXplZExheWVycywgdGhpcy5zb3VyY2VDYWNoZXMsIGUsIGksIHRoaXMucGxhY2VtZW50LmNvbGxpc2lvbkluZGV4LCB0aGlzLnBsYWNlbWVudC5yZXRhaW5lZFF1ZXJ5RGF0YSkpLCB0aGlzLl9mbGF0dGVuQW5kU29ydFJlbmRlcmVkRmVhdHVyZXMoYyk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnF1ZXJ5U291cmNlRmVhdHVyZXMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGkgJiYgaS5maWx0ZXIgJiYgdGhpcy5fdmFsaWRhdGUodC52YWxpZGF0ZVN0eWxlLmZpbHRlciwgXCJxdWVyeVNvdXJjZUZlYXR1cmVzLmZpbHRlclwiLCBpLmZpbHRlciwgbnVsbCwgaSk7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLnNvdXJjZUNhY2hlc1tlXTtcbiAgICAgICAgICByZXR1cm4gbyA/IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdC5nZXRSZW5kZXJhYmxlSWRzKCkubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQuZ2V0VGlsZUJ5SUQoZSk7XG4gICAgICAgICAgICAgIH0pLCBvID0gW10sIHIgPSB7fSwgYSA9IDA7IGEgPCBpLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgIHZhciBuID0gaVthXSxcbiAgICAgICAgICAgICAgICBzID0gbi50aWxlSUQuY2Fub25pY2FsLmtleTtcbiAgICAgICAgICAgICAgcltzXSB8fCAocltzXSA9ICEwLCBuLnF1ZXJ5U291cmNlRmVhdHVyZXMobywgZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgfShvLCBpKSA6IFtdO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5hZGRTb3VyY2VUeXBlID0gZnVuY3Rpb24gKHQsIGUsIG8pIHtcbiAgICAgICAgICByZXR1cm4gaS5nZXRTb3VyY2VUeXBlKHQpID8gbyhuZXcgRXJyb3IoJ0Egc291cmNlIHR5cGUgY2FsbGVkIFwiJyArIHQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJykpIDogKGkuc2V0U291cmNlVHlwZSh0LCBlKSwgZS53b3JrZXJTb3VyY2VVUkwgPyB2b2lkIHRoaXMuZGlzcGF0Y2hlci5icm9hZGNhc3QoXCJsb2FkV29ya2VyU291cmNlXCIsIHtcbiAgICAgICAgICAgIG5hbWU6IHQsXG4gICAgICAgICAgICB1cmw6IGUud29ya2VyU291cmNlVVJMXG4gICAgICAgICAgfSwgbykgOiBvKG51bGwsIG51bGwpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0TGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHQuZ2V0TGlnaHQoKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0TGlnaHQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMubGlnaHQuZ2V0TGlnaHQoKSxcbiAgICAgICAgICAgIHIgPSAhMTtcbiAgICAgICAgICBmb3IgKHZhciBhIGluIGUpIGlmICghdC5kZWVwRXF1YWwoZVthXSwgb1thXSkpIHtcbiAgICAgICAgICAgIHIgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgICAgIG5vdzogdC5icm93c2VyLm5vdygpLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0LmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgICAgICBkZWxheTogMFxuICAgICAgICAgICAgICB9LCB0aGlzLnN0eWxlc2hlZXQudHJhbnNpdGlvbilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxpZ2h0LnNldExpZ2h0KGUsIGkpLCB0aGlzLmxpZ2h0LnVwZGF0ZVRyYW5zaXRpb25zKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3ZhbGlkYXRlID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBhICYmIChhID0ge30pLCAoIWEgfHwgITEgIT09IGEudmFsaWRhdGUpICYmIFVlKHRoaXMsIGUuY2FsbCh0LnZhbGlkYXRlU3R5bGUsIHQuZXh0ZW5kKHtcbiAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdmFsdWU6IG8sXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHQuc3R5bGVTcGVjXG4gICAgICAgICAgfSwgcikpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBlIGluIHRoaXMuX3JlcXVlc3QgJiYgKHRoaXMuX3JlcXVlc3QuY2FuY2VsKCksIHRoaXMuX3JlcXVlc3QgPSBudWxsKSwgdGhpcy5fc3ByaXRlUmVxdWVzdCAmJiAodGhpcy5fc3ByaXRlUmVxdWVzdC5jYW5jZWwoKSwgdGhpcy5fc3ByaXRlUmVxdWVzdCA9IG51bGwpLCB0LmV2ZW50ZWQub2ZmKFwicGx1Z2luU3RhdGVDaGFuZ2VcIiwgdGhpcy5fcnRsVGV4dFBsdWdpbkNhbGxiYWNrKSwgdGhpcy5fbGF5ZXJzKSB0aGlzLl9sYXllcnNbZV0uc2V0RXZlbnRlZFBhcmVudChudWxsKTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuc291cmNlQ2FjaGVzKSB0aGlzLnNvdXJjZUNhY2hlc1tpXS5jbGVhclRpbGVzKCksIHRoaXMuc291cmNlQ2FjaGVzW2ldLnNldEV2ZW50ZWRQYXJlbnQobnVsbCk7XG4gICAgICAgICAgdGhpcy5pbWFnZU1hbmFnZXIuc2V0RXZlbnRlZFBhcmVudChudWxsKSwgdGhpcy5zZXRFdmVudGVkUGFyZW50KG51bGwpLCB0aGlzLmRpc3BhdGNoZXIucmVtb3ZlKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9jbGVhclNvdXJjZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZXNbdF0uY2xlYXJUaWxlcygpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fcmVsb2FkU291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlc1t0XS5yZXN1bWUoKSwgdGhpcy5zb3VyY2VDYWNoZXNbdF0ucmVsb2FkKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl91cGRhdGVTb3VyY2VzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBlIGluIHRoaXMuc291cmNlQ2FjaGVzKSB0aGlzLnNvdXJjZUNhY2hlc1tlXS51cGRhdGUodCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9nZW5lcmF0ZUNvbGxpc2lvbkJveGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5zb3VyY2VDYWNoZXMpIHRoaXMuX3JlbG9hZFNvdXJjZSh0KTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX3VwZGF0ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gITEpO1xuICAgICAgICAgIGZvciAodmFyIG4gPSAhMSwgcyA9ICExLCBsID0ge30sIGMgPSAwLCB1ID0gdGhpcy5fb3JkZXI7IGMgPCB1Lmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuX2xheWVyc1t1W2NdXTtcbiAgICAgICAgICAgIGlmIChcInN5bWJvbFwiID09PSBoLnR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFsW2guc291cmNlXSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5zb3VyY2VDYWNoZXNbaC5zb3VyY2VdO1xuICAgICAgICAgICAgICAgIGxbaC5zb3VyY2VdID0gcC5nZXRSZW5kZXJhYmxlSWRzKCEwKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwLmdldFRpbGVCeUlEKHQpO1xuICAgICAgICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRpbGVJRC5vdmVyc2NhbGVkWiAtIHQudGlsZUlELm92ZXJzY2FsZWRaIHx8ICh0LnRpbGVJRC5pc0xlc3NUaGFuKGUudGlsZUlEKSA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4LmFkZExheWVyKGgsIGxbaC5zb3VyY2VdLCBlLmNlbnRlci5sbmcpO1xuICAgICAgICAgICAgICBuID0gbiB8fCBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5jcm9zc1RpbGVTeW1ib2xJbmRleC5wcnVuZVVudXNlZExheWVycyh0aGlzLl9vcmRlciksICgoYSA9IGEgfHwgdGhpcy5fbGF5ZXJPcmRlckNoYW5nZWQgfHwgMCA9PT0gbykgfHwgIXRoaXMucGF1c2VhYmxlUGxhY2VtZW50IHx8IHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LmlzRG9uZSgpICYmICF0aGlzLnBsYWNlbWVudC5zdGlsbFJlY2VudCh0LmJyb3dzZXIubm93KCksIGUuem9vbSkpICYmICh0aGlzLnBhdXNlYWJsZVBsYWNlbWVudCA9IG5ldyBMZShlLCB0aGlzLl9vcmRlciwgYSwgaSwgbywgciwgdGhpcy5wbGFjZW1lbnQpLCB0aGlzLl9sYXllck9yZGVyQ2hhbmdlZCA9ICExKSwgdGhpcy5wYXVzZWFibGVQbGFjZW1lbnQuaXNEb25lKCkgPyB0aGlzLnBsYWNlbWVudC5zZXRTdGFsZSgpIDogKHRoaXMucGF1c2VhYmxlUGxhY2VtZW50LmNvbnRpbnVlUGxhY2VtZW50KHRoaXMuX29yZGVyLCB0aGlzLl9sYXllcnMsIGwpLCB0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5pc0RvbmUoKSAmJiAodGhpcy5wbGFjZW1lbnQgPSB0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5jb21taXQodC5icm93c2VyLm5vdygpKSwgcyA9ICEwKSwgbiAmJiB0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5wbGFjZW1lbnQuc2V0U3RhbGUoKSksIHMgfHwgbikgZm9yICh2YXIgXyA9IDAsIGYgPSB0aGlzLl9vcmRlcjsgXyA8IGYubGVuZ3RoOyBfICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5fbGF5ZXJzW2ZbX11dO1xuICAgICAgICAgICAgXCJzeW1ib2xcIiA9PT0gbS50eXBlICYmIHRoaXMucGxhY2VtZW50LnVwZGF0ZUxheWVyT3BhY2l0aWVzKG0sIGxbbS5zb3VyY2VdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICF0aGlzLnBhdXNlYWJsZVBsYWNlbWVudC5pc0RvbmUoKSB8fCB0aGlzLnBsYWNlbWVudC5oYXNUcmFuc2l0aW9ucyh0LmJyb3dzZXIubm93KCkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fcmVsZWFzZVN5bWJvbEZhZGVUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuc291cmNlQ2FjaGVzKSB0aGlzLnNvdXJjZUNhY2hlc1t0XS5yZWxlYXNlU3ltYm9sRmFkZVRpbGVzKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmdldEltYWdlcyA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZU1hbmFnZXIuZ2V0SW1hZ2VzKGUuaWNvbnMsIGkpLCB0aGlzLl91cGRhdGVUaWxlc0ZvckNoYW5nZWRJbWFnZXMoKTtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuc291cmNlQ2FjaGVzW2Uuc291cmNlXTtcbiAgICAgICAgICBvICYmIG8uc2V0RGVwZW5kZW5jaWVzKGUudGlsZUlELmtleSwgZS50eXBlLCBlLmljb25zKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0R2x5cGhzID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICB0aGlzLmdseXBoTWFuYWdlci5nZXRHbHlwaHMoZS5zdGFja3MsIGkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgcmV0dXJuIHQubWFrZVJlcXVlc3QoaSwgbyk7XG4gICAgICAgIH0sIGk7XG4gICAgICB9KHQuRXZlbnRlZCk7XG4gICAgamUuZ2V0U291cmNlVHlwZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4ga1t0XTtcbiAgICB9LCBqZS5zZXRTb3VyY2VUeXBlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGtbdF0gPSBlO1xuICAgIH0sIGplLnJlZ2lzdGVyRm9yUGx1Z2luU3RhdGVDaGFuZ2UgPSB0LnJlZ2lzdGVyRm9yUGx1Z2luU3RhdGVDaGFuZ2U7XG4gICAgdmFyIFZlID0gdC5jcmVhdGVMYXlvdXQoW3tcbiAgICAgICAgbmFtZTogXCJhX3Bvc1wiLFxuICAgICAgICB0eXBlOiBcIkludDE2XCIsXG4gICAgICAgIGNvbXBvbmVudHM6IDJcbiAgICAgIH1dKSxcbiAgICAgIEdlID0gZ2koXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNpZiAhZGVmaW5lZChsb3dwKVxcbiNkZWZpbmUgbG93cFxcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZChtZWRpdW1wKVxcbiNkZWZpbmUgbWVkaXVtcFxcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZChoaWdocClcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuI2VuZGlmXCIsIFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbHNlXFxuI2lmICFkZWZpbmVkKGxvd3ApXFxuI2RlZmluZSBsb3dwXFxuI2VuZGlmXFxuI2lmICFkZWZpbmVkKG1lZGl1bXApXFxuI2RlZmluZSBtZWRpdW1wXFxuI2VuZGlmXFxuI2lmICFkZWZpbmVkKGhpZ2hwKVxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG4jZW5kaWZcXG52ZWMyIHVucGFja19mbG9hdChjb25zdCBmbG9hdCBwYWNrZWRWYWx1ZSkge2ludCBwYWNrZWRJbnRWYWx1ZT1pbnQocGFja2VkVmFsdWUpO2ludCB2MD1wYWNrZWRJbnRWYWx1ZS8yNTY7cmV0dXJuIHZlYzIodjAscGFja2VkSW50VmFsdWUtdjAqMjU2KTt9dmVjMiB1bnBhY2tfb3BhY2l0eShjb25zdCBmbG9hdCBwYWNrZWRPcGFjaXR5KSB7aW50IGludE9wYWNpdHk9aW50KHBhY2tlZE9wYWNpdHkpLzI7cmV0dXJuIHZlYzIoZmxvYXQoaW50T3BhY2l0eSkvMTI3LjAsbW9kKHBhY2tlZE9wYWNpdHksMi4wKSk7fXZlYzQgZGVjb2RlX2NvbG9yKGNvbnN0IHZlYzIgZW5jb2RlZENvbG9yKSB7cmV0dXJuIHZlYzQodW5wYWNrX2Zsb2F0KGVuY29kZWRDb2xvclswXSkvMjU1LjAsdW5wYWNrX2Zsb2F0KGVuY29kZWRDb2xvclsxXSkvMjU1LjBcXG4pO31mbG9hdCB1bnBhY2tfbWl4X3ZlYzIoY29uc3QgdmVjMiBwYWNrZWRWYWx1ZSxjb25zdCBmbG9hdCB0KSB7cmV0dXJuIG1peChwYWNrZWRWYWx1ZVswXSxwYWNrZWRWYWx1ZVsxXSx0KTt9dmVjNCB1bnBhY2tfbWl4X2NvbG9yKGNvbnN0IHZlYzQgcGFja2VkQ29sb3JzLGNvbnN0IGZsb2F0IHQpIHt2ZWM0IG1pbkNvbG9yPWRlY29kZV9jb2xvcih2ZWMyKHBhY2tlZENvbG9yc1swXSxwYWNrZWRDb2xvcnNbMV0pKTt2ZWM0IG1heENvbG9yPWRlY29kZV9jb2xvcih2ZWMyKHBhY2tlZENvbG9yc1syXSxwYWNrZWRDb2xvcnNbM10pKTtyZXR1cm4gbWl4KG1pbkNvbG9yLG1heENvbG9yLHQpO312ZWMyIGdldF9wYXR0ZXJuX3Bvcyhjb25zdCB2ZWMyIHBpeGVsX2Nvb3JkX3VwcGVyLGNvbnN0IHZlYzIgcGl4ZWxfY29vcmRfbG93ZXIsY29uc3QgdmVjMiBwYXR0ZXJuX3NpemUsY29uc3QgZmxvYXQgdGlsZV91bml0c190b19waXhlbHMsY29uc3QgdmVjMiBwb3MpIHt2ZWMyIG9mZnNldD1tb2QobW9kKG1vZChwaXhlbF9jb29yZF91cHBlcixwYXR0ZXJuX3NpemUpKjI1Ni4wLHBhdHRlcm5fc2l6ZSkqMjU2LjArcGl4ZWxfY29vcmRfbG93ZXIscGF0dGVybl9zaXplKTtyZXR1cm4gKHRpbGVfdW5pdHNfdG9fcGl4ZWxzKnBvcytvZmZzZXQpL3BhdHRlcm5fc2l6ZTt9XCIpLFxuICAgICAgV2UgPSBnaShcInVuaWZvcm0gdmVjNCB1X2NvbG9yO3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O3ZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3I9dV9jb2xvcip1X29wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO31cIiksXG4gICAgICBYZSA9IGdpKFwidW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9hO3VuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYTt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2I7dW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9iO3VuaWZvcm0gdmVjMiB1X3RleHNpemU7dW5pZm9ybSBmbG9hdCB1X21peDt1bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvc19hO3ZhcnlpbmcgdmVjMiB2X3Bvc19iO3ZvaWQgbWFpbigpIHt2ZWMyIGltYWdlY29vcmQ9bW9kKHZfcG9zX2EsMS4wKTt2ZWMyIHBvcz1taXgodV9wYXR0ZXJuX3RsX2EvdV90ZXhzaXplLHVfcGF0dGVybl9icl9hL3VfdGV4c2l6ZSxpbWFnZWNvb3JkKTt2ZWM0IGNvbG9yMT10ZXh0dXJlMkQodV9pbWFnZSxwb3MpO3ZlYzIgaW1hZ2Vjb29yZF9iPW1vZCh2X3Bvc19iLDEuMCk7dmVjMiBwb3MyPW1peCh1X3BhdHRlcm5fdGxfYi91X3RleHNpemUsdV9wYXR0ZXJuX2JyX2IvdV90ZXhzaXplLGltYWdlY29vcmRfYik7dmVjNCBjb2xvcjI9dGV4dHVyZTJEKHVfaW1hZ2UscG9zMik7Z2xfRnJhZ0NvbG9yPW1peChjb2xvcjEsY29sb3IyLHVfbWl4KSp1X29wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3NpemVfYTt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3NpemVfYjt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF91cHBlcjt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF9sb3dlcjt1bmlmb3JtIGZsb2F0IHVfc2NhbGVfYTt1bmlmb3JtIGZsb2F0IHVfc2NhbGVfYjt1bmlmb3JtIGZsb2F0IHVfdGlsZV91bml0c190b19waXhlbHM7YXR0cmlidXRlIHZlYzIgYV9wb3M7dmFyeWluZyB2ZWMyIHZfcG9zX2E7dmFyeWluZyB2ZWMyIHZfcG9zX2I7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvc19hPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsdV9zY2FsZV9hKnVfcGF0dGVybl9zaXplX2EsdV90aWxlX3VuaXRzX3RvX3BpeGVscyxhX3Bvcyk7dl9wb3NfYj1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLHVfc2NhbGVfYip1X3BhdHRlcm5fc2l6ZV9iLHVfdGlsZV91bml0c190b19waXhlbHMsYV9wb3MpO31cIiksXG4gICAgICBIZSA9IGdpKFwidmFyeWluZyB2ZWMzIHZfZGF0YTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgcmFkaXVzXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBzdHJva2VfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgc3Ryb2tlX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHN0cm9rZV9vcGFjaXR5XFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgc3Ryb2tlX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBzdHJva2Vfd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHN0cm9rZV9vcGFjaXR5XFxudmVjMiBleHRydWRlPXZfZGF0YS54eTtmbG9hdCBleHRydWRlX2xlbmd0aD1sZW5ndGgoZXh0cnVkZSk7bG93cCBmbG9hdCBhbnRpYWxpYXNibHVyPXZfZGF0YS56O2Zsb2F0IGFudGlhbGlhc2VkX2JsdXI9LW1heChibHVyLGFudGlhbGlhc2JsdXIpO2Zsb2F0IG9wYWNpdHlfdD1zbW9vdGhzdGVwKDAuMCxhbnRpYWxpYXNlZF9ibHVyLGV4dHJ1ZGVfbGVuZ3RoLTEuMCk7ZmxvYXQgY29sb3JfdD1zdHJva2Vfd2lkdGggPCAwLjAxID8gMC4wIDogc21vb3Roc3RlcChhbnRpYWxpYXNlZF9ibHVyLDAuMCxleHRydWRlX2xlbmd0aC1yYWRpdXMvKHJhZGl1cytzdHJva2Vfd2lkdGgpKTtnbF9GcmFnQ29sb3I9b3BhY2l0eV90Km1peChjb2xvcipvcGFjaXR5LHN0cm9rZV9jb2xvcipzdHJva2Vfb3BhY2l0eSxjb2xvcl90KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gYm9vbCB1X3NjYWxlX3dpdGhfbWFwO3VuaWZvcm0gYm9vbCB1X3BpdGNoX3dpdGhfbWFwO3VuaWZvcm0gdmVjMiB1X2V4dHJ1ZGVfc2NhbGU7dW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO3ZhcnlpbmcgdmVjMyB2X2RhdGE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgc3Ryb2tlX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHN0cm9rZV93aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBzdHJva2Vfb3BhY2l0eVxcbnZvaWQgbWFpbih2b2lkKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgcmFkaXVzXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBzdHJva2VfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHN0cm9rZV93aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgc3Ryb2tlX29wYWNpdHlcXG52ZWMyIGV4dHJ1ZGU9dmVjMihtb2QoYV9wb3MsMi4wKSoyLjAtMS4wKTt2ZWMyIGNpcmNsZV9jZW50ZXI9Zmxvb3IoYV9wb3MqMC41KTtpZiAodV9waXRjaF93aXRoX21hcCkge3ZlYzIgY29ybmVyX3Bvc2l0aW9uPWNpcmNsZV9jZW50ZXI7aWYgKHVfc2NhbGVfd2l0aF9tYXApIHtjb3JuZXJfcG9zaXRpb24rPWV4dHJ1ZGUqKHJhZGl1cytzdHJva2Vfd2lkdGgpKnVfZXh0cnVkZV9zY2FsZTt9IGVsc2Uge3ZlYzQgcHJvamVjdGVkX2NlbnRlcj11X21hdHJpeCp2ZWM0KGNpcmNsZV9jZW50ZXIsMCwxKTtjb3JuZXJfcG9zaXRpb24rPWV4dHJ1ZGUqKHJhZGl1cytzdHJva2Vfd2lkdGgpKnVfZXh0cnVkZV9zY2FsZSoocHJvamVjdGVkX2NlbnRlci53L3VfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSk7fWdsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoY29ybmVyX3Bvc2l0aW9uLDAsMSk7fSBlbHNlIHtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGNpcmNsZV9jZW50ZXIsMCwxKTtpZiAodV9zY2FsZV93aXRoX21hcCkge2dsX1Bvc2l0aW9uLnh5Kz1leHRydWRlKihyYWRpdXMrc3Ryb2tlX3dpZHRoKSp1X2V4dHJ1ZGVfc2NhbGUqdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO30gZWxzZSB7Z2xfUG9zaXRpb24ueHkrPWV4dHJ1ZGUqKHJhZGl1cytzdHJva2Vfd2lkdGgpKnVfZXh0cnVkZV9zY2FsZSpnbF9Qb3NpdGlvbi53O319bG93cCBmbG9hdCBhbnRpYWxpYXNibHVyPTEuMC91X2RldmljZV9waXhlbF9yYXRpby8ocmFkaXVzK3N0cm9rZV93aWR0aCk7dl9kYXRhPXZlYzMoZXh0cnVkZS54LGV4dHJ1ZGUueSxhbnRpYWxpYXNibHVyKTt9XCIpLFxuICAgICAgS2UgPSBnaShcInZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3I9dmVjNCgxLjApO31cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt9XCIpLFxuICAgICAgWWUgPSBnaShcInVuaWZvcm0gaGlnaHAgZmxvYXQgdV9pbnRlbnNpdHk7dmFyeWluZyB2ZWMyIHZfZXh0cnVkZTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIGZsb2F0IHdlaWdodFxcbiNkZWZpbmUgR0FVU1NfQ09FRiAwLjM5ODk0MjI4MDQwMTQzMjdcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgZmxvYXQgd2VpZ2h0XFxuZmxvYXQgZD0tMC41KjMuMCozLjAqZG90KHZfZXh0cnVkZSx2X2V4dHJ1ZGUpO2Zsb2F0IHZhbD13ZWlnaHQqdV9pbnRlbnNpdHkqR0FVU1NfQ09FRipleHAoZCk7Z2xfRnJhZ0NvbG9yPXZlYzQodmFsLDEuMCwxLjAsMS4wKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gZmxvYXQgdV9leHRydWRlX3NjYWxlO3VuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O3VuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7YXR0cmlidXRlIHZlYzIgYV9wb3M7dmFyeWluZyB2ZWMyIHZfZXh0cnVkZTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIGZsb2F0IHdlaWdodFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG5jb25zdCBoaWdocCBmbG9hdCBaRVJPPTEuMC8yNTUuMC8xNi4wO1xcbiNkZWZpbmUgR0FVU1NfQ09FRiAwLjM5ODk0MjI4MDQwMTQzMjdcXG52b2lkIG1haW4odm9pZCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIGZsb2F0IHdlaWdodFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgZmxvYXQgcmFkaXVzXFxudmVjMiB1bnNjYWxlZF9leHRydWRlPXZlYzIobW9kKGFfcG9zLDIuMCkqMi4wLTEuMCk7ZmxvYXQgUz1zcXJ0KC0yLjAqbG9nKFpFUk8vd2VpZ2h0L3VfaW50ZW5zaXR5L0dBVVNTX0NPRUYpKS8zLjA7dl9leHRydWRlPVMqdW5zY2FsZWRfZXh0cnVkZTt2ZWMyIGV4dHJ1ZGU9dl9leHRydWRlKnJhZGl1cyp1X2V4dHJ1ZGVfc2NhbGU7dmVjNCBwb3M9dmVjNChmbG9vcihhX3BvcyowLjUpK2V4dHJ1ZGUsMCwxKTtnbF9Qb3NpdGlvbj11X21hdHJpeCpwb3M7fVwiKSxcbiAgICAgIEplID0gZ2koXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3VuaWZvcm0gc2FtcGxlcjJEIHVfY29sb3JfcmFtcDt1bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTt2YXJ5aW5nIHZlYzIgdl9wb3M7dm9pZCBtYWluKCkge2Zsb2F0IHQ9dGV4dHVyZTJEKHVfaW1hZ2Usdl9wb3MpLnI7dmVjNCBjb2xvcj10ZXh0dXJlMkQodV9jb2xvcl9yYW1wLHZlYzIodCwwLjUpKTtnbF9GcmFnQ29sb3I9Y29sb3IqdV9vcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgwLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSB2ZWMyIHVfd29ybGQ7YXR0cmlidXRlIHZlYzIgYV9wb3M7dmFyeWluZyB2ZWMyIHZfcG9zO3ZvaWQgbWFpbigpIHtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zKnVfd29ybGQsMCwxKTt2X3Bvcy54PWFfcG9zLng7dl9wb3MueT0xLjAtYV9wb3MueTt9XCIpLFxuICAgICAgUWUgPSBnaShcInZhcnlpbmcgZmxvYXQgdl9wbGFjZWQ7dmFyeWluZyBmbG9hdCB2X25vdFVzZWQ7dm9pZCBtYWluKCkge2Zsb2F0IGFscGhhPTAuNTtnbF9GcmFnQ29sb3I9dmVjNCgxLjAsMC4wLDAuMCwxLjApKmFscGhhO2lmICh2X3BsYWNlZCA+IDAuNSkge2dsX0ZyYWdDb2xvcj12ZWM0KDAuMCwwLjAsMS4wLDAuNSkqYWxwaGE7fWlmICh2X25vdFVzZWQgPiAwLjUpIHtnbF9GcmFnQ29sb3IqPS4xO319XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV9hbmNob3JfcG9zO2F0dHJpYnV0ZSB2ZWMyIGFfZXh0cnVkZTthdHRyaWJ1dGUgdmVjMiBhX3BsYWNlZDthdHRyaWJ1dGUgdmVjMiBhX3NoaWZ0O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO3VuaWZvcm0gZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3ZhcnlpbmcgZmxvYXQgdl9wbGFjZWQ7dmFyeWluZyBmbG9hdCB2X25vdFVzZWQ7dm9pZCBtYWluKCkge3ZlYzQgcHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX2FuY2hvcl9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgY29sbGlzaW9uX3BlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqKHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlKSwwLjAsNC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAuMCwxLjApO2dsX1Bvc2l0aW9uLnh5Kz0oYV9leHRydWRlK2Ffc2hpZnQpKnVfZXh0cnVkZV9zY2FsZSpnbF9Qb3NpdGlvbi53KmNvbGxpc2lvbl9wZXJzcGVjdGl2ZV9yYXRpbzt2X3BsYWNlZD1hX3BsYWNlZC54O3Zfbm90VXNlZD1hX3BsYWNlZC55O31cIiksXG4gICAgICAkZSA9IGdpKFwidmFyeWluZyBmbG9hdCB2X3JhZGl1czt2YXJ5aW5nIHZlYzIgdl9leHRydWRlO3ZhcnlpbmcgZmxvYXQgdl9wZXJzcGVjdGl2ZV9yYXRpbzt2YXJ5aW5nIGZsb2F0IHZfY29sbGlzaW9uO3ZvaWQgbWFpbigpIHtmbG9hdCBhbHBoYT0wLjUqbWluKHZfcGVyc3BlY3RpdmVfcmF0aW8sMS4wKTtmbG9hdCBzdHJva2VfcmFkaXVzPTAuOSptYXgodl9wZXJzcGVjdGl2ZV9yYXRpbywxLjApO2Zsb2F0IGRpc3RhbmNlX3RvX2NlbnRlcj1sZW5ndGgodl9leHRydWRlKTtmbG9hdCBkaXN0YW5jZV90b19lZGdlPWFicyhkaXN0YW5jZV90b19jZW50ZXItdl9yYWRpdXMpO2Zsb2F0IG9wYWNpdHlfdD1zbW9vdGhzdGVwKC1zdHJva2VfcmFkaXVzLDAuMCwtZGlzdGFuY2VfdG9fZWRnZSk7dmVjNCBjb2xvcj1taXgodmVjNCgwLjAsMC4wLDEuMCwwLjUpLHZlYzQoMS4wLDAuMCwwLjAsMS4wKSx2X2NvbGxpc2lvbik7Z2xfRnJhZ0NvbG9yPWNvbG9yKmFscGhhKm9wYWNpdHlfdDt9XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzO2F0dHJpYnV0ZSB2ZWMyIGFfZmxhZ3M7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWF0NCB1X2ludl9tYXRyaXg7dW5pZm9ybSB2ZWMyIHVfdmlld3BvcnRfc2l6ZTt1bmlmb3JtIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt2YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO3ZhcnlpbmcgdmVjMiB2X2V4dHJ1ZGU7dmFyeWluZyBmbG9hdCB2X3BlcnNwZWN0aXZlX3JhdGlvO3ZhcnlpbmcgZmxvYXQgdl9jb2xsaXNpb247dmVjMyB0b1RpbGVQb3NpdGlvbih2ZWMyIHNjcmVlblBvcykge3ZlYzQgcmF5U3RhcnQ9dV9pbnZfbWF0cml4KnZlYzQoc2NyZWVuUG9zLC0xLjAsMS4wKTt2ZWM0IHJheUVuZCAgPXVfaW52X21hdHJpeCp2ZWM0KHNjcmVlblBvcywgMS4wLDEuMCk7cmF5U3RhcnQueHl6Lz1yYXlTdGFydC53O3JheUVuZC54eXogIC89cmF5RW5kLnc7aGlnaHAgZmxvYXQgdD0oMC4wLXJheVN0YXJ0LnopLyhyYXlFbmQuei1yYXlTdGFydC56KTtyZXR1cm4gbWl4KHJheVN0YXJ0Lnh5eixyYXlFbmQueHl6LHQpO312b2lkIG1haW4oKSB7dmVjMiBxdWFkQ2VudGVyUG9zPWFfcG9zO2Zsb2F0IHJhZGl1cz1hX3JhZGl1cztmbG9hdCBjb2xsaXNpb249YV9mbGFncy54O2Zsb2F0IHZlcnRleElkeD1hX2ZsYWdzLnk7dmVjMiBxdWFkVmVydGV4T2Zmc2V0PXZlYzIobWl4KC0xLjAsMS4wLGZsb2F0KHZlcnRleElkeCA+PTIuMCkpLG1peCgtMS4wLDEuMCxmbG9hdCh2ZXJ0ZXhJZHggPj0xLjAgJiYgdmVydGV4SWR4IDw9Mi4wKSkpO3ZlYzIgcXVhZFZlcnRleEV4dGVudD1xdWFkVmVydGV4T2Zmc2V0KnJhZGl1czt2ZWMzIHRpbGVQb3M9dG9UaWxlUG9zaXRpb24ocXVhZENlbnRlclBvcyk7dmVjNCBjbGlwUG9zPXVfbWF0cml4KnZlYzQodGlsZVBvcywxLjApO2hpZ2hwIGZsb2F0IGNhbWVyYV90b19hbmNob3JfZGlzdGFuY2U9Y2xpcFBvcy53O2hpZ2hwIGZsb2F0IGNvbGxpc2lvbl9wZXJzcGVjdGl2ZV9yYXRpbz1jbGFtcCgwLjUrMC41Kih1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UvY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZSksMC4wLDQuMCk7ZmxvYXQgcGFkZGluZ19mYWN0b3I9MS4yO3ZfcmFkaXVzPXJhZGl1czt2X2V4dHJ1ZGU9cXVhZFZlcnRleEV4dGVudCpwYWRkaW5nX2ZhY3Rvcjt2X3BlcnNwZWN0aXZlX3JhdGlvPWNvbGxpc2lvbl9wZXJzcGVjdGl2ZV9yYXRpbzt2X2NvbGxpc2lvbj1jb2xsaXNpb247Z2xfUG9zaXRpb249dmVjNChjbGlwUG9zLnh5ei9jbGlwUG9zLncsMS4wKSt2ZWM0KHF1YWRWZXJ0ZXhFeHRlbnQqcGFkZGluZ19mYWN0b3IvdV92aWV3cG9ydF9zaXplKjIuMCwwLjAsMC4wKTt9XCIpLFxuICAgICAgdGkgPSBnaShcInVuaWZvcm0gaGlnaHAgdmVjNCB1X2NvbG9yO3VuaWZvcm0gc2FtcGxlcjJEIHVfb3ZlcmxheTt2YXJ5aW5nIHZlYzIgdl91djt2b2lkIG1haW4oKSB7dmVjNCBvdmVybGF5X2NvbG9yPXRleHR1cmUyRCh1X292ZXJsYXksdl91dik7Z2xfRnJhZ0NvbG9yPW1peCh1X2NvbG9yLG92ZXJsYXlfY29sb3Isb3ZlcmxheV9jb2xvci5hKTt9XCIsIFwiYXR0cmlidXRlIHZlYzIgYV9wb3M7dmFyeWluZyB2ZWMyIHZfdXY7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gZmxvYXQgdV9vdmVybGF5X3NjYWxlO3ZvaWQgbWFpbigpIHt2X3V2PWFfcG9zLzgxOTIuMDtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zKnVfb3ZlcmxheV9zY2FsZSwwLDEpO31cIiksXG4gICAgICBlaSA9IGdpKFwiI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX0ZyYWdDb2xvcj1jb2xvcipvcGFjaXR5O1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvczt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmdsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt9XCIpLFxuICAgICAgaWkgPSBnaShcInZhcnlpbmcgdmVjMiB2X3BvcztcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgb3V0bGluZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgb3V0bGluZV9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmZsb2F0IGRpc3Q9bGVuZ3RoKHZfcG9zLWdsX0ZyYWdDb29yZC54eSk7ZmxvYXQgYWxwaGE9MS4wLXNtb290aHN0ZXAoMC4wLDEuMCxkaXN0KTtnbF9GcmFnQ29sb3I9b3V0bGluZV9jb2xvciooYWxwaGEqb3BhY2l0eSk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV93b3JsZDt2YXJ5aW5nIHZlYzIgdl9wb3M7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IG91dGxpbmVfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IG91dGxpbmVfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5nbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAsMSk7dl9wb3M9KGdsX1Bvc2l0aW9uLnh5L2dsX1Bvc2l0aW9uLncrMS4wKS8yLjAqdV93b3JsZDt9XCIpLFxuICAgICAgb2kgPSBnaShcInVuaWZvcm0gdmVjMiB1X3RleHNpemU7dW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTt1bmlmb3JtIGZsb2F0IHVfZmFkZTt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2YXJ5aW5nIHZlYzIgdl9wb3M7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX3RvXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl90b1xcbnZlYzIgcGF0dGVybl90bF9hPXBhdHRlcm5fZnJvbS54eTt2ZWMyIHBhdHRlcm5fYnJfYT1wYXR0ZXJuX2Zyb20uenc7dmVjMiBwYXR0ZXJuX3RsX2I9cGF0dGVybl90by54eTt2ZWMyIHBhdHRlcm5fYnJfYj1wYXR0ZXJuX3RvLnp3O3ZlYzIgaW1hZ2Vjb29yZD1tb2Qodl9wb3NfYSwxLjApO3ZlYzIgcG9zPW1peChwYXR0ZXJuX3RsX2EvdV90ZXhzaXplLHBhdHRlcm5fYnJfYS91X3RleHNpemUsaW1hZ2Vjb29yZCk7dmVjNCBjb2xvcjE9dGV4dHVyZTJEKHVfaW1hZ2UscG9zKTt2ZWMyIGltYWdlY29vcmRfYj1tb2Qodl9wb3NfYiwxLjApO3ZlYzIgcG9zMj1taXgocGF0dGVybl90bF9iL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2IvdV90ZXhzaXplLGltYWdlY29vcmRfYik7dmVjNCBjb2xvcjI9dGV4dHVyZTJEKHVfaW1hZ2UscG9zMik7ZmxvYXQgZGlzdD1sZW5ndGgodl9wb3MtZ2xfRnJhZ0Nvb3JkLnh5KTtmbG9hdCBhbHBoYT0xLjAtc21vb3Roc3RlcCgwLjAsMS4wLGRpc3QpO2dsX0ZyYWdDb2xvcj1taXgoY29sb3IxLGNvbG9yMix1X2ZhZGUpKmFscGhhKm9wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV93b3JsZDt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF91cHBlcjt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF9sb3dlcjt1bmlmb3JtIHZlYzMgdV9zY2FsZTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2YXJ5aW5nIHZlYzIgdl9wb3M7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZlYzIgcGF0dGVybl90bF9hPXBhdHRlcm5fZnJvbS54eTt2ZWMyIHBhdHRlcm5fYnJfYT1wYXR0ZXJuX2Zyb20uenc7dmVjMiBwYXR0ZXJuX3RsX2I9cGF0dGVybl90by54eTt2ZWMyIHBhdHRlcm5fYnJfYj1wYXR0ZXJuX3RvLnp3O2Zsb2F0IHRpbGVSYXRpbz11X3NjYWxlLng7ZmxvYXQgZnJvbVNjYWxlPXVfc2NhbGUueTtmbG9hdCB0b1NjYWxlPXVfc2NhbGUuejtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KGFfcG9zLDAsMSk7dmVjMiBkaXNwbGF5X3NpemVfYT0ocGF0dGVybl9icl9hLXBhdHRlcm5fdGxfYSkvcGl4ZWxfcmF0aW9fZnJvbTt2ZWMyIGRpc3BsYXlfc2l6ZV9iPShwYXR0ZXJuX2JyX2ItcGF0dGVybl90bF9iKS9waXhlbF9yYXRpb190bzt2X3Bvc19hPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsZnJvbVNjYWxlKmRpc3BsYXlfc2l6ZV9hLHRpbGVSYXRpbyxhX3Bvcyk7dl9wb3NfYj1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLHRvU2NhbGUqZGlzcGxheV9zaXplX2IsdGlsZVJhdGlvLGFfcG9zKTt2X3Bvcz0oZ2xfUG9zaXRpb24ueHkvZ2xfUG9zaXRpb24udysxLjApLzIuMCp1X3dvcmxkO31cIiksXG4gICAgICByaSA9IGdpKFwidW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIGZsb2F0IHVfZmFkZTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvc19hO3ZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgcGF0dGVybl90b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dzt2ZWMyIGltYWdlY29vcmQ9bW9kKHZfcG9zX2EsMS4wKTt2ZWMyIHBvcz1taXgocGF0dGVybl90bF9hL3VfdGV4c2l6ZSxwYXR0ZXJuX2JyX2EvdV90ZXhzaXplLGltYWdlY29vcmQpO3ZlYzQgY29sb3IxPXRleHR1cmUyRCh1X2ltYWdlLHBvcyk7dmVjMiBpbWFnZWNvb3JkX2I9bW9kKHZfcG9zX2IsMS4wKTt2ZWMyIHBvczI9bWl4KHBhdHRlcm5fdGxfYi91X3RleHNpemUscGF0dGVybl9icl9iL3VfdGV4c2l6ZSxpbWFnZWNvb3JkX2IpO3ZlYzQgY29sb3IyPXRleHR1cmUyRCh1X2ltYWdlLHBvczIpO2dsX0ZyYWdDb2xvcj1taXgoY29sb3IxLGNvbG9yMix1X2ZhZGUpKm9wYWNpdHk7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcInVuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF91cHBlcjt1bmlmb3JtIHZlYzIgdV9waXhlbF9jb29yZF9sb3dlcjt1bmlmb3JtIHZlYzMgdV9zY2FsZTthdHRyaWJ1dGUgdmVjMiBhX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7ZmxvYXQgdGlsZVpvb21SYXRpbz11X3NjYWxlLng7ZmxvYXQgZnJvbVNjYWxlPXVfc2NhbGUueTtmbG9hdCB0b1NjYWxlPXVfc2NhbGUuejt2ZWMyIGRpc3BsYXlfc2l6ZV9hPShwYXR0ZXJuX2JyX2EtcGF0dGVybl90bF9hKS9waXhlbF9yYXRpb19mcm9tO3ZlYzIgZGlzcGxheV9zaXplX2I9KHBhdHRlcm5fYnJfYi1wYXR0ZXJuX3RsX2IpL3BpeGVsX3JhdGlvX3RvO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvc19hPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsZnJvbVNjYWxlKmRpc3BsYXlfc2l6ZV9hLHRpbGVab29tUmF0aW8sYV9wb3MpO3ZfcG9zX2I9Z2V0X3BhdHRlcm5fcG9zKHVfcGl4ZWxfY29vcmRfdXBwZXIsdV9waXhlbF9jb29yZF9sb3dlcix0b1NjYWxlKmRpc3BsYXlfc2l6ZV9iLHRpbGVab29tUmF0aW8sYV9wb3MpO31cIiksXG4gICAgICBhaSA9IGdpKFwidmFyeWluZyB2ZWM0IHZfY29sb3I7dm9pZCBtYWluKCkge2dsX0ZyYWdDb2xvcj12X2NvbG9yO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSB2ZWMzIHVfbGlnaHRjb2xvcjt1bmlmb3JtIGxvd3AgdmVjMyB1X2xpZ2h0cG9zO3VuaWZvcm0gbG93cCBmbG9hdCB1X2xpZ2h0aW50ZW5zaXR5O3VuaWZvcm0gZmxvYXQgdV92ZXJ0aWNhbF9ncmFkaWVudDt1bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO2F0dHJpYnV0ZSB2ZWM0IGFfbm9ybWFsX2VkO3ZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgZmxvYXQgaGVpZ2h0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIGZsb2F0IGJhc2VcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxudmVjMyBub3JtYWw9YV9ub3JtYWxfZWQueHl6O2Jhc2U9bWF4KDAuMCxiYXNlKTtoZWlnaHQ9bWF4KDAuMCxoZWlnaHQpO2Zsb2F0IHQ9bW9kKG5vcm1hbC54LDIuMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3Bvcyx0ID4gMC4wID8gaGVpZ2h0IDogYmFzZSwxKTtmbG9hdCBjb2xvcnZhbHVlPWNvbG9yLnIqMC4yMTI2K2NvbG9yLmcqMC43MTUyK2NvbG9yLmIqMC4wNzIyO3ZfY29sb3I9dmVjNCgwLjAsMC4wLDAuMCwxLjApO3ZlYzQgYW1iaWVudGxpZ2h0PXZlYzQoMC4wMywwLjAzLDAuMDMsMS4wKTtjb2xvcis9YW1iaWVudGxpZ2h0O2Zsb2F0IGRpcmVjdGlvbmFsPWNsYW1wKGRvdChub3JtYWwvMTYzODQuMCx1X2xpZ2h0cG9zKSwwLjAsMS4wKTtkaXJlY3Rpb25hbD1taXgoKDEuMC11X2xpZ2h0aW50ZW5zaXR5KSxtYXgoKDEuMC1jb2xvcnZhbHVlK3VfbGlnaHRpbnRlbnNpdHkpLDEuMCksZGlyZWN0aW9uYWwpO2lmIChub3JtYWwueSAhPTAuMCkge2RpcmVjdGlvbmFsKj0oKDEuMC11X3ZlcnRpY2FsX2dyYWRpZW50KSsodV92ZXJ0aWNhbF9ncmFkaWVudCpjbGFtcCgodCtiYXNlKSpwb3coaGVpZ2h0LzE1MC4wLDAuNSksbWl4KDAuNywwLjk4LDEuMC11X2xpZ2h0aW50ZW5zaXR5KSwxLjApKSk7fXZfY29sb3Iucis9Y2xhbXAoY29sb3IucipkaXJlY3Rpb25hbCp1X2xpZ2h0Y29sb3IucixtaXgoMC4wLDAuMywxLjAtdV9saWdodGNvbG9yLnIpLDEuMCk7dl9jb2xvci5nKz1jbGFtcChjb2xvci5nKmRpcmVjdGlvbmFsKnVfbGlnaHRjb2xvci5nLG1peCgwLjAsMC4zLDEuMC11X2xpZ2h0Y29sb3IuZyksMS4wKTt2X2NvbG9yLmIrPWNsYW1wKGNvbG9yLmIqZGlyZWN0aW9uYWwqdV9saWdodGNvbG9yLmIsbWl4KDAuMCwwLjMsMS4wLXVfbGlnaHRjb2xvci5iKSwxLjApO3ZfY29sb3IqPXVfb3BhY2l0eTt9XCIpLFxuICAgICAgbmkgPSBnaShcInVuaWZvcm0gdmVjMiB1X3RleHNpemU7dW5pZm9ybSBmbG9hdCB1X2ZhZGU7dW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTt2YXJ5aW5nIHZlYzIgdl9wb3NfYTt2YXJ5aW5nIHZlYzIgdl9wb3NfYjt2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmFzZVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBiYXNlXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoZWlnaHRcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl9mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX3RvXFxudmVjMiBwYXR0ZXJuX3RsX2E9cGF0dGVybl9mcm9tLnh5O3ZlYzIgcGF0dGVybl9icl9hPXBhdHRlcm5fZnJvbS56dzt2ZWMyIHBhdHRlcm5fdGxfYj1wYXR0ZXJuX3RvLnh5O3ZlYzIgcGF0dGVybl9icl9iPXBhdHRlcm5fdG8uenc7dmVjMiBpbWFnZWNvb3JkPW1vZCh2X3Bvc19hLDEuMCk7dmVjMiBwb3M9bWl4KHBhdHRlcm5fdGxfYS91X3RleHNpemUscGF0dGVybl9icl9hL3VfdGV4c2l6ZSxpbWFnZWNvb3JkKTt2ZWM0IGNvbG9yMT10ZXh0dXJlMkQodV9pbWFnZSxwb3MpO3ZlYzIgaW1hZ2Vjb29yZF9iPW1vZCh2X3Bvc19iLDEuMCk7dmVjMiBwb3MyPW1peChwYXR0ZXJuX3RsX2IvdV90ZXhzaXplLHBhdHRlcm5fYnJfYi91X3RleHNpemUsaW1hZ2Vjb29yZF9iKTt2ZWM0IGNvbG9yMj10ZXh0dXJlMkQodV9pbWFnZSxwb3MyKTt2ZWM0IG1peGVkQ29sb3I9bWl4KGNvbG9yMSxjb2xvcjIsdV9mYWRlKTtnbF9GcmFnQ29sb3I9bWl4ZWRDb2xvcip2X2xpZ2h0aW5nO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfdXBwZXI7dW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfbG93ZXI7dW5pZm9ybSBmbG9hdCB1X2hlaWdodF9mYWN0b3I7dW5pZm9ybSB2ZWMzIHVfc2NhbGU7dW5pZm9ybSBmbG9hdCB1X3ZlcnRpY2FsX2dyYWRpZW50O3VuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7dW5pZm9ybSB2ZWMzIHVfbGlnaHRjb2xvcjt1bmlmb3JtIGxvd3AgdmVjMyB1X2xpZ2h0cG9zO3VuaWZvcm0gbG93cCBmbG9hdCB1X2xpZ2h0aW50ZW5zaXR5O2F0dHJpYnV0ZSB2ZWMyIGFfcG9zO2F0dHJpYnV0ZSB2ZWM0IGFfbm9ybWFsX2VkO3ZhcnlpbmcgdmVjMiB2X3Bvc19hO3ZhcnlpbmcgdmVjMiB2X3Bvc19iO3ZhcnlpbmcgdmVjNCB2X2xpZ2h0aW5nO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBiYXNlXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhlaWdodFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJhc2VcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGhlaWdodFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52ZWMyIHBhdHRlcm5fdGxfYT1wYXR0ZXJuX2Zyb20ueHk7dmVjMiBwYXR0ZXJuX2JyX2E9cGF0dGVybl9mcm9tLnp3O3ZlYzIgcGF0dGVybl90bF9iPXBhdHRlcm5fdG8ueHk7dmVjMiBwYXR0ZXJuX2JyX2I9cGF0dGVybl90by56dztmbG9hdCB0aWxlUmF0aW89dV9zY2FsZS54O2Zsb2F0IGZyb21TY2FsZT11X3NjYWxlLnk7ZmxvYXQgdG9TY2FsZT11X3NjYWxlLno7dmVjMyBub3JtYWw9YV9ub3JtYWxfZWQueHl6O2Zsb2F0IGVkZ2VkaXN0YW5jZT1hX25vcm1hbF9lZC53O3ZlYzIgZGlzcGxheV9zaXplX2E9KHBhdHRlcm5fYnJfYS1wYXR0ZXJuX3RsX2EpL3BpeGVsX3JhdGlvX2Zyb207dmVjMiBkaXNwbGF5X3NpemVfYj0ocGF0dGVybl9icl9iLXBhdHRlcm5fdGxfYikvcGl4ZWxfcmF0aW9fdG87YmFzZT1tYXgoMC4wLGJhc2UpO2hlaWdodD1tYXgoMC4wLGhlaWdodCk7ZmxvYXQgdD1tb2Qobm9ybWFsLngsMi4wKTtmbG9hdCB6PXQgPiAwLjAgPyBoZWlnaHQgOiBiYXNlO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MseiwxKTt2ZWMyIHBvcz1ub3JtYWwueD09MS4wICYmIG5vcm1hbC55PT0wLjAgJiYgbm9ybWFsLno9PTE2Mzg0LjBcXG4/IGFfcG9zXFxuOiB2ZWMyKGVkZ2VkaXN0YW5jZSx6KnVfaGVpZ2h0X2ZhY3Rvcik7dl9wb3NfYT1nZXRfcGF0dGVybl9wb3ModV9waXhlbF9jb29yZF91cHBlcix1X3BpeGVsX2Nvb3JkX2xvd2VyLGZyb21TY2FsZSpkaXNwbGF5X3NpemVfYSx0aWxlUmF0aW8scG9zKTt2X3Bvc19iPWdldF9wYXR0ZXJuX3Bvcyh1X3BpeGVsX2Nvb3JkX3VwcGVyLHVfcGl4ZWxfY29vcmRfbG93ZXIsdG9TY2FsZSpkaXNwbGF5X3NpemVfYix0aWxlUmF0aW8scG9zKTt2X2xpZ2h0aW5nPXZlYzQoMC4wLDAuMCwwLjAsMS4wKTtmbG9hdCBkaXJlY3Rpb25hbD1jbGFtcChkb3Qobm9ybWFsLzE2MzgzLjAsdV9saWdodHBvcyksMC4wLDEuMCk7ZGlyZWN0aW9uYWw9bWl4KCgxLjAtdV9saWdodGludGVuc2l0eSksbWF4KCgwLjUrdV9saWdodGludGVuc2l0eSksMS4wKSxkaXJlY3Rpb25hbCk7aWYgKG5vcm1hbC55ICE9MC4wKSB7ZGlyZWN0aW9uYWwqPSgoMS4wLXVfdmVydGljYWxfZ3JhZGllbnQpKyh1X3ZlcnRpY2FsX2dyYWRpZW50KmNsYW1wKCh0K2Jhc2UpKnBvdyhoZWlnaHQvMTUwLjAsMC41KSxtaXgoMC43LDAuOTgsMS4wLXVfbGlnaHRpbnRlbnNpdHkpLDEuMCkpKTt9dl9saWdodGluZy5yZ2IrPWNsYW1wKGRpcmVjdGlvbmFsKnVfbGlnaHRjb2xvcixtaXgodmVjMygwLjApLHZlYzMoMC4zKSwxLjAtdV9saWdodGNvbG9yKSx2ZWMzKDEuMCkpO3ZfbGlnaHRpbmcqPXVfb3BhY2l0eTt9XCIpLFxuICAgICAgc2kgPSBnaShcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X3Bvczt1bmlmb3JtIHZlYzIgdV9kaW1lbnNpb247dW5pZm9ybSBmbG9hdCB1X3pvb207dW5pZm9ybSB2ZWM0IHVfdW5wYWNrO2Zsb2F0IGdldEVsZXZhdGlvbih2ZWMyIGNvb3JkLGZsb2F0IGJpYXMpIHt2ZWM0IGRhdGE9dGV4dHVyZTJEKHVfaW1hZ2UsY29vcmQpKjI1NS4wO2RhdGEuYT0tMS4wO3JldHVybiBkb3QoZGF0YSx1X3VucGFjaykvNC4wO312b2lkIG1haW4oKSB7dmVjMiBlcHNpbG9uPTEuMC91X2RpbWVuc2lvbjtmbG9hdCBhPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKC1lcHNpbG9uLngsLWVwc2lsb24ueSksMC4wKTtmbG9hdCBiPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKDAsLWVwc2lsb24ueSksMC4wKTtmbG9hdCBjPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKGVwc2lsb24ueCwtZXBzaWxvbi55KSwwLjApO2Zsb2F0IGQ9Z2V0RWxldmF0aW9uKHZfcG9zK3ZlYzIoLWVwc2lsb24ueCwwKSwwLjApO2Zsb2F0IGU9Z2V0RWxldmF0aW9uKHZfcG9zLDAuMCk7ZmxvYXQgZj1nZXRFbGV2YXRpb24odl9wb3MrdmVjMihlcHNpbG9uLngsMCksMC4wKTtmbG9hdCBnPWdldEVsZXZhdGlvbih2X3Bvcyt2ZWMyKC1lcHNpbG9uLngsZXBzaWxvbi55KSwwLjApO2Zsb2F0IGg9Z2V0RWxldmF0aW9uKHZfcG9zK3ZlYzIoMCxlcHNpbG9uLnkpLDAuMCk7ZmxvYXQgaT1nZXRFbGV2YXRpb24odl9wb3MrdmVjMihlcHNpbG9uLngsZXBzaWxvbi55KSwwLjApO2Zsb2F0IGV4YWdnZXJhdGlvbkZhY3Rvcj11X3pvb20gPCAyLjAgPyAwLjQgOiB1X3pvb20gPCA0LjUgPyAwLjM1IDogMC4zO2Zsb2F0IGV4YWdnZXJhdGlvbj11X3pvb20gPCAxNS4wID8gKHVfem9vbS0xNS4wKSpleGFnZ2VyYXRpb25GYWN0b3IgOiAwLjA7dmVjMiBkZXJpdj12ZWMyKChjK2YrZitpKS0oYStkK2QrZyksKGcraCtoK2kpLShhK2IrYitjKSkvcG93KDIuMCxleGFnZ2VyYXRpb24rKDE5LjI1NjItdV96b29tKSk7Z2xfRnJhZ0NvbG9yPWNsYW1wKHZlYzQoZGVyaXYueC8yLjArMC41LGRlcml2LnkvMi4wKzAuNSwxLjAsMS4wKSwwLjAsMS4wKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X2RpbWVuc2lvbjthdHRyaWJ1dGUgdmVjMiBhX3BvczthdHRyaWJ1dGUgdmVjMiBhX3RleHR1cmVfcG9zO3ZhcnlpbmcgdmVjMiB2X3Bvczt2b2lkIG1haW4oKSB7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2hpZ2hwIHZlYzIgZXBzaWxvbj0xLjAvdV9kaW1lbnNpb247ZmxvYXQgc2NhbGU9KHVfZGltZW5zaW9uLngtMi4wKS91X2RpbWVuc2lvbi54O3ZfcG9zPShhX3RleHR1cmVfcG9zLzgxOTIuMCkqc2NhbGUrZXBzaWxvbjt9XCIpLFxuICAgICAgbGkgPSBnaShcInVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfcG9zO3VuaWZvcm0gdmVjMiB1X2xhdHJhbmdlO3VuaWZvcm0gdmVjMiB1X2xpZ2h0O3VuaWZvcm0gdmVjNCB1X3NoYWRvdzt1bmlmb3JtIHZlYzQgdV9oaWdobGlnaHQ7dW5pZm9ybSB2ZWM0IHVfYWNjZW50O1xcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTNcXG52b2lkIG1haW4oKSB7dmVjNCBwaXhlbD10ZXh0dXJlMkQodV9pbWFnZSx2X3Bvcyk7dmVjMiBkZXJpdj0oKHBpeGVsLnJnKjIuMCktMS4wKTtmbG9hdCBzY2FsZUZhY3Rvcj1jb3MocmFkaWFucygodV9sYXRyYW5nZVswXS11X2xhdHJhbmdlWzFdKSooMS4wLXZfcG9zLnkpK3VfbGF0cmFuZ2VbMV0pKTtmbG9hdCBzbG9wZT1hdGFuKDEuMjUqbGVuZ3RoKGRlcml2KS9zY2FsZUZhY3Rvcik7ZmxvYXQgYXNwZWN0PWRlcml2LnggIT0wLjAgPyBhdGFuKGRlcml2LnksLWRlcml2LngpIDogUEkvMi4wKihkZXJpdi55ID4gMC4wID8gMS4wIDotMS4wKTtmbG9hdCBpbnRlbnNpdHk9dV9saWdodC54O2Zsb2F0IGF6aW11dGg9dV9saWdodC55K1BJO2Zsb2F0IGJhc2U9MS44NzUtaW50ZW5zaXR5KjEuNzU7ZmxvYXQgbWF4VmFsdWU9MC41KlBJO2Zsb2F0IHNjYWxlZFNsb3BlPWludGVuc2l0eSAhPTAuNSA/ICgocG93KGJhc2Usc2xvcGUpLTEuMCkvKHBvdyhiYXNlLG1heFZhbHVlKS0xLjApKSptYXhWYWx1ZSA6IHNsb3BlO2Zsb2F0IGFjY2VudD1jb3Moc2NhbGVkU2xvcGUpO3ZlYzQgYWNjZW50X2NvbG9yPSgxLjAtYWNjZW50KSp1X2FjY2VudCpjbGFtcChpbnRlbnNpdHkqMi4wLDAuMCwxLjApO2Zsb2F0IHNoYWRlPWFicyhtb2QoKGFzcGVjdCthemltdXRoKS9QSSswLjUsMi4wKS0xLjApO3ZlYzQgc2hhZGVfY29sb3I9bWl4KHVfc2hhZG93LHVfaGlnaGxpZ2h0LHNoYWRlKSpzaW4oc2NhbGVkU2xvcGUpKmNsYW1wKGludGVuc2l0eSoyLjAsMC4wLDEuMCk7Z2xfRnJhZ0NvbG9yPWFjY2VudF9jb2xvciooMS4wLXNoYWRlX2NvbG9yLmEpK3NoYWRlX2NvbG9yO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJ1bmlmb3JtIG1hdDQgdV9tYXRyaXg7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3M7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3Bvcz1hX3RleHR1cmVfcG9zLzgxOTIuMDt9XCIpLFxuICAgICAgY2kgPSBnaShcInVuaWZvcm0gbG93cCBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbzt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5mbG9hdCBkaXN0PWxlbmd0aCh2X25vcm1hbCkqdl93aWR0aDIucztmbG9hdCBibHVyMj0oYmx1cisxLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8pKnZfZ2FtbWFfc2NhbGU7ZmxvYXQgYWxwaGE9Y2xhbXAobWluKGRpc3QtKHZfd2lkdGgyLnQtYmx1cjIpLHZfd2lkdGgyLnMtZGlzdCkvYmx1cjIsMC4wLDEuMCk7Z2xfRnJhZ0NvbG9yPWNvbG9yKihhbHBoYSpvcGFjaXR5KTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiXFxuI2RlZmluZSBzY2FsZSAwLjAxNTg3MzAxNlxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zX25vcm1hbDthdHRyaWJ1dGUgdmVjNCBhX2RhdGE7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3JhdGlvO3VuaWZvcm0gdmVjMiB1X3VuaXRzX3RvX3BpeGVsczt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCBmbG9hdCB2X2xpbmVzb2ZhcjtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IGdhcHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9mZnNldFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7dl9saW5lc29mYXI9KGZsb29yKGFfZGF0YS56LzQuMCkrYV9kYXRhLncqNjQuMCkqMi4wO3ZlYzIgcG9zPWZsb29yKGFfcG9zX25vcm1hbCowLjUpO21lZGl1bXAgdmVjMiBub3JtYWw9YV9wb3Nfbm9ybWFsLTIuMCpwb3M7bm9ybWFsLnk9bm9ybWFsLnkqMi4wLTEuMDt2X25vcm1hbD1ub3JtYWw7Z2Fwd2lkdGg9Z2Fwd2lkdGgvMi4wO2Zsb2F0IGhhbGZ3aWR0aD13aWR0aC8yLjA7b2Zmc2V0PS0xLjAqb2Zmc2V0O2Zsb2F0IGluc2V0PWdhcHdpZHRoKyhnYXB3aWR0aCA+IDAuMCA/IEFOVElBTElBU0lORyA6IDAuMCk7ZmxvYXQgb3V0c2V0PWdhcHdpZHRoK2hhbGZ3aWR0aCooZ2Fwd2lkdGggPiAwLjAgPyAyLjAgOiAxLjApKyhoYWxmd2lkdGg9PTAuMCA/IDAuMCA6IEFOVElBTElBU0lORyk7bWVkaXVtcCB2ZWMyIGRpc3Q9b3V0c2V0KmFfZXh0cnVkZSpzY2FsZTttZWRpdW1wIGZsb2F0IHU9MC41KmFfZGlyZWN0aW9uO21lZGl1bXAgZmxvYXQgdD0xLjAtYWJzKHUpO21lZGl1bXAgdmVjMiBvZmZzZXQyPW9mZnNldCphX2V4dHJ1ZGUqc2NhbGUqbm9ybWFsLnkqbWF0Mih0LC11LHUsdCk7dmVjNCBwcm9qZWN0ZWRfZXh0cnVkZT11X21hdHJpeCp2ZWM0KGRpc3QvdV9yYXRpbywwLjAsMC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KHBvcytvZmZzZXQyL3VfcmF0aW8sMC4wLDEuMCkrcHJvamVjdGVkX2V4dHJ1ZGU7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZT1sZW5ndGgoZGlzdCk7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZT1sZW5ndGgocHJvamVjdGVkX2V4dHJ1ZGUueHkvZ2xfUG9zaXRpb24udyp1X3VuaXRzX3RvX3BpeGVscyk7dl9nYW1tYV9zY2FsZT1leHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlL2V4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU7dl93aWR0aDI9dmVjMihvdXRzZXQsaW5zZXQpO31cIiksXG4gICAgICB1aSA9IGdpKFwidW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dmFyeWluZyB2ZWMyIHZfd2lkdGgyO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCB2ZWMyIHZfdXY7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5mbG9hdCBkaXN0PWxlbmd0aCh2X25vcm1hbCkqdl93aWR0aDIucztmbG9hdCBibHVyMj0oYmx1cisxLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8pKnZfZ2FtbWFfc2NhbGU7ZmxvYXQgYWxwaGE9Y2xhbXAobWluKGRpc3QtKHZfd2lkdGgyLnQtYmx1cjIpLHZfd2lkdGgyLnMtZGlzdCkvYmx1cjIsMC4wLDEuMCk7dmVjNCBjb2xvcj10ZXh0dXJlMkQodV9pbWFnZSx2X3V2KTtnbF9GcmFnQ29sb3I9Y29sb3IqKGFscGhhKm9wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuYXR0cmlidXRlIHZlYzIgYV9wb3Nfbm9ybWFsO2F0dHJpYnV0ZSB2ZWM0IGFfZGF0YTthdHRyaWJ1dGUgZmxvYXQgYV91dl94O2F0dHJpYnV0ZSBmbG9hdCBhX3NwbGl0X2luZGV4O3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbzt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSB2ZWMyIHVfdW5pdHNfdG9fcGl4ZWxzO3VuaWZvcm0gZmxvYXQgdV9pbWFnZV9oZWlnaHQ7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBoaWdocCB2ZWMyIHZfdXY7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7aGlnaHAgZmxvYXQgdGV4ZWxfaGVpZ2h0PTEuMC91X2ltYWdlX2hlaWdodDtoaWdocCBmbG9hdCBoYWxmX3RleGVsX2hlaWdodD0wLjUqdGV4ZWxfaGVpZ2h0O3ZfdXY9dmVjMihhX3V2X3gsYV9zcGxpdF9pbmRleCp0ZXhlbF9oZWlnaHQtaGFsZl90ZXhlbF9oZWlnaHQpO3ZlYzIgcG9zPWZsb29yKGFfcG9zX25vcm1hbCowLjUpO21lZGl1bXAgdmVjMiBub3JtYWw9YV9wb3Nfbm9ybWFsLTIuMCpwb3M7bm9ybWFsLnk9bm9ybWFsLnkqMi4wLTEuMDt2X25vcm1hbD1ub3JtYWw7Z2Fwd2lkdGg9Z2Fwd2lkdGgvMi4wO2Zsb2F0IGhhbGZ3aWR0aD13aWR0aC8yLjA7b2Zmc2V0PS0xLjAqb2Zmc2V0O2Zsb2F0IGluc2V0PWdhcHdpZHRoKyhnYXB3aWR0aCA+IDAuMCA/IEFOVElBTElBU0lORyA6IDAuMCk7ZmxvYXQgb3V0c2V0PWdhcHdpZHRoK2hhbGZ3aWR0aCooZ2Fwd2lkdGggPiAwLjAgPyAyLjAgOiAxLjApKyhoYWxmd2lkdGg9PTAuMCA/IDAuMCA6IEFOVElBTElBU0lORyk7bWVkaXVtcCB2ZWMyIGRpc3Q9b3V0c2V0KmFfZXh0cnVkZSpzY2FsZTttZWRpdW1wIGZsb2F0IHU9MC41KmFfZGlyZWN0aW9uO21lZGl1bXAgZmxvYXQgdD0xLjAtYWJzKHUpO21lZGl1bXAgdmVjMiBvZmZzZXQyPW9mZnNldCphX2V4dHJ1ZGUqc2NhbGUqbm9ybWFsLnkqbWF0Mih0LC11LHUsdCk7dmVjNCBwcm9qZWN0ZWRfZXh0cnVkZT11X21hdHJpeCp2ZWM0KGRpc3QvdV9yYXRpbywwLjAsMC4wKTtnbF9Qb3NpdGlvbj11X21hdHJpeCp2ZWM0KHBvcytvZmZzZXQyL3VfcmF0aW8sMC4wLDEuMCkrcHJvamVjdGVkX2V4dHJ1ZGU7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZT1sZW5ndGgoZGlzdCk7ZmxvYXQgZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZT1sZW5ndGgocHJvamVjdGVkX2V4dHJ1ZGUueHkvZ2xfUG9zaXRpb24udyp1X3VuaXRzX3RvX3BpeGVscyk7dl9nYW1tYV9zY2FsZT1leHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlL2V4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU7dl93aWR0aDI9dmVjMihvdXRzZXQsaW5zZXQpO31cIiksXG4gICAgICBoaSA9IGdpKFwidW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gdmVjMiB1X3RleHNpemU7dW5pZm9ybSBmbG9hdCB1X2ZhZGU7dW5pZm9ybSBtZWRpdW1wIHZlYzMgdV9zY2FsZTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyBmbG9hdCB2X2xpbmVzb2Zhcjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBmbG9hdCB2X3dpZHRoO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IHBhdHRlcm5fdG9cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCB2ZWM0IHBhdHRlcm5fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb19mcm9tXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBwaXhlbF9yYXRpb190b1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbnZlYzIgcGF0dGVybl90bF9hPXBhdHRlcm5fZnJvbS54eTt2ZWMyIHBhdHRlcm5fYnJfYT1wYXR0ZXJuX2Zyb20uenc7dmVjMiBwYXR0ZXJuX3RsX2I9cGF0dGVybl90by54eTt2ZWMyIHBhdHRlcm5fYnJfYj1wYXR0ZXJuX3RvLnp3O2Zsb2F0IHRpbGVab29tUmF0aW89dV9zY2FsZS54O2Zsb2F0IGZyb21TY2FsZT11X3NjYWxlLnk7ZmxvYXQgdG9TY2FsZT11X3NjYWxlLno7dmVjMiBkaXNwbGF5X3NpemVfYT0ocGF0dGVybl9icl9hLXBhdHRlcm5fdGxfYSkvcGl4ZWxfcmF0aW9fZnJvbTt2ZWMyIGRpc3BsYXlfc2l6ZV9iPShwYXR0ZXJuX2JyX2ItcGF0dGVybl90bF9iKS9waXhlbF9yYXRpb190bzt2ZWMyIHBhdHRlcm5fc2l6ZV9hPXZlYzIoZGlzcGxheV9zaXplX2EueCpmcm9tU2NhbGUvdGlsZVpvb21SYXRpbyxkaXNwbGF5X3NpemVfYS55KTt2ZWMyIHBhdHRlcm5fc2l6ZV9iPXZlYzIoZGlzcGxheV9zaXplX2IueCp0b1NjYWxlL3RpbGVab29tUmF0aW8sZGlzcGxheV9zaXplX2IueSk7ZmxvYXQgYXNwZWN0X2E9ZGlzcGxheV9zaXplX2EueS92X3dpZHRoO2Zsb2F0IGFzcGVjdF9iPWRpc3BsYXlfc2l6ZV9iLnkvdl93aWR0aDtmbG9hdCBkaXN0PWxlbmd0aCh2X25vcm1hbCkqdl93aWR0aDIucztmbG9hdCBibHVyMj0oYmx1cisxLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8pKnZfZ2FtbWFfc2NhbGU7ZmxvYXQgYWxwaGE9Y2xhbXAobWluKGRpc3QtKHZfd2lkdGgyLnQtYmx1cjIpLHZfd2lkdGgyLnMtZGlzdCkvYmx1cjIsMC4wLDEuMCk7ZmxvYXQgeF9hPW1vZCh2X2xpbmVzb2Zhci9wYXR0ZXJuX3NpemVfYS54KmFzcGVjdF9hLDEuMCk7ZmxvYXQgeF9iPW1vZCh2X2xpbmVzb2Zhci9wYXR0ZXJuX3NpemVfYi54KmFzcGVjdF9iLDEuMCk7ZmxvYXQgeT0wLjUqdl9ub3JtYWwueSswLjU7dmVjMiB0ZXhlbF9zaXplPTEuMC91X3RleHNpemU7dmVjMiBwb3NfYT1taXgocGF0dGVybl90bF9hKnRleGVsX3NpemUtdGV4ZWxfc2l6ZSxwYXR0ZXJuX2JyX2EqdGV4ZWxfc2l6ZSt0ZXhlbF9zaXplLHZlYzIoeF9hLHkpKTt2ZWMyIHBvc19iPW1peChwYXR0ZXJuX3RsX2IqdGV4ZWxfc2l6ZS10ZXhlbF9zaXplLHBhdHRlcm5fYnJfYip0ZXhlbF9zaXplK3RleGVsX3NpemUsdmVjMih4X2IseSkpO3ZlYzQgY29sb3I9bWl4KHRleHR1cmUyRCh1X2ltYWdlLHBvc19hKSx0ZXh0dXJlMkQodV9pbWFnZSxwb3NfYiksdV9mYWRlKTtnbF9GcmFnQ29sb3I9Y29sb3IqYWxwaGEqb3BhY2l0eTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwiXFxuI2RlZmluZSBzY2FsZSAwLjAxNTg3MzAxNlxcbiNkZWZpbmUgTElORV9ESVNUQU5DRV9TQ0FMRSAyLjBcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc19ub3JtYWw7YXR0cmlidXRlIHZlYzQgYV9kYXRhO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIHZlYzIgdV91bml0c190b19waXhlbHM7dW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfcmF0aW87dW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3ZhcnlpbmcgdmVjMiB2X25vcm1hbDt2YXJ5aW5nIHZlYzIgdl93aWR0aDI7dmFyeWluZyBmbG9hdCB2X2xpbmVzb2Zhcjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7dmFyeWluZyBmbG9hdCB2X3dpZHRoO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IGdhcHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBtZWRpdW1wIGZsb2F0IHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGZsb29yd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBwYXR0ZXJuX3RvXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IHBpeGVsX3JhdGlvX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IGdhcHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIG1lZGl1bXAgdmVjNCBwYXR0ZXJuX2Zyb21cXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIHZlYzQgcGF0dGVybl90b1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fZnJvbVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgcGl4ZWxfcmF0aW9fdG9cXG5mbG9hdCBBTlRJQUxJQVNJTkc9MS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvLzIuMDt2ZWMyIGFfZXh0cnVkZT1hX2RhdGEueHktMTI4LjA7ZmxvYXQgYV9kaXJlY3Rpb249bW9kKGFfZGF0YS56LDQuMCktMS4wO2Zsb2F0IGFfbGluZXNvZmFyPShmbG9vcihhX2RhdGEuei80LjApK2FfZGF0YS53KjY0LjApKkxJTkVfRElTVEFOQ0VfU0NBTEU7dmVjMiBwb3M9Zmxvb3IoYV9wb3Nfbm9ybWFsKjAuNSk7bWVkaXVtcCB2ZWMyIG5vcm1hbD1hX3Bvc19ub3JtYWwtMi4wKnBvcztub3JtYWwueT1ub3JtYWwueSoyLjAtMS4wO3Zfbm9ybWFsPW5vcm1hbDtnYXB3aWR0aD1nYXB3aWR0aC8yLjA7ZmxvYXQgaGFsZndpZHRoPXdpZHRoLzIuMDtvZmZzZXQ9LTEuMCpvZmZzZXQ7ZmxvYXQgaW5zZXQ9Z2Fwd2lkdGgrKGdhcHdpZHRoID4gMC4wID8gQU5USUFMSUFTSU5HIDogMC4wKTtmbG9hdCBvdXRzZXQ9Z2Fwd2lkdGgraGFsZndpZHRoKihnYXB3aWR0aCA+IDAuMCA/IDIuMCA6IDEuMCkrKGhhbGZ3aWR0aD09MC4wID8gMC4wIDogQU5USUFMSUFTSU5HKTttZWRpdW1wIHZlYzIgZGlzdD1vdXRzZXQqYV9leHRydWRlKnNjYWxlO21lZGl1bXAgZmxvYXQgdT0wLjUqYV9kaXJlY3Rpb247bWVkaXVtcCBmbG9hdCB0PTEuMC1hYnModSk7bWVkaXVtcCB2ZWMyIG9mZnNldDI9b2Zmc2V0KmFfZXh0cnVkZSpzY2FsZSpub3JtYWwueSptYXQyKHQsLXUsdSx0KTt2ZWM0IHByb2plY3RlZF9leHRydWRlPXVfbWF0cml4KnZlYzQoZGlzdC91X3JhdGlvLDAuMCwwLjApO2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQocG9zK29mZnNldDIvdV9yYXRpbywwLjAsMS4wKStwcm9qZWN0ZWRfZXh0cnVkZTtmbG9hdCBleHRydWRlX2xlbmd0aF93aXRob3V0X3BlcnNwZWN0aXZlPWxlbmd0aChkaXN0KTtmbG9hdCBleHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlPWxlbmd0aChwcm9qZWN0ZWRfZXh0cnVkZS54eS9nbF9Qb3NpdGlvbi53KnVfdW5pdHNfdG9fcGl4ZWxzKTt2X2dhbW1hX3NjYWxlPWV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmUvZXh0cnVkZV9sZW5ndGhfd2l0aF9wZXJzcGVjdGl2ZTt2X2xpbmVzb2Zhcj1hX2xpbmVzb2Zhcjt2X3dpZHRoMj12ZWMyKG91dHNldCxpbnNldCk7dl93aWR0aD1mbG9vcndpZHRoO31cIiksXG4gICAgICBwaSA9IGdpKFwidW5pZm9ybSBsb3dwIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO3VuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7dW5pZm9ybSBmbG9hdCB1X3NkZmdhbW1hO3VuaWZvcm0gZmxvYXQgdV9taXg7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIHZlYzIgdl90ZXhfYTt2YXJ5aW5nIHZlYzIgdl90ZXhfYjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBmbG9vcndpZHRoXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHdpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBmbG9vcndpZHRoXFxuZmxvYXQgZGlzdD1sZW5ndGgodl9ub3JtYWwpKnZfd2lkdGgyLnM7ZmxvYXQgYmx1cjI9KGJsdXIrMS4wL3VfZGV2aWNlX3BpeGVsX3JhdGlvKSp2X2dhbW1hX3NjYWxlO2Zsb2F0IGFscGhhPWNsYW1wKG1pbihkaXN0LSh2X3dpZHRoMi50LWJsdXIyKSx2X3dpZHRoMi5zLWRpc3QpL2JsdXIyLDAuMCwxLjApO2Zsb2F0IHNkZmRpc3RfYT10ZXh0dXJlMkQodV9pbWFnZSx2X3RleF9hKS5hO2Zsb2F0IHNkZmRpc3RfYj10ZXh0dXJlMkQodV9pbWFnZSx2X3RleF9iKS5hO2Zsb2F0IHNkZmRpc3Q9bWl4KHNkZmRpc3RfYSxzZGZkaXN0X2IsdV9taXgpO2FscGhhKj1zbW9vdGhzdGVwKDAuNS11X3NkZmdhbW1hL2Zsb29yd2lkdGgsMC41K3Vfc2RmZ2FtbWEvZmxvb3J3aWR0aCxzZGZkaXN0KTtnbF9GcmFnQ29sb3I9Y29sb3IqKGFscGhhKm9wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJcXG4jZGVmaW5lIHNjYWxlIDAuMDE1ODczMDE2XFxuI2RlZmluZSBMSU5FX0RJU1RBTkNFX1NDQUxFIDIuMFxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zX25vcm1hbDthdHRyaWJ1dGUgdmVjNCBhX2RhdGE7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X3JhdGlvO3VuaWZvcm0gbG93cCBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbzt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYTt1bmlmb3JtIGZsb2F0IHVfdGV4X3lfYTt1bmlmb3JtIHZlYzIgdV9wYXR0ZXJuc2NhbGVfYjt1bmlmb3JtIGZsb2F0IHVfdGV4X3lfYjt1bmlmb3JtIHZlYzIgdV91bml0c190b19waXhlbHM7dmFyeWluZyB2ZWMyIHZfbm9ybWFsO3ZhcnlpbmcgdmVjMiB2X3dpZHRoMjt2YXJ5aW5nIHZlYzIgdl90ZXhfYTt2YXJ5aW5nIHZlYzIgdl90ZXhfYjt2YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGJsdXJcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvZmZzZXRcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIG1lZGl1bXAgZmxvYXQgd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGNvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCBnYXB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb2Zmc2V0XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbWVkaXVtcCBmbG9hdCB3aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgZmxvb3J3aWR0aFxcbmZsb2F0IEFOVElBTElBU0lORz0xLjAvdV9kZXZpY2VfcGl4ZWxfcmF0aW8vMi4wO3ZlYzIgYV9leHRydWRlPWFfZGF0YS54eS0xMjguMDtmbG9hdCBhX2RpcmVjdGlvbj1tb2QoYV9kYXRhLnosNC4wKS0xLjA7ZmxvYXQgYV9saW5lc29mYXI9KGZsb29yKGFfZGF0YS56LzQuMCkrYV9kYXRhLncqNjQuMCkqTElORV9ESVNUQU5DRV9TQ0FMRTt2ZWMyIHBvcz1mbG9vcihhX3Bvc19ub3JtYWwqMC41KTttZWRpdW1wIHZlYzIgbm9ybWFsPWFfcG9zX25vcm1hbC0yLjAqcG9zO25vcm1hbC55PW5vcm1hbC55KjIuMC0xLjA7dl9ub3JtYWw9bm9ybWFsO2dhcHdpZHRoPWdhcHdpZHRoLzIuMDtmbG9hdCBoYWxmd2lkdGg9d2lkdGgvMi4wO29mZnNldD0tMS4wKm9mZnNldDtmbG9hdCBpbnNldD1nYXB3aWR0aCsoZ2Fwd2lkdGggPiAwLjAgPyBBTlRJQUxJQVNJTkcgOiAwLjApO2Zsb2F0IG91dHNldD1nYXB3aWR0aCtoYWxmd2lkdGgqKGdhcHdpZHRoID4gMC4wID8gMi4wIDogMS4wKSsoaGFsZndpZHRoPT0wLjAgPyAwLjAgOiBBTlRJQUxJQVNJTkcpO21lZGl1bXAgdmVjMiBkaXN0PW91dHNldCphX2V4dHJ1ZGUqc2NhbGU7bWVkaXVtcCBmbG9hdCB1PTAuNSphX2RpcmVjdGlvbjttZWRpdW1wIGZsb2F0IHQ9MS4wLWFicyh1KTttZWRpdW1wIHZlYzIgb2Zmc2V0Mj1vZmZzZXQqYV9leHRydWRlKnNjYWxlKm5vcm1hbC55Km1hdDIodCwtdSx1LHQpO3ZlYzQgcHJvamVjdGVkX2V4dHJ1ZGU9dV9tYXRyaXgqdmVjNChkaXN0L3VfcmF0aW8sMC4wLDAuMCk7Z2xfUG9zaXRpb249dV9tYXRyaXgqdmVjNChwb3Mrb2Zmc2V0Mi91X3JhdGlvLDAuMCwxLjApK3Byb2plY3RlZF9leHRydWRlO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhvdXRfcGVyc3BlY3RpdmU9bGVuZ3RoKGRpc3QpO2Zsb2F0IGV4dHJ1ZGVfbGVuZ3RoX3dpdGhfcGVyc3BlY3RpdmU9bGVuZ3RoKHByb2plY3RlZF9leHRydWRlLnh5L2dsX1Bvc2l0aW9uLncqdV91bml0c190b19waXhlbHMpO3ZfZ2FtbWFfc2NhbGU9ZXh0cnVkZV9sZW5ndGhfd2l0aG91dF9wZXJzcGVjdGl2ZS9leHRydWRlX2xlbmd0aF93aXRoX3BlcnNwZWN0aXZlO3ZfdGV4X2E9dmVjMihhX2xpbmVzb2Zhcip1X3BhdHRlcm5zY2FsZV9hLngvZmxvb3J3aWR0aCxub3JtYWwueSp1X3BhdHRlcm5zY2FsZV9hLnkrdV90ZXhfeV9hKTt2X3RleF9iPXZlYzIoYV9saW5lc29mYXIqdV9wYXR0ZXJuc2NhbGVfYi54L2Zsb29yd2lkdGgsbm9ybWFsLnkqdV9wYXR0ZXJuc2NhbGVfYi55K3VfdGV4X3lfYik7dl93aWR0aDI9dmVjMihvdXRzZXQsaW5zZXQpO31cIiksXG4gICAgICBkaSA9IGdpKFwidW5pZm9ybSBmbG9hdCB1X2ZhZGVfdDt1bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMDt1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMTt2YXJ5aW5nIHZlYzIgdl9wb3MwO3ZhcnlpbmcgdmVjMiB2X3BvczE7dW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3NfbG93O3VuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2hpZ2g7dW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb25fZmFjdG9yO3VuaWZvcm0gZmxvYXQgdV9jb250cmFzdF9mYWN0b3I7dW5pZm9ybSB2ZWMzIHVfc3Bpbl93ZWlnaHRzO3ZvaWQgbWFpbigpIHt2ZWM0IGNvbG9yMD10ZXh0dXJlMkQodV9pbWFnZTAsdl9wb3MwKTt2ZWM0IGNvbG9yMT10ZXh0dXJlMkQodV9pbWFnZTEsdl9wb3MxKTtpZiAoY29sb3IwLmEgPiAwLjApIHtjb2xvcjAucmdiPWNvbG9yMC5yZ2IvY29sb3IwLmE7fWlmIChjb2xvcjEuYSA+IDAuMCkge2NvbG9yMS5yZ2I9Y29sb3IxLnJnYi9jb2xvcjEuYTt9dmVjNCBjb2xvcj1taXgoY29sb3IwLGNvbG9yMSx1X2ZhZGVfdCk7Y29sb3IuYSo9dV9vcGFjaXR5O3ZlYzMgcmdiPWNvbG9yLnJnYjtyZ2I9dmVjMyhkb3QocmdiLHVfc3Bpbl93ZWlnaHRzLnh5eiksZG90KHJnYix1X3NwaW5fd2VpZ2h0cy56eHkpLGRvdChyZ2IsdV9zcGluX3dlaWdodHMueXp4KSk7ZmxvYXQgYXZlcmFnZT0oY29sb3Iucitjb2xvci5nK2NvbG9yLmIpLzMuMDtyZ2IrPShhdmVyYWdlLXJnYikqdV9zYXR1cmF0aW9uX2ZhY3RvcjtyZ2I9KHJnYi0wLjUpKnVfY29udHJhc3RfZmFjdG9yKzAuNTt2ZWMzIHVfaGlnaF92ZWM9dmVjMyh1X2JyaWdodG5lc3NfbG93LHVfYnJpZ2h0bmVzc19sb3csdV9icmlnaHRuZXNzX2xvdyk7dmVjMyB1X2xvd192ZWM9dmVjMyh1X2JyaWdodG5lc3NfaGlnaCx1X2JyaWdodG5lc3NfaGlnaCx1X2JyaWdodG5lc3NfaGlnaCk7Z2xfRnJhZ0NvbG9yPXZlYzQobWl4KHVfaGlnaF92ZWMsdV9sb3dfdmVjLHJnYikqY29sb3IuYSxjb2xvci5hKTtcXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuZ2xfRnJhZ0NvbG9yPXZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XCIsIFwidW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDt1bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O3VuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7YXR0cmlidXRlIHZlYzIgYV9wb3M7YXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3Bvczt2YXJ5aW5nIHZlYzIgdl9wb3MwO3ZhcnlpbmcgdmVjMiB2X3BvczE7dm9pZCBtYWluKCkge2dsX1Bvc2l0aW9uPXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTt2X3BvczA9KCgoYV90ZXh0dXJlX3Bvcy84MTkyLjApLTAuNSkvdV9idWZmZXJfc2NhbGUgKSswLjU7dl9wb3MxPSh2X3BvczAqdV9zY2FsZV9wYXJlbnQpK3VfdGxfcGFyZW50O31cIiksXG4gICAgICBfaSA9IGdpKFwidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO3ZhcnlpbmcgdmVjMiB2X3RleDt2YXJ5aW5nIGZsb2F0IHZfZmFkZV9vcGFjaXR5O1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbmxvd3AgZmxvYXQgYWxwaGE9b3BhY2l0eSp2X2ZhZGVfb3BhY2l0eTtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHVfdGV4dHVyZSx2X3RleCkqYWxwaGE7XFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbmdsX0ZyYWdDb2xvcj12ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVwiLCBcImNvbnN0IGZsb2F0IFBJPTMuMTQxNTkyNjUzNTg5NzkzO2F0dHJpYnV0ZSB2ZWM0IGFfcG9zX29mZnNldDthdHRyaWJ1dGUgdmVjNCBhX2RhdGE7YXR0cmlidXRlIHZlYzQgYV9waXhlbG9mZnNldDthdHRyaWJ1dGUgdmVjMyBhX3Byb2plY3RlZF9wb3M7YXR0cmlidXRlIGZsb2F0IGFfZmFkZV9vcGFjaXR5O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfem9vbV9jb25zdGFudDt1bmlmb3JtIGJvb2wgdV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQ7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3NpemVfdDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZTt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfcGl0Y2g7dW5pZm9ybSBib29sIHVfcm90YXRlX3N5bWJvbDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfYXNwZWN0X3JhdGlvO3VuaWZvcm0gZmxvYXQgdV9mYWRlX2NoYW5nZTt1bmlmb3JtIG1hdDQgdV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfbGFiZWxfcGxhbmVfbWF0cml4O3VuaWZvcm0gbWF0NCB1X2Nvb3JkX21hdHJpeDt1bmlmb3JtIGJvb2wgdV9pc190ZXh0O3VuaWZvcm0gYm9vbCB1X3BpdGNoX3dpdGhfbWFwO3VuaWZvcm0gdmVjMiB1X3RleHNpemU7dmFyeWluZyB2ZWMyIHZfdGV4O3ZhcnlpbmcgZmxvYXQgdl9mYWRlX29wYWNpdHk7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxudmVjMiBhX3Bvcz1hX3Bvc19vZmZzZXQueHk7dmVjMiBhX29mZnNldD1hX3Bvc19vZmZzZXQuenc7dmVjMiBhX3RleD1hX2RhdGEueHk7dmVjMiBhX3NpemU9YV9kYXRhLnp3O2Zsb2F0IGFfc2l6ZV9taW49Zmxvb3IoYV9zaXplWzBdKjAuNSk7dmVjMiBhX3B4b2Zmc2V0PWFfcGl4ZWxvZmZzZXQueHk7dmVjMiBhX21pbkZvbnRTY2FsZT1hX3BpeGVsb2Zmc2V0Lnp3LzI1Ni4wO2hpZ2hwIGZsb2F0IHNlZ21lbnRfYW5nbGU9LWFfcHJvamVjdGVkX3Bvc1syXTtmbG9hdCBzaXplO2lmICghdV9pc19zaXplX3pvb21fY29uc3RhbnQgJiYgIXVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50KSB7c2l6ZT1taXgoYV9zaXplX21pbixhX3NpemVbMV0sdV9zaXplX3QpLzEyOC4wO30gZWxzZSBpZiAodV9pc19zaXplX3pvb21fY29uc3RhbnQgJiYgIXVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50KSB7c2l6ZT1hX3NpemVfbWluLzEyOC4wO30gZWxzZSB7c2l6ZT11X3NpemU7fXZlYzQgcHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2hpZ2hwIGZsb2F0IGNhbWVyYV90b19hbmNob3JfZGlzdGFuY2U9cHJvamVjdGVkUG9pbnQudztoaWdocCBmbG9hdCBkaXN0YW5jZV9yYXRpbz11X3BpdGNoX3dpdGhfbWFwID9cXG5jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlL3VfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSA6XFxudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlL2NhbWVyYV90b19hbmNob3JfZGlzdGFuY2U7aGlnaHAgZmxvYXQgcGVyc3BlY3RpdmVfcmF0aW89Y2xhbXAoMC41KzAuNSpkaXN0YW5jZV9yYXRpbywwLjAsNC4wKTtzaXplKj1wZXJzcGVjdGl2ZV9yYXRpbztmbG9hdCBmb250U2NhbGU9dV9pc190ZXh0ID8gc2l6ZS8yNC4wIDogc2l6ZTtoaWdocCBmbG9hdCBzeW1ib2xfcm90YXRpb249MC4wO2lmICh1X3JvdGF0ZV9zeW1ib2wpIHt2ZWM0IG9mZnNldFByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MrdmVjMigxLDApLDAsMSk7dmVjMiBhPXByb2plY3RlZFBvaW50Lnh5L3Byb2plY3RlZFBvaW50Lnc7dmVjMiBiPW9mZnNldFByb2plY3RlZFBvaW50Lnh5L29mZnNldFByb2plY3RlZFBvaW50Lnc7c3ltYm9sX3JvdGF0aW9uPWF0YW4oKGIueS1hLnkpL3VfYXNwZWN0X3JhdGlvLGIueC1hLngpO31oaWdocCBmbG9hdCBhbmdsZV9zaW49c2luKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTtoaWdocCBmbG9hdCBhbmdsZV9jb3M9Y29zKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTttYXQyIHJvdGF0aW9uX21hdHJpeD1tYXQyKGFuZ2xlX2NvcywtMS4wKmFuZ2xlX3NpbixhbmdsZV9zaW4sYW5nbGVfY29zKTt2ZWM0IHByb2plY3RlZF9wb3M9dV9sYWJlbF9wbGFuZV9tYXRyaXgqdmVjNChhX3Byb2plY3RlZF9wb3MueHksMC4wLDEuMCk7Z2xfUG9zaXRpb249dV9jb29yZF9tYXRyaXgqdmVjNChwcm9qZWN0ZWRfcG9zLnh5L3Byb2plY3RlZF9wb3Mudytyb3RhdGlvbl9tYXRyaXgqKGFfb2Zmc2V0LzMyLjAqbWF4KGFfbWluRm9udFNjYWxlLGZvbnRTY2FsZSkrYV9weG9mZnNldC8xNi4wKSwwLjAsMS4wKTt2X3RleD1hX3RleC91X3RleHNpemU7dmVjMiBmYWRlX29wYWNpdHk9dW5wYWNrX29wYWNpdHkoYV9mYWRlX29wYWNpdHkpO2Zsb2F0IGZhZGVfY2hhbmdlPWZhZGVfb3BhY2l0eVsxXSA+IDAuNSA/IHVfZmFkZV9jaGFuZ2UgOi11X2ZhZGVfY2hhbmdlO3ZfZmFkZV9vcGFjaXR5PW1heCgwLjAsbWluKDEuMCxmYWRlX29wYWNpdHlbMF0rZmFkZV9jaGFuZ2UpKTt9XCIpLFxuICAgICAgZmkgPSBnaShcIiNkZWZpbmUgU0RGX1BYIDguMFxcbnVuaWZvcm0gYm9vbCB1X2lzX2hhbG87dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9nYW1tYV9zY2FsZTt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dW5pZm9ybSBib29sIHVfaXNfdGV4dDt2YXJ5aW5nIHZlYzIgdl9kYXRhMDt2YXJ5aW5nIHZlYzMgdl9kYXRhMTtcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBoYWxvX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoYWxvX2JsdXJcXG52b2lkIG1haW4oKSB7XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBmaWxsX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgaGlnaHAgdmVjNCBoYWxvX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoYWxvX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBoYWxvX2JsdXJcXG5mbG9hdCBFREdFX0dBTU1BPTAuMTA1L3VfZGV2aWNlX3BpeGVsX3JhdGlvO3ZlYzIgdGV4PXZfZGF0YTAueHk7ZmxvYXQgZ2FtbWFfc2NhbGU9dl9kYXRhMS54O2Zsb2F0IHNpemU9dl9kYXRhMS55O2Zsb2F0IGZhZGVfb3BhY2l0eT12X2RhdGExWzJdO2Zsb2F0IGZvbnRTY2FsZT11X2lzX3RleHQgPyBzaXplLzI0LjAgOiBzaXplO2xvd3AgdmVjNCBjb2xvcj1maWxsX2NvbG9yO2hpZ2hwIGZsb2F0IGdhbW1hPUVER0VfR0FNTUEvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtsb3dwIGZsb2F0IGJ1ZmY9KDI1Ni4wLTY0LjApLzI1Ni4wO2lmICh1X2lzX2hhbG8pIHtjb2xvcj1oYWxvX2NvbG9yO2dhbW1hPShoYWxvX2JsdXIqMS4xOS9TREZfUFgrRURHRV9HQU1NQSkvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtidWZmPSg2LjAtaGFsb193aWR0aC9mb250U2NhbGUpL1NERl9QWDt9bG93cCBmbG9hdCBkaXN0PXRleHR1cmUyRCh1X3RleHR1cmUsdGV4KS5hO2hpZ2hwIGZsb2F0IGdhbW1hX3NjYWxlZD1nYW1tYSpnYW1tYV9zY2FsZTtoaWdocCBmbG9hdCBhbHBoYT1zbW9vdGhzdGVwKGJ1ZmYtZ2FtbWFfc2NhbGVkLGJ1ZmYrZ2FtbWFfc2NhbGVkLGRpc3QpO2dsX0ZyYWdDb2xvcj1jb2xvciooYWxwaGEqb3BhY2l0eSpmYWRlX29wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJjb25zdCBmbG9hdCBQST0zLjE0MTU5MjY1MzU4OTc5MzthdHRyaWJ1dGUgdmVjNCBhX3Bvc19vZmZzZXQ7YXR0cmlidXRlIHZlYzQgYV9kYXRhO2F0dHJpYnV0ZSB2ZWM0IGFfcGl4ZWxvZmZzZXQ7YXR0cmlidXRlIHZlYzMgYV9wcm9qZWN0ZWRfcG9zO2F0dHJpYnV0ZSBmbG9hdCBhX2ZhZGVfb3BhY2l0eTt1bmlmb3JtIGJvb2wgdV9pc19zaXplX3pvb21fY29uc3RhbnQ7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplX3Q7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3NpemU7dW5pZm9ybSBtYXQ0IHVfbWF0cml4O3VuaWZvcm0gbWF0NCB1X2xhYmVsX3BsYW5lX21hdHJpeDt1bmlmb3JtIG1hdDQgdV9jb29yZF9tYXRyaXg7dW5pZm9ybSBib29sIHVfaXNfdGV4dDt1bmlmb3JtIGJvb2wgdV9waXRjaF93aXRoX21hcDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfcGl0Y2g7dW5pZm9ybSBib29sIHVfcm90YXRlX3N5bWJvbDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfYXNwZWN0X3JhdGlvO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlO3VuaWZvcm0gZmxvYXQgdV9mYWRlX2NoYW5nZTt1bmlmb3JtIHZlYzIgdV90ZXhzaXplO3ZhcnlpbmcgdmVjMiB2X2RhdGEwO3ZhcnlpbmcgdmVjMyB2X2RhdGExO1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgaGlnaHAgdmVjNCBmaWxsX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGhhbG9fY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBoYWxvX3dpZHRoXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fYmx1clxcbnZvaWQgbWFpbigpIHtcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBoaWdocCB2ZWM0IGhhbG9fY29sb3JcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGhhbG9fYmx1clxcbnZlYzIgYV9wb3M9YV9wb3Nfb2Zmc2V0Lnh5O3ZlYzIgYV9vZmZzZXQ9YV9wb3Nfb2Zmc2V0Lnp3O3ZlYzIgYV90ZXg9YV9kYXRhLnh5O3ZlYzIgYV9zaXplPWFfZGF0YS56dztmbG9hdCBhX3NpemVfbWluPWZsb29yKGFfc2l6ZVswXSowLjUpO3ZlYzIgYV9weG9mZnNldD1hX3BpeGVsb2Zmc2V0Lnh5O2hpZ2hwIGZsb2F0IHNlZ21lbnRfYW5nbGU9LWFfcHJvamVjdGVkX3Bvc1syXTtmbG9hdCBzaXplO2lmICghdV9pc19zaXplX3pvb21fY29uc3RhbnQgJiYgIXVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50KSB7c2l6ZT1taXgoYV9zaXplX21pbixhX3NpemVbMV0sdV9zaXplX3QpLzEyOC4wO30gZWxzZSBpZiAodV9pc19zaXplX3pvb21fY29uc3RhbnQgJiYgIXVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50KSB7c2l6ZT1hX3NpemVfbWluLzEyOC4wO30gZWxzZSB7c2l6ZT11X3NpemU7fXZlYzQgcHJvamVjdGVkUG9pbnQ9dV9tYXRyaXgqdmVjNChhX3BvcywwLDEpO2hpZ2hwIGZsb2F0IGNhbWVyYV90b19hbmNob3JfZGlzdGFuY2U9cHJvamVjdGVkUG9pbnQudztoaWdocCBmbG9hdCBkaXN0YW5jZV9yYXRpbz11X3BpdGNoX3dpdGhfbWFwID9cXG5jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlL3VfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSA6XFxudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlL2NhbWVyYV90b19hbmNob3JfZGlzdGFuY2U7aGlnaHAgZmxvYXQgcGVyc3BlY3RpdmVfcmF0aW89Y2xhbXAoMC41KzAuNSpkaXN0YW5jZV9yYXRpbywwLjAsNC4wKTtzaXplKj1wZXJzcGVjdGl2ZV9yYXRpbztmbG9hdCBmb250U2NhbGU9dV9pc190ZXh0ID8gc2l6ZS8yNC4wIDogc2l6ZTtoaWdocCBmbG9hdCBzeW1ib2xfcm90YXRpb249MC4wO2lmICh1X3JvdGF0ZV9zeW1ib2wpIHt2ZWM0IG9mZnNldFByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MrdmVjMigxLDApLDAsMSk7dmVjMiBhPXByb2plY3RlZFBvaW50Lnh5L3Byb2plY3RlZFBvaW50Lnc7dmVjMiBiPW9mZnNldFByb2plY3RlZFBvaW50Lnh5L29mZnNldFByb2plY3RlZFBvaW50Lnc7c3ltYm9sX3JvdGF0aW9uPWF0YW4oKGIueS1hLnkpL3VfYXNwZWN0X3JhdGlvLGIueC1hLngpO31oaWdocCBmbG9hdCBhbmdsZV9zaW49c2luKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTtoaWdocCBmbG9hdCBhbmdsZV9jb3M9Y29zKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTttYXQyIHJvdGF0aW9uX21hdHJpeD1tYXQyKGFuZ2xlX2NvcywtMS4wKmFuZ2xlX3NpbixhbmdsZV9zaW4sYW5nbGVfY29zKTt2ZWM0IHByb2plY3RlZF9wb3M9dV9sYWJlbF9wbGFuZV9tYXRyaXgqdmVjNChhX3Byb2plY3RlZF9wb3MueHksMC4wLDEuMCk7Z2xfUG9zaXRpb249dV9jb29yZF9tYXRyaXgqdmVjNChwcm9qZWN0ZWRfcG9zLnh5L3Byb2plY3RlZF9wb3Mudytyb3RhdGlvbl9tYXRyaXgqKGFfb2Zmc2V0LzMyLjAqZm9udFNjYWxlK2FfcHhvZmZzZXQpLDAuMCwxLjApO2Zsb2F0IGdhbW1hX3NjYWxlPWdsX1Bvc2l0aW9uLnc7dmVjMiBmYWRlX29wYWNpdHk9dW5wYWNrX29wYWNpdHkoYV9mYWRlX29wYWNpdHkpO2Zsb2F0IGZhZGVfY2hhbmdlPWZhZGVfb3BhY2l0eVsxXSA+IDAuNSA/IHVfZmFkZV9jaGFuZ2UgOi11X2ZhZGVfY2hhbmdlO2Zsb2F0IGludGVycG9sYXRlZF9mYWRlX29wYWNpdHk9bWF4KDAuMCxtaW4oMS4wLGZhZGVfb3BhY2l0eVswXStmYWRlX2NoYW5nZSkpO3ZfZGF0YTA9YV90ZXgvdV90ZXhzaXplO3ZfZGF0YTE9dmVjMyhnYW1tYV9zY2FsZSxzaXplLGludGVycG9sYXRlZF9mYWRlX29wYWNpdHkpO31cIiksXG4gICAgICBtaSA9IGdpKFwiI2RlZmluZSBTREZfUFggOC4wXFxuI2RlZmluZSBTREYgMS4wXFxuI2RlZmluZSBJQ09OIDAuMFxcbnVuaWZvcm0gYm9vbCB1X2lzX2hhbG87dW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO3VuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZV9pY29uO3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9nYW1tYV9zY2FsZTt1bmlmb3JtIGxvd3AgZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87dmFyeWluZyB2ZWM0IHZfZGF0YTA7dmFyeWluZyB2ZWM0IHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxuZmxvYXQgZmFkZV9vcGFjaXR5PXZfZGF0YTFbMl07aWYgKHZfZGF0YTEudz09SUNPTikge3ZlYzIgdGV4X2ljb249dl9kYXRhMC56dztsb3dwIGZsb2F0IGFscGhhPW9wYWNpdHkqZmFkZV9vcGFjaXR5O2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQodV90ZXh0dXJlX2ljb24sdGV4X2ljb24pKmFscGhhO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbnJldHVybjt9dmVjMiB0ZXg9dl9kYXRhMC54eTtmbG9hdCBFREdFX0dBTU1BPTAuMTA1L3VfZGV2aWNlX3BpeGVsX3JhdGlvO2Zsb2F0IGdhbW1hX3NjYWxlPXZfZGF0YTEueDtmbG9hdCBzaXplPXZfZGF0YTEueTtmbG9hdCBmb250U2NhbGU9c2l6ZS8yNC4wO2xvd3AgdmVjNCBjb2xvcj1maWxsX2NvbG9yO2hpZ2hwIGZsb2F0IGdhbW1hPUVER0VfR0FNTUEvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtsb3dwIGZsb2F0IGJ1ZmY9KDI1Ni4wLTY0LjApLzI1Ni4wO2lmICh1X2lzX2hhbG8pIHtjb2xvcj1oYWxvX2NvbG9yO2dhbW1hPShoYWxvX2JsdXIqMS4xOS9TREZfUFgrRURHRV9HQU1NQSkvKGZvbnRTY2FsZSp1X2dhbW1hX3NjYWxlKTtidWZmPSg2LjAtaGFsb193aWR0aC9mb250U2NhbGUpL1NERl9QWDt9bG93cCBmbG9hdCBkaXN0PXRleHR1cmUyRCh1X3RleHR1cmUsdGV4KS5hO2hpZ2hwIGZsb2F0IGdhbW1hX3NjYWxlZD1nYW1tYSpnYW1tYV9zY2FsZTtoaWdocCBmbG9hdCBhbHBoYT1zbW9vdGhzdGVwKGJ1ZmYtZ2FtbWFfc2NhbGVkLGJ1ZmYrZ2FtbWFfc2NhbGVkLGRpc3QpO2dsX0ZyYWdDb2xvcj1jb2xvciooYWxwaGEqb3BhY2l0eSpmYWRlX29wYWNpdHkpO1xcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG5nbF9GcmFnQ29sb3I9dmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cIiwgXCJjb25zdCBmbG9hdCBQST0zLjE0MTU5MjY1MzU4OTc5MzthdHRyaWJ1dGUgdmVjNCBhX3Bvc19vZmZzZXQ7YXR0cmlidXRlIHZlYzQgYV9kYXRhO2F0dHJpYnV0ZSB2ZWMzIGFfcHJvamVjdGVkX3BvczthdHRyaWJ1dGUgZmxvYXQgYV9mYWRlX29wYWNpdHk7dW5pZm9ybSBib29sIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50O3VuaWZvcm0gYm9vbCB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfc2l6ZV90O3VuaWZvcm0gaGlnaHAgZmxvYXQgdV9zaXplO3VuaWZvcm0gbWF0NCB1X21hdHJpeDt1bmlmb3JtIG1hdDQgdV9sYWJlbF9wbGFuZV9tYXRyaXg7dW5pZm9ybSBtYXQ0IHVfY29vcmRfbWF0cml4O3VuaWZvcm0gYm9vbCB1X2lzX3RleHQ7dW5pZm9ybSBib29sIHVfcGl0Y2hfd2l0aF9tYXA7dW5pZm9ybSBoaWdocCBmbG9hdCB1X3BpdGNoO3VuaWZvcm0gYm9vbCB1X3JvdGF0ZV9zeW1ib2w7dW5pZm9ybSBoaWdocCBmbG9hdCB1X2FzcGVjdF9yYXRpbzt1bmlmb3JtIGhpZ2hwIGZsb2F0IHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVfZmFkZV9jaGFuZ2U7dW5pZm9ybSB2ZWMyIHVfdGV4c2l6ZTt1bmlmb3JtIHZlYzIgdV90ZXhzaXplX2ljb247dmFyeWluZyB2ZWM0IHZfZGF0YTA7dmFyeWluZyB2ZWM0IHZfZGF0YTE7XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBoaWdocCB2ZWM0IGZpbGxfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IGhhbG9fd2lkdGhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudm9pZCBtYWluKCkge1xcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgZmlsbF9jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGhpZ2hwIHZlYzQgaGFsb19jb2xvclxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb193aWR0aFxcbiNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgaGFsb19ibHVyXFxudmVjMiBhX3Bvcz1hX3Bvc19vZmZzZXQueHk7dmVjMiBhX29mZnNldD1hX3Bvc19vZmZzZXQuenc7dmVjMiBhX3RleD1hX2RhdGEueHk7dmVjMiBhX3NpemU9YV9kYXRhLnp3O2Zsb2F0IGFfc2l6ZV9taW49Zmxvb3IoYV9zaXplWzBdKjAuNSk7ZmxvYXQgaXNfc2RmPWFfc2l6ZVswXS0yLjAqYV9zaXplX21pbjtoaWdocCBmbG9hdCBzZWdtZW50X2FuZ2xlPS1hX3Byb2plY3RlZF9wb3NbMl07ZmxvYXQgc2l6ZTtpZiAoIXVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9bWl4KGFfc2l6ZV9taW4sYV9zaXplWzFdLHVfc2l6ZV90KS8xMjguMDt9IGVsc2UgaWYgKHVfaXNfc2l6ZV96b29tX2NvbnN0YW50ICYmICF1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCkge3NpemU9YV9zaXplX21pbi8xMjguMDt9IGVsc2Uge3NpemU9dV9zaXplO312ZWM0IHByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MsMCwxKTtoaWdocCBmbG9hdCBjYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlPXByb2plY3RlZFBvaW50Lnc7aGlnaHAgZmxvYXQgZGlzdGFuY2VfcmF0aW89dV9waXRjaF93aXRoX21hcCA/XFxuY2FtZXJhX3RvX2FuY2hvcl9kaXN0YW5jZS91X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UgOlxcbnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZS9jYW1lcmFfdG9fYW5jaG9yX2Rpc3RhbmNlO2hpZ2hwIGZsb2F0IHBlcnNwZWN0aXZlX3JhdGlvPWNsYW1wKDAuNSswLjUqZGlzdGFuY2VfcmF0aW8sMC4wLDQuMCk7c2l6ZSo9cGVyc3BlY3RpdmVfcmF0aW87ZmxvYXQgZm9udFNjYWxlPXNpemUvMjQuMDtoaWdocCBmbG9hdCBzeW1ib2xfcm90YXRpb249MC4wO2lmICh1X3JvdGF0ZV9zeW1ib2wpIHt2ZWM0IG9mZnNldFByb2plY3RlZFBvaW50PXVfbWF0cml4KnZlYzQoYV9wb3MrdmVjMigxLDApLDAsMSk7dmVjMiBhPXByb2plY3RlZFBvaW50Lnh5L3Byb2plY3RlZFBvaW50Lnc7dmVjMiBiPW9mZnNldFByb2plY3RlZFBvaW50Lnh5L29mZnNldFByb2plY3RlZFBvaW50Lnc7c3ltYm9sX3JvdGF0aW9uPWF0YW4oKGIueS1hLnkpL3VfYXNwZWN0X3JhdGlvLGIueC1hLngpO31oaWdocCBmbG9hdCBhbmdsZV9zaW49c2luKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTtoaWdocCBmbG9hdCBhbmdsZV9jb3M9Y29zKHNlZ21lbnRfYW5nbGUrc3ltYm9sX3JvdGF0aW9uKTttYXQyIHJvdGF0aW9uX21hdHJpeD1tYXQyKGFuZ2xlX2NvcywtMS4wKmFuZ2xlX3NpbixhbmdsZV9zaW4sYW5nbGVfY29zKTt2ZWM0IHByb2plY3RlZF9wb3M9dV9sYWJlbF9wbGFuZV9tYXRyaXgqdmVjNChhX3Byb2plY3RlZF9wb3MueHksMC4wLDEuMCk7Z2xfUG9zaXRpb249dV9jb29yZF9tYXRyaXgqdmVjNChwcm9qZWN0ZWRfcG9zLnh5L3Byb2plY3RlZF9wb3Mudytyb3RhdGlvbl9tYXRyaXgqKGFfb2Zmc2V0LzMyLjAqZm9udFNjYWxlKSwwLjAsMS4wKTtmbG9hdCBnYW1tYV9zY2FsZT1nbF9Qb3NpdGlvbi53O3ZlYzIgZmFkZV9vcGFjaXR5PXVucGFja19vcGFjaXR5KGFfZmFkZV9vcGFjaXR5KTtmbG9hdCBmYWRlX2NoYW5nZT1mYWRlX29wYWNpdHlbMV0gPiAwLjUgPyB1X2ZhZGVfY2hhbmdlIDotdV9mYWRlX2NoYW5nZTtmbG9hdCBpbnRlcnBvbGF0ZWRfZmFkZV9vcGFjaXR5PW1heCgwLjAsbWluKDEuMCxmYWRlX29wYWNpdHlbMF0rZmFkZV9jaGFuZ2UpKTt2X2RhdGEwLnh5PWFfdGV4L3VfdGV4c2l6ZTt2X2RhdGEwLnp3PWFfdGV4L3VfdGV4c2l6ZV9pY29uO3ZfZGF0YTE9dmVjNChnYW1tYV9zY2FsZSxzaXplLGludGVycG9sYXRlZF9mYWRlX29wYWNpdHksaXNfc2RmKTt9XCIpO1xuICAgIGZ1bmN0aW9uIGdpKHQsIGUpIHtcbiAgICAgIHZhciBpID0gLyNwcmFnbWEgbWFwYm94OiAoW1xcd10rKSAoW1xcd10rKSAoW1xcd10rKSAoW1xcd10rKS9nLFxuICAgICAgICBvID0gZS5tYXRjaCgvYXR0cmlidXRlIChbXFx3XSspIChbXFx3XSspL2cpLFxuICAgICAgICByID0gdC5tYXRjaCgvdW5pZm9ybSAoW1xcd10rKSAoW1xcd10rKShbXFxzXSopKFtcXHddKikvZyksXG4gICAgICAgIGEgPSBlLm1hdGNoKC91bmlmb3JtIChbXFx3XSspIChbXFx3XSspKFtcXHNdKikoW1xcd10qKS9nKSxcbiAgICAgICAgbiA9IGEgPyBhLmNvbmNhdChyKSA6IHIsXG4gICAgICAgIHMgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyYWdtZW50U291cmNlOiB0ID0gdC5yZXBsYWNlKGksIGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICAgICAgcmV0dXJuIHNbcl0gPSAhMCwgXCJkZWZpbmVcIiA9PT0gZSA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxudmFyeWluZyBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiBcIiArIHIgKyBcIjtcXG4jZWxzZVxcbnVuaWZvcm0gXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgdV9cIiArIHIgKyBcIjtcXG4jZW5kaWZcXG5cIiA6IFwiXFxuI2lmZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiO1xuICAgICAgICB9KSxcbiAgICAgICAgdmVydGV4U291cmNlOiBlID0gZS5yZXBsYWNlKGksIGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByKSB7XG4gICAgICAgICAgdmFyIGEgPSBcImZsb2F0XCIgPT09IG8gPyBcInZlYzJcIiA6IFwidmVjNFwiLFxuICAgICAgICAgICAgbiA9IHIubWF0Y2goL2NvbG9yLykgPyBcImNvbG9yXCIgOiBhO1xuICAgICAgICAgIHJldHVybiBzW3JdID8gXCJkZWZpbmVcIiA9PT0gZSA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfXCIgKyByICsgXCJfdDtcXG5hdHRyaWJ1dGUgXCIgKyBpICsgXCIgXCIgKyBhICsgXCIgYV9cIiArIHIgKyBcIjtcXG52YXJ5aW5nIFwiICsgaSArIFwiIFwiICsgbyArIFwiIFwiICsgciArIFwiO1xcbiNlbHNlXFxudW5pZm9ybSBcIiArIGkgKyBcIiBcIiArIG8gKyBcIiB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJ2ZWM0XCIgPT09IG4gPyBcIlxcbiNpZm5kZWYgSEFTX1VOSUZPUk1fdV9cIiArIHIgKyBcIlxcbiAgICBcIiArIHIgKyBcIiA9IGFfXCIgKyByICsgXCI7XFxuI2Vsc2VcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyByICsgXCIgPSB1bnBhY2tfbWl4X1wiICsgbiArIFwiKGFfXCIgKyByICsgXCIsIHVfXCIgKyByICsgXCJfdCk7XFxuI2Vsc2VcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSB1X1wiICsgciArIFwiO1xcbiNlbmRpZlxcblwiIDogXCJkZWZpbmVcIiA9PT0gZSA/IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfXCIgKyByICsgXCJfdDtcXG5hdHRyaWJ1dGUgXCIgKyBpICsgXCIgXCIgKyBhICsgXCIgYV9cIiArIHIgKyBcIjtcXG4jZWxzZVxcbnVuaWZvcm0gXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgdV9cIiArIHIgKyBcIjtcXG4jZW5kaWZcXG5cIiA6IFwidmVjNFwiID09PSBuID8gXCJcXG4jaWZuZGVmIEhBU19VTklGT1JNX3VfXCIgKyByICsgXCJcXG4gICAgXCIgKyBpICsgXCIgXCIgKyBvICsgXCIgXCIgKyByICsgXCIgPSBhX1wiICsgciArIFwiO1xcbiNlbHNlXFxuICAgIFwiICsgaSArIFwiIFwiICsgbyArIFwiIFwiICsgciArIFwiID0gdV9cIiArIHIgKyBcIjtcXG4jZW5kaWZcXG5cIiA6IFwiXFxuI2lmbmRlZiBIQVNfVU5JRk9STV91X1wiICsgciArIFwiXFxuICAgIFwiICsgaSArIFwiIFwiICsgbyArIFwiIFwiICsgciArIFwiID0gdW5wYWNrX21peF9cIiArIG4gKyBcIihhX1wiICsgciArIFwiLCB1X1wiICsgciArIFwiX3QpO1xcbiNlbHNlXFxuICAgIFwiICsgaSArIFwiIFwiICsgbyArIFwiIFwiICsgciArIFwiID0gdV9cIiArIHIgKyBcIjtcXG4jZW5kaWZcXG5cIjtcbiAgICAgICAgfSksXG4gICAgICAgIHN0YXRpY0F0dHJpYnV0ZXM6IG8sXG4gICAgICAgIHN0YXRpY1VuaWZvcm1zOiBuXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgdmkgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBwcmVsdWRlOiBHZSxcbiAgICAgICAgYmFja2dyb3VuZDogV2UsXG4gICAgICAgIGJhY2tncm91bmRQYXR0ZXJuOiBYZSxcbiAgICAgICAgY2lyY2xlOiBIZSxcbiAgICAgICAgY2xpcHBpbmdNYXNrOiBLZSxcbiAgICAgICAgaGVhdG1hcDogWWUsXG4gICAgICAgIGhlYXRtYXBUZXh0dXJlOiBKZSxcbiAgICAgICAgY29sbGlzaW9uQm94OiBRZSxcbiAgICAgICAgY29sbGlzaW9uQ2lyY2xlOiAkZSxcbiAgICAgICAgZGVidWc6IHRpLFxuICAgICAgICBmaWxsOiBlaSxcbiAgICAgICAgZmlsbE91dGxpbmU6IGlpLFxuICAgICAgICBmaWxsT3V0bGluZVBhdHRlcm46IG9pLFxuICAgICAgICBmaWxsUGF0dGVybjogcmksXG4gICAgICAgIGZpbGxFeHRydXNpb246IGFpLFxuICAgICAgICBmaWxsRXh0cnVzaW9uUGF0dGVybjogbmksXG4gICAgICAgIGhpbGxzaGFkZVByZXBhcmU6IHNpLFxuICAgICAgICBoaWxsc2hhZGU6IGxpLFxuICAgICAgICBsaW5lOiBjaSxcbiAgICAgICAgbGluZUdyYWRpZW50OiB1aSxcbiAgICAgICAgbGluZVBhdHRlcm46IGhpLFxuICAgICAgICBsaW5lU0RGOiBwaSxcbiAgICAgICAgcmFzdGVyOiBkaSxcbiAgICAgICAgc3ltYm9sSWNvbjogX2ksXG4gICAgICAgIHN5bWJvbFNERjogZmksXG4gICAgICAgIHN5bWJvbFRleHRBbmRJY29uOiBtaVxuICAgICAgfSksXG4gICAgICB5aSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ib3VuZFByb2dyYW0gPSBudWxsLCB0aGlzLmJvdW5kTGF5b3V0VmVydGV4QnVmZmVyID0gbnVsbCwgdGhpcy5ib3VuZFBhaW50VmVydGV4QnVmZmVycyA9IFtdLCB0aGlzLmJvdW5kSW5kZXhCdWZmZXIgPSBudWxsLCB0aGlzLmJvdW5kVmVydGV4T2Zmc2V0ID0gbnVsbCwgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIgPSBudWxsLCB0aGlzLnZhbyA9IG51bGw7XG4gICAgICB9O1xuICAgIGZ1bmN0aW9uIHhpKHQpIHtcbiAgICAgIGZvciAodmFyIGUgPSBbXSwgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSBpZiAobnVsbCAhPT0gdFtpXSkge1xuICAgICAgICB2YXIgbyA9IHRbaV0uc3BsaXQoXCIgXCIpO1xuICAgICAgICBlLnB1c2goby5wb3AoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgeWkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgdGhpcy5jb250ZXh0ID0gdDtcbiAgICAgIGZvciAodmFyIGwgPSB0aGlzLmJvdW5kUGFpbnRWZXJ0ZXhCdWZmZXJzLmxlbmd0aCAhPT0gby5sZW5ndGgsIGMgPSAwOyAhbCAmJiBjIDwgby5sZW5ndGg7IGMrKykgdGhpcy5ib3VuZFBhaW50VmVydGV4QnVmZmVyc1tjXSAhPT0gb1tjXSAmJiAobCA9ICEwKTtcbiAgICAgIHQuZXh0VmVydGV4QXJyYXlPYmplY3QgJiYgdGhpcy52YW8gJiYgdGhpcy5ib3VuZFByb2dyYW0gPT09IGUgJiYgdGhpcy5ib3VuZExheW91dFZlcnRleEJ1ZmZlciA9PT0gaSAmJiAhbCAmJiB0aGlzLmJvdW5kSW5kZXhCdWZmZXIgPT09IHIgJiYgdGhpcy5ib3VuZFZlcnRleE9mZnNldCA9PT0gYSAmJiB0aGlzLmJvdW5kRHluYW1pY1ZlcnRleEJ1ZmZlciA9PT0gbiAmJiB0aGlzLmJvdW5kRHluYW1pY1ZlcnRleEJ1ZmZlcjIgPT09IHMgPyAodC5iaW5kVmVydGV4QXJyYXlPRVMuc2V0KHRoaXMudmFvKSwgbiAmJiBuLmJpbmQoKSwgciAmJiByLmR5bmFtaWNEcmF3ICYmIHIuYmluZCgpLCBzICYmIHMuYmluZCgpKSA6IHRoaXMuZnJlc2hCaW5kKGUsIGksIG8sIHIsIGEsIG4sIHMpO1xuICAgIH0sIHlpLnByb3RvdHlwZS5mcmVzaEJpbmQgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMsXG4gICAgICAgIGwgPSB0Lm51bUF0dHJpYnV0ZXMsXG4gICAgICAgIGMgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIHUgPSBjLmdsO1xuICAgICAgaWYgKGMuZXh0VmVydGV4QXJyYXlPYmplY3QpIHRoaXMudmFvICYmIHRoaXMuZGVzdHJveSgpLCB0aGlzLnZhbyA9IGMuZXh0VmVydGV4QXJyYXlPYmplY3QuY3JlYXRlVmVydGV4QXJyYXlPRVMoKSwgYy5iaW5kVmVydGV4QXJyYXlPRVMuc2V0KHRoaXMudmFvKSwgcyA9IDAsIHRoaXMuYm91bmRQcm9ncmFtID0gdCwgdGhpcy5ib3VuZExheW91dFZlcnRleEJ1ZmZlciA9IGUsIHRoaXMuYm91bmRQYWludFZlcnRleEJ1ZmZlcnMgPSBpLCB0aGlzLmJvdW5kSW5kZXhCdWZmZXIgPSBvLCB0aGlzLmJvdW5kVmVydGV4T2Zmc2V0ID0gciwgdGhpcy5ib3VuZER5bmFtaWNWZXJ0ZXhCdWZmZXIgPSBhLCB0aGlzLmJvdW5kRHluYW1pY1ZlcnRleEJ1ZmZlcjIgPSBuO2Vsc2Uge1xuICAgICAgICBzID0gYy5jdXJyZW50TnVtQXR0cmlidXRlcyB8fCAwO1xuICAgICAgICBmb3IgKHZhciBoID0gbDsgaCA8IHM7IGgrKykgdS5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaCk7XG4gICAgICB9XG4gICAgICBlLmVuYWJsZUF0dHJpYnV0ZXModSwgdCk7XG4gICAgICBmb3IgKHZhciBwID0gMCwgZCA9IGk7IHAgPCBkLmxlbmd0aDsgcCArPSAxKSBkW3BdLmVuYWJsZUF0dHJpYnV0ZXModSwgdCk7XG4gICAgICBhICYmIGEuZW5hYmxlQXR0cmlidXRlcyh1LCB0KSwgbiAmJiBuLmVuYWJsZUF0dHJpYnV0ZXModSwgdCksIGUuYmluZCgpLCBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKHUsIHQsIHIpO1xuICAgICAgZm9yICh2YXIgXyA9IDAsIGYgPSBpOyBfIDwgZi5sZW5ndGg7IF8gKz0gMSkge1xuICAgICAgICB2YXIgbSA9IGZbX107XG4gICAgICAgIG0uYmluZCgpLCBtLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKHUsIHQsIHIpO1xuICAgICAgfVxuICAgICAgYSAmJiAoYS5iaW5kKCksIGEuc2V0VmVydGV4QXR0cmliUG9pbnRlcnModSwgdCwgcikpLCBvICYmIG8uYmluZCgpLCBuICYmIChuLmJpbmQoKSwgbi5zZXRWZXJ0ZXhBdHRyaWJQb2ludGVycyh1LCB0LCByKSksIGMuY3VycmVudE51bUF0dHJpYnV0ZXMgPSBsO1xuICAgIH0sIHlpLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy52YW8gJiYgKHRoaXMuY29udGV4dC5leHRWZXJ0ZXhBcnJheU9iamVjdC5kZWxldGVWZXJ0ZXhBcnJheU9FUyh0aGlzLnZhbyksIHRoaXMudmFvID0gbnVsbCk7XG4gICAgfTtcbiAgICB2YXIgYmkgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSkge1xuICAgICAgdmFyIG4gPSB0LmdsO1xuICAgICAgdGhpcy5wcm9ncmFtID0gbi5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICBmb3IgKHZhciBzID0geGkoaS5zdGF0aWNBdHRyaWJ1dGVzKSwgbCA9IG8gPyBvLmdldEJpbmRlckF0dHJpYnV0ZXMoKSA6IFtdLCBjID0gcy5jb25jYXQobCksIHUgPSBpLnN0YXRpY1VuaWZvcm1zID8geGkoaS5zdGF0aWNVbmlmb3JtcykgOiBbXSwgaCA9IG8gPyBvLmdldEJpbmRlclVuaWZvcm1zKCkgOiBbXSwgcCA9IFtdLCBkID0gMCwgXyA9IHUuY29uY2F0KGgpOyBkIDwgXy5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICB2YXIgZiA9IF9bZF07XG4gICAgICAgIHAuaW5kZXhPZihmKSA8IDAgJiYgcC5wdXNoKGYpO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSBvID8gby5kZWZpbmVzKCkgOiBbXTtcbiAgICAgIGEgJiYgbS5wdXNoKFwiI2RlZmluZSBPVkVSRFJBV19JTlNQRUNUT1I7XCIpO1xuICAgICAgdmFyIGcgPSBtLmNvbmNhdChHZS5mcmFnbWVudFNvdXJjZSwgaS5mcmFnbWVudFNvdXJjZSkuam9pbihcIlxcblwiKSxcbiAgICAgICAgdiA9IG0uY29uY2F0KEdlLnZlcnRleFNvdXJjZSwgaS52ZXJ0ZXhTb3VyY2UpLmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHkgPSBuLmNyZWF0ZVNoYWRlcihuLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICBpZiAobi5pc0NvbnRleHRMb3N0KCkpIHRoaXMuZmFpbGVkVG9DcmVhdGUgPSAhMDtlbHNlIHtcbiAgICAgICAgbi5zaGFkZXJTb3VyY2UoeSwgZyksIG4uY29tcGlsZVNoYWRlcih5KSwgbi5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLCB5KTtcbiAgICAgICAgdmFyIHggPSBuLmNyZWF0ZVNoYWRlcihuLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICBpZiAobi5pc0NvbnRleHRMb3N0KCkpIHRoaXMuZmFpbGVkVG9DcmVhdGUgPSAhMDtlbHNlIHtcbiAgICAgICAgICBuLnNoYWRlclNvdXJjZSh4LCB2KSwgbi5jb21waWxlU2hhZGVyKHgpLCBuLmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sIHgpLCB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICB2YXIgYiA9IHt9O1xuICAgICAgICAgIHRoaXMubnVtQXR0cmlidXRlcyA9IGMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgdGhpcy5udW1BdHRyaWJ1dGVzOyB3KyspIGNbd10gJiYgKG4uYmluZEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdywgY1t3XSksIHRoaXMuYXR0cmlidXRlc1tjW3ddXSA9IHcpO1xuICAgICAgICAgIG4ubGlua1Byb2dyYW0odGhpcy5wcm9ncmFtKSwgbi5kZWxldGVTaGFkZXIoeCksIG4uZGVsZXRlU2hhZGVyKHkpO1xuICAgICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgcC5sZW5ndGg7IFQrKykge1xuICAgICAgICAgICAgdmFyIEUgPSBwW1RdO1xuICAgICAgICAgICAgaWYgKEUgJiYgIWJbRV0pIHtcbiAgICAgICAgICAgICAgdmFyIEkgPSBuLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIEUpO1xuICAgICAgICAgICAgICBJICYmIChiW0VdID0gSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZml4ZWRVbmlmb3JtcyA9IHIodCwgYiksIHRoaXMuYmluZGVyVW5pZm9ybXMgPSBvID8gby5nZXRVbmlmb3Jtcyh0LCBiKSA6IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3aSh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IDEgLyBwZShpLCAxLCBlLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgIHIgPSBNYXRoLnBvdygyLCBpLnRpbGVJRC5vdmVyc2NhbGVkWiksXG4gICAgICAgIGEgPSBpLnRpbGVTaXplICogTWF0aC5wb3coMiwgZS50cmFuc2Zvcm0udGlsZVpvb20pIC8gcixcbiAgICAgICAgbiA9IGEgKiAoaS50aWxlSUQuY2Fub25pY2FsLnggKyBpLnRpbGVJRC53cmFwICogciksXG4gICAgICAgIHMgPSBhICogaS50aWxlSUQuY2Fub25pY2FsLnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICB1X3RleHNpemU6IGkuaW1hZ2VBdGxhc1RleHR1cmUuc2l6ZSxcbiAgICAgICAgdV9zY2FsZTogW28sIHQuZnJvbVNjYWxlLCB0LnRvU2NhbGVdLFxuICAgICAgICB1X2ZhZGU6IHQudCxcbiAgICAgICAgdV9waXhlbF9jb29yZF91cHBlcjogW24gPj4gMTYsIHMgPj4gMTZdLFxuICAgICAgICB1X3BpeGVsX2Nvb3JkX2xvd2VyOiBbNjU1MzUgJiBuLCA2NTUzNSAmIHNdXG4gICAgICB9O1xuICAgIH1cbiAgICBiaS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoLCBwLCBkLCBfLCBmKSB7XG4gICAgICB2YXIgbSxcbiAgICAgICAgZyA9IHQuZ2w7XG4gICAgICBpZiAoIXRoaXMuZmFpbGVkVG9DcmVhdGUpIHtcbiAgICAgICAgZm9yICh2YXIgdiBpbiB0LnByb2dyYW0uc2V0KHRoaXMucHJvZ3JhbSksIHQuc2V0RGVwdGhNb2RlKGkpLCB0LnNldFN0ZW5jaWxNb2RlKG8pLCB0LnNldENvbG9yTW9kZShyKSwgdC5zZXRDdWxsRmFjZShhKSwgdGhpcy5maXhlZFVuaWZvcm1zKSB0aGlzLmZpeGVkVW5pZm9ybXNbdl0uc2V0KG5bdl0pO1xuICAgICAgICBkICYmIGQuc2V0VW5pZm9ybXModCwgdGhpcy5iaW5kZXJVbmlmb3JtcywgaCwge1xuICAgICAgICAgIHpvb206IHBcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIHkgPSAobSA9IHt9LCBtW2cuTElORVNdID0gMiwgbVtnLlRSSUFOR0xFU10gPSAzLCBtW2cuTElORV9TVFJJUF0gPSAxLCBtKVtlXSwgeCA9IDAsIGIgPSB1LmdldCgpOyB4IDwgYi5sZW5ndGg7IHggKz0gMSkge1xuICAgICAgICAgIHZhciB3ID0gYlt4XSxcbiAgICAgICAgICAgIFQgPSB3LnZhb3MgfHwgKHcudmFvcyA9IHt9KTtcbiAgICAgICAgICAoVFtzXSB8fCAoVFtzXSA9IG5ldyB5aSgpKSkuYmluZCh0LCB0aGlzLCBsLCBkID8gZC5nZXRQYWludFZlcnRleEJ1ZmZlcnMoKSA6IFtdLCBjLCB3LnZlcnRleE9mZnNldCwgXywgZiksIGcuZHJhd0VsZW1lbnRzKGUsIHcucHJpbWl0aXZlTGVuZ3RoICogeSwgZy5VTlNJR05FRF9TSE9SVCwgdy5wcmltaXRpdmVPZmZzZXQgKiB5ICogMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBUaSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIHZhciBhID0gaS5zdHlsZS5saWdodCxcbiAgICAgICAgICBuID0gYS5wcm9wZXJ0aWVzLmdldChcInBvc2l0aW9uXCIpLFxuICAgICAgICAgIHMgPSBbbi54LCBuLnksIG4uel0sXG4gICAgICAgICAgbCA9IHQuY3JlYXRlJDEoKTtcbiAgICAgICAgXCJ2aWV3cG9ydFwiID09PSBhLnByb3BlcnRpZXMuZ2V0KFwiYW5jaG9yXCIpICYmIHQuZnJvbVJvdGF0aW9uKGwsIC1pLnRyYW5zZm9ybS5hbmdsZSksIHQudHJhbnNmb3JtTWF0MyhzLCBzLCBsKTtcbiAgICAgICAgdmFyIGMgPSBhLnByb3BlcnRpZXMuZ2V0KFwiY29sb3JcIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IGUsXG4gICAgICAgICAgdV9saWdodHBvczogcyxcbiAgICAgICAgICB1X2xpZ2h0aW50ZW5zaXR5OiBhLnByb3BlcnRpZXMuZ2V0KFwiaW50ZW5zaXR5XCIpLFxuICAgICAgICAgIHVfbGlnaHRjb2xvcjogW2MuciwgYy5nLCBjLmJdLFxuICAgICAgICAgIHVfdmVydGljYWxfZ3JhZGllbnQ6ICtvLFxuICAgICAgICAgIHVfb3BhY2l0eTogclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIEVpID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEsIG4sIHMpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKFRpKGUsIGksIG8sIHIpLCB3aShuLCBpLCBzKSwge1xuICAgICAgICAgIHVfaGVpZ2h0X2ZhY3RvcjogLU1hdGgucG93KDIsIGEub3ZlcnNjYWxlZFopIC8gcy50aWxlU2l6ZSAvIDhcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgSWkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiB0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgUGkgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICByZXR1cm4gdC5leHRlbmQoSWkoZSksIHdpKG8sIGksIHIpKTtcbiAgICAgIH0sXG4gICAgICBTaSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgICAgdV93b3JsZDogZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIENpID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKFBpKGUsIGksIG8sIHIpLCB7XG4gICAgICAgICAgdV93b3JsZDogYVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB6aSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIHZhciBhLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcyA9IGUudHJhbnNmb3JtO1xuICAgICAgICBpZiAoXCJtYXBcIiA9PT0gci5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCIpKSB7XG4gICAgICAgICAgdmFyIGwgPSBwZShvLCAxLCBzLnpvb20pO1xuICAgICAgICAgIGEgPSAhMCwgbiA9IFtsLCBsXTtcbiAgICAgICAgfSBlbHNlIGEgPSAhMSwgbiA9IHMucGl4ZWxzVG9HTFVuaXRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogcy5jYW1lcmFUb0NlbnRlckRpc3RhbmNlLFxuICAgICAgICAgIHVfc2NhbGVfd2l0aF9tYXA6ICsoXCJtYXBcIiA9PT0gci5wYWludC5nZXQoXCJjaXJjbGUtcGl0Y2gtc2NhbGVcIikpLFxuICAgICAgICAgIHVfbWF0cml4OiBlLnRyYW5zbGF0ZVBvc01hdHJpeChpLnBvc01hdHJpeCwgbywgci5wYWludC5nZXQoXCJjaXJjbGUtdHJhbnNsYXRlXCIpLCByLnBhaW50LmdldChcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCIpKSxcbiAgICAgICAgICB1X3BpdGNoX3dpdGhfbWFwOiArYSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgdV9leHRydWRlX3NjYWxlOiBuXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgRGkgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICB2YXIgbyA9IHBlKGksIDEsIGUuem9vbSksXG4gICAgICAgICAgciA9IE1hdGgucG93KDIsIGUuem9vbSAtIGkudGlsZUlELm92ZXJzY2FsZWRaKSxcbiAgICAgICAgICBhID0gaS50aWxlSUQub3ZlcnNjYWxlRmFjdG9yKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiBlLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsXG4gICAgICAgICAgdV9waXhlbHNfdG9fdGlsZV91bml0czogbyxcbiAgICAgICAgICB1X2V4dHJ1ZGVfc2NhbGU6IFtlLnBpeGVsc1RvR0xVbml0c1swXSAvIChvICogciksIGUucGl4ZWxzVG9HTFVuaXRzWzFdIC8gKG8gKiByKV0sXG4gICAgICAgICAgdV9vdmVyc2NhbGVfZmFjdG9yOiBhXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgQWkgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICAgIHVfaW52X21hdHJpeDogZSxcbiAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IGkuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSxcbiAgICAgICAgICB1X3ZpZXdwb3J0X3NpemU6IFtpLndpZHRoLCBpLmhlaWdodF1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBNaSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IGkgJiYgKGkgPSAxKSwge1xuICAgICAgICAgIHVfbWF0cml4OiB0LFxuICAgICAgICAgIHVfY29sb3I6IGUsXG4gICAgICAgICAgdV9vdmVybGF5OiAwLFxuICAgICAgICAgIHVfb3ZlcmxheV9zY2FsZTogaVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIExpID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogdFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFJpID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogdCxcbiAgICAgICAgICB1X2V4dHJ1ZGVfc2NhbGU6IHBlKGUsIDEsIGkpLFxuICAgICAgICAgIHVfaW50ZW5zaXR5OiBvXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAga2kgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICB2YXIgciA9IGUudHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfbWF0cml4OiBOaShlLCBpLCBvKSxcbiAgICAgICAgICB1X3JhdGlvOiAxIC8gcGUoaSwgMSwgci56b29tKSxcbiAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgdV91bml0c190b19waXhlbHM6IFsxIC8gci5waXhlbHNUb0dMVW5pdHNbMF0sIDEgLyByLnBpeGVsc1RvR0xVbml0c1sxXV1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBCaSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgIHJldHVybiB0LmV4dGVuZChraShlLCBpLCBvKSwge1xuICAgICAgICAgIHVfaW1hZ2U6IDAsXG4gICAgICAgICAgdV9pbWFnZV9oZWlnaHQ6IHJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgT2kgPSBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICB2YXIgYSA9IGUudHJhbnNmb3JtLFxuICAgICAgICAgIG4gPSBVaShpLCBhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1X21hdHJpeDogTmkoZSwgaSwgbyksXG4gICAgICAgICAgdV90ZXhzaXplOiBpLmltYWdlQXRsYXNUZXh0dXJlLnNpemUsXG4gICAgICAgICAgdV9yYXRpbzogMSAvIHBlKGksIDEsIGEuem9vbSksXG4gICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICAgIHVfaW1hZ2U6IDAsXG4gICAgICAgICAgdV9zY2FsZTogW24sIHIuZnJvbVNjYWxlLCByLnRvU2NhbGVdLFxuICAgICAgICAgIHVfZmFkZTogci50LFxuICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBbMSAvIGEucGl4ZWxzVG9HTFVuaXRzWzBdLCAxIC8gYS5waXhlbHNUb0dMVW5pdHNbMV1dXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgRmkgPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgICB2YXIgbiA9IGUubGluZUF0bGFzLFxuICAgICAgICAgIHMgPSBVaShpLCBlLnRyYW5zZm9ybSksXG4gICAgICAgICAgbCA9IFwicm91bmRcIiA9PT0gby5sYXlvdXQuZ2V0KFwibGluZS1jYXBcIiksXG4gICAgICAgICAgYyA9IG4uZ2V0RGFzaChyLmZyb20sIGwpLFxuICAgICAgICAgIHUgPSBuLmdldERhc2goci50bywgbCksXG4gICAgICAgICAgaCA9IGMud2lkdGggKiBhLmZyb21TY2FsZSxcbiAgICAgICAgICBwID0gdS53aWR0aCAqIGEudG9TY2FsZTtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKGtpKGUsIGksIG8pLCB7XG4gICAgICAgICAgdV9wYXR0ZXJuc2NhbGVfYTogW3MgLyBoLCAtYy5oZWlnaHQgLyAyXSxcbiAgICAgICAgICB1X3BhdHRlcm5zY2FsZV9iOiBbcyAvIHAsIC11LmhlaWdodCAvIDJdLFxuICAgICAgICAgIHVfc2RmZ2FtbWE6IG4ud2lkdGggLyAoMjU2ICogTWF0aC5taW4oaCwgcCkgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbykgLyAyLFxuICAgICAgICAgIHVfaW1hZ2U6IDAsXG4gICAgICAgICAgdV90ZXhfeV9hOiBjLnksXG4gICAgICAgICAgdV90ZXhfeV9iOiB1LnksXG4gICAgICAgICAgdV9taXg6IGEudFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gVWkodCwgZSkge1xuICAgICAgcmV0dXJuIDEgLyBwZSh0LCAxLCBlLnRpbGVab29tKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTmkodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlUG9zTWF0cml4KGUudGlsZUlELnBvc01hdHJpeCwgZSwgaS5wYWludC5nZXQoXCJsaW5lLXRyYW5zbGF0ZVwiKSwgaS5wYWludC5nZXQoXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIikpO1xuICAgIH1cbiAgICB2YXIgWmkgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgIHVfdGxfcGFyZW50OiBlLFxuICAgICAgICB1X3NjYWxlX3BhcmVudDogaSxcbiAgICAgICAgdV9idWZmZXJfc2NhbGU6IDEsXG4gICAgICAgIHVfZmFkZV90OiBvLm1peCxcbiAgICAgICAgdV9vcGFjaXR5OiBvLm9wYWNpdHkgKiByLnBhaW50LmdldChcInJhc3Rlci1vcGFjaXR5XCIpLFxuICAgICAgICB1X2ltYWdlMDogMCxcbiAgICAgICAgdV9pbWFnZTE6IDEsXG4gICAgICAgIHVfYnJpZ2h0bmVzc19sb3c6IHIucGFpbnQuZ2V0KFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCIpLFxuICAgICAgICB1X2JyaWdodG5lc3NfaGlnaDogci5wYWludC5nZXQoXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIiksXG4gICAgICAgIHVfc2F0dXJhdGlvbl9mYWN0b3I6IChuID0gci5wYWludC5nZXQoXCJyYXN0ZXItc2F0dXJhdGlvblwiKSwgbiA+IDAgPyAxIC0gMSAvICgxLjAwMSAtIG4pIDogLW4pLFxuICAgICAgICB1X2NvbnRyYXN0X2ZhY3RvcjogKGEgPSByLnBhaW50LmdldChcInJhc3Rlci1jb250cmFzdFwiKSwgYSA+IDAgPyAxIC8gKDEgLSBhKSA6IDEgKyBhKSxcbiAgICAgICAgdV9zcGluX3dlaWdodHM6IHFpKHIucGFpbnQuZ2V0KFwicmFzdGVyLWh1ZS1yb3RhdGVcIikpXG4gICAgICB9O1xuICAgICAgdmFyIGEsIG47XG4gICAgfTtcbiAgICBmdW5jdGlvbiBxaSh0KSB7XG4gICAgICB0ICo9IE1hdGguUEkgLyAxODA7XG4gICAgICB2YXIgZSA9IE1hdGguc2luKHQpLFxuICAgICAgICBpID0gTWF0aC5jb3ModCk7XG4gICAgICByZXR1cm4gWygyICogaSArIDEpIC8gMywgKC1NYXRoLnNxcnQoMykgKiBlIC0gaSArIDEpIC8gMywgKE1hdGguc3FydCgzKSAqIGUgLSBpICsgMSkgLyAzXTtcbiAgICB9XG4gICAgdmFyIGppLFxuICAgICAgVmkgPSBmdW5jdGlvbiAodCwgZSwgaSwgbywgciwgYSwgbiwgcywgbCwgYykge1xuICAgICAgICB2YXIgdSA9IHIudHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiArKFwiY29uc3RhbnRcIiA9PT0gdCB8fCBcInNvdXJjZVwiID09PSB0KSxcbiAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogKyhcImNvbnN0YW50XCIgPT09IHQgfHwgXCJjYW1lcmFcIiA9PT0gdCksXG4gICAgICAgICAgdV9zaXplX3Q6IGUgPyBlLnVTaXplVCA6IDAsXG4gICAgICAgICAgdV9zaXplOiBlID8gZS51U2l6ZSA6IDAsXG4gICAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiB1LmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UsXG4gICAgICAgICAgdV9waXRjaDogdS5waXRjaCAvIDM2MCAqIDIgKiBNYXRoLlBJLFxuICAgICAgICAgIHVfcm90YXRlX3N5bWJvbDogK2ksXG4gICAgICAgICAgdV9hc3BlY3RfcmF0aW86IHUud2lkdGggLyB1LmhlaWdodCxcbiAgICAgICAgICB1X2ZhZGVfY2hhbmdlOiByLm9wdGlvbnMuZmFkZUR1cmF0aW9uID8gci5zeW1ib2xGYWRlQ2hhbmdlIDogMSxcbiAgICAgICAgICB1X21hdHJpeDogYSxcbiAgICAgICAgICB1X2xhYmVsX3BsYW5lX21hdHJpeDogbixcbiAgICAgICAgICB1X2Nvb3JkX21hdHJpeDogcyxcbiAgICAgICAgICB1X2lzX3RleHQ6ICtsLFxuICAgICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6ICtvLFxuICAgICAgICAgIHVfdGV4c2l6ZTogYyxcbiAgICAgICAgICB1X3RleHR1cmU6IDBcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBHaSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoKSB7XG4gICAgICAgIHZhciBwID0gYS50cmFuc2Zvcm07XG4gICAgICAgIHJldHVybiB0LmV4dGVuZChWaShlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1KSwge1xuICAgICAgICAgIHVfZ2FtbWFfc2NhbGU6IHIgPyBNYXRoLmNvcyhwLl9waXRjaCkgKiBwLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UgOiAxLFxuICAgICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICB1X2lzX2hhbG86ICtoXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFdpID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUpIHtcbiAgICAgICAgcmV0dXJuIHQuZXh0ZW5kKEdpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsICEwLCBjLCAhMCksIHtcbiAgICAgICAgICB1X3RleHNpemVfaWNvbjogdSxcbiAgICAgICAgICB1X3RleHR1cmVfaWNvbjogMVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBYaSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdV9tYXRyaXg6IHQsXG4gICAgICAgICAgdV9vcGFjaXR5OiBlLFxuICAgICAgICAgIHVfY29sb3I6IGlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBIaSA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICAgIHJldHVybiB0LmV4dGVuZChmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICAgIHZhciByID0gaS5pbWFnZU1hbmFnZXIuZ2V0UGF0dGVybih0LmZyb20udG9TdHJpbmcoKSksXG4gICAgICAgICAgICBhID0gaS5pbWFnZU1hbmFnZXIuZ2V0UGF0dGVybih0LnRvLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgbiA9IGkuaW1hZ2VNYW5hZ2VyLmdldFBpeGVsU2l6ZSgpLFxuICAgICAgICAgICAgcyA9IG4ud2lkdGgsXG4gICAgICAgICAgICBsID0gbi5oZWlnaHQsXG4gICAgICAgICAgICBjID0gTWF0aC5wb3coMiwgby50aWxlSUQub3ZlcnNjYWxlZFopLFxuICAgICAgICAgICAgdSA9IG8udGlsZVNpemUgKiBNYXRoLnBvdygyLCBpLnRyYW5zZm9ybS50aWxlWm9vbSkgLyBjLFxuICAgICAgICAgICAgaCA9IHUgKiAoby50aWxlSUQuY2Fub25pY2FsLnggKyBvLnRpbGVJRC53cmFwICogYyksXG4gICAgICAgICAgICBwID0gdSAqIG8udGlsZUlELmNhbm9uaWNhbC55O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X2ltYWdlOiAwLFxuICAgICAgICAgICAgdV9wYXR0ZXJuX3RsX2E6IHIudGwsXG4gICAgICAgICAgICB1X3BhdHRlcm5fYnJfYTogci5icixcbiAgICAgICAgICAgIHVfcGF0dGVybl90bF9iOiBhLnRsLFxuICAgICAgICAgICAgdV9wYXR0ZXJuX2JyX2I6IGEuYnIsXG4gICAgICAgICAgICB1X3RleHNpemU6IFtzLCBsXSxcbiAgICAgICAgICAgIHVfbWl4OiBlLnQsXG4gICAgICAgICAgICB1X3BhdHRlcm5fc2l6ZV9hOiByLmRpc3BsYXlTaXplLFxuICAgICAgICAgICAgdV9wYXR0ZXJuX3NpemVfYjogYS5kaXNwbGF5U2l6ZSxcbiAgICAgICAgICAgIHVfc2NhbGVfYTogZS5mcm9tU2NhbGUsXG4gICAgICAgICAgICB1X3NjYWxlX2I6IGUudG9TY2FsZSxcbiAgICAgICAgICAgIHVfdGlsZV91bml0c190b19waXhlbHM6IDEgLyBwZShvLCAxLCBpLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgICB1X3BpeGVsX2Nvb3JkX3VwcGVyOiBbaCA+PiAxNiwgcCA+PiAxNl0sXG4gICAgICAgICAgICB1X3BpeGVsX2Nvb3JkX2xvd2VyOiBbNjU1MzUgJiBoLCA2NTUzNSAmIHBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfShyLCBuLCBvLCBhKSwge1xuICAgICAgICAgIHVfbWF0cml4OiBlLFxuICAgICAgICAgIHVfb3BhY2l0eTogaVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBLaSA9IHtcbiAgICAgICAgZmlsbEV4dHJ1c2lvbjogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfbGlnaHRwb3M6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfbGlnaHRwb3MpLFxuICAgICAgICAgICAgdV9saWdodGludGVuc2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9saWdodGludGVuc2l0eSksXG4gICAgICAgICAgICB1X2xpZ2h0Y29sb3I6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfbGlnaHRjb2xvciksXG4gICAgICAgICAgICB1X3ZlcnRpY2FsX2dyYWRpZW50OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3ZlcnRpY2FsX2dyYWRpZW50KSxcbiAgICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxFeHRydXNpb25QYXR0ZXJuOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgICAgdV9saWdodHBvczogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9saWdodHBvcyksXG4gICAgICAgICAgICB1X2xpZ2h0aW50ZW5zaXR5OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2xpZ2h0aW50ZW5zaXR5KSxcbiAgICAgICAgICAgIHVfbGlnaHRjb2xvcjogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9saWdodGNvbG9yKSxcbiAgICAgICAgICAgIHVfdmVydGljYWxfZ3JhZGllbnQ6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdmVydGljYWxfZ3JhZGllbnQpLFxuICAgICAgICAgICAgdV9oZWlnaHRfZmFjdG9yOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2hlaWdodF9mYWN0b3IpLFxuICAgICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgICB1X3BpeGVsX2Nvb3JkX3VwcGVyOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BpeGVsX2Nvb3JkX3VwcGVyKSxcbiAgICAgICAgICAgIHVfcGl4ZWxfY29vcmRfbG93ZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfbG93ZXIpLFxuICAgICAgICAgICAgdV9zY2FsZTogbmV3IHQuVW5pZm9ybTNmKGUsIGkudV9zY2FsZSksXG4gICAgICAgICAgICB1X2ZhZGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZmFkZSksXG4gICAgICAgICAgICB1X29wYWNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3BhY2l0eSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBmaWxsOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbFBhdHRlcm46IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICAgIHVfdGV4c2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV90ZXhzaXplKSxcbiAgICAgICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfdXBwZXIpLFxuICAgICAgICAgICAgdV9waXhlbF9jb29yZF9sb3dlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF9sb3dlciksXG4gICAgICAgICAgICB1X3NjYWxlOiBuZXcgdC5Vbmlmb3JtM2YoZSwgaS51X3NjYWxlKSxcbiAgICAgICAgICAgIHVfZmFkZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxPdXRsaW5lOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgICAgdV93b3JsZDogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV93b3JsZClcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBmaWxsT3V0bGluZVBhdHRlcm46IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X3dvcmxkOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3dvcmxkKSxcbiAgICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgICAgdV90ZXhzaXplOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemUpLFxuICAgICAgICAgICAgdV9waXhlbF9jb29yZF91cHBlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF91cHBlciksXG4gICAgICAgICAgICB1X3BpeGVsX2Nvb3JkX2xvd2VyOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BpeGVsX2Nvb3JkX2xvd2VyKSxcbiAgICAgICAgICAgIHVfc2NhbGU6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc2NhbGUpLFxuICAgICAgICAgICAgdV9mYWRlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2ZhZGUpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgICB1X3NjYWxlX3dpdGhfbWFwOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3NjYWxlX3dpdGhfbWFwKSxcbiAgICAgICAgICAgIHVfcGl0Y2hfd2l0aF9tYXA6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcGl0Y2hfd2l0aF9tYXApLFxuICAgICAgICAgICAgdV9leHRydWRlX3NjYWxlOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X2V4dHJ1ZGVfc2NhbGUpLFxuICAgICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjb2xsaXNpb25Cb3g6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZSksXG4gICAgICAgICAgICB1X3BpeGVsc190b190aWxlX3VuaXRzOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3BpeGVsc190b190aWxlX3VuaXRzKSxcbiAgICAgICAgICAgIHVfZXh0cnVkZV9zY2FsZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9leHRydWRlX3NjYWxlKSxcbiAgICAgICAgICAgIHVfb3ZlcnNjYWxlX2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vdmVyc2NhbGVfZmFjdG9yKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxpc2lvbkNpcmNsZTogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfaW52X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9pbnZfbWF0cml4KSxcbiAgICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICAgIHVfdmlld3BvcnRfc2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV92aWV3cG9ydF9zaXplKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGRlYnVnOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X2NvbG9yOiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X2NvbG9yKSxcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X292ZXJsYXk6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfb3ZlcmxheSksXG4gICAgICAgICAgICB1X292ZXJsYXlfc2NhbGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3ZlcmxheV9zY2FsZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjbGlwcGluZ01hc2s6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeClcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBoZWF0bWFwOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X2V4dHJ1ZGVfc2NhbGU6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZXh0cnVkZV9zY2FsZSksXG4gICAgICAgICAgICB1X2ludGVuc2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9pbnRlbnNpdHkpLFxuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhlYXRtYXBUZXh0dXJlOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgICAgdV93b3JsZDogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV93b3JsZCksXG4gICAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICAgIHVfY29sb3JfcmFtcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9jb2xvcl9yYW1wKSxcbiAgICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhpbGxzaGFkZTogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfaW1hZ2U6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaW1hZ2UpLFxuICAgICAgICAgICAgdV9sYXRyYW5nZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9sYXRyYW5nZSksXG4gICAgICAgICAgICB1X2xpZ2h0OiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X2xpZ2h0KSxcbiAgICAgICAgICAgIHVfc2hhZG93OiBuZXcgdC5Vbmlmb3JtQ29sb3IoZSwgaS51X3NoYWRvdyksXG4gICAgICAgICAgICB1X2hpZ2hsaWdodDogbmV3IHQuVW5pZm9ybUNvbG9yKGUsIGkudV9oaWdobGlnaHQpLFxuICAgICAgICAgICAgdV9hY2NlbnQ6IG5ldyB0LlVuaWZvcm1Db2xvcihlLCBpLnVfYWNjZW50KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhpbGxzaGFkZVByZXBhcmU6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICAgIHVfZGltZW5zaW9uOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X2RpbWVuc2lvbiksXG4gICAgICAgICAgICB1X3pvb206IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfem9vbSksXG4gICAgICAgICAgICB1X3VucGFjazogbmV3IHQuVW5pZm9ybTRmKGUsIGkudV91bnBhY2spXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfcmF0aW8pLFxuICAgICAgICAgICAgdV9kZXZpY2VfcGl4ZWxfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZGV2aWNlX3BpeGVsX3JhdGlvKSxcbiAgICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3VuaXRzX3RvX3BpeGVscylcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBsaW5lR3JhZGllbnQ6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2RldmljZV9waXhlbF9yYXRpbyksXG4gICAgICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV91bml0c190b19waXhlbHMpLFxuICAgICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgICB1X2ltYWdlX2hlaWdodDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9pbWFnZV9oZWlnaHQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVBhdHRlcm46IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2RldmljZV9waXhlbF9yYXRpbyksXG4gICAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICAgIHVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3VuaXRzX3RvX3BpeGVscyksXG4gICAgICAgICAgICB1X3NjYWxlOiBuZXcgdC5Vbmlmb3JtM2YoZSwgaS51X3NjYWxlKSxcbiAgICAgICAgICAgIHVfZmFkZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTREY6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3JhdGlvKSxcbiAgICAgICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2RldmljZV9waXhlbF9yYXRpbyksXG4gICAgICAgICAgICB1X3VuaXRzX3RvX3BpeGVsczogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV91bml0c190b19waXhlbHMpLFxuICAgICAgICAgICAgdV9wYXR0ZXJuc2NhbGVfYTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9wYXR0ZXJuc2NhbGVfYSksXG4gICAgICAgICAgICB1X3BhdHRlcm5zY2FsZV9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5zY2FsZV9iKSxcbiAgICAgICAgICAgIHVfc2RmZ2FtbWE6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2RmZ2FtbWEpLFxuICAgICAgICAgICAgdV9pbWFnZTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZSksXG4gICAgICAgICAgICB1X3RleF95X2E6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdGV4X3lfYSksXG4gICAgICAgICAgICB1X3RleF95X2I6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfdGV4X3lfYiksXG4gICAgICAgICAgICB1X21peDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9taXgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmFzdGVyOiBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgICAgdV90bF9wYXJlbnQ6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGxfcGFyZW50KSxcbiAgICAgICAgICAgIHVfc2NhbGVfcGFyZW50OiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NjYWxlX3BhcmVudCksXG4gICAgICAgICAgICB1X2J1ZmZlcl9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9idWZmZXJfc2NhbGUpLFxuICAgICAgICAgICAgdV9mYWRlX3Q6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZmFkZV90KSxcbiAgICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KSxcbiAgICAgICAgICAgIHVfaW1hZ2UwOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlMCksXG4gICAgICAgICAgICB1X2ltYWdlMTogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pbWFnZTEpLFxuICAgICAgICAgICAgdV9icmlnaHRuZXNzX2xvdzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9icmlnaHRuZXNzX2xvdyksXG4gICAgICAgICAgICB1X2JyaWdodG5lc3NfaGlnaDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9icmlnaHRuZXNzX2hpZ2gpLFxuICAgICAgICAgICAgdV9zYXR1cmF0aW9uX2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zYXR1cmF0aW9uX2ZhY3RvciksXG4gICAgICAgICAgICB1X2NvbnRyYXN0X2ZhY3RvcjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jb250cmFzdF9mYWN0b3IpLFxuICAgICAgICAgICAgdV9zcGluX3dlaWdodHM6IG5ldyB0LlVuaWZvcm0zZihlLCBpLnVfc3Bpbl93ZWlnaHRzKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbEljb246IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3NpemVfem9vbV9jb25zdGFudCksXG4gICAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpLFxuICAgICAgICAgICAgdV9zaXplX3Q6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2l6ZV90KSxcbiAgICAgICAgICAgIHVfc2l6ZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplKSxcbiAgICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICAgIHVfcGl0Y2g6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfcGl0Y2gpLFxuICAgICAgICAgICAgdV9yb3RhdGVfc3ltYm9sOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3JvdGF0ZV9zeW1ib2wpLFxuICAgICAgICAgICAgdV9hc3BlY3RfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfYXNwZWN0X3JhdGlvKSxcbiAgICAgICAgICAgIHVfZmFkZV9jaGFuZ2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZmFkZV9jaGFuZ2UpLFxuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfbGFiZWxfcGxhbmVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2xhYmVsX3BsYW5lX21hdHJpeCksXG4gICAgICAgICAgICB1X2Nvb3JkX21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9jb29yZF9tYXRyaXgpLFxuICAgICAgICAgICAgdV9pc190ZXh0OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3RleHQpLFxuICAgICAgICAgICAgdV9waXRjaF93aXRoX21hcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9waXRjaF93aXRoX21hcCksXG4gICAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgICB1X3RleHR1cmU6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfdGV4dHVyZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xTREY6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfaXNfc2l6ZV96b29tX2NvbnN0YW50OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3NpemVfem9vbV9jb25zdGFudCksXG4gICAgICAgICAgICB1X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9pc19zaXplX2ZlYXR1cmVfY29uc3RhbnQpLFxuICAgICAgICAgICAgdV9zaXplX3Q6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfc2l6ZV90KSxcbiAgICAgICAgICAgIHVfc2l6ZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplKSxcbiAgICAgICAgICAgIHVfY2FtZXJhX3RvX2NlbnRlcl9kaXN0YW5jZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlKSxcbiAgICAgICAgICAgIHVfcGl0Y2g6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfcGl0Y2gpLFxuICAgICAgICAgICAgdV9yb3RhdGVfc3ltYm9sOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3JvdGF0ZV9zeW1ib2wpLFxuICAgICAgICAgICAgdV9hc3BlY3RfcmF0aW86IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfYXNwZWN0X3JhdGlvKSxcbiAgICAgICAgICAgIHVfZmFkZV9jaGFuZ2U6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfZmFkZV9jaGFuZ2UpLFxuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfbGFiZWxfcGxhbmVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2xhYmVsX3BsYW5lX21hdHJpeCksXG4gICAgICAgICAgICB1X2Nvb3JkX21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9jb29yZF9tYXRyaXgpLFxuICAgICAgICAgICAgdV9pc190ZXh0OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3RleHQpLFxuICAgICAgICAgICAgdV9waXRjaF93aXRoX21hcDogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV9waXRjaF93aXRoX21hcCksXG4gICAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgICB1X3RleHR1cmU6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfdGV4dHVyZSksXG4gICAgICAgICAgICB1X2dhbW1hX3NjYWxlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2dhbW1hX3NjYWxlKSxcbiAgICAgICAgICAgIHVfZGV2aWNlX3BpeGVsX3JhdGlvOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2RldmljZV9waXhlbF9yYXRpbyksXG4gICAgICAgICAgICB1X2lzX2hhbG86IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfaGFsbylcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xUZXh0QW5kSWNvbjogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9pc19zaXplX3pvb21fY29uc3RhbnQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfc2l6ZV96b29tX2NvbnN0YW50KSxcbiAgICAgICAgICAgIHVfaXNfc2l6ZV9mZWF0dXJlX2NvbnN0YW50OiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX3NpemVfZmVhdHVyZV9jb25zdGFudCksXG4gICAgICAgICAgICB1X3NpemVfdDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zaXplX3QpLFxuICAgICAgICAgICAgdV9zaXplOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3NpemUpLFxuICAgICAgICAgICAgdV9jYW1lcmFfdG9fY2VudGVyX2Rpc3RhbmNlOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X2NhbWVyYV90b19jZW50ZXJfZGlzdGFuY2UpLFxuICAgICAgICAgICAgdV9waXRjaDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9waXRjaCksXG4gICAgICAgICAgICB1X3JvdGF0ZV9zeW1ib2w6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfcm90YXRlX3N5bWJvbCksXG4gICAgICAgICAgICB1X2FzcGVjdF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9hc3BlY3RfcmF0aW8pLFxuICAgICAgICAgICAgdV9mYWRlX2NoYW5nZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9mYWRlX2NoYW5nZSksXG4gICAgICAgICAgICB1X21hdHJpeDogbmV3IHQuVW5pZm9ybU1hdHJpeDRmKGUsIGkudV9tYXRyaXgpLFxuICAgICAgICAgICAgdV9sYWJlbF9wbGFuZV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbGFiZWxfcGxhbmVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfY29vcmRfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X2Nvb3JkX21hdHJpeCksXG4gICAgICAgICAgICB1X2lzX3RleHQ6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfaXNfdGV4dCksXG4gICAgICAgICAgICB1X3BpdGNoX3dpdGhfbWFwOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X3BpdGNoX3dpdGhfbWFwKSxcbiAgICAgICAgICAgIHVfdGV4c2l6ZTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV90ZXhzaXplKSxcbiAgICAgICAgICAgIHVfdGV4c2l6ZV9pY29uOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3RleHNpemVfaWNvbiksXG4gICAgICAgICAgICB1X3RleHR1cmU6IG5ldyB0LlVuaWZvcm0xaShlLCBpLnVfdGV4dHVyZSksXG4gICAgICAgICAgICB1X3RleHR1cmVfaWNvbjogbmV3IHQuVW5pZm9ybTFpKGUsIGkudV90ZXh0dXJlX2ljb24pLFxuICAgICAgICAgICAgdV9nYW1tYV9zY2FsZTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9nYW1tYV9zY2FsZSksXG4gICAgICAgICAgICB1X2RldmljZV9waXhlbF9yYXRpbzogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgICAgdV9pc19oYWxvOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2lzX2hhbG8pXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZDogZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdV9tYXRyaXg6IG5ldyB0LlVuaWZvcm1NYXRyaXg0ZihlLCBpLnVfbWF0cml4KSxcbiAgICAgICAgICAgIHVfb3BhY2l0eTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9vcGFjaXR5KSxcbiAgICAgICAgICAgIHVfY29sb3I6IG5ldyB0LlVuaWZvcm1Db2xvcihlLCBpLnVfY29sb3IpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZFBhdHRlcm46IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVfbWF0cml4OiBuZXcgdC5Vbmlmb3JtTWF0cml4NGYoZSwgaS51X21hdHJpeCksXG4gICAgICAgICAgICB1X29wYWNpdHk6IG5ldyB0LlVuaWZvcm0xZihlLCBpLnVfb3BhY2l0eSksXG4gICAgICAgICAgICB1X2ltYWdlOiBuZXcgdC5Vbmlmb3JtMWkoZSwgaS51X2ltYWdlKSxcbiAgICAgICAgICAgIHVfcGF0dGVybl90bF9hOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fdGxfYSksXG4gICAgICAgICAgICB1X3BhdHRlcm5fYnJfYTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9wYXR0ZXJuX2JyX2EpLFxuICAgICAgICAgICAgdV9wYXR0ZXJuX3RsX2I6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGF0dGVybl90bF9iKSxcbiAgICAgICAgICAgIHVfcGF0dGVybl9icl9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fYnJfYiksXG4gICAgICAgICAgICB1X3RleHNpemU6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfdGV4c2l6ZSksXG4gICAgICAgICAgICB1X21peDogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9taXgpLFxuICAgICAgICAgICAgdV9wYXR0ZXJuX3NpemVfYTogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9wYXR0ZXJuX3NpemVfYSksXG4gICAgICAgICAgICB1X3BhdHRlcm5fc2l6ZV9iOiBuZXcgdC5Vbmlmb3JtMmYoZSwgaS51X3BhdHRlcm5fc2l6ZV9iKSxcbiAgICAgICAgICAgIHVfc2NhbGVfYTogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zY2FsZV9hKSxcbiAgICAgICAgICAgIHVfc2NhbGVfYjogbmV3IHQuVW5pZm9ybTFmKGUsIGkudV9zY2FsZV9iKSxcbiAgICAgICAgICAgIHVfcGl4ZWxfY29vcmRfdXBwZXI6IG5ldyB0LlVuaWZvcm0yZihlLCBpLnVfcGl4ZWxfY29vcmRfdXBwZXIpLFxuICAgICAgICAgICAgdV9waXhlbF9jb29yZF9sb3dlcjogbmV3IHQuVW5pZm9ybTJmKGUsIGkudV9waXhlbF9jb29yZF9sb3dlciksXG4gICAgICAgICAgICB1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzOiBuZXcgdC5Vbmlmb3JtMWYoZSwgaS51X3RpbGVfdW5pdHNfdG9fcGl4ZWxzKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgZnVuY3Rpb24gWWkoZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgZm9yICh2YXIgbCA9IGUuY29udGV4dCwgYyA9IGwuZ2wsIHUgPSBlLnVzZVByb2dyYW0oXCJjb2xsaXNpb25Cb3hcIiksIGggPSBbXSwgcCA9IDAsIGQgPSAwLCBfID0gMDsgXyA8IHIubGVuZ3RoOyBfKyspIHtcbiAgICAgICAgdmFyIGYgPSByW19dLFxuICAgICAgICAgIG0gPSBpLmdldFRpbGUoZiksXG4gICAgICAgICAgZyA9IG0uZ2V0QnVja2V0KG8pO1xuICAgICAgICBpZiAoZykge1xuICAgICAgICAgIHZhciB2ID0gZi5wb3NNYXRyaXg7XG4gICAgICAgICAgMCA9PT0gYVswXSAmJiAwID09PSBhWzFdIHx8ICh2ID0gZS50cmFuc2xhdGVQb3NNYXRyaXgoZi5wb3NNYXRyaXgsIG0sIGEsIG4pKTtcbiAgICAgICAgICB2YXIgeSA9IHMgPyBnLnRleHRDb2xsaXNpb25Cb3ggOiBnLmljb25Db2xsaXNpb25Cb3gsXG4gICAgICAgICAgICB4ID0gZy5jb2xsaXNpb25DaXJjbGVBcnJheTtcbiAgICAgICAgICBpZiAoeC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHQuY3JlYXRlKCksXG4gICAgICAgICAgICAgIHcgPSB2O1xuICAgICAgICAgICAgdC5tdWwoYiwgZy5wbGFjZW1lbnRJbnZQcm9qTWF0cml4LCBlLnRyYW5zZm9ybS5nbENvb3JkTWF0cml4KSwgdC5tdWwoYiwgYiwgZy5wbGFjZW1lbnRWaWV3cG9ydE1hdHJpeCksIGgucHVzaCh7XG4gICAgICAgICAgICAgIGNpcmNsZUFycmF5OiB4LFxuICAgICAgICAgICAgICBjaXJjbGVPZmZzZXQ6IGQsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdyxcbiAgICAgICAgICAgICAgaW52VHJhbnNmb3JtOiBiXG4gICAgICAgICAgICB9KSwgZCA9IHAgKz0geC5sZW5ndGggLyA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB5ICYmIHUuZHJhdyhsLCBjLkxJTkVTLCBJdC5kaXNhYmxlZCwgUHQuZGlzYWJsZWQsIGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBDdC5kaXNhYmxlZCwgRGkodiwgZS50cmFuc2Zvcm0sIG0pLCBvLmlkLCB5LmxheW91dFZlcnRleEJ1ZmZlciwgeS5pbmRleEJ1ZmZlciwgeS5zZWdtZW50cywgbnVsbCwgZS50cmFuc2Zvcm0uem9vbSwgbnVsbCwgbnVsbCwgeS5jb2xsaXNpb25WZXJ0ZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocyAmJiBoLmxlbmd0aCkge1xuICAgICAgICB2YXIgVCA9IGUudXNlUHJvZ3JhbShcImNvbGxpc2lvbkNpcmNsZVwiKSxcbiAgICAgICAgICBFID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyZjFmMmkxNigpO1xuICAgICAgICBFLnJlc2l6ZSg0ICogcCksIEUuX3RyaW0oKTtcbiAgICAgICAgZm9yICh2YXIgSSA9IDAsIFAgPSAwLCBTID0gaDsgUCA8IFMubGVuZ3RoOyBQICs9IDEpIGZvciAodmFyIEMgPSBTW1BdLCB6ID0gMDsgeiA8IEMuY2lyY2xlQXJyYXkubGVuZ3RoIC8gNDsgeisrKSB7XG4gICAgICAgICAgdmFyIEQgPSA0ICogeixcbiAgICAgICAgICAgIEEgPSBDLmNpcmNsZUFycmF5W0QgKyAwXSxcbiAgICAgICAgICAgIE0gPSBDLmNpcmNsZUFycmF5W0QgKyAxXSxcbiAgICAgICAgICAgIEwgPSBDLmNpcmNsZUFycmF5W0QgKyAyXSxcbiAgICAgICAgICAgIFIgPSBDLmNpcmNsZUFycmF5W0QgKyAzXTtcbiAgICAgICAgICBFLmVtcGxhY2UoSSsrLCBBLCBNLCBMLCBSLCAwKSwgRS5lbXBsYWNlKEkrKywgQSwgTSwgTCwgUiwgMSksIEUuZW1wbGFjZShJKyssIEEsIE0sIEwsIFIsIDIpLCBFLmVtcGxhY2UoSSsrLCBBLCBNLCBMLCBSLCAzKTtcbiAgICAgICAgfVxuICAgICAgICAoIWppIHx8IGppLmxlbmd0aCA8IDIgKiBwKSAmJiAoamkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gMiAqIGUsXG4gICAgICAgICAgICBvID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQzdWk2KCk7XG4gICAgICAgICAgby5yZXNpemUoaSksIG8uX3RyaW0oKTtcbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGk7IHIrKykge1xuICAgICAgICAgICAgdmFyIGEgPSA2ICogcjtcbiAgICAgICAgICAgIG8udWludDE2W2EgKyAwXSA9IDQgKiByICsgMCwgby51aW50MTZbYSArIDFdID0gNCAqIHIgKyAxLCBvLnVpbnQxNlthICsgMl0gPSA0ICogciArIDIsIG8udWludDE2W2EgKyAzXSA9IDQgKiByICsgMiwgby51aW50MTZbYSArIDRdID0gNCAqIHIgKyAzLCBvLnVpbnQxNlthICsgNV0gPSA0ICogciArIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9KHApKTtcbiAgICAgICAgZm9yICh2YXIgayA9IGwuY3JlYXRlSW5kZXhCdWZmZXIoamksICEwKSwgQiA9IGwuY3JlYXRlVmVydGV4QnVmZmVyKEUsIHQuY29sbGlzaW9uQ2lyY2xlTGF5b3V0Lm1lbWJlcnMsICEwKSwgTyA9IDAsIEYgPSBoOyBPIDwgRi5sZW5ndGg7IE8gKz0gMSkge1xuICAgICAgICAgIHZhciBVID0gRltPXSxcbiAgICAgICAgICAgIE4gPSBBaShVLnRyYW5zZm9ybSwgVS5pbnZUcmFuc2Zvcm0sIGUudHJhbnNmb3JtKTtcbiAgICAgICAgICBULmRyYXcobCwgYy5UUklBTkdMRVMsIEl0LmRpc2FibGVkLCBQdC5kaXNhYmxlZCwgZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksIEN0LmRpc2FibGVkLCBOLCBvLmlkLCBCLCBrLCB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAyICogVS5jaXJjbGVPZmZzZXQsIFUuY2lyY2xlQXJyYXkubGVuZ3RoLCBVLmNpcmNsZUFycmF5Lmxlbmd0aCAvIDIpLCBudWxsLCBlLnRyYW5zZm9ybS56b29tLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBCLmRlc3Ryb3koKSwgay5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBKaSA9IHQuaWRlbnRpdHkobmV3IEZsb2F0MzJBcnJheSgxNikpO1xuICAgIGZ1bmN0aW9uIFFpKGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gdC5nZXRBbmNob3JBbGlnbm1lbnQoZSksXG4gICAgICAgIGwgPSAtKHMuaG9yaXpvbnRhbEFsaWduIC0gLjUpICogaSxcbiAgICAgICAgYyA9IC0ocy52ZXJ0aWNhbEFsaWduIC0gLjUpICogbyxcbiAgICAgICAgdSA9IHQuZXZhbHVhdGVWYXJpYWJsZU9mZnNldChlLCByKTtcbiAgICAgIHJldHVybiBuZXcgdC5Qb2ludCgobCAvIGEgKyB1WzBdKSAqIG4sIChjIC8gYSArIHVbMV0pICogbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uICRpKGUsIGksIG8sIHIsIGEsIG4sIHMsIGwsIGMsIHUsIGgpIHtcbiAgICAgIHZhciBwID0gZS50ZXh0LnBsYWNlZFN5bWJvbEFycmF5LFxuICAgICAgICBkID0gZS50ZXh0LmR5bmFtaWNMYXlvdXRWZXJ0ZXhBcnJheSxcbiAgICAgICAgXyA9IGUuaWNvbi5keW5hbWljTGF5b3V0VmVydGV4QXJyYXksXG4gICAgICAgIGYgPSB7fTtcbiAgICAgIGQuY2xlYXIoKTtcbiAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgcC5sZW5ndGg7IG0rKykge1xuICAgICAgICB2YXIgZyA9IHAuZ2V0KG0pLFxuICAgICAgICAgIHYgPSBnLmhpZGRlbiB8fCAhZy5jcm9zc1RpbGVJRCB8fCBlLmFsbG93VmVydGljYWxQbGFjZW1lbnQgJiYgIWcucGxhY2VkT3JpZW50YXRpb24gPyBudWxsIDogcltnLmNyb3NzVGlsZUlEXTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICB2YXIgeSA9IG5ldyB0LlBvaW50KGcuYW5jaG9yWCwgZy5hbmNob3JZKSxcbiAgICAgICAgICAgIHggPSAkdCh5LCBvID8gbCA6IHMpLFxuICAgICAgICAgICAgYiA9IHRlKG4uY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSwgeC5zaWduZWREaXN0YW5jZUZyb21DYW1lcmEpLFxuICAgICAgICAgICAgdyA9IGEuZXZhbHVhdGVTaXplRm9yRmVhdHVyZShlLnRleHRTaXplRGF0YSwgdSwgZykgKiBiIC8gdC5PTkVfRU07XG4gICAgICAgICAgbyAmJiAodyAqPSBlLnRpbGVQaXhlbFJhdGlvIC8gYyk7XG4gICAgICAgICAgZm9yICh2YXIgVCA9IFFpKHYuYW5jaG9yLCB2LndpZHRoLCB2LmhlaWdodCwgdi50ZXh0T2Zmc2V0LCB2LnRleHRCb3hTY2FsZSwgdyksIEUgPSBvID8gJHQoeS5hZGQoVCksIHMpLnBvaW50IDogeC5wb2ludC5hZGQoaSA/IFQucm90YXRlKC1uLmFuZ2xlKSA6IFQpLCBJID0gZS5hbGxvd1ZlcnRpY2FsUGxhY2VtZW50ICYmIGcucGxhY2VkT3JpZW50YXRpb24gPT09IHQuV3JpdGluZ01vZGUudmVydGljYWwgPyBNYXRoLlBJIC8gMiA6IDAsIFAgPSAwOyBQIDwgZy5udW1HbHlwaHM7IFArKykgdC5hZGREeW5hbWljQXR0cmlidXRlcyhkLCBFLCBJKTtcbiAgICAgICAgICBoICYmIGcuYXNzb2NpYXRlZEljb25JbmRleCA+PSAwICYmIChmW2cuYXNzb2NpYXRlZEljb25JbmRleF0gPSB7XG4gICAgICAgICAgICBzaGlmdGVkQW5jaG9yOiBFLFxuICAgICAgICAgICAgYW5nbGU6IElcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGNlKGcubnVtR2x5cGhzLCBkKTtcbiAgICAgIH1cbiAgICAgIGlmIChoKSB7XG4gICAgICAgIF8uY2xlYXIoKTtcbiAgICAgICAgZm9yICh2YXIgUyA9IGUuaWNvbi5wbGFjZWRTeW1ib2xBcnJheSwgQyA9IDA7IEMgPCBTLmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgdmFyIHogPSBTLmdldChDKTtcbiAgICAgICAgICBpZiAoei5oaWRkZW4pIGNlKHoubnVtR2x5cGhzLCBfKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBEID0gZltDXTtcbiAgICAgICAgICAgIGlmIChEKSBmb3IgKHZhciBBID0gMDsgQSA8IHoubnVtR2x5cGhzOyBBKyspIHQuYWRkRHluYW1pY0F0dHJpYnV0ZXMoXywgRC5zaGlmdGVkQW5jaG9yLCBELmFuZ2xlKTtlbHNlIGNlKHoubnVtR2x5cGhzLCBfKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZS5pY29uLmR5bmFtaWNMYXlvdXRWZXJ0ZXhCdWZmZXIudXBkYXRlRGF0YShfKTtcbiAgICAgIH1cbiAgICAgIGUudGV4dC5keW5hbWljTGF5b3V0VmVydGV4QnVmZmVyLnVwZGF0ZURhdGEoZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiBpLmljb25zSW5UZXh0ICYmIGUgPyBcInN5bWJvbFRleHRBbmRJY29uXCIgOiB0ID8gXCJzeW1ib2xTREZcIiA6IFwic3ltYm9sSWNvblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbyhlLCBpLCBvLCByLCBhLCBuLCBzLCBsLCBjLCB1LCBoLCBwKSB7XG4gICAgICBmb3IgKHZhciBkID0gZS5jb250ZXh0LCBfID0gZC5nbCwgZiA9IGUudHJhbnNmb3JtLCBtID0gXCJtYXBcIiA9PT0gbCwgZyA9IFwibWFwXCIgPT09IGMsIHYgPSBtICYmIFwicG9pbnRcIiAhPT0gby5sYXlvdXQuZ2V0KFwic3ltYm9sLXBsYWNlbWVudFwiKSwgeSA9IG0gJiYgIWcgJiYgIXYsIHggPSAhby5sYXlvdXQuZ2V0KFwic3ltYm9sLXNvcnQta2V5XCIpLmlzQ29uc3RhbnQoKSwgYiA9ICExLCB3ID0gZS5kZXB0aE1vZGVGb3JTdWJsYXllcigwLCBJdC5SZWFkT25seSksIFQgPSBvLmxheW91dC5nZXQoXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiKSwgRSA9IFtdLCBJID0gMCwgUCA9IHI7IEkgPCBQLmxlbmd0aDsgSSArPSAxKSB7XG4gICAgICAgIHZhciBTID0gUFtJXSxcbiAgICAgICAgICBDID0gaS5nZXRUaWxlKFMpLFxuICAgICAgICAgIHogPSBDLmdldEJ1Y2tldChvKTtcbiAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICB2YXIgRCA9IGEgPyB6LnRleHQgOiB6Lmljb247XG4gICAgICAgICAgaWYgKEQgJiYgRC5zZWdtZW50cy5nZXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBBID0gRC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KG8uaWQpLFxuICAgICAgICAgICAgICBNID0gYSB8fCB6LnNkZkljb25zLFxuICAgICAgICAgICAgICBMID0gYSA/IHoudGV4dFNpemVEYXRhIDogei5pY29uU2l6ZURhdGEsXG4gICAgICAgICAgICAgIFIgPSBnIHx8IDAgIT09IGYucGl0Y2gsXG4gICAgICAgICAgICAgIGsgPSBlLnVzZVByb2dyYW0odG8oTSwgYSwgeiksIEEpLFxuICAgICAgICAgICAgICBCID0gdC5ldmFsdWF0ZVNpemVGb3Jab29tKEwsIGYuem9vbSksXG4gICAgICAgICAgICAgIE8gPSB2b2lkIDAsXG4gICAgICAgICAgICAgIEYgPSBbMCwgMF0sXG4gICAgICAgICAgICAgIFUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgIE4gPSB2b2lkIDAsXG4gICAgICAgICAgICAgIFogPSBudWxsLFxuICAgICAgICAgICAgICBxID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGEpIFUgPSBDLmdseXBoQXRsYXNUZXh0dXJlLCBOID0gXy5MSU5FQVIsIE8gPSBDLmdseXBoQXRsYXNUZXh0dXJlLnNpemUsIHouaWNvbnNJblRleHQgJiYgKEYgPSBDLmltYWdlQXRsYXNUZXh0dXJlLnNpemUsIFogPSBDLmltYWdlQXRsYXNUZXh0dXJlLCBxID0gUiB8fCBlLm9wdGlvbnMucm90YXRpbmcgfHwgZS5vcHRpb25zLnpvb21pbmcgfHwgXCJjb21wb3NpdGVcIiA9PT0gTC5raW5kIHx8IFwiY2FtZXJhXCIgPT09IEwua2luZCA/IF8uTElORUFSIDogXy5ORUFSRVNUKTtlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGogPSAxICE9PSBvLmxheW91dC5nZXQoXCJpY29uLXNpemVcIikuY29uc3RhbnRPcigwKSB8fCB6Lmljb25zTmVlZExpbmVhcjtcbiAgICAgICAgICAgICAgVSA9IEMuaW1hZ2VBdGxhc1RleHR1cmUsIE4gPSBNIHx8IGUub3B0aW9ucy5yb3RhdGluZyB8fCBlLm9wdGlvbnMuem9vbWluZyB8fCBqIHx8IFIgPyBfLkxJTkVBUiA6IF8uTkVBUkVTVCwgTyA9IEMuaW1hZ2VBdGxhc1RleHR1cmUuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBWID0gcGUoQywgMSwgZS50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgICAgICAgIEcgPSBKdChTLnBvc01hdHJpeCwgZywgbSwgZS50cmFuc2Zvcm0sIFYpLFxuICAgICAgICAgICAgICBXID0gUXQoUy5wb3NNYXRyaXgsIGcsIG0sIGUudHJhbnNmb3JtLCBWKSxcbiAgICAgICAgICAgICAgWCA9IFQgJiYgei5oYXNUZXh0RGF0YSgpLFxuICAgICAgICAgICAgICBIID0gXCJub25lXCIgIT09IG8ubGF5b3V0LmdldChcImljb24tdGV4dC1maXRcIikgJiYgWCAmJiB6Lmhhc0ljb25EYXRhKCk7XG4gICAgICAgICAgICB2ICYmIGllKHosIFMucG9zTWF0cml4LCBlLCBhLCBHLCBXLCBnLCB1KTtcbiAgICAgICAgICAgIHZhciBLID0gZS50cmFuc2xhdGVQb3NNYXRyaXgoUy5wb3NNYXRyaXgsIEMsIG4sIHMpLFxuICAgICAgICAgICAgICBZID0gdiB8fCBhICYmIFQgfHwgSCA/IEppIDogRyxcbiAgICAgICAgICAgICAgSiA9IGUudHJhbnNsYXRlUG9zTWF0cml4KFcsIEMsIG4sIHMsICEwKSxcbiAgICAgICAgICAgICAgUSA9IE0gJiYgMCAhPT0gby5wYWludC5nZXQoYSA/IFwidGV4dC1oYWxvLXdpZHRoXCIgOiBcImljb24taGFsby13aWR0aFwiKS5jb25zdGFudE9yKDEpLFxuICAgICAgICAgICAgICAkID0ge1xuICAgICAgICAgICAgICAgIHByb2dyYW06IGssXG4gICAgICAgICAgICAgICAgYnVmZmVyczogRCxcbiAgICAgICAgICAgICAgICB1bmlmb3JtVmFsdWVzOiBNID8gei5pY29uc0luVGV4dCA/IFdpKEwua2luZCwgQiwgeSwgZywgZSwgSywgWSwgSiwgTywgRikgOiBHaShMLmtpbmQsIEIsIHksIGcsIGUsIEssIFksIEosIGEsIE8sICEwKSA6IFZpKEwua2luZCwgQiwgeSwgZywgZSwgSywgWSwgSiwgYSwgTyksXG4gICAgICAgICAgICAgICAgYXRsYXNUZXh0dXJlOiBVLFxuICAgICAgICAgICAgICAgIGF0bGFzVGV4dHVyZUljb246IFosXG4gICAgICAgICAgICAgICAgYXRsYXNJbnRlcnBvbGF0aW9uOiBOLFxuICAgICAgICAgICAgICAgIGF0bGFzSW50ZXJwb2xhdGlvbkljb246IHEsXG4gICAgICAgICAgICAgICAgaXNTREY6IE0sXG4gICAgICAgICAgICAgICAgaGFzSGFsbzogUVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHggJiYgei5jYW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgIGIgPSAhMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgdHQgPSAwLCBldCA9IEQuc2VnbWVudHMuZ2V0KCk7IHR0IDwgZXQubGVuZ3RoOyB0dCArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gZXRbdHRdO1xuICAgICAgICAgICAgICAgIEUucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzZWdtZW50czogbmV3IHQuU2VnbWVudFZlY3RvcihbaXRdKSxcbiAgICAgICAgICAgICAgICAgIHNvcnRLZXk6IGl0LnNvcnRLZXksXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgRS5wdXNoKHtcbiAgICAgICAgICAgICAgc2VnbWVudHM6IEQuc2VnbWVudHMsXG4gICAgICAgICAgICAgIHNvcnRLZXk6IDAsXG4gICAgICAgICAgICAgIHN0YXRlOiAkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGIgJiYgRS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIG90ID0gMCwgcnQgPSBFOyBvdCA8IHJ0Lmxlbmd0aDsgb3QgKz0gMSkge1xuICAgICAgICB2YXIgYXQgPSBydFtvdF0sXG4gICAgICAgICAgbnQgPSBhdC5zdGF0ZTtcbiAgICAgICAgaWYgKGQuYWN0aXZlVGV4dHVyZS5zZXQoXy5URVhUVVJFMCksIG50LmF0bGFzVGV4dHVyZS5iaW5kKG50LmF0bGFzSW50ZXJwb2xhdGlvbiwgXy5DTEFNUF9UT19FREdFKSwgbnQuYXRsYXNUZXh0dXJlSWNvbiAmJiAoZC5hY3RpdmVUZXh0dXJlLnNldChfLlRFWFRVUkUxKSwgbnQuYXRsYXNUZXh0dXJlSWNvbiAmJiBudC5hdGxhc1RleHR1cmVJY29uLmJpbmQobnQuYXRsYXNJbnRlcnBvbGF0aW9uSWNvbiwgXy5DTEFNUF9UT19FREdFKSksIG50LmlzU0RGKSB7XG4gICAgICAgICAgdmFyIHN0ID0gbnQudW5pZm9ybVZhbHVlcztcbiAgICAgICAgICBudC5oYXNIYWxvICYmIChzdC51X2lzX2hhbG8gPSAxLCBpbyhudC5idWZmZXJzLCBhdC5zZWdtZW50cywgbywgZSwgbnQucHJvZ3JhbSwgdywgaCwgcCwgc3QpKSwgc3QudV9pc19oYWxvID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpbyhudC5idWZmZXJzLCBhdC5zZWdtZW50cywgbywgZSwgbnQucHJvZ3JhbSwgdywgaCwgcCwgbnQudW5pZm9ybVZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlvKHQsIGUsIGksIG8sIHIsIGEsIG4sIHMsIGwpIHtcbiAgICAgIHZhciBjID0gby5jb250ZXh0O1xuICAgICAgci5kcmF3KGMsIGMuZ2wuVFJJQU5HTEVTLCBhLCBuLCBzLCBDdC5kaXNhYmxlZCwgbCwgaS5pZCwgdC5sYXlvdXRWZXJ0ZXhCdWZmZXIsIHQuaW5kZXhCdWZmZXIsIGUsIGkucGFpbnQsIG8udHJhbnNmb3JtLnpvb20sIHQucHJvZ3JhbUNvbmZpZ3VyYXRpb25zLmdldChpLmlkKSwgdC5keW5hbWljTGF5b3V0VmVydGV4QnVmZmVyLCB0Lm9wYWNpdHlWZXJ0ZXhCdWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbyh0LCBlLCBpLCBvLCByLCBhLCBuKSB7XG4gICAgICB2YXIgcyxcbiAgICAgICAgbCxcbiAgICAgICAgYyxcbiAgICAgICAgdSxcbiAgICAgICAgaCxcbiAgICAgICAgcCA9IHQuY29udGV4dC5nbCxcbiAgICAgICAgZCA9IGkucGFpbnQuZ2V0KFwiZmlsbC1wYXR0ZXJuXCIpLFxuICAgICAgICBfID0gZCAmJiBkLmNvbnN0YW50T3IoMSksXG4gICAgICAgIGYgPSBpLmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKTtcbiAgICAgIG4gPyAobCA9IF8gJiYgIWkuZ2V0UGFpbnRQcm9wZXJ0eShcImZpbGwtb3V0bGluZS1jb2xvclwiKSA/IFwiZmlsbE91dGxpbmVQYXR0ZXJuXCIgOiBcImZpbGxPdXRsaW5lXCIsIHMgPSBwLkxJTkVTKSA6IChsID0gXyA/IFwiZmlsbFBhdHRlcm5cIiA6IFwiZmlsbFwiLCBzID0gcC5UUklBTkdMRVMpO1xuICAgICAgZm9yICh2YXIgbSA9IDAsIGcgPSBvOyBtIDwgZy5sZW5ndGg7IG0gKz0gMSkge1xuICAgICAgICB2YXIgdiA9IGdbbV0sXG4gICAgICAgICAgeSA9IGUuZ2V0VGlsZSh2KTtcbiAgICAgICAgaWYgKCFfIHx8IHkucGF0dGVybnNMb2FkZWQoKSkge1xuICAgICAgICAgIHZhciB4ID0geS5nZXRCdWNrZXQoaSk7XG4gICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgIHZhciBiID0geC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KGkuaWQpLFxuICAgICAgICAgICAgICB3ID0gdC51c2VQcm9ncmFtKGwsIGIpO1xuICAgICAgICAgICAgXyAmJiAodC5jb250ZXh0LmFjdGl2ZVRleHR1cmUuc2V0KHAuVEVYVFVSRTApLCB5LmltYWdlQXRsYXNUZXh0dXJlLmJpbmQocC5MSU5FQVIsIHAuQ0xBTVBfVE9fRURHRSksIGIudXBkYXRlUGFpbnRCdWZmZXJzKGYpKTtcbiAgICAgICAgICAgIHZhciBUID0gZC5jb25zdGFudE9yKG51bGwpO1xuICAgICAgICAgICAgaWYgKFQgJiYgeS5pbWFnZUF0bGFzKSB7XG4gICAgICAgICAgICAgIHZhciBFID0geS5pbWFnZUF0bGFzLFxuICAgICAgICAgICAgICAgIEkgPSBFLnBhdHRlcm5Qb3NpdGlvbnNbVC50by50b1N0cmluZygpXSxcbiAgICAgICAgICAgICAgICBQID0gRS5wYXR0ZXJuUG9zaXRpb25zW1QuZnJvbS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgSSAmJiBQICYmIGIuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zKEksIFApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIFMgPSB0LnRyYW5zbGF0ZVBvc01hdHJpeCh2LnBvc01hdHJpeCwgeSwgaS5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZVwiKSwgaS5wYWludC5nZXQoXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIikpO1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgdSA9IHguaW5kZXhCdWZmZXIyLCBoID0geC5zZWdtZW50czI7XG4gICAgICAgICAgICAgIHZhciBDID0gW3AuZHJhd2luZ0J1ZmZlcldpZHRoLCBwLmRyYXdpbmdCdWZmZXJIZWlnaHRdO1xuICAgICAgICAgICAgICBjID0gXCJmaWxsT3V0bGluZVBhdHRlcm5cIiA9PT0gbCAmJiBfID8gQ2koUywgdCwgZiwgeSwgQykgOiBTaShTLCBDKTtcbiAgICAgICAgICAgIH0gZWxzZSB1ID0geC5pbmRleEJ1ZmZlciwgaCA9IHguc2VnbWVudHMsIGMgPSBfID8gUGkoUywgdCwgZiwgeSkgOiBJaShTKTtcbiAgICAgICAgICAgIHcuZHJhdyh0LmNvbnRleHQsIHMsIHIsIHQuc3RlbmNpbE1vZGVGb3JDbGlwcGluZyh2KSwgYSwgQ3QuZGlzYWJsZWQsIGMsIGkuaWQsIHgubGF5b3V0VmVydGV4QnVmZmVyLCB1LCBoLCBpLnBhaW50LCB0LnRyYW5zZm9ybS56b29tLCBiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcm8odCwgZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgZm9yICh2YXIgcyA9IHQuY29udGV4dCwgbCA9IHMuZ2wsIGMgPSBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIiksIHUgPSBjLmNvbnN0YW50T3IoMSksIGggPSBpLmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSwgcCA9IGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiKSwgZCA9IDAsIF8gPSBvOyBkIDwgXy5sZW5ndGg7IGQgKz0gMSkge1xuICAgICAgICB2YXIgZiA9IF9bZF0sXG4gICAgICAgICAgbSA9IGUuZ2V0VGlsZShmKSxcbiAgICAgICAgICBnID0gbS5nZXRCdWNrZXQoaSk7XG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgdmFyIHYgPSBnLnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoaS5pZCksXG4gICAgICAgICAgICB5ID0gdC51c2VQcm9ncmFtKHUgPyBcImZpbGxFeHRydXNpb25QYXR0ZXJuXCIgOiBcImZpbGxFeHRydXNpb25cIiwgdik7XG4gICAgICAgICAgdSAmJiAodC5jb250ZXh0LmFjdGl2ZVRleHR1cmUuc2V0KGwuVEVYVFVSRTApLCBtLmltYWdlQXRsYXNUZXh0dXJlLmJpbmQobC5MSU5FQVIsIGwuQ0xBTVBfVE9fRURHRSksIHYudXBkYXRlUGFpbnRCdWZmZXJzKGgpKTtcbiAgICAgICAgICB2YXIgeCA9IGMuY29uc3RhbnRPcihudWxsKTtcbiAgICAgICAgICBpZiAoeCAmJiBtLmltYWdlQXRsYXMpIHtcbiAgICAgICAgICAgIHZhciBiID0gbS5pbWFnZUF0bGFzLFxuICAgICAgICAgICAgICB3ID0gYi5wYXR0ZXJuUG9zaXRpb25zW3gudG8udG9TdHJpbmcoKV0sXG4gICAgICAgICAgICAgIFQgPSBiLnBhdHRlcm5Qb3NpdGlvbnNbeC5mcm9tLnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgdyAmJiBUICYmIHYuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zKHcsIFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgRSA9IHQudHJhbnNsYXRlUG9zTWF0cml4KGYucG9zTWF0cml4LCBtLCBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiKSwgaS5wYWludC5nZXQoXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGUtYW5jaG9yXCIpKSxcbiAgICAgICAgICAgIEkgPSBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXZlcnRpY2FsLWdyYWRpZW50XCIpLFxuICAgICAgICAgICAgUCA9IHUgPyBFaShFLCB0LCBJLCBwLCBmLCBoLCBtKSA6IFRpKEUsIHQsIEksIHApO1xuICAgICAgICAgIHkuZHJhdyhzLCBzLmdsLlRSSUFOR0xFUywgciwgYSwgbiwgQ3QuYmFja0NDVywgUCwgaS5pZCwgZy5sYXlvdXRWZXJ0ZXhCdWZmZXIsIGcuaW5kZXhCdWZmZXIsIGcuc2VnbWVudHMsIGkucGFpbnQsIHQudHJhbnNmb3JtLnpvb20sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFvKGUsIGksIG8sIHIsIGEsIG4pIHtcbiAgICAgIHZhciBzID0gZS5jb250ZXh0LFxuICAgICAgICBsID0gcy5nbCxcbiAgICAgICAgYyA9IGkuZmJvO1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgdmFyIHUgPSBlLnVzZVByb2dyYW0oXCJoaWxsc2hhZGVcIik7XG4gICAgICAgIHMuYWN0aXZlVGV4dHVyZS5zZXQobC5URVhUVVJFMCksIGwuYmluZFRleHR1cmUobC5URVhUVVJFXzJELCBjLmNvbG9yQXR0YWNobWVudC5nZXQoKSk7XG4gICAgICAgIHZhciBoID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICB2YXIgciA9IG8ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiKSxcbiAgICAgICAgICAgIGEgPSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIiksXG4gICAgICAgICAgICBuID0gby5wYWludC5nZXQoXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCIpLFxuICAgICAgICAgICAgcyA9IG8ucGFpbnQuZ2V0KFwiaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1kaXJlY3Rpb25cIikgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgXCJ2aWV3cG9ydFwiID09PSBvLnBhaW50LmdldChcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCIpICYmIChzIC09IGUudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgICB2YXIgbCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICB1LFxuICAgICAgICAgICAgaCA9ICFlLm9wdGlvbnMubW92aW5nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1X21hdHJpeDogZS50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KGkudGlsZUlELnRvVW53cmFwcGVkKCksIGgpLFxuICAgICAgICAgICAgdV9pbWFnZTogMCxcbiAgICAgICAgICAgIHVfbGF0cmFuZ2U6IChsID0gaS50aWxlSUQsIGMgPSBNYXRoLnBvdygyLCBsLmNhbm9uaWNhbC56KSwgdSA9IGwuY2Fub25pY2FsLnksIFtuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoMCwgdSAvIGMpLnRvTG5nTGF0KCkubGF0LCBuZXcgdC5NZXJjYXRvckNvb3JkaW5hdGUoMCwgKHUgKyAxKSAvIGMpLnRvTG5nTGF0KCkubGF0XSksXG4gICAgICAgICAgICB1X2xpZ2h0OiBbby5wYWludC5nZXQoXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCIpLCBzXSxcbiAgICAgICAgICAgIHVfc2hhZG93OiByLFxuICAgICAgICAgICAgdV9oaWdobGlnaHQ6IGEsXG4gICAgICAgICAgICB1X2FjY2VudDogblxuICAgICAgICAgIH07XG4gICAgICAgIH0oZSwgaSwgbyk7XG4gICAgICAgIHUuZHJhdyhzLCBsLlRSSUFOR0xFUywgciwgYSwgbiwgQ3QuZGlzYWJsZWQsIGgsIG8uaWQsIGUucmFzdGVyQm91bmRzQnVmZmVyLCBlLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCBlLnJhc3RlckJvdW5kc1NlZ21lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm8oZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMgPSBlLmNvbnRleHQsXG4gICAgICAgIGwgPSBzLmdsLFxuICAgICAgICBjID0gaS5kZW07XG4gICAgICBpZiAoYyAmJiBjLmRhdGEpIHtcbiAgICAgICAgdmFyIHUgPSBjLmRpbSxcbiAgICAgICAgICBoID0gYy5zdHJpZGUsXG4gICAgICAgICAgcCA9IGMuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIGlmIChzLmFjdGl2ZVRleHR1cmUuc2V0KGwuVEVYVFVSRTEpLCBzLnBpeGVsU3RvcmVVbnBhY2tQcmVtdWx0aXBseUFscGhhLnNldCghMSksIGkuZGVtVGV4dHVyZSA9IGkuZGVtVGV4dHVyZSB8fCBlLmdldFRpbGVUZXh0dXJlKGgpLCBpLmRlbVRleHR1cmUpIHtcbiAgICAgICAgICB2YXIgZCA9IGkuZGVtVGV4dHVyZTtcbiAgICAgICAgICBkLnVwZGF0ZShwLCB7XG4gICAgICAgICAgICBwcmVtdWx0aXBseTogITFcbiAgICAgICAgICB9KSwgZC5iaW5kKGwuTkVBUkVTVCwgbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfSBlbHNlIGkuZGVtVGV4dHVyZSA9IG5ldyB0LlRleHR1cmUocywgcCwgbC5SR0JBLCB7XG4gICAgICAgICAgcHJlbXVsdGlwbHk6ICExXG4gICAgICAgIH0pLCBpLmRlbVRleHR1cmUuYmluZChsLk5FQVJFU1QsIGwuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIHMuYWN0aXZlVGV4dHVyZS5zZXQobC5URVhUVVJFMCk7XG4gICAgICAgIHZhciBfID0gaS5mYm87XG4gICAgICAgIGlmICghXykge1xuICAgICAgICAgIHZhciBmID0gbmV3IHQuVGV4dHVyZShzLCB7XG4gICAgICAgICAgICB3aWR0aDogdSxcbiAgICAgICAgICAgIGhlaWdodDogdSxcbiAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICB9LCBsLlJHQkEpO1xuICAgICAgICAgIGYuYmluZChsLkxJTkVBUiwgbC5DTEFNUF9UT19FREdFKSwgKF8gPSBpLmZibyA9IHMuY3JlYXRlRnJhbWVidWZmZXIodSwgdSwgITApKS5jb2xvckF0dGFjaG1lbnQuc2V0KGYudGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcy5iaW5kRnJhbWVidWZmZXIuc2V0KF8uZnJhbWVidWZmZXIpLCBzLnZpZXdwb3J0LnNldChbMCwgMCwgdSwgdV0pLCBlLnVzZVByb2dyYW0oXCJoaWxsc2hhZGVQcmVwYXJlXCIpLmRyYXcocywgbC5UUklBTkdMRVMsIHIsIGEsIG4sIEN0LmRpc2FibGVkLCBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gaS5zdHJpZGUsXG4gICAgICAgICAgICByID0gdC5jcmVhdGUoKTtcbiAgICAgICAgICByZXR1cm4gdC5vcnRobyhyLCAwLCB0LkVYVEVOVCwgLXQuRVhURU5ULCAwLCAwLCAxKSwgdC50cmFuc2xhdGUociwgciwgWzAsIC10LkVYVEVOVCwgMF0pLCB7XG4gICAgICAgICAgICB1X21hdHJpeDogcixcbiAgICAgICAgICAgIHVfaW1hZ2U6IDEsXG4gICAgICAgICAgICB1X2RpbWVuc2lvbjogW28sIG9dLFxuICAgICAgICAgICAgdV96b29tOiBlLm92ZXJzY2FsZWRaLFxuICAgICAgICAgICAgdV91bnBhY2s6IGkuZ2V0VW5wYWNrVmVjdG9yKClcbiAgICAgICAgICB9O1xuICAgICAgICB9KGkudGlsZUlELCBjKSwgby5pZCwgZS5yYXN0ZXJCb3VuZHNCdWZmZXIsIGUucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIGUucmFzdGVyQm91bmRzU2VnbWVudHMpLCBpLm5lZWRzSGlsbHNoYWRlUHJlcGFyZSA9ICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzbyhlLCBpLCBvLCByLCBhKSB7XG4gICAgICB2YXIgbiA9IHIucGFpbnQuZ2V0KFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIik7XG4gICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgdmFyIHMgPSB0LmJyb3dzZXIubm93KCksXG4gICAgICAgICAgbCA9IChzIC0gZS50aW1lQWRkZWQpIC8gbixcbiAgICAgICAgICBjID0gaSA/IChzIC0gaS50aW1lQWRkZWQpIC8gbiA6IC0xLFxuICAgICAgICAgIHUgPSBvLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGggPSBhLmNvdmVyaW5nWm9vbUxldmVsKHtcbiAgICAgICAgICAgIHRpbGVTaXplOiB1LnRpbGVTaXplLFxuICAgICAgICAgICAgcm91bmRab29tOiB1LnJvdW5kWm9vbVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHAgPSAhaSB8fCBNYXRoLmFicyhpLnRpbGVJRC5vdmVyc2NhbGVkWiAtIGgpID4gTWF0aC5hYnMoZS50aWxlSUQub3ZlcnNjYWxlZFogLSBoKSxcbiAgICAgICAgICBkID0gcCAmJiBlLnJlZnJlc2hlZFVwb25FeHBpcmF0aW9uID8gMSA6IHQuY2xhbXAocCA/IGwgOiAxIC0gYywgMCwgMSk7XG4gICAgICAgIHJldHVybiBlLnJlZnJlc2hlZFVwb25FeHBpcmF0aW9uICYmIGwgPj0gMSAmJiAoZS5yZWZyZXNoZWRVcG9uRXhwaXJhdGlvbiA9ICExKSwgaSA/IHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIG1peDogMSAtIGRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBvcGFjaXR5OiBkLFxuICAgICAgICAgIG1peDogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgbWl4OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbG8gPSBuZXcgdC5Db2xvcigxLCAwLCAwLCAxKSxcbiAgICAgIGNvID0gbmV3IHQuQ29sb3IoMCwgMSwgMCwgMSksXG4gICAgICB1byA9IG5ldyB0LkNvbG9yKDAsIDAsIDEsIDEpLFxuICAgICAgaG8gPSBuZXcgdC5Db2xvcigxLCAwLCAxLCAxKSxcbiAgICAgIHBvID0gbmV3IHQuQ29sb3IoMCwgMSwgMSwgMSk7XG4gICAgZnVuY3Rpb24gX28odCwgZSwgaSwgbykge1xuICAgICAgbW8odCwgMCwgZSArIGkgLyAyLCB0LnRyYW5zZm9ybS53aWR0aCwgaSwgbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvKHQsIGUsIGksIG8pIHtcbiAgICAgIG1vKHQsIGUgLSBpIC8gMiwgMCwgaSwgdC50cmFuc2Zvcm0uaGVpZ2h0LCBvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW8oZSwgaSwgbywgciwgYSwgbikge1xuICAgICAgdmFyIHMgPSBlLmNvbnRleHQsXG4gICAgICAgIGwgPSBzLmdsO1xuICAgICAgbC5lbmFibGUobC5TQ0lTU09SX1RFU1QpLCBsLnNjaXNzb3IoaSAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLCBvICogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sIHIgKiB0LmJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbywgYSAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSwgcy5jbGVhcih7XG4gICAgICAgIGNvbG9yOiBuXG4gICAgICB9KSwgbC5kaXNhYmxlKGwuU0NJU1NPUl9URVNUKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBlLmNvbnRleHQsXG4gICAgICAgIGEgPSByLmdsLFxuICAgICAgICBuID0gby5wb3NNYXRyaXgsXG4gICAgICAgIHMgPSBlLnVzZVByb2dyYW0oXCJkZWJ1Z1wiKSxcbiAgICAgICAgbCA9IEl0LmRpc2FibGVkLFxuICAgICAgICBjID0gUHQuZGlzYWJsZWQsXG4gICAgICAgIHUgPSBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKTtcbiAgICAgIHIuYWN0aXZlVGV4dHVyZS5zZXQoYS5URVhUVVJFMCksIGUuZW1wdHlUZXh0dXJlLmJpbmQoYS5MSU5FQVIsIGEuQ0xBTVBfVE9fRURHRSksIHMuZHJhdyhyLCBhLkxJTkVfU1RSSVAsIGwsIGMsIHUsIEN0LmRpc2FibGVkLCBNaShuLCB0LkNvbG9yLnJlZCksIFwiJGRlYnVnXCIsIGUuZGVidWdCdWZmZXIsIGUudGlsZUJvcmRlckluZGV4QnVmZmVyLCBlLmRlYnVnU2VnbWVudHMpO1xuICAgICAgdmFyIGggPSBpLmdldFRpbGVCeUlEKG8ua2V5KS5sYXRlc3RSYXdUaWxlRGF0YSxcbiAgICAgICAgcCA9IE1hdGguZmxvb3IoKGggJiYgaC5ieXRlTGVuZ3RoIHx8IDApIC8gMTAyNCksXG4gICAgICAgIGQgPSBpLmdldFRpbGUobykudGlsZVNpemUsXG4gICAgICAgIF8gPSA1MTIgLyBNYXRoLm1pbihkLCA1MTIpICogKG8ub3ZlcnNjYWxlZFogLyBlLnRyYW5zZm9ybS56b29tKSAqIC41LFxuICAgICAgICBmID0gby5jYW5vbmljYWwudG9TdHJpbmcoKTtcbiAgICAgIG8ub3ZlcnNjYWxlZFogIT09IG8uY2Fub25pY2FsLnogJiYgKGYgKz0gXCIgPT4gXCIgKyBvLm92ZXJzY2FsZWRaKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdC5pbml0RGVidWdPdmVybGF5Q2FudmFzKCk7XG4gICAgICAgIHZhciBpID0gdC5kZWJ1Z092ZXJsYXlDYW52YXMsXG4gICAgICAgICAgbyA9IHQuY29udGV4dC5nbCxcbiAgICAgICAgICByID0gdC5kZWJ1Z092ZXJsYXlDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICByLmNsZWFyUmVjdCgwLCAwLCBpLndpZHRoLCBpLmhlaWdodCksIHIuc2hhZG93Q29sb3IgPSBcIndoaXRlXCIsIHIuc2hhZG93Qmx1ciA9IDIsIHIubGluZVdpZHRoID0gMS41LCByLnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiLCByLnRleHRCYXNlbGluZSA9IFwidG9wXCIsIHIuZm9udCA9IFwiYm9sZCAzNnB4IE9wZW4gU2Fucywgc2Fucy1zZXJpZlwiLCByLmZpbGxUZXh0KGUsIDUsIDUpLCByLnN0cm9rZVRleHQoZSwgNSwgNSksIHQuZGVidWdPdmVybGF5VGV4dHVyZS51cGRhdGUoaSksIHQuZGVidWdPdmVybGF5VGV4dHVyZS5iaW5kKG8uTElORUFSLCBvLkNMQU1QX1RPX0VER0UpO1xuICAgICAgfShlLCBmICsgXCIgXCIgKyBwICsgXCJrYlwiKSwgcy5kcmF3KHIsIGEuVFJJQU5HTEVTLCBsLCBjLCBTdC5hbHBoYUJsZW5kZWQsIEN0LmRpc2FibGVkLCBNaShuLCB0LkNvbG9yLnRyYW5zcGFyZW50LCBfKSwgXCIkZGVidWdcIiwgZS5kZWJ1Z0J1ZmZlciwgZS5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgZS5kZWJ1Z1NlZ21lbnRzKTtcbiAgICB9XG4gICAgdmFyIHZvID0ge1xuICAgICAgICBzeW1ib2w6IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhKSB7XG4gICAgICAgICAgaWYgKFwidHJhbnNsdWNlbnRcIiA9PT0gZS5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgICB2YXIgbiA9IFB0LmRpc2FibGVkLFxuICAgICAgICAgICAgICBzID0gZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCk7XG4gICAgICAgICAgICBvLmxheW91dC5nZXQoXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiKSAmJiBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSwgbiwgcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBsID0gaS50cmFuc2Zvcm0sIGMgPSBcIm1hcFwiID09PSBhLCB1ID0gXCJtYXBcIiA9PT0gbiwgaCA9IDAsIHAgPSBlOyBoIDwgcC5sZW5ndGg7IGggKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gcFtoXSxcbiAgICAgICAgICAgICAgICAgIF8gPSByLmdldFRpbGUoZCksXG4gICAgICAgICAgICAgICAgICBmID0gXy5nZXRCdWNrZXQobyk7XG4gICAgICAgICAgICAgICAgaWYgKGYgJiYgZi50ZXh0ICYmIGYudGV4dC5zZWdtZW50cy5nZXQoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtID0gdC5ldmFsdWF0ZVNpemVGb3Jab29tKGYudGV4dFNpemVEYXRhLCBsLnpvb20pLFxuICAgICAgICAgICAgICAgICAgICBnID0gcGUoXywgMSwgaS50cmFuc2Zvcm0uem9vbSksXG4gICAgICAgICAgICAgICAgICAgIHYgPSBKdChkLnBvc01hdHJpeCwgdSwgYywgaS50cmFuc2Zvcm0sIGcpLFxuICAgICAgICAgICAgICAgICAgICB5ID0gXCJub25lXCIgIT09IG8ubGF5b3V0LmdldChcImljb24tdGV4dC1maXRcIikgJiYgZi5oYXNJY29uRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBNYXRoLnBvdygyLCBsLnpvb20gLSBfLnRpbGVJRC5vdmVyc2NhbGVkWik7XG4gICAgICAgICAgICAgICAgICAgICRpKGYsIGMsIHUsIHMsIHQuc3ltYm9sU2l6ZSwgbCwgdiwgZC5wb3NNYXRyaXgsIHgsIG0sIHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShyLCBlLCBvLCBpLCBvLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSwgby5sYXlvdXQuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksIGEpLCAwICE9PSBvLnBhaW50LmdldChcImljb24tb3BhY2l0eVwiKS5jb25zdGFudE9yKDEpICYmIGVvKGUsIGksIG8sIHIsICExLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlLWFuY2hvclwiKSwgby5sYXlvdXQuZ2V0KFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIiksIG8ubGF5b3V0LmdldChcImljb24tcGl0Y2gtYWxpZ25tZW50XCIpLCBvLmxheW91dC5nZXQoXCJpY29uLWtlZXAtdXByaWdodFwiKSwgbiwgcyksIDAgIT09IG8ucGFpbnQuZ2V0KFwidGV4dC1vcGFjaXR5XCIpLmNvbnN0YW50T3IoMSkgJiYgZW8oZSwgaSwgbywgciwgITAsIG8ucGFpbnQuZ2V0KFwidGV4dC10cmFuc2xhdGVcIiksIG8ucGFpbnQuZ2V0KFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCIpLCBvLmxheW91dC5nZXQoXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiKSwgby5sYXlvdXQuZ2V0KFwidGV4dC1waXRjaC1hbGlnbm1lbnRcIiksIG8ubGF5b3V0LmdldChcInRleHQta2VlcC11cHJpZ2h0XCIpLCBuLCBzKSwgaS5tYXAuc2hvd0NvbGxpc2lvbkJveGVzICYmIChZaShlLCBpLCBvLCByLCBvLnBhaW50LmdldChcInRleHQtdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiKSwgITApLCBZaShlLCBpLCBvLCByLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlXCIpLCBvLnBhaW50LmdldChcImljb24tdHJhbnNsYXRlLWFuY2hvclwiKSwgITEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgICBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSBlLnJlbmRlclBhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gby5wYWludC5nZXQoXCJjaXJjbGUtb3BhY2l0eVwiKSxcbiAgICAgICAgICAgICAgbiA9IG8ucGFpbnQuZ2V0KFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiKSxcbiAgICAgICAgICAgICAgcyA9IG8ucGFpbnQuZ2V0KFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCIpLFxuICAgICAgICAgICAgICBsID0gIW8ubGF5b3V0LmdldChcImNpcmNsZS1zb3J0LWtleVwiKS5pc0NvbnN0YW50KCk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gYS5jb25zdGFudE9yKDEpIHx8IDAgIT09IG4uY29uc3RhbnRPcigxKSAmJiAwICE9PSBzLmNvbnN0YW50T3IoMSkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IGUuY29udGV4dCwgdSA9IGMuZ2wsIGggPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKDAsIEl0LlJlYWRPbmx5KSwgcCA9IFB0LmRpc2FibGVkLCBkID0gZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksIF8gPSBbXSwgZiA9IDA7IGYgPCByLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSByW2ZdLFxuICAgICAgICAgICAgICAgICAgZyA9IGkuZ2V0VGlsZShtKSxcbiAgICAgICAgICAgICAgICAgIHYgPSBnLmdldEJ1Y2tldChvKTtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgdmFyIHkgPSB2LnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoby5pZCksXG4gICAgICAgICAgICAgICAgICAgIHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbUNvbmZpZ3VyYXRpb246IHksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbTogZS51c2VQcm9ncmFtKFwiY2lyY2xlXCIsIHkpLFxuICAgICAgICAgICAgICAgICAgICAgIGxheW91dFZlcnRleEJ1ZmZlcjogdi5sYXlvdXRWZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXhCdWZmZXI6IHYuaW5kZXhCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybVZhbHVlczogemkoZSwgbSwgZywgbylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGlmIChsKSBmb3IgKHZhciBiID0gMCwgdyA9IHYuc2VnbWVudHMuZ2V0KCk7IGIgPCB3Lmxlbmd0aDsgYiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBUID0gd1tiXTtcbiAgICAgICAgICAgICAgICAgICAgXy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50czogbmV3IHQuU2VnbWVudFZlY3RvcihbVF0pLFxuICAgICAgICAgICAgICAgICAgICAgIHNvcnRLZXk6IFQuc29ydEtleSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogeFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBfLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50czogdi5zZWdtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgc29ydEtleTogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHhcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsICYmIF8uc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0LnNvcnRLZXkgLSBlLnNvcnRLZXk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBmb3IgKHZhciBFID0gMCwgSSA9IF87IEUgPCBJLmxlbmd0aDsgRSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIFAgPSBJW0VdLFxuICAgICAgICAgICAgICAgICAgUyA9IFAuc3RhdGU7XG4gICAgICAgICAgICAgICAgUy5wcm9ncmFtLmRyYXcoYywgdS5UUklBTkdMRVMsIGgsIHAsIGQsIEN0LmRpc2FibGVkLCBTLnVuaWZvcm1WYWx1ZXMsIG8uaWQsIFMubGF5b3V0VmVydGV4QnVmZmVyLCBTLmluZGV4QnVmZmVyLCBQLnNlZ21lbnRzLCBvLnBhaW50LCBlLnRyYW5zZm9ybS56b29tLCBTLnByb2dyYW1Db25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGVhdG1hcDogZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgICBpZiAoMCAhPT0gby5wYWludC5nZXQoXCJoZWF0bWFwLW9wYWNpdHlcIikpIGlmIChcIm9mZnNjcmVlblwiID09PSBlLnJlbmRlclBhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gZS5jb250ZXh0LFxuICAgICAgICAgICAgICBuID0gYS5nbCxcbiAgICAgICAgICAgICAgcyA9IFB0LmRpc2FibGVkLFxuICAgICAgICAgICAgICBsID0gbmV3IFN0KFtuLk9ORSwgbi5PTkVdLCB0LkNvbG9yLnRyYW5zcGFyZW50LCBbITAsICEwLCAhMCwgITBdKTtcbiAgICAgICAgICAgICFmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgICAgICB2YXIgbyA9IHQuZ2w7XG4gICAgICAgICAgICAgIHQuYWN0aXZlVGV4dHVyZS5zZXQoby5URVhUVVJFMSksIHQudmlld3BvcnQuc2V0KFswLCAwLCBlLndpZHRoIC8gNCwgZS5oZWlnaHQgLyA0XSk7XG4gICAgICAgICAgICAgIHZhciByID0gaS5oZWF0bWFwRmJvO1xuICAgICAgICAgICAgICBpZiAocikgby5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsIHIuY29sb3JBdHRhY2htZW50LmdldCgpKSwgdC5iaW5kRnJhbWVidWZmZXIuc2V0KHIuZnJhbWVidWZmZXIpO2Vsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBhID0gby5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgby5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsIGEpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfV1JBUF9TLCBvLkNMQU1QX1RPX0VER0UpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfV1JBUF9ULCBvLkNMQU1QX1RPX0VER0UpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfTUlOX0ZJTFRFUiwgby5MSU5FQVIpLCBvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELCBvLlRFWFRVUkVfTUFHX0ZJTFRFUiwgby5MSU5FQVIpLCByID0gaS5oZWF0bWFwRmJvID0gdC5jcmVhdGVGcmFtZWJ1ZmZlcihlLndpZHRoIC8gNCwgZS5oZWlnaHQgLyA0LCAhMSksIGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IHQuZ2w7XG4gICAgICAgICAgICAgICAgICByLnRleEltYWdlMkQoci5URVhUVVJFXzJELCAwLCByLlJHQkEsIGUud2lkdGggLyA0LCBlLmhlaWdodCAvIDQsIDAsIHIuUkdCQSwgdC5leHRSZW5kZXJUb1RleHR1cmVIYWxmRmxvYXQgPyB0LmV4dFRleHR1cmVIYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVMgOiByLlVOU0lHTkVEX0JZVEUsIG51bGwpLCBvLmNvbG9yQXR0YWNobWVudC5zZXQoaSk7XG4gICAgICAgICAgICAgICAgfSh0LCBlLCBhLCByKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShhLCBlLCBvKSwgYS5jbGVhcih7XG4gICAgICAgICAgICAgIGNvbG9yOiB0LkNvbG9yLnRyYW5zcGFyZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgci5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICB2YXIgdSA9IHJbY107XG4gICAgICAgICAgICAgIGlmICghaS5oYXNSZW5kZXJhYmxlUGFyZW50KHUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBpLmdldFRpbGUodSksXG4gICAgICAgICAgICAgICAgICBwID0gaC5nZXRCdWNrZXQobyk7XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkID0gcC5wcm9ncmFtQ29uZmlndXJhdGlvbnMuZ2V0KG8uaWQpO1xuICAgICAgICAgICAgICAgICAgZS51c2VQcm9ncmFtKFwiaGVhdG1hcFwiLCBkKS5kcmF3KGEsIG4uVFJJQU5HTEVTLCBJdC5kaXNhYmxlZCwgcywgbCwgQ3QuZGlzYWJsZWQsIFJpKHUucG9zTWF0cml4LCBoLCBlLnRyYW5zZm9ybS56b29tLCBvLnBhaW50LmdldChcImhlYXRtYXAtaW50ZW5zaXR5XCIpKSwgby5pZCwgcC5sYXlvdXRWZXJ0ZXhCdWZmZXIsIHAuaW5kZXhCdWZmZXIsIHAuc2VnbWVudHMsIG8ucGFpbnQsIGUudHJhbnNmb3JtLnpvb20sIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYS52aWV3cG9ydC5zZXQoWzAsIDAsIGUud2lkdGgsIGUuaGVpZ2h0XSk7XG4gICAgICAgICAgfSBlbHNlIFwidHJhbnNsdWNlbnRcIiA9PT0gZS5yZW5kZXJQYXNzICYmIChlLmNvbnRleHQuc2V0Q29sb3JNb2RlKGUuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKSwgZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICAgIHZhciBvID0gZS5jb250ZXh0LFxuICAgICAgICAgICAgICByID0gby5nbCxcbiAgICAgICAgICAgICAgYSA9IGkuaGVhdG1hcEZibztcbiAgICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICAgIG8uYWN0aXZlVGV4dHVyZS5zZXQoci5URVhUVVJFMCksIHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELCBhLmNvbG9yQXR0YWNobWVudC5nZXQoKSksIG8uYWN0aXZlVGV4dHVyZS5zZXQoci5URVhUVVJFMSk7XG4gICAgICAgICAgICAgIHZhciBuID0gaS5jb2xvclJhbXBUZXh0dXJlO1xuICAgICAgICAgICAgICBuIHx8IChuID0gaS5jb2xvclJhbXBUZXh0dXJlID0gbmV3IHQuVGV4dHVyZShvLCBpLmNvbG9yUmFtcCwgci5SR0JBKSksIG4uYmluZChyLkxJTkVBUiwgci5DTEFNUF9UT19FREdFKSwgZS51c2VQcm9ncmFtKFwiaGVhdG1hcFRleHR1cmVcIikuZHJhdyhvLCByLlRSSUFOR0xFUywgSXQuZGlzYWJsZWQsIFB0LmRpc2FibGVkLCBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSwgQ3QuZGlzYWJsZWQsIGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIHQub3J0aG8oYSwgMCwgZS53aWR0aCwgZS5oZWlnaHQsIDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgIHZhciBuID0gZS5jb250ZXh0LmdsO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB1X21hdHJpeDogYSxcbiAgICAgICAgICAgICAgICAgIHVfd29ybGQ6IFtuLmRyYXdpbmdCdWZmZXJXaWR0aCwgbi5kcmF3aW5nQnVmZmVySGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgIHVfaW1hZ2U6IDAsXG4gICAgICAgICAgICAgICAgICB1X2NvbG9yX3JhbXA6IDEsXG4gICAgICAgICAgICAgICAgICB1X29wYWNpdHk6IGkucGFpbnQuZ2V0KFwiaGVhdG1hcC1vcGFjaXR5XCIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfShlLCBpKSwgaS5pZCwgZS52aWV3cG9ydEJ1ZmZlciwgZS5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgZS52aWV3cG9ydFNlZ21lbnRzLCBpLnBhaW50LCBlLnRyYW5zZm9ybS56b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KGUsIG8pKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGUsIGksIG8sIHIpIHtcbiAgICAgICAgICBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSBlLnJlbmRlclBhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gby5wYWludC5nZXQoXCJsaW5lLW9wYWNpdHlcIiksXG4gICAgICAgICAgICAgIG4gPSBvLnBhaW50LmdldChcImxpbmUtd2lkdGhcIik7XG4gICAgICAgICAgICBpZiAoMCAhPT0gYS5jb25zdGFudE9yKDEpICYmIDAgIT09IG4uY29uc3RhbnRPcigxKSkgZm9yICh2YXIgcyA9IGUuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgSXQuUmVhZE9ubHkpLCBsID0gZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksIGMgPSBvLnBhaW50LmdldChcImxpbmUtZGFzaGFycmF5XCIpLCB1ID0gby5wYWludC5nZXQoXCJsaW5lLXBhdHRlcm5cIiksIGggPSB1LmNvbnN0YW50T3IoMSksIHAgPSBvLnBhaW50LmdldChcImxpbmUtZ3JhZGllbnRcIiksIGQgPSBvLmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSwgXyA9IGggPyBcImxpbmVQYXR0ZXJuXCIgOiBjID8gXCJsaW5lU0RGXCIgOiBwID8gXCJsaW5lR3JhZGllbnRcIiA6IFwibGluZVwiLCBmID0gZS5jb250ZXh0LCBtID0gZi5nbCwgZyA9ICEwLCB2ID0gMCwgeSA9IHI7IHYgPCB5Lmxlbmd0aDsgdiArPSAxKSB7XG4gICAgICAgICAgICAgIHZhciB4ID0geVt2XSxcbiAgICAgICAgICAgICAgICBiID0gaS5nZXRUaWxlKHgpO1xuICAgICAgICAgICAgICBpZiAoIWggfHwgYi5wYXR0ZXJuc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBiLmdldEJ1Y2tldChvKTtcbiAgICAgICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgICAgdmFyIFQgPSB3LnByb2dyYW1Db25maWd1cmF0aW9ucy5nZXQoby5pZCksXG4gICAgICAgICAgICAgICAgICAgIEUgPSBlLmNvbnRleHQucHJvZ3JhbS5nZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgSSA9IGUudXNlUHJvZ3JhbShfLCBUKSxcbiAgICAgICAgICAgICAgICAgICAgUCA9IGcgfHwgSS5wcm9ncmFtICE9PSBFLFxuICAgICAgICAgICAgICAgICAgICBTID0gdS5jb25zdGFudE9yKG51bGwpO1xuICAgICAgICAgICAgICAgICAgaWYgKFMgJiYgYi5pbWFnZUF0bGFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDID0gYi5pbWFnZUF0bGFzLFxuICAgICAgICAgICAgICAgICAgICAgIHogPSBDLnBhdHRlcm5Qb3NpdGlvbnNbUy50by50b1N0cmluZygpXSxcbiAgICAgICAgICAgICAgICAgICAgICBEID0gQy5wYXR0ZXJuUG9zaXRpb25zW1MuZnJvbS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgICAgeiAmJiBEICYmIFQuc2V0Q29uc3RhbnRQYXR0ZXJuUG9zaXRpb25zKHosIEQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIEEgPSBoID8gT2koZSwgYiwgbywgZCkgOiBjID8gRmkoZSwgYiwgbywgYywgZCkgOiBwID8gQmkoZSwgYiwgbywgdy5saW5lQ2xpcHNBcnJheS5sZW5ndGgpIDoga2koZSwgYiwgbyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaCkgZi5hY3RpdmVUZXh0dXJlLnNldChtLlRFWFRVUkUwKSwgYi5pbWFnZUF0bGFzVGV4dHVyZS5iaW5kKG0uTElORUFSLCBtLkNMQU1QX1RPX0VER0UpLCBULnVwZGF0ZVBhaW50QnVmZmVycyhkKTtlbHNlIGlmIChjICYmIChQIHx8IGUubGluZUF0bGFzLmRpcnR5KSkgZi5hY3RpdmVUZXh0dXJlLnNldChtLlRFWFRVUkUwKSwgZS5saW5lQXRsYXMuYmluZChmKTtlbHNlIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBNID0gdy5ncmFkaWVudHNbby5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgTCA9IE0udGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uZ3JhZGllbnRWZXJzaW9uICE9PSBNLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgUiA9IDI1NjtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoby5zdGVwSW50ZXJwb2xhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gaS5nZXRTb3VyY2UoKS5tYXh6b29tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBCID0geC5jYW5vbmljYWwueiA9PT0gayA/IE1hdGguY2VpbCgxIDw8IGUudHJhbnNmb3JtLm1heFpvb20gLSB4LmNhbm9uaWNhbC56KSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBSID0gdC5jbGFtcCh0Lm5leHRQb3dlck9mVHdvKHcubWF4TGluZUxlbmd0aCAvIHQuRVhURU5UICogMTAyNCAqIEIpLCAyNTYsIGYubWF4VGV4dHVyZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBNLmdyYWRpZW50ID0gdC5yZW5kZXJDb2xvclJhbXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogby5ncmFkaWVudEV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRpb25LZXk6IFwibGluZVByb2dyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiBSLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IE0uZ3JhZGllbnQgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHM6IHcubGluZUNsaXBzQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICB9KSwgTS50ZXh0dXJlID8gTS50ZXh0dXJlLnVwZGF0ZShNLmdyYWRpZW50KSA6IE0udGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZiwgTS5ncmFkaWVudCwgbS5SR0JBKSwgTS52ZXJzaW9uID0gby5ncmFkaWVudFZlcnNpb24sIEwgPSBNLnRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZi5hY3RpdmVUZXh0dXJlLnNldChtLlRFWFRVUkUwKSwgTC5iaW5kKG8uc3RlcEludGVycG9sYW50ID8gbS5ORUFSRVNUIDogbS5MSU5FQVIsIG0uQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJLmRyYXcoZiwgbS5UUklBTkdMRVMsIHMsIGUuc3RlbmNpbE1vZGVGb3JDbGlwcGluZyh4KSwgbCwgQ3QuZGlzYWJsZWQsIEEsIG8uaWQsIHcubGF5b3V0VmVydGV4QnVmZmVyLCB3LmluZGV4QnVmZmVyLCB3LnNlZ21lbnRzLCBvLnBhaW50LCBlLnRyYW5zZm9ybS56b29tLCBULCB3LmxheW91dFZlcnRleEJ1ZmZlcjIpLCBnID0gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiBmdW5jdGlvbiAoZSwgaSwgbywgcikge1xuICAgICAgICAgIHZhciBhID0gby5wYWludC5nZXQoXCJmaWxsLWNvbG9yXCIpLFxuICAgICAgICAgICAgbiA9IG8ucGFpbnQuZ2V0KFwiZmlsbC1vcGFjaXR5XCIpO1xuICAgICAgICAgIGlmICgwICE9PSBuLmNvbnN0YW50T3IoMSkpIHtcbiAgICAgICAgICAgIHZhciBzID0gZS5jb2xvck1vZGVGb3JSZW5kZXJQYXNzKCksXG4gICAgICAgICAgICAgIGwgPSBvLnBhaW50LmdldChcImZpbGwtcGF0dGVyblwiKSxcbiAgICAgICAgICAgICAgYyA9IGUub3BhcXVlUGFzc0VuYWJsZWRGb3JMYXllcigpICYmICFsLmNvbnN0YW50T3IoMSkgJiYgMSA9PT0gYS5jb25zdGFudE9yKHQuQ29sb3IudHJhbnNwYXJlbnQpLmEgJiYgMSA9PT0gbi5jb25zdGFudE9yKDApID8gXCJvcGFxdWVcIiA6IFwidHJhbnNsdWNlbnRcIjtcbiAgICAgICAgICAgIGlmIChlLnJlbmRlclBhc3MgPT09IGMpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKDEsIFwib3BhcXVlXCIgPT09IGUucmVuZGVyUGFzcyA/IEl0LlJlYWRXcml0ZSA6IEl0LlJlYWRPbmx5KTtcbiAgICAgICAgICAgICAgb28oZSwgaSwgbywgciwgdSwgcywgITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwidHJhbnNsdWNlbnRcIiA9PT0gZS5yZW5kZXJQYXNzICYmIG8ucGFpbnQuZ2V0KFwiZmlsbC1hbnRpYWxpYXNcIikpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBlLmRlcHRoTW9kZUZvclN1YmxheWVyKG8uZ2V0UGFpbnRQcm9wZXJ0eShcImZpbGwtb3V0bGluZS1jb2xvclwiKSA/IDIgOiAwLCBJdC5SZWFkT25seSk7XG4gICAgICAgICAgICAgIG9vKGUsIGksIG8sIHIsIGgsIHMsICEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZmlsbC1leHRydXNpb25cIjogZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgICB2YXIgciA9IGkucGFpbnQuZ2V0KFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiKTtcbiAgICAgICAgICBpZiAoMCAhPT0gciAmJiBcInRyYW5zbHVjZW50XCIgPT09IHQucmVuZGVyUGFzcykge1xuICAgICAgICAgICAgdmFyIGEgPSBuZXcgSXQodC5jb250ZXh0LmdsLkxFUVVBTCwgSXQuUmVhZFdyaXRlLCB0LmRlcHRoUmFuZ2VGb3IzRCk7XG4gICAgICAgICAgICBpZiAoMSAhPT0gciB8fCBpLnBhaW50LmdldChcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIikuY29uc3RhbnRPcigxKSkgcm8odCwgZSwgaSwgbywgYSwgUHQuZGlzYWJsZWQsIFN0LmRpc2FibGVkKSwgcm8odCwgZSwgaSwgbywgYSwgdC5zdGVuY2lsTW9kZUZvcjNEKCksIHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKTtlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSB0LmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKTtcbiAgICAgICAgICAgICAgcm8odCwgZSwgaSwgbywgYSwgUHQuZGlzYWJsZWQsIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGlsbHNoYWRlOiBmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICAgIGlmIChcIm9mZnNjcmVlblwiID09PSB0LnJlbmRlclBhc3MgfHwgXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSB0LmNvbnRleHQsIGEgPSB0LmRlcHRoTW9kZUZvclN1YmxheWVyKDAsIEl0LlJlYWRPbmx5KSwgbiA9IHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBzID0gXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MgPyB0LnN0ZW5jaWxDb25maWdGb3JPdmVybGFwKG8pIDogW3t9LCBvXSwgbCA9IHNbMF0sIGMgPSAwLCB1ID0gc1sxXTsgYyA8IHUubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSB1W2NdLFxuICAgICAgICAgICAgICAgIHAgPSBlLmdldFRpbGUoaCk7XG4gICAgICAgICAgICAgIHAubmVlZHNIaWxsc2hhZGVQcmVwYXJlICYmIFwib2Zmc2NyZWVuXCIgPT09IHQucmVuZGVyUGFzcyA/IG5vKHQsIHAsIGksIGEsIFB0LmRpc2FibGVkLCBuKSA6IFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzICYmIGFvKHQsIHAsIGksIGEsIGxbaC5vdmVyc2NhbGVkWl0sIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci52aWV3cG9ydC5zZXQoWzAsIDAsIHQud2lkdGgsIHQuaGVpZ2h0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByYXN0ZXI6IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICAgICAgaWYgKFwidHJhbnNsdWNlbnRcIiA9PT0gdC5yZW5kZXJQYXNzICYmIDAgIT09IGkucGFpbnQuZ2V0KFwicmFzdGVyLW9wYWNpdHlcIikgJiYgby5sZW5ndGgpIGZvciAodmFyIHIgPSB0LmNvbnRleHQsIGEgPSByLmdsLCBuID0gZS5nZXRTb3VyY2UoKSwgcyA9IHQudXNlUHJvZ3JhbShcInJhc3RlclwiKSwgbCA9IHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLCBjID0gbiBpbnN0YW5jZW9mIE0gPyBbe30sIG9dIDogdC5zdGVuY2lsQ29uZmlnRm9yT3ZlcmxhcChvKSwgdSA9IGNbMF0sIGggPSBjWzFdLCBwID0gaFtoLmxlbmd0aCAtIDFdLm92ZXJzY2FsZWRaLCBkID0gIXQub3B0aW9ucy5tb3ZpbmcsIF8gPSAwLCBmID0gaDsgXyA8IGYubGVuZ3RoOyBfICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtID0gZltfXSxcbiAgICAgICAgICAgICAgZyA9IHQuZGVwdGhNb2RlRm9yU3VibGF5ZXIobS5vdmVyc2NhbGVkWiAtIHAsIDEgPT09IGkucGFpbnQuZ2V0KFwicmFzdGVyLW9wYWNpdHlcIikgPyBJdC5SZWFkV3JpdGUgOiBJdC5SZWFkT25seSwgYS5MRVNTKSxcbiAgICAgICAgICAgICAgdiA9IGUuZ2V0VGlsZShtKSxcbiAgICAgICAgICAgICAgeSA9IHQudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeChtLnRvVW53cmFwcGVkKCksIGQpO1xuICAgICAgICAgICAgdi5yZWdpc3RlckZhZGVEdXJhdGlvbihpLnBhaW50LmdldChcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCIpKTtcbiAgICAgICAgICAgIHZhciB4ID0gZS5maW5kTG9hZGVkUGFyZW50KG0sIDApLFxuICAgICAgICAgICAgICBiID0gc28odiwgeCwgZSwgaSwgdC50cmFuc2Zvcm0pLFxuICAgICAgICAgICAgICB3ID0gdm9pZCAwLFxuICAgICAgICAgICAgICBUID0gdm9pZCAwLFxuICAgICAgICAgICAgICBFID0gXCJuZWFyZXN0XCIgPT09IGkucGFpbnQuZ2V0KFwicmFzdGVyLXJlc2FtcGxpbmdcIikgPyBhLk5FQVJFU1QgOiBhLkxJTkVBUjtcbiAgICAgICAgICAgIHIuYWN0aXZlVGV4dHVyZS5zZXQoYS5URVhUVVJFMCksIHYudGV4dHVyZS5iaW5kKEUsIGEuQ0xBTVBfVE9fRURHRSwgYS5MSU5FQVJfTUlQTUFQX05FQVJFU1QpLCByLmFjdGl2ZVRleHR1cmUuc2V0KGEuVEVYVFVSRTEpLCB4ID8gKHgudGV4dHVyZS5iaW5kKEUsIGEuQ0xBTVBfVE9fRURHRSwgYS5MSU5FQVJfTUlQTUFQX05FQVJFU1QpLCB3ID0gTWF0aC5wb3coMiwgeC50aWxlSUQub3ZlcnNjYWxlZFogLSB2LnRpbGVJRC5vdmVyc2NhbGVkWiksIFQgPSBbdi50aWxlSUQuY2Fub25pY2FsLnggKiB3ICUgMSwgdi50aWxlSUQuY2Fub25pY2FsLnkgKiB3ICUgMV0pIDogdi50ZXh0dXJlLmJpbmQoRSwgYS5DTEFNUF9UT19FREdFLCBhLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCk7XG4gICAgICAgICAgICB2YXIgSSA9IFppKHksIFQgfHwgWzAsIDBdLCB3IHx8IDEsIGIsIGkpO1xuICAgICAgICAgICAgbiBpbnN0YW5jZW9mIE0gPyBzLmRyYXcociwgYS5UUklBTkdMRVMsIGcsIFB0LmRpc2FibGVkLCBsLCBDdC5kaXNhYmxlZCwgSSwgaS5pZCwgbi5ib3VuZHNCdWZmZXIsIHQucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIG4uYm91bmRzU2VnbWVudHMpIDogcy5kcmF3KHIsIGEuVFJJQU5HTEVTLCBnLCB1W20ub3ZlcnNjYWxlZFpdLCBsLCBDdC5kaXNhYmxlZCwgSSwgaS5pZCwgdC5yYXN0ZXJCb3VuZHNCdWZmZXIsIHQucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIsIHQucmFzdGVyQm91bmRzU2VnbWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZDogZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IGkucGFpbnQuZ2V0KFwiYmFja2dyb3VuZC1jb2xvclwiKSxcbiAgICAgICAgICAgIHIgPSBpLnBhaW50LmdldChcImJhY2tncm91bmQtb3BhY2l0eVwiKTtcbiAgICAgICAgICBpZiAoMCAhPT0gcikge1xuICAgICAgICAgICAgdmFyIGEgPSB0LmNvbnRleHQsXG4gICAgICAgICAgICAgIG4gPSBhLmdsLFxuICAgICAgICAgICAgICBzID0gdC50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGwgPSBzLnRpbGVTaXplLFxuICAgICAgICAgICAgICBjID0gaS5wYWludC5nZXQoXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIik7XG4gICAgICAgICAgICBpZiAoIXQuaXNQYXR0ZXJuTWlzc2luZyhjKSkge1xuICAgICAgICAgICAgICB2YXIgdSA9ICFjICYmIDEgPT09IG8uYSAmJiAxID09PSByICYmIHQub3BhcXVlUGFzc0VuYWJsZWRGb3JMYXllcigpID8gXCJvcGFxdWVcIiA6IFwidHJhbnNsdWNlbnRcIjtcbiAgICAgICAgICAgICAgaWYgKHQucmVuZGVyUGFzcyA9PT0gdSkge1xuICAgICAgICAgICAgICAgIHZhciBoID0gUHQuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICBwID0gdC5kZXB0aE1vZGVGb3JTdWJsYXllcigwLCBcIm9wYXF1ZVwiID09PSB1ID8gSXQuUmVhZFdyaXRlIDogSXQuUmVhZE9ubHkpLFxuICAgICAgICAgICAgICAgICAgZCA9IHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpLFxuICAgICAgICAgICAgICAgICAgXyA9IHQudXNlUHJvZ3JhbShjID8gXCJiYWNrZ3JvdW5kUGF0dGVyblwiIDogXCJiYWNrZ3JvdW5kXCIpLFxuICAgICAgICAgICAgICAgICAgZiA9IHMuY292ZXJpbmdUaWxlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVTaXplOiBsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjICYmIChhLmFjdGl2ZVRleHR1cmUuc2V0KG4uVEVYVFVSRTApLCB0LmltYWdlTWFuYWdlci5iaW5kKHQuY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSBpLmdldENyb3NzZmFkZVBhcmFtZXRlcnMoKSwgZyA9IDAsIHYgPSBmOyBnIDwgdi5sZW5ndGg7IGcgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHkgPSB2W2ddLFxuICAgICAgICAgICAgICAgICAgICB4ID0gdC50cmFuc2Zvcm0uY2FsY3VsYXRlUG9zTWF0cml4KHkudG9VbndyYXBwZWQoKSksXG4gICAgICAgICAgICAgICAgICAgIGIgPSBjID8gSGkoeCwgciwgdCwgYywge1xuICAgICAgICAgICAgICAgICAgICAgIHRpbGVJRDogeSxcbiAgICAgICAgICAgICAgICAgICAgICB0aWxlU2l6ZTogbFxuICAgICAgICAgICAgICAgICAgICB9LCBtKSA6IFhpKHgsIHIsIG8pO1xuICAgICAgICAgICAgICAgICAgXy5kcmF3KGEsIG4uVFJJQU5HTEVTLCBwLCBoLCBkLCBDdC5kaXNhYmxlZCwgYiwgaS5pZCwgdC50aWxlRXh0ZW50QnVmZmVyLCB0LnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCB0LnRpbGVFeHRlbnRTZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGkubGVuZ3RoOyBvKyspIGdvKHQsIGUsIGlbb10pO1xuICAgICAgICB9LFxuICAgICAgICBjdXN0b206IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgdmFyIG8gPSB0LmNvbnRleHQsXG4gICAgICAgICAgICByID0gaS5pbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgICBpZiAoXCJvZmZzY3JlZW5cIiA9PT0gdC5yZW5kZXJQYXNzKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHIucHJlcmVuZGVyO1xuICAgICAgICAgICAgYSAmJiAodC5zZXRDdXN0b21MYXllckRlZmF1bHRzKCksIG8uc2V0Q29sb3JNb2RlKHQuY29sb3JNb2RlRm9yUmVuZGVyUGFzcygpKSwgYS5jYWxsKHIsIG8uZ2wsIHQudHJhbnNmb3JtLmN1c3RvbUxheWVyTWF0cml4KCkpLCBvLnNldERpcnR5KCksIHQuc2V0QmFzZVN0YXRlKCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXCJ0cmFuc2x1Y2VudFwiID09PSB0LnJlbmRlclBhc3MpIHtcbiAgICAgICAgICAgIHQuc2V0Q3VzdG9tTGF5ZXJEZWZhdWx0cygpLCBvLnNldENvbG9yTW9kZSh0LmNvbG9yTW9kZUZvclJlbmRlclBhc3MoKSksIG8uc2V0U3RlbmNpbE1vZGUoUHQuZGlzYWJsZWQpO1xuICAgICAgICAgICAgdmFyIG4gPSBcIjNkXCIgPT09IHIucmVuZGVyaW5nTW9kZSA/IG5ldyBJdCh0LmNvbnRleHQuZ2wuTEVRVUFMLCBJdC5SZWFkV3JpdGUsIHQuZGVwdGhSYW5nZUZvcjNEKSA6IHQuZGVwdGhNb2RlRm9yU3VibGF5ZXIoMCwgSXQuUmVhZE9ubHkpO1xuICAgICAgICAgICAgby5zZXREZXB0aE1vZGUobiksIHIucmVuZGVyKG8uZ2wsIHQudHJhbnNmb3JtLmN1c3RvbUxheWVyTWF0cml4KCkpLCBvLnNldERpcnR5KCksIHQuc2V0QmFzZVN0YXRlKCksIG8uYmluZEZyYW1lYnVmZmVyLnNldChudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB5byA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyB6dCh0KSwgdGhpcy50cmFuc2Zvcm0gPSBlLCB0aGlzLl90aWxlVGV4dHVyZXMgPSB7fSwgdGhpcy5zZXR1cCgpLCB0aGlzLm51bVN1YmxheWVycyA9IER0Lm1heFVuZGVyem9vbWluZyArIER0Lm1heE92ZXJ6b29taW5nICsgMSwgdGhpcy5kZXB0aEVwc2lsb24gPSAxIC8gTWF0aC5wb3coMiwgMTYpLCB0aGlzLmNyb3NzVGlsZVN5bWJvbEluZGV4ID0gbmV3IEZlKCksIHRoaXMuZ3B1VGltZXJzID0ge307XG4gICAgICB9O1xuICAgIHlvLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgaWYgKHRoaXMud2lkdGggPSBlICogdC5icm93c2VyLmRldmljZVBpeGVsUmF0aW8sIHRoaXMuaGVpZ2h0ID0gaSAqIHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvLCB0aGlzLmNvbnRleHQudmlld3BvcnQuc2V0KFswLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0pLCB0aGlzLnN0eWxlKSBmb3IgKHZhciBvID0gMCwgciA9IHRoaXMuc3R5bGUuX29yZGVyOyBvIDwgci5sZW5ndGg7IG8gKz0gMSkgdGhpcy5zdHlsZS5fbGF5ZXJzW3Jbb11dLnJlc2l6ZSgpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jb250ZXh0LFxuICAgICAgICBpID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyaTQoKTtcbiAgICAgIGkuZW1wbGFjZUJhY2soMCwgMCksIGkuZW1wbGFjZUJhY2sodC5FWFRFTlQsIDApLCBpLmVtcGxhY2VCYWNrKDAsIHQuRVhURU5UKSwgaS5lbXBsYWNlQmFjayh0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcihpLCBWZS5tZW1iZXJzKSwgdGhpcy50aWxlRXh0ZW50U2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKTtcbiAgICAgIHZhciBvID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyaTQoKTtcbiAgICAgIG8uZW1wbGFjZUJhY2soMCwgMCksIG8uZW1wbGFjZUJhY2sodC5FWFRFTlQsIDApLCBvLmVtcGxhY2VCYWNrKDAsIHQuRVhURU5UKSwgby5lbXBsYWNlQmFjayh0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLmRlYnVnQnVmZmVyID0gZS5jcmVhdGVWZXJ0ZXhCdWZmZXIobywgVmUubWVtYmVycyksIHRoaXMuZGVidWdTZWdtZW50cyA9IHQuU2VnbWVudFZlY3Rvci5zaW1wbGVTZWdtZW50KDAsIDAsIDQsIDUpO1xuICAgICAgdmFyIHIgPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDRpOCgpO1xuICAgICAgci5lbXBsYWNlQmFjaygwLCAwLCAwLCAwKSwgci5lbXBsYWNlQmFjayh0LkVYVEVOVCwgMCwgdC5FWFRFTlQsIDApLCByLmVtcGxhY2VCYWNrKDAsIHQuRVhURU5ULCAwLCB0LkVYVEVOVCksIHIuZW1wbGFjZUJhY2sodC5FWFRFTlQsIHQuRVhURU5ULCB0LkVYVEVOVCwgdC5FWFRFTlQpLCB0aGlzLnJhc3RlckJvdW5kc0J1ZmZlciA9IGUuY3JlYXRlVmVydGV4QnVmZmVyKHIsIEEubWVtYmVycyksIHRoaXMucmFzdGVyQm91bmRzU2VnbWVudHMgPSB0LlNlZ21lbnRWZWN0b3Iuc2ltcGxlU2VnbWVudCgwLCAwLCA0LCAyKTtcbiAgICAgIHZhciBhID0gbmV3IHQuU3RydWN0QXJyYXlMYXlvdXQyaTQoKTtcbiAgICAgIGEuZW1wbGFjZUJhY2soMCwgMCksIGEuZW1wbGFjZUJhY2soMSwgMCksIGEuZW1wbGFjZUJhY2soMCwgMSksIGEuZW1wbGFjZUJhY2soMSwgMSksIHRoaXMudmlld3BvcnRCdWZmZXIgPSBlLmNyZWF0ZVZlcnRleEJ1ZmZlcihhLCBWZS5tZW1iZXJzKSwgdGhpcy52aWV3cG9ydFNlZ21lbnRzID0gdC5TZWdtZW50VmVjdG9yLnNpbXBsZVNlZ21lbnQoMCwgMCwgNCwgMik7XG4gICAgICB2YXIgbiA9IG5ldyB0LlN0cnVjdEFycmF5TGF5b3V0MXVpMigpO1xuICAgICAgbi5lbXBsYWNlQmFjaygwKSwgbi5lbXBsYWNlQmFjaygxKSwgbi5lbXBsYWNlQmFjaygzKSwgbi5lbXBsYWNlQmFjaygyKSwgbi5lbXBsYWNlQmFjaygwKSwgdGhpcy50aWxlQm9yZGVySW5kZXhCdWZmZXIgPSBlLmNyZWF0ZUluZGV4QnVmZmVyKG4pO1xuICAgICAgdmFyIHMgPSBuZXcgdC5TdHJ1Y3RBcnJheUxheW91dDN1aTYoKTtcbiAgICAgIHMuZW1wbGFjZUJhY2soMCwgMSwgMiksIHMuZW1wbGFjZUJhY2soMiwgMSwgMyksIHRoaXMucXVhZFRyaWFuZ2xlSW5kZXhCdWZmZXIgPSBlLmNyZWF0ZUluZGV4QnVmZmVyKHMpLCB0aGlzLmVtcHR5VGV4dHVyZSA9IG5ldyB0LlRleHR1cmUoZSwge1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBkYXRhOiBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMF0pXG4gICAgICB9LCBlLmdsLlJHQkEpO1xuICAgICAgdmFyIGwgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICB0aGlzLnN0ZW5jaWxDbGVhck1vZGUgPSBuZXcgUHQoe1xuICAgICAgICBmdW5jOiBsLkFMV0FZUyxcbiAgICAgICAgbWFzazogMFxuICAgICAgfSwgMCwgMjU1LCBsLlpFUk8sIGwuWkVSTywgbC5aRVJPKTtcbiAgICB9LCB5by5wcm90b3R5cGUuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIGkgPSBlLmdsO1xuICAgICAgdGhpcy5uZXh0U3RlbmNpbElEID0gMSwgdGhpcy5jdXJyZW50U3RlbmNpbFNvdXJjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBvID0gdC5jcmVhdGUoKTtcbiAgICAgIHQub3J0aG8obywgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIDAsIDEpLCB0LnNjYWxlKG8sIG8sIFtpLmRyYXdpbmdCdWZmZXJXaWR0aCwgaS5kcmF3aW5nQnVmZmVySGVpZ2h0LCAwXSksIHRoaXMudXNlUHJvZ3JhbShcImNsaXBwaW5nTWFza1wiKS5kcmF3KGUsIGkuVFJJQU5HTEVTLCBJdC5kaXNhYmxlZCwgdGhpcy5zdGVuY2lsQ2xlYXJNb2RlLCBTdC5kaXNhYmxlZCwgQ3QuZGlzYWJsZWQsIExpKG8pLCBcIiRjbGlwcGluZ1wiLCB0aGlzLnZpZXdwb3J0QnVmZmVyLCB0aGlzLnF1YWRUcmlhbmdsZUluZGV4QnVmZmVyLCB0aGlzLnZpZXdwb3J0U2VnbWVudHMpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5fcmVuZGVyVGlsZUNsaXBwaW5nTWFza3MgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFN0ZW5jaWxTb3VyY2UgIT09IHQuc291cmNlICYmIHQuaXNUaWxlQ2xpcHBlZCgpICYmIGUgJiYgZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlbmNpbFNvdXJjZSA9IHQuc291cmNlO1xuICAgICAgICB2YXIgaSA9IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBvID0gaS5nbDtcbiAgICAgICAgdGhpcy5uZXh0U3RlbmNpbElEICsgZS5sZW5ndGggPiAyNTYgJiYgdGhpcy5jbGVhclN0ZW5jaWwoKSwgaS5zZXRDb2xvck1vZGUoU3QuZGlzYWJsZWQpLCBpLnNldERlcHRoTW9kZShJdC5kaXNhYmxlZCk7XG4gICAgICAgIHZhciByID0gdGhpcy51c2VQcm9ncmFtKFwiY2xpcHBpbmdNYXNrXCIpO1xuICAgICAgICB0aGlzLl90aWxlQ2xpcHBpbmdNYXNrSURzID0ge307XG4gICAgICAgIGZvciAodmFyIGEgPSAwLCBuID0gZTsgYSA8IG4ubGVuZ3RoOyBhICs9IDEpIHtcbiAgICAgICAgICB2YXIgcyA9IG5bYV0sXG4gICAgICAgICAgICBsID0gdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEc1tzLmtleV0gPSB0aGlzLm5leHRTdGVuY2lsSUQrKztcbiAgICAgICAgICByLmRyYXcoaSwgby5UUklBTkdMRVMsIEl0LmRpc2FibGVkLCBuZXcgUHQoe1xuICAgICAgICAgICAgZnVuYzogby5BTFdBWVMsXG4gICAgICAgICAgICBtYXNrOiAwXG4gICAgICAgICAgfSwgbCwgMjU1LCBvLktFRVAsIG8uS0VFUCwgby5SRVBMQUNFKSwgU3QuZGlzYWJsZWQsIEN0LmRpc2FibGVkLCBMaShzLnBvc01hdHJpeCksIFwiJGNsaXBwaW5nXCIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlciwgdGhpcy5xdWFkVHJpYW5nbGVJbmRleEJ1ZmZlciwgdGhpcy50aWxlRXh0ZW50U2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgeW8ucHJvdG90eXBlLnN0ZW5jaWxNb2RlRm9yM0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVuY2lsU291cmNlID0gdm9pZCAwLCB0aGlzLm5leHRTdGVuY2lsSUQgKyAxID4gMjU2ICYmIHRoaXMuY2xlYXJTdGVuY2lsKCk7XG4gICAgICB2YXIgdCA9IHRoaXMubmV4dFN0ZW5jaWxJRCsrLFxuICAgICAgICBlID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgcmV0dXJuIG5ldyBQdCh7XG4gICAgICAgIGZ1bmM6IGUuTk9URVFVQUwsXG4gICAgICAgIG1hc2s6IDI1NVxuICAgICAgfSwgdCwgMjU1LCBlLktFRVAsIGUuS0VFUCwgZS5SRVBMQUNFKTtcbiAgICB9LCB5by5wcm90b3R5cGUuc3RlbmNpbE1vZGVGb3JDbGlwcGluZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgIHJldHVybiBuZXcgUHQoe1xuICAgICAgICBmdW5jOiBlLkVRVUFMLFxuICAgICAgICBtYXNrOiAyNTVcbiAgICAgIH0sIHRoaXMuX3RpbGVDbGlwcGluZ01hc2tJRHNbdC5rZXldLCAwLCBlLktFRVAsIGUuS0VFUCwgZS5SRVBMQUNFKTtcbiAgICB9LCB5by5wcm90b3R5cGUuc3RlbmNpbENvbmZpZ0Zvck92ZXJsYXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgIGkgPSB0aGlzLmNvbnRleHQuZ2wsXG4gICAgICAgIG8gPSB0LnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5vdmVyc2NhbGVkWiAtIHQub3ZlcnNjYWxlZFo7XG4gICAgICAgIH0pLFxuICAgICAgICByID0gb1tvLmxlbmd0aCAtIDFdLm92ZXJzY2FsZWRaLFxuICAgICAgICBhID0gb1swXS5vdmVyc2NhbGVkWiAtIHIgKyAxO1xuICAgICAgaWYgKGEgPiAxKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZW5jaWxTb3VyY2UgPSB2b2lkIDAsIHRoaXMubmV4dFN0ZW5jaWxJRCArIGEgPiAyNTYgJiYgdGhpcy5jbGVhclN0ZW5jaWwoKTtcbiAgICAgICAgZm9yICh2YXIgbiA9IHt9LCBzID0gMDsgcyA8IGE7IHMrKykgbltzICsgcl0gPSBuZXcgUHQoe1xuICAgICAgICAgIGZ1bmM6IGkuR0VRVUFMLFxuICAgICAgICAgIG1hc2s6IDI1NVxuICAgICAgICB9LCBzICsgdGhpcy5uZXh0U3RlbmNpbElELCAyNTUsIGkuS0VFUCwgaS5LRUVQLCBpLlJFUExBQ0UpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0U3RlbmNpbElEICs9IGEsIFtuLCBvXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbKGUgPSB7fSwgZVtyXSA9IFB0LmRpc2FibGVkLCBlKSwgb107XG4gICAgfSwgeW8ucHJvdG90eXBlLmNvbG9yTW9kZUZvclJlbmRlclBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgIHJldHVybiB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPyBuZXcgU3QoW2UuQ09OU1RBTlRfQ09MT1IsIGUuT05FXSwgbmV3IHQuQ29sb3IoMSAvIDgsIDEgLyA4LCAxIC8gOCwgMCksIFshMCwgITAsICEwLCAhMF0pIDogXCJvcGFxdWVcIiA9PT0gdGhpcy5yZW5kZXJQYXNzID8gU3QudW5ibGVuZGVkIDogU3QuYWxwaGFCbGVuZGVkO1xuICAgIH0sIHlvLnByb3RvdHlwZS5kZXB0aE1vZGVGb3JTdWJsYXllciA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAoIXRoaXMub3BhcXVlUGFzc0VuYWJsZWRGb3JMYXllcigpKSByZXR1cm4gSXQuZGlzYWJsZWQ7XG4gICAgICB2YXIgbyA9IDEgLSAoKDEgKyB0aGlzLmN1cnJlbnRMYXllcikgKiB0aGlzLm51bVN1YmxheWVycyArIHQpICogdGhpcy5kZXB0aEVwc2lsb247XG4gICAgICByZXR1cm4gbmV3IEl0KGkgfHwgdGhpcy5jb250ZXh0LmdsLkxFUVVBTCwgZSwgW28sIG9dKTtcbiAgICB9LCB5by5wcm90b3R5cGUub3BhcXVlUGFzc0VuYWJsZWRGb3JMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRMYXllciA8IHRoaXMub3BhcXVlUGFzc0N1dG9mZjtcbiAgICB9LCB5by5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcztcbiAgICAgIHRoaXMuc3R5bGUgPSBlLCB0aGlzLm9wdGlvbnMgPSBpLCB0aGlzLmxpbmVBdGxhcyA9IGUubGluZUF0bGFzLCB0aGlzLmltYWdlTWFuYWdlciA9IGUuaW1hZ2VNYW5hZ2VyLCB0aGlzLmdseXBoTWFuYWdlciA9IGUuZ2x5cGhNYW5hZ2VyLCB0aGlzLnN5bWJvbEZhZGVDaGFuZ2UgPSBlLnBsYWNlbWVudC5zeW1ib2xGYWRlQ2hhbmdlKHQuYnJvd3Nlci5ub3coKSksIHRoaXMuaW1hZ2VNYW5hZ2VyLmJlZ2luRnJhbWUoKTtcbiAgICAgIHZhciByID0gdGhpcy5zdHlsZS5fb3JkZXIsXG4gICAgICAgIGEgPSB0aGlzLnN0eWxlLnNvdXJjZUNhY2hlcztcbiAgICAgIGZvciAodmFyIG4gaW4gYSkge1xuICAgICAgICB2YXIgcyA9IGFbbl07XG4gICAgICAgIHMudXNlZCAmJiBzLnByZXBhcmUodGhpcy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHZhciBsLFxuICAgICAgICBjLFxuICAgICAgICB1ID0ge30sXG4gICAgICAgIGggPSB7fSxcbiAgICAgICAgcCA9IHt9O1xuICAgICAgZm9yICh2YXIgZCBpbiBhKSB7XG4gICAgICAgIHZhciBfID0gYVtkXTtcbiAgICAgICAgdVtkXSA9IF8uZ2V0VmlzaWJsZUNvb3JkaW5hdGVzKCksIGhbZF0gPSB1W2RdLnNsaWNlKCkucmV2ZXJzZSgpLCBwW2RdID0gXy5nZXRWaXNpYmxlQ29vcmRpbmF0ZXMoITApLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3BhcXVlUGFzc0N1dG9mZiA9IDEgLyAwO1xuICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCByLmxlbmd0aDsgZisrKSBpZiAodGhpcy5zdHlsZS5fbGF5ZXJzW3JbZl1dLmlzM0QoKSkge1xuICAgICAgICB0aGlzLm9wYXF1ZVBhc3NDdXRvZmYgPSBmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyUGFzcyA9IFwib2Zmc2NyZWVuXCI7XG4gICAgICBmb3IgKHZhciBtID0gMCwgZyA9IHI7IG0gPCBnLmxlbmd0aDsgbSArPSAxKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5zdHlsZS5fbGF5ZXJzW2dbbV1dO1xuICAgICAgICBpZiAodi5oYXNPZmZzY3JlZW5QYXNzKCkgJiYgIXYuaXNIaWRkZW4odGhpcy50cmFuc2Zvcm0uem9vbSkpIHtcbiAgICAgICAgICB2YXIgeSA9IGhbdi5zb3VyY2VdO1xuICAgICAgICAgIChcImN1c3RvbVwiID09PSB2LnR5cGUgfHwgeS5sZW5ndGgpICYmIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgYVt2LnNvdXJjZV0sIHYsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHRoaXMuY29udGV4dC5iaW5kRnJhbWVidWZmZXIuc2V0KG51bGwpLCB0aGlzLmNvbnRleHQuY2xlYXIoe1xuICAgICAgICBjb2xvcjogaS5zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPyB0LkNvbG9yLmJsYWNrIDogdC5Db2xvci50cmFuc3BhcmVudCxcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pLCB0aGlzLmNsZWFyU3RlbmNpbCgpLCB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPSBpLnNob3dPdmVyZHJhd0luc3BlY3RvciwgdGhpcy5kZXB0aFJhbmdlRm9yM0QgPSBbMCwgMSAtIChlLl9vcmRlci5sZW5ndGggKyAyKSAqIHRoaXMubnVtU3VibGF5ZXJzICogdGhpcy5kZXB0aEVwc2lsb25dLCB0aGlzLnJlbmRlclBhc3MgPSBcIm9wYXF1ZVwiLCB0aGlzLmN1cnJlbnRMYXllciA9IHIubGVuZ3RoIC0gMTsgdGhpcy5jdXJyZW50TGF5ZXIgPj0gMDsgdGhpcy5jdXJyZW50TGF5ZXItLSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuc3R5bGUuX2xheWVyc1tyW3RoaXMuY3VycmVudExheWVyXV0sXG4gICAgICAgICAgYiA9IGFbeC5zb3VyY2VdLFxuICAgICAgICAgIHcgPSB1W3guc291cmNlXTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGlsZUNsaXBwaW5nTWFza3MoeCwgdyksIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgYiwgeCwgdyk7XG4gICAgICB9XG4gICAgICBmb3IgKHRoaXMucmVuZGVyUGFzcyA9IFwidHJhbnNsdWNlbnRcIiwgdGhpcy5jdXJyZW50TGF5ZXIgPSAwOyB0aGlzLmN1cnJlbnRMYXllciA8IHIubGVuZ3RoOyB0aGlzLmN1cnJlbnRMYXllcisrKSB7XG4gICAgICAgIHZhciBUID0gdGhpcy5zdHlsZS5fbGF5ZXJzW3JbdGhpcy5jdXJyZW50TGF5ZXJdXSxcbiAgICAgICAgICBFID0gYVtULnNvdXJjZV0sXG4gICAgICAgICAgSSA9IChcInN5bWJvbFwiID09PSBULnR5cGUgPyBwIDogaClbVC5zb3VyY2VdO1xuICAgICAgICB0aGlzLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyhULCB1W1Quc291cmNlXSksIHRoaXMucmVuZGVyTGF5ZXIodGhpcywgRSwgVCwgSSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMuc2hvd1RpbGVCb3VuZGFyaWVzICYmICh0LnZhbHVlcyh0aGlzLnN0eWxlLl9sYXllcnMpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdC5zb3VyY2UgJiYgIXQuaXNIaWRkZW4oby50cmFuc2Zvcm0uem9vbSkgJiYgKHQuc291cmNlICE9PSAoYyAmJiBjLmlkKSAmJiAoYyA9IG8uc3R5bGUuc291cmNlQ2FjaGVzW3Quc291cmNlXSksICghbCB8fCBsLmdldFNvdXJjZSgpLm1heHpvb20gPCBjLmdldFNvdXJjZSgpLm1heHpvb20pICYmIChsID0gYykpO1xuICAgICAgfSksIGwgJiYgdm8uZGVidWcodGhpcywgbCwgbC5nZXRWaXNpYmxlQ29vcmRpbmF0ZXMoKSkpLCB0aGlzLm9wdGlvbnMuc2hvd1BhZGRpbmcgJiYgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0LnRyYW5zZm9ybS5wYWRkaW5nO1xuICAgICAgICBfbyh0LCB0LnRyYW5zZm9ybS5oZWlnaHQgLSAoZS50b3AgfHwgMCksIDMsIGxvKSwgX28odCwgZS5ib3R0b20gfHwgMCwgMywgY28pLCBmbyh0LCBlLmxlZnQgfHwgMCwgMywgdW8pLCBmbyh0LCB0LnRyYW5zZm9ybS53aWR0aCAtIChlLnJpZ2h0IHx8IDApLCAzLCBobyk7XG4gICAgICAgIHZhciBpID0gdC50cmFuc2Zvcm0uY2VudGVyUG9pbnQ7XG4gICAgICAgICFmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICAgIG1vKHQsIGUgLSAxLCBpIC0gMTAsIDIsIDIwLCBvKSwgbW8odCwgZSAtIDEwLCBpIC0gMSwgMjAsIDIsIG8pO1xuICAgICAgICB9KHQsIGkueCwgdC50cmFuc2Zvcm0uaGVpZ2h0IC0gaS55LCBwbyk7XG4gICAgICB9KHRoaXMpLCB0aGlzLmNvbnRleHQuc2V0RGVmYXVsdCgpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5yZW5kZXJMYXllciA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICBpLmlzSGlkZGVuKHRoaXMudHJhbnNmb3JtLnpvb20pIHx8IChcImJhY2tncm91bmRcIiA9PT0gaS50eXBlIHx8IFwiY3VzdG9tXCIgPT09IGkudHlwZSB8fCBvLmxlbmd0aCkgJiYgKHRoaXMuaWQgPSBpLmlkLCB0aGlzLmdwdVRpbWluZ1N0YXJ0KGkpLCB2b1tpLnR5cGVdKHQsIGUsIGksIG8sIHRoaXMuc3R5bGUucGxhY2VtZW50LnZhcmlhYmxlT2Zmc2V0cyksIHRoaXMuZ3B1VGltaW5nRW5kKCkpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5ncHVUaW1pbmdTdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdwdVRpbWluZykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY29udGV4dC5leHRUaW1lclF1ZXJ5LFxuICAgICAgICAgIGkgPSB0aGlzLmdwdVRpbWVyc1t0LmlkXTtcbiAgICAgICAgaSB8fCAoaSA9IHRoaXMuZ3B1VGltZXJzW3QuaWRdID0ge1xuICAgICAgICAgIGNhbGxzOiAwLFxuICAgICAgICAgIGNwdVRpbWU6IDAsXG4gICAgICAgICAgcXVlcnk6IGUuY3JlYXRlUXVlcnlFWFQoKVxuICAgICAgICB9KSwgaS5jYWxscysrLCBlLmJlZ2luUXVlcnlFWFQoZS5USU1FX0VMQVBTRURfRVhULCBpLnF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9LCB5by5wcm90b3R5cGUuZ3B1VGltaW5nRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncHVUaW1pbmcpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLmNvbnRleHQuZXh0VGltZXJRdWVyeTtcbiAgICAgICAgdC5lbmRRdWVyeUVYVCh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgfVxuICAgIH0sIHlvLnByb3RvdHlwZS5jb2xsZWN0R3B1VGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmdwdVRpbWVycztcbiAgICAgIHJldHVybiB0aGlzLmdwdVRpbWVycyA9IHt9LCB0O1xuICAgIH0sIHlvLnByb3RvdHlwZS5xdWVyeUdwdVRpbWVycyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSBpbiB0KSB7XG4gICAgICAgIHZhciBvID0gdFtpXSxcbiAgICAgICAgICByID0gdGhpcy5jb250ZXh0LmV4dFRpbWVyUXVlcnksXG4gICAgICAgICAgYSA9IHIuZ2V0UXVlcnlPYmplY3RFWFQoby5xdWVyeSwgci5RVUVSWV9SRVNVTFRfRVhUKSAvIDFlNjtcbiAgICAgICAgci5kZWxldGVRdWVyeUVYVChvLnF1ZXJ5KSwgZVtpXSA9IGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9LCB5by5wcm90b3R5cGUudHJhbnNsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgIGlmICghb1swXSAmJiAhb1sxXSkgcmV0dXJuIGU7XG4gICAgICB2YXIgbiA9IGEgPyBcIm1hcFwiID09PSByID8gdGhpcy50cmFuc2Zvcm0uYW5nbGUgOiAwIDogXCJ2aWV3cG9ydFwiID09PSByID8gLXRoaXMudHJhbnNmb3JtLmFuZ2xlIDogMDtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4obiksXG4gICAgICAgICAgbCA9IE1hdGguY29zKG4pO1xuICAgICAgICBvID0gW29bMF0gKiBsIC0gb1sxXSAqIHMsIG9bMF0gKiBzICsgb1sxXSAqIGxdO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSBbYSA/IG9bMF0gOiBwZShpLCBvWzBdLCB0aGlzLnRyYW5zZm9ybS56b29tKSwgYSA/IG9bMV0gOiBwZShpLCBvWzFdLCB0aGlzLnRyYW5zZm9ybS56b29tKSwgMF0sXG4gICAgICAgIHUgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgIHJldHVybiB0LnRyYW5zbGF0ZSh1LCBlLCBjKSwgdTtcbiAgICB9LCB5by5wcm90b3R5cGUuc2F2ZVRpbGVUZXh0dXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fdGlsZVRleHR1cmVzW3Quc2l6ZVswXV07XG4gICAgICBlID8gZS5wdXNoKHQpIDogdGhpcy5fdGlsZVRleHR1cmVzW3Quc2l6ZVswXV0gPSBbdF07XG4gICAgfSwgeW8ucHJvdG90eXBlLmdldFRpbGVUZXh0dXJlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcy5fdGlsZVRleHR1cmVzW3RdO1xuICAgICAgcmV0dXJuIGUgJiYgZS5sZW5ndGggPiAwID8gZS5wb3AoKSA6IG51bGw7XG4gICAgfSwgeW8ucHJvdG90eXBlLmlzUGF0dGVybk1pc3NpbmcgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKCF0KSByZXR1cm4gITE7XG4gICAgICBpZiAoIXQuZnJvbSB8fCAhdC50bykgcmV0dXJuICEwO1xuICAgICAgdmFyIGUgPSB0aGlzLmltYWdlTWFuYWdlci5nZXRQYXR0ZXJuKHQuZnJvbS50b1N0cmluZygpKSxcbiAgICAgICAgaSA9IHRoaXMuaW1hZ2VNYW5hZ2VyLmdldFBhdHRlcm4odC50by50b1N0cmluZygpKTtcbiAgICAgIHJldHVybiAhZSB8fCAhaTtcbiAgICB9LCB5by5wcm90b3R5cGUudXNlUHJvZ3JhbSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZSB8fCB7fTtcbiAgICAgIHZhciBpID0gXCJcIiArIHQgKyAoZSA/IGUuY2FjaGVLZXkgOiBcIlwiKSArICh0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPyBcIi9vdmVyZHJhd1wiIDogXCJcIik7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVtpXSB8fCAodGhpcy5jYWNoZVtpXSA9IG5ldyBiaSh0aGlzLmNvbnRleHQsIHQsIHZpW3RdLCBlLCBLaVt0XSwgdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yKSksIHRoaXMuY2FjaGVbaV07XG4gICAgfSwgeW8ucHJvdG90eXBlLnNldEN1c3RvbUxheWVyRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbnRleHQudW5iaW5kVkFPKCksIHRoaXMuY29udGV4dC5jdWxsRmFjZS5zZXREZWZhdWx0KCksIHRoaXMuY29udGV4dC5hY3RpdmVUZXh0dXJlLnNldERlZmF1bHQoKSwgdGhpcy5jb250ZXh0LnBpeGVsU3RvcmVVbnBhY2suc2V0RGVmYXVsdCgpLCB0aGlzLmNvbnRleHQucGl4ZWxTdG9yZVVucGFja1ByZW11bHRpcGx5QWxwaGEuc2V0RGVmYXVsdCgpLCB0aGlzLmNvbnRleHQucGl4ZWxTdG9yZVVucGFja0ZsaXBZLnNldERlZmF1bHQoKTtcbiAgICB9LCB5by5wcm90b3R5cGUuc2V0QmFzZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICB0aGlzLmNvbnRleHQuY3VsbEZhY2Uuc2V0KCExKSwgdGhpcy5jb250ZXh0LnZpZXdwb3J0LnNldChbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdKSwgdGhpcy5jb250ZXh0LmJsZW5kRXF1YXRpb24uc2V0KHQuRlVOQ19BREQpO1xuICAgIH0sIHlvLnByb3RvdHlwZS5pbml0RGVidWdPdmVybGF5Q2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgICAgbnVsbCA9PSB0aGlzLmRlYnVnT3ZlcmxheUNhbnZhcyAmJiAodGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMgPSB0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCB0aGlzLmRlYnVnT3ZlcmxheUNhbnZhcy53aWR0aCA9IDUxMiwgdGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMuaGVpZ2h0ID0gNTEyLCB0aGlzLmRlYnVnT3ZlcmxheVRleHR1cmUgPSBuZXcgdC5UZXh0dXJlKHRoaXMuY29udGV4dCwgdGhpcy5kZWJ1Z092ZXJsYXlDYW52YXMsIHRoaXMuY29udGV4dC5nbC5SR0JBKSk7XG4gICAgfSwgeW8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVtcHR5VGV4dHVyZS5kZXN0cm95KCksIHRoaXMuZGVidWdPdmVybGF5VGV4dHVyZSAmJiB0aGlzLmRlYnVnT3ZlcmxheVRleHR1cmUuZGVzdHJveSgpO1xuICAgIH07XG4gICAgdmFyIHhvID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHRoaXMucG9pbnRzID0gdCwgdGhpcy5wbGFuZXMgPSBlO1xuICAgIH07XG4gICAgeG8uZnJvbUludlByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgdmFyIHIgPSBNYXRoLnBvdygyLCBvKSxcbiAgICAgICAgYSA9IFtbLTEsIDEsIC0xLCAxXSwgWzEsIDEsIC0xLCAxXSwgWzEsIC0xLCAtMSwgMV0sIFstMSwgLTEsIC0xLCAxXSwgWy0xLCAxLCAxLCAxXSwgWzEsIDEsIDEsIDFdLCBbMSwgLTEsIDEsIDFdLCBbLTEsIC0xLCAxLCAxXV0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIHQudHJhbnNmb3JtTWF0NChbXSwgaSwgZSk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiB0LnNjYWxlJDEoW10sIGUsIDEgLyBlWzNdIC8gaSAqIHIpO1xuICAgICAgICB9KSxcbiAgICAgICAgbiA9IFtbMCwgMSwgMl0sIFs2LCA1LCA0XSwgWzAsIDMsIDddLCBbMiwgMSwgNV0sIFszLCAyLCA2XSwgWzAsIDQsIDVdXS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgaSA9IHQuc3ViKFtdLCBhW2VbMF1dLCBhW2VbMV1dKSxcbiAgICAgICAgICAgIG8gPSB0LnN1YihbXSwgYVtlWzJdXSwgYVtlWzFdXSksXG4gICAgICAgICAgICByID0gdC5ub3JtYWxpemUoW10sIHQuY3Jvc3MoW10sIGksIG8pKSxcbiAgICAgICAgICAgIG4gPSAtdC5kb3QociwgYVtlWzFdXSk7XG4gICAgICAgICAgcmV0dXJuIHIuY29uY2F0KG4pO1xuICAgICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgeG8oYSwgbik7XG4gICAgfTtcbiAgICB2YXIgYm8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdGhpcy5taW4gPSBlLCB0aGlzLm1heCA9IGksIHRoaXMuY2VudGVyID0gdC5zY2FsZSQyKFtdLCB0LmFkZChbXSwgdGhpcy5taW4sIHRoaXMubWF4KSwgLjUpO1xuICAgIH07XG4gICAgYm8ucHJvdG90eXBlLnF1YWRyYW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBbZSAlIDIgPT0gMCwgZSA8IDJdLCBvID0gdC5jbG9uZSQyKHRoaXMubWluKSwgciA9IHQuY2xvbmUkMih0aGlzLm1heCksIGEgPSAwOyBhIDwgaS5sZW5ndGg7IGErKykgb1thXSA9IGlbYV0gPyB0aGlzLm1pblthXSA6IHRoaXMuY2VudGVyW2FdLCByW2FdID0gaVthXSA/IHRoaXMuY2VudGVyW2FdIDogdGhpcy5tYXhbYV07XG4gICAgICByZXR1cm4gclsyXSA9IHRoaXMubWF4WzJdLCBuZXcgYm8obywgcik7XG4gICAgfSwgYm8ucHJvdG90eXBlLmRpc3RhbmNlWCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5tYXhbMF0sIHRbMF0pLCB0aGlzLm1pblswXSkgLSB0WzBdO1xuICAgIH0sIGJvLnByb3RvdHlwZS5kaXN0YW5jZVkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHRoaXMubWF4WzFdLCB0WzFdKSwgdGhpcy5taW5bMV0pIC0gdFsxXTtcbiAgICB9LCBiby5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBmb3IgKHZhciBpID0gW1t0aGlzLm1pblswXSwgdGhpcy5taW5bMV0sIDAsIDFdLCBbdGhpcy5tYXhbMF0sIHRoaXMubWluWzFdLCAwLCAxXSwgW3RoaXMubWF4WzBdLCB0aGlzLm1heFsxXSwgMCwgMV0sIFt0aGlzLm1pblswXSwgdGhpcy5tYXhbMV0sIDAsIDFdXSwgbyA9ICEwLCByID0gMDsgciA8IGUucGxhbmVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBlLnBsYW5lc1tyXSwgbiA9IDAsIHMgPSAwOyBzIDwgaS5sZW5ndGg7IHMrKykgbiArPSB0LmRvdCQxKGEsIGlbc10pID49IDA7XG4gICAgICAgIGlmICgwID09PSBuKSByZXR1cm4gMDtcbiAgICAgICAgbiAhPT0gaS5sZW5ndGggJiYgKG8gPSAhMSk7XG4gICAgICB9XG4gICAgICBpZiAobykgcmV0dXJuIDI7XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IDM7IGwrKykge1xuICAgICAgICBmb3IgKHZhciBjID0gTnVtYmVyLk1BWF9WQUxVRSwgdSA9IC1OdW1iZXIuTUFYX1ZBTFVFLCBoID0gMDsgaCA8IGUucG9pbnRzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgdmFyIHAgPSBlLnBvaW50c1toXVtsXSAtIHRoaXMubWluW2xdO1xuICAgICAgICAgIGMgPSBNYXRoLm1pbihjLCBwKSwgdSA9IE1hdGgubWF4KHUsIHApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1IDwgMCB8fCBjID4gdGhpcy5tYXhbbF0gLSB0aGlzLm1pbltsXSkgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIHZhciB3byA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICBpZiAodm9pZCAwID09PSB0ICYmICh0ID0gMCksIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLCB2b2lkIDAgPT09IGkgJiYgKGkgPSAwKSwgdm9pZCAwID09PSBvICYmIChvID0gMCksIGlzTmFOKHQpIHx8IHQgPCAwIHx8IGlzTmFOKGUpIHx8IGUgPCAwIHx8IGlzTmFOKGkpIHx8IGkgPCAwIHx8IGlzTmFOKG8pIHx8IG8gPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBlZGdlLWluc2V0cywgdG9wLCBib3R0b20sIGxlZnQgYW5kIHJpZ2h0IG11c3QgYWxsIGJlIG51bWJlcnNcIik7XG4gICAgICB0aGlzLnRvcCA9IHQsIHRoaXMuYm90dG9tID0gZSwgdGhpcy5sZWZ0ID0gaSwgdGhpcy5yaWdodCA9IG87XG4gICAgfTtcbiAgICB3by5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgcmV0dXJuIG51bGwgIT0gaS50b3AgJiYgbnVsbCAhPSBlLnRvcCAmJiAodGhpcy50b3AgPSB0Lm51bWJlcihlLnRvcCwgaS50b3AsIG8pKSwgbnVsbCAhPSBpLmJvdHRvbSAmJiBudWxsICE9IGUuYm90dG9tICYmICh0aGlzLmJvdHRvbSA9IHQubnVtYmVyKGUuYm90dG9tLCBpLmJvdHRvbSwgbykpLCBudWxsICE9IGkubGVmdCAmJiBudWxsICE9IGUubGVmdCAmJiAodGhpcy5sZWZ0ID0gdC5udW1iZXIoZS5sZWZ0LCBpLmxlZnQsIG8pKSwgbnVsbCAhPSBpLnJpZ2h0ICYmIG51bGwgIT0gZS5yaWdodCAmJiAodGhpcy5yaWdodCA9IHQubnVtYmVyKGUucmlnaHQsIGkucmlnaHQsIG8pKSwgdGhpcztcbiAgICB9LCB3by5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZhciBvID0gdC5jbGFtcCgodGhpcy5sZWZ0ICsgZSAtIHRoaXMucmlnaHQpIC8gMiwgMCwgZSksXG4gICAgICAgIHIgPSB0LmNsYW1wKCh0aGlzLnRvcCArIGkgLSB0aGlzLmJvdHRvbSkgLyAyLCAwLCBpKTtcbiAgICAgIHJldHVybiBuZXcgdC5Qb2ludChvLCByKTtcbiAgICB9LCB3by5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvcCA9PT0gdC50b3AgJiYgdGhpcy5ib3R0b20gPT09IHQuYm90dG9tICYmIHRoaXMubGVmdCA9PT0gdC5sZWZ0ICYmIHRoaXMucmlnaHQgPT09IHQucmlnaHQ7XG4gICAgfSwgd28ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyB3byh0aGlzLnRvcCwgdGhpcy5ib3R0b20sIHRoaXMubGVmdCwgdGhpcy5yaWdodCk7XG4gICAgfSwgd28ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy50b3AsXG4gICAgICAgIGJvdHRvbTogdGhpcy5ib3R0b20sXG4gICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgcmlnaHQ6IHRoaXMucmlnaHRcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgVG8gPSBmdW5jdGlvbiAoZSwgaSwgbywgciwgYSkge1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gNTEyLCB0aGlzLm1heFZhbGlkTGF0aXR1ZGUgPSA4NS4wNTExMjksIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzID0gdm9pZCAwID09PSBhIHx8IGEsIHRoaXMuX21pblpvb20gPSBlIHx8IDAsIHRoaXMuX21heFpvb20gPSBpIHx8IDIyLCB0aGlzLl9taW5QaXRjaCA9IG51bGwgPT0gbyA/IDAgOiBvLCB0aGlzLl9tYXhQaXRjaCA9IG51bGwgPT0gciA/IDYwIDogciwgdGhpcy5zZXRNYXhCb3VuZHMoKSwgdGhpcy53aWR0aCA9IDAsIHRoaXMuaGVpZ2h0ID0gMCwgdGhpcy5fY2VudGVyID0gbmV3IHQuTG5nTGF0KDAsIDApLCB0aGlzLnpvb20gPSAwLCB0aGlzLmFuZ2xlID0gMCwgdGhpcy5fZm92ID0gLjY0MzUwMTEwODc5MzI4NDQsIHRoaXMuX3BpdGNoID0gMCwgdGhpcy5fdW5tb2RpZmllZCA9ICEwLCB0aGlzLl9lZGdlSW5zZXRzID0gbmV3IHdvKCksIHRoaXMuX3Bvc01hdHJpeENhY2hlID0ge30sIHRoaXMuX2FsaWduZWRQb3NNYXRyaXhDYWNoZSA9IHt9O1xuICAgICAgfSxcbiAgICAgIEVvID0ge1xuICAgICAgICBtaW5ab29tOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBtYXhab29tOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBtaW5QaXRjaDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgbWF4UGl0Y2g6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcldvcmxkQ29waWVzOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICB3b3JsZFNpemU6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGNlbnRlck9mZnNldDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgYmVhcmluZzoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcGl0Y2g6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGZvdjoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgem9vbToge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9LFxuICAgICAgICBjZW50ZXJQb2ludDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgdW5tb2RpZmllZDoge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgVG8ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHQgPSBuZXcgVG8odGhpcy5fbWluWm9vbSwgdGhpcy5fbWF4Wm9vbSwgdGhpcy5fbWluUGl0Y2gsIHRoaXMubWF4UGl0Y2gsIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzKTtcbiAgICAgIHJldHVybiB0LnRpbGVTaXplID0gdGhpcy50aWxlU2l6ZSwgdC5sYXRSYW5nZSA9IHRoaXMubGF0UmFuZ2UsIHQud2lkdGggPSB0aGlzLndpZHRoLCB0LmhlaWdodCA9IHRoaXMuaGVpZ2h0LCB0Ll9jZW50ZXIgPSB0aGlzLl9jZW50ZXIsIHQuem9vbSA9IHRoaXMuem9vbSwgdC5hbmdsZSA9IHRoaXMuYW5nbGUsIHQuX2ZvdiA9IHRoaXMuX2ZvdiwgdC5fcGl0Y2ggPSB0aGlzLl9waXRjaCwgdC5fdW5tb2RpZmllZCA9IHRoaXMuX3VubW9kaWZpZWQsIHQuX2VkZ2VJbnNldHMgPSB0aGlzLl9lZGdlSW5zZXRzLmNsb25lKCksIHQuX2NhbGNNYXRyaWNlcygpLCB0O1xuICAgIH0sIEVvLm1pblpvb20uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pblpvb207XG4gICAgfSwgRW8ubWluWm9vbS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWluWm9vbSAhPT0gdCAmJiAodGhpcy5fbWluWm9vbSA9IHQsIHRoaXMuem9vbSA9IE1hdGgubWF4KHRoaXMuem9vbSwgdCkpO1xuICAgIH0sIEVvLm1heFpvb20uZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21heFpvb207XG4gICAgfSwgRW8ubWF4Wm9vbS5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWF4Wm9vbSAhPT0gdCAmJiAodGhpcy5fbWF4Wm9vbSA9IHQsIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgdCkpO1xuICAgIH0sIEVvLm1pblBpdGNoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5QaXRjaDtcbiAgICB9LCBFby5taW5QaXRjaC5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWluUGl0Y2ggIT09IHQgJiYgKHRoaXMuX21pblBpdGNoID0gdCwgdGhpcy5waXRjaCA9IE1hdGgubWF4KHRoaXMucGl0Y2gsIHQpKTtcbiAgICB9LCBFby5tYXhQaXRjaC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4UGl0Y2g7XG4gICAgfSwgRW8ubWF4UGl0Y2guc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21heFBpdGNoICE9PSB0ICYmICh0aGlzLl9tYXhQaXRjaCA9IHQsIHRoaXMucGl0Y2ggPSBNYXRoLm1pbih0aGlzLnBpdGNoLCB0KSk7XG4gICAgfSwgRW8ucmVuZGVyV29ybGRDb3BpZXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcldvcmxkQ29waWVzO1xuICAgIH0sIEVvLnJlbmRlcldvcmxkQ29waWVzLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2b2lkIDAgPT09IHQgPyB0ID0gITAgOiBudWxsID09PSB0ICYmICh0ID0gITEpLCB0aGlzLl9yZW5kZXJXb3JsZENvcGllcyA9IHQ7XG4gICAgfSwgRW8ud29ybGRTaXplLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplICogdGhpcy5zY2FsZTtcbiAgICB9LCBFby5jZW50ZXJPZmZzZXQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2VudGVyUG9pbnQuX3N1Yih0aGlzLnNpemUuX2RpdigyKSk7XG4gICAgfSwgRW8uc2l6ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IHQuUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sIEVvLmJlYXJpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LCBFby5iZWFyaW5nLnNldCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IC10LndyYXAoZSwgLTE4MCwgMTgwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICB0aGlzLmFuZ2xlICE9PSBpICYmICh0aGlzLl91bm1vZGlmaWVkID0gITEsIHRoaXMuYW5nbGUgPSBpLCB0aGlzLl9jYWxjTWF0cmljZXMoKSwgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IHQuY3JlYXRlJDIoKSwgdC5yb3RhdGUodGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5hbmdsZSkpO1xuICAgIH0sIEVvLnBpdGNoLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9waXRjaCAvIE1hdGguUEkgKiAxODA7XG4gICAgfSwgRW8ucGl0Y2guc2V0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpID0gdC5jbGFtcChlLCB0aGlzLm1pblBpdGNoLCB0aGlzLm1heFBpdGNoKSAvIDE4MCAqIE1hdGguUEk7XG4gICAgICB0aGlzLl9waXRjaCAhPT0gaSAmJiAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9waXRjaCA9IGksIHRoaXMuX2NhbGNNYXRyaWNlcygpKTtcbiAgICB9LCBFby5mb3YuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvdiAvIE1hdGguUEkgKiAxODA7XG4gICAgfSwgRW8uZm92LnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0ID0gTWF0aC5tYXgoLjAxLCBNYXRoLm1pbig2MCwgdCkpLCB0aGlzLl9mb3YgIT09IHQgJiYgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fZm92ID0gdCAvIDE4MCAqIE1hdGguUEksIHRoaXMuX2NhbGNNYXRyaWNlcygpKTtcbiAgICB9LCBFby56b29tLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl96b29tO1xuICAgIH0sIEVvLnpvb20uc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gTWF0aC5taW4oTWF0aC5tYXgodCwgdGhpcy5taW5ab29tKSwgdGhpcy5tYXhab29tKTtcbiAgICAgIHRoaXMuX3pvb20gIT09IGUgJiYgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fem9vbSA9IGUsIHRoaXMuc2NhbGUgPSB0aGlzLnpvb21TY2FsZShlKSwgdGhpcy50aWxlWm9vbSA9IE1hdGguZmxvb3IoZSksIHRoaXMuem9vbUZyYWN0aW9uID0gZSAtIHRoaXMudGlsZVpvb20sIHRoaXMuX2NvbnN0cmFpbigpLCB0aGlzLl9jYWxjTWF0cmljZXMoKSk7XG4gICAgfSwgRW8uY2VudGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXI7XG4gICAgfSwgRW8uY2VudGVyLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LmxhdCA9PT0gdGhpcy5fY2VudGVyLmxhdCAmJiB0LmxuZyA9PT0gdGhpcy5fY2VudGVyLmxuZyB8fCAodGhpcy5fdW5tb2RpZmllZCA9ICExLCB0aGlzLl9jZW50ZXIgPSB0LCB0aGlzLl9jb25zdHJhaW4oKSwgdGhpcy5fY2FsY01hdHJpY2VzKCkpO1xuICAgIH0sIEVvLnBhZGRpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VkZ2VJbnNldHMudG9KU09OKCk7XG4gICAgfSwgRW8ucGFkZGluZy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZWRnZUluc2V0cy5lcXVhbHModCkgfHwgKHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fZWRnZUluc2V0cy5pbnRlcnBvbGF0ZSh0aGlzLl9lZGdlSW5zZXRzLCB0LCAxKSwgdGhpcy5fY2FsY01hdHJpY2VzKCkpO1xuICAgIH0sIEVvLmNlbnRlclBvaW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGdlSW5zZXRzLmdldENlbnRlcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmlzUGFkZGluZ0VxdWFsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGdlSW5zZXRzLmVxdWFscyh0KTtcbiAgICB9LCBUby5wcm90b3R5cGUuaW50ZXJwb2xhdGVQYWRkaW5nID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSAhMSwgdGhpcy5fZWRnZUluc2V0cy5pbnRlcnBvbGF0ZSh0LCBlLCBpKSwgdGhpcy5fY29uc3RyYWluKCksIHRoaXMuX2NhbGNNYXRyaWNlcygpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5jb3ZlcmluZ1pvb21MZXZlbCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9ICh0LnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKSh0aGlzLnpvb20gKyB0aGlzLnNjYWxlWm9vbSh0aGlzLnRpbGVTaXplIC8gdC50aWxlU2l6ZSkpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGUpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5nZXRWaXNpYmxlVW53cmFwcGVkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSBbbmV3IHQuVW53cmFwcGVkVGlsZUlEKDAsIGUpXTtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJXb3JsZENvcGllcykgZm9yICh2YXIgbyA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KDAsIDApKSwgciA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KHRoaXMud2lkdGgsIDApKSwgYSA9IHRoaXMucG9pbnRDb29yZGluYXRlKG5ldyB0LlBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSksIG4gPSB0aGlzLnBvaW50Q29vcmRpbmF0ZShuZXcgdC5Qb2ludCgwLCB0aGlzLmhlaWdodCkpLCBzID0gTWF0aC5mbG9vcihNYXRoLm1pbihvLngsIHIueCwgYS54LCBuLngpKSwgbCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoby54LCByLngsIGEueCwgbi54KSksIGMgPSBzIC0gMTsgYyA8PSBsICsgMTsgYysrKSAwICE9PSBjICYmIGkucHVzaChuZXcgdC5VbndyYXBwZWRUaWxlSUQoYywgZSkpO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmNvdmVyaW5nVGlsZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLmNvdmVyaW5nWm9vbUxldmVsKGUpLFxuICAgICAgICBvID0gaTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGUubWluem9vbSAmJiBpIDwgZS5taW56b29tKSByZXR1cm4gW107XG4gICAgICB2b2lkIDAgIT09IGUubWF4em9vbSAmJiBpID4gZS5tYXh6b29tICYmIChpID0gZS5tYXh6b29tKTtcbiAgICAgIHZhciByID0gdC5NZXJjYXRvckNvb3JkaW5hdGUuZnJvbUxuZ0xhdCh0aGlzLmNlbnRlciksXG4gICAgICAgIGEgPSBNYXRoLnBvdygyLCBpKSxcbiAgICAgICAgbiA9IFthICogci54LCBhICogci55LCAwXSxcbiAgICAgICAgcyA9IHhvLmZyb21JbnZQcm9qZWN0aW9uTWF0cml4KHRoaXMuaW52UHJvak1hdHJpeCwgdGhpcy53b3JsZFNpemUsIGkpLFxuICAgICAgICBsID0gZS5taW56b29tIHx8IDA7XG4gICAgICB0aGlzLnBpdGNoIDw9IDYwICYmIHRoaXMuX2VkZ2VJbnNldHMudG9wIDwgLjEgJiYgKGwgPSBpKTtcbiAgICAgIHZhciBjID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWFiYjogbmV3IGJvKFt0ICogYSwgMCwgMF0sIFsodCArIDEpICogYSwgYSwgMF0pLFxuICAgICAgICAgICAgem9vbTogMCxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd3JhcDogdCxcbiAgICAgICAgICAgIGZ1bGx5VmlzaWJsZTogITFcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB1ID0gW10sXG4gICAgICAgIGggPSBbXSxcbiAgICAgICAgcCA9IGksXG4gICAgICAgIGQgPSBlLnJlcGFyc2VPdmVyc2NhbGVkID8gbyA6IGk7XG4gICAgICBpZiAodGhpcy5fcmVuZGVyV29ybGRDb3BpZXMpIGZvciAodmFyIF8gPSAxOyBfIDw9IDM7IF8rKykgdS5wdXNoKGMoLV8pKSwgdS5wdXNoKGMoXykpO1xuICAgICAgZm9yICh1LnB1c2goYygwKSk7IHUubGVuZ3RoID4gMDspIHtcbiAgICAgICAgdmFyIGYgPSB1LnBvcCgpLFxuICAgICAgICAgIG0gPSBmLngsXG4gICAgICAgICAgZyA9IGYueSxcbiAgICAgICAgICB2ID0gZi5mdWxseVZpc2libGU7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgIHZhciB5ID0gZi5hYWJiLmludGVyc2VjdHMocyk7XG4gICAgICAgICAgaWYgKDAgPT09IHkpIGNvbnRpbnVlO1xuICAgICAgICAgIHYgPSAyID09PSB5O1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gZi5hYWJiLmRpc3RhbmNlWChuKSxcbiAgICAgICAgICBiID0gZi5hYWJiLmRpc3RhbmNlWShuKSxcbiAgICAgICAgICB3ID0gTWF0aC5tYXgoTWF0aC5hYnMoeCksIE1hdGguYWJzKGIpKTtcbiAgICAgICAgaWYgKGYuem9vbSA9PT0gcCB8fCB3ID4gMyArICgxIDw8IHAgLSBmLnpvb20pIC0gMiAmJiBmLnpvb20gPj0gbCkgaC5wdXNoKHtcbiAgICAgICAgICB0aWxlSUQ6IG5ldyB0Lk92ZXJzY2FsZWRUaWxlSUQoZi56b29tID09PSBwID8gZCA6IGYuem9vbSwgZi53cmFwLCBmLnpvb20sIG0sIGcpLFxuICAgICAgICAgIGRpc3RhbmNlU3E6IHQuc3FyTGVuKFtuWzBdIC0gLjUgLSBtLCBuWzFdIC0gLjUgLSBnXSlcbiAgICAgICAgfSk7ZWxzZSBmb3IgKHZhciBUID0gMDsgVCA8IDQ7IFQrKykge1xuICAgICAgICAgIHZhciBFID0gKG0gPDwgMSkgKyBUICUgMixcbiAgICAgICAgICAgIEkgPSAoZyA8PCAxKSArIChUID4+IDEpO1xuICAgICAgICAgIHUucHVzaCh7XG4gICAgICAgICAgICBhYWJiOiBmLmFhYmIucXVhZHJhbnQoVCksXG4gICAgICAgICAgICB6b29tOiBmLnpvb20gKyAxLFxuICAgICAgICAgICAgeDogRSxcbiAgICAgICAgICAgIHk6IEksXG4gICAgICAgICAgICB3cmFwOiBmLndyYXAsXG4gICAgICAgICAgICBmdWxseVZpc2libGU6IHZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGguc29ydChmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICByZXR1cm4gdC5kaXN0YW5jZVNxIC0gZS5kaXN0YW5jZVNxO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnRpbGVJRDtcbiAgICAgIH0pO1xuICAgIH0sIFRvLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy53aWR0aCA9IHQsIHRoaXMuaGVpZ2h0ID0gZSwgdGhpcy5waXhlbHNUb0dMVW5pdHMgPSBbMiAvIHQsIC0yIC8gZV0sIHRoaXMuX2NvbnN0cmFpbigpLCB0aGlzLl9jYWxjTWF0cmljZXMoKTtcbiAgICB9LCBFby51bm1vZGlmaWVkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91bm1vZGlmaWVkO1xuICAgIH0sIFRvLnByb3RvdHlwZS56b29tU2NhbGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIHQpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5zY2FsZVpvb20gPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKHQpIC8gTWF0aC5MTjI7XG4gICAgfSwgVG8ucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0LmNsYW1wKGUubGF0LCAtdGhpcy5tYXhWYWxpZExhdGl0dWRlLCB0aGlzLm1heFZhbGlkTGF0aXR1ZGUpO1xuICAgICAgcmV0dXJuIG5ldyB0LlBvaW50KHQubWVyY2F0b3JYZnJvbUxuZyhlLmxuZykgKiB0aGlzLndvcmxkU2l6ZSwgdC5tZXJjYXRvcllmcm9tTGF0KGkpICogdGhpcy53b3JsZFNpemUpO1xuICAgIH0sIFRvLnByb3RvdHlwZS51bnByb2plY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIG5ldyB0Lk1lcmNhdG9yQ29vcmRpbmF0ZShlLnggLyB0aGlzLndvcmxkU2l6ZSwgZS55IC8gdGhpcy53b3JsZFNpemUpLnRvTG5nTGF0KCk7XG4gICAgfSwgRW8ucG9pbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvamVjdCh0aGlzLmNlbnRlcik7XG4gICAgfSwgVG8ucHJvdG90eXBlLnNldExvY2F0aW9uQXRQb2ludCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMucG9pbnRDb29yZGluYXRlKGkpLFxuICAgICAgICByID0gdGhpcy5wb2ludENvb3JkaW5hdGUodGhpcy5jZW50ZXJQb2ludCksXG4gICAgICAgIGEgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShlKSxcbiAgICAgICAgbiA9IG5ldyB0Lk1lcmNhdG9yQ29vcmRpbmF0ZShhLnggLSAoby54IC0gci54KSwgYS55IC0gKG8ueSAtIHIueSkpO1xuICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLmNvb3JkaW5hdGVMb2NhdGlvbihuKSwgdGhpcy5fcmVuZGVyV29ybGRDb3BpZXMgJiYgKHRoaXMuY2VudGVyID0gdGhpcy5jZW50ZXIud3JhcCgpKTtcbiAgICB9LCBUby5wcm90b3R5cGUubG9jYXRpb25Qb2ludCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlUG9pbnQodGhpcy5sb2NhdGlvbkNvb3JkaW5hdGUodCkpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5wb2ludExvY2F0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVMb2NhdGlvbih0aGlzLnBvaW50Q29vcmRpbmF0ZSh0KSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmxvY2F0aW9uQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gdC5NZXJjYXRvckNvb3JkaW5hdGUuZnJvbUxuZ0xhdChlKTtcbiAgICB9LCBUby5wcm90b3R5cGUuY29vcmRpbmF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LnRvTG5nTGF0KCk7XG4gICAgfSwgVG8ucHJvdG90eXBlLnBvaW50Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IFtlLngsIGUueSwgMCwgMV0sXG4gICAgICAgIG8gPSBbZS54LCBlLnksIDEsIDFdO1xuICAgICAgdC50cmFuc2Zvcm1NYXQ0KGksIGksIHRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlKSwgdC50cmFuc2Zvcm1NYXQ0KG8sIG8sIHRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlKTtcbiAgICAgIHZhciByID0gaVszXSxcbiAgICAgICAgYSA9IG9bM10sXG4gICAgICAgIG4gPSBpWzFdIC8gcixcbiAgICAgICAgcyA9IG9bMV0gLyBhLFxuICAgICAgICBsID0gaVsyXSAvIHIsXG4gICAgICAgIGMgPSBvWzJdIC8gYSxcbiAgICAgICAgdSA9IGwgPT09IGMgPyAwIDogKDAgLSBsKSAvIChjIC0gbCk7XG4gICAgICByZXR1cm4gbmV3IHQuTWVyY2F0b3JDb29yZGluYXRlKHQubnVtYmVyKGlbMF0gLyByLCBvWzBdIC8gYSwgdSkgLyB0aGlzLndvcmxkU2l6ZSwgdC5udW1iZXIobiwgcywgdSkgLyB0aGlzLndvcmxkU2l6ZSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmNvb3JkaW5hdGVQb2ludCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaSA9IFtlLnggKiB0aGlzLndvcmxkU2l6ZSwgZS55ICogdGhpcy53b3JsZFNpemUsIDAsIDFdO1xuICAgICAgcmV0dXJuIHQudHJhbnNmb3JtTWF0NChpLCBpLCB0aGlzLnBpeGVsTWF0cml4KSwgbmV3IHQuUG9pbnQoaVswXSAvIGlbM10sIGlbMV0gLyBpWzNdKTtcbiAgICB9LCBUby5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyB0LkxuZ0xhdEJvdW5kcygpLmV4dGVuZCh0aGlzLnBvaW50TG9jYXRpb24obmV3IHQuUG9pbnQoMCwgMCkpKS5leHRlbmQodGhpcy5wb2ludExvY2F0aW9uKG5ldyB0LlBvaW50KHRoaXMud2lkdGgsIDApKSkuZXh0ZW5kKHRoaXMucG9pbnRMb2NhdGlvbihuZXcgdC5Qb2ludCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpKS5leHRlbmQodGhpcy5wb2ludExvY2F0aW9uKG5ldyB0LlBvaW50KDAsIHRoaXMuaGVpZ2h0KSkpO1xuICAgIH0sIFRvLnByb3RvdHlwZS5nZXRNYXhCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXRSYW5nZSAmJiAyID09PSB0aGlzLmxhdFJhbmdlLmxlbmd0aCAmJiB0aGlzLmxuZ1JhbmdlICYmIDIgPT09IHRoaXMubG5nUmFuZ2UubGVuZ3RoID8gbmV3IHQuTG5nTGF0Qm91bmRzKFt0aGlzLmxuZ1JhbmdlWzBdLCB0aGlzLmxhdFJhbmdlWzBdXSwgW3RoaXMubG5nUmFuZ2VbMV0sIHRoaXMubGF0UmFuZ2VbMV1dKSA6IG51bGw7XG4gICAgfSwgVG8ucHJvdG90eXBlLnNldE1heEJvdW5kcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0ID8gKHRoaXMubG5nUmFuZ2UgPSBbdC5nZXRXZXN0KCksIHQuZ2V0RWFzdCgpXSwgdGhpcy5sYXRSYW5nZSA9IFt0LmdldFNvdXRoKCksIHQuZ2V0Tm9ydGgoKV0sIHRoaXMuX2NvbnN0cmFpbigpKSA6ICh0aGlzLmxuZ1JhbmdlID0gbnVsbCwgdGhpcy5sYXRSYW5nZSA9IFstdGhpcy5tYXhWYWxpZExhdGl0dWRlLCB0aGlzLm1heFZhbGlkTGF0aXR1ZGVdKTtcbiAgICB9LCBUby5wcm90b3R5cGUuY2FsY3VsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9ICExKTtcbiAgICAgIHZhciBvID0gZS5rZXksXG4gICAgICAgIHIgPSBpID8gdGhpcy5fYWxpZ25lZFBvc01hdHJpeENhY2hlIDogdGhpcy5fcG9zTWF0cml4Q2FjaGU7XG4gICAgICBpZiAocltvXSkgcmV0dXJuIHJbb107XG4gICAgICB2YXIgYSA9IGUuY2Fub25pY2FsLFxuICAgICAgICBuID0gdGhpcy53b3JsZFNpemUgLyB0aGlzLnpvb21TY2FsZShhLnopLFxuICAgICAgICBzID0gYS54ICsgTWF0aC5wb3coMiwgYS56KSAqIGUud3JhcCxcbiAgICAgICAgbCA9IHQuaWRlbnRpdHkobmV3IEZsb2F0NjRBcnJheSgxNikpO1xuICAgICAgcmV0dXJuIHQudHJhbnNsYXRlKGwsIGwsIFtzICogbiwgYS55ICogbiwgMF0pLCB0LnNjYWxlKGwsIGwsIFtuIC8gdC5FWFRFTlQsIG4gLyB0LkVYVEVOVCwgMV0pLCB0Lm11bHRpcGx5KGwsIGkgPyB0aGlzLmFsaWduZWRQcm9qTWF0cml4IDogdGhpcy5wcm9qTWF0cml4LCBsKSwgcltvXSA9IG5ldyBGbG9hdDMyQXJyYXkobCksIHJbb107XG4gICAgfSwgVG8ucHJvdG90eXBlLmN1c3RvbUxheWVyTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVyY2F0b3JNYXRyaXguc2xpY2UoKTtcbiAgICB9LCBUby5wcm90b3R5cGUuX2NvbnN0cmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLmNlbnRlciAmJiB0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0ICYmICF0aGlzLl9jb25zdHJhaW5pbmcpIHtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gITA7XG4gICAgICAgIHZhciBlLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbyxcbiAgICAgICAgICByLFxuICAgICAgICAgIGEgPSAtOTAsXG4gICAgICAgICAgbiA9IDkwLFxuICAgICAgICAgIHMgPSAtMTgwLFxuICAgICAgICAgIGwgPSAxODAsXG4gICAgICAgICAgYyA9IHRoaXMuc2l6ZSxcbiAgICAgICAgICB1ID0gdGhpcy5fdW5tb2RpZmllZDtcbiAgICAgICAgaWYgKHRoaXMubGF0UmFuZ2UpIHtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMubGF0UmFuZ2U7XG4gICAgICAgICAgYSA9IHQubWVyY2F0b3JZZnJvbUxhdChoWzFdKSAqIHRoaXMud29ybGRTaXplLCBlID0gKG4gPSB0Lm1lcmNhdG9yWWZyb21MYXQoaFswXSkgKiB0aGlzLndvcmxkU2l6ZSkgLSBhIDwgYy55ID8gYy55IC8gKG4gLSBhKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG5nUmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcCA9IHRoaXMubG5nUmFuZ2U7XG4gICAgICAgICAgcyA9IHQubWVyY2F0b3JYZnJvbUxuZyhwWzBdKSAqIHRoaXMud29ybGRTaXplLCBpID0gKGwgPSB0Lm1lcmNhdG9yWGZyb21MbmcocFsxXSkgKiB0aGlzLndvcmxkU2l6ZSkgLSBzIDwgYy54ID8gYy54IC8gKGwgLSBzKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSB0aGlzLnBvaW50LFxuICAgICAgICAgIF8gPSBNYXRoLm1heChpIHx8IDAsIGUgfHwgMCk7XG4gICAgICAgIGlmIChfKSByZXR1cm4gdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgdC5Qb2ludChpID8gKGwgKyBzKSAvIDIgOiBkLngsIGUgPyAobiArIGEpIC8gMiA6IGQueSkpLCB0aGlzLnpvb20gKz0gdGhpcy5zY2FsZVpvb20oXyksIHRoaXMuX3VubW9kaWZpZWQgPSB1LCB2b2lkICh0aGlzLl9jb25zdHJhaW5pbmcgPSAhMSk7XG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgdmFyIGYgPSBkLnksXG4gICAgICAgICAgICBtID0gYy55IC8gMjtcbiAgICAgICAgICBmIC0gbSA8IGEgJiYgKHIgPSBhICsgbSksIGYgKyBtID4gbiAmJiAociA9IG4gLSBtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgIHZhciBnID0gZC54LFxuICAgICAgICAgICAgdiA9IGMueCAvIDI7XG4gICAgICAgICAgZyAtIHYgPCBzICYmIChvID0gcyArIHYpLCBnICsgdiA+IGwgJiYgKG8gPSBsIC0gdik7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCAwID09PSBvICYmIHZvaWQgMCA9PT0gciB8fCAodGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgdC5Qb2ludCh2b2lkIDAgIT09IG8gPyBvIDogZC54LCB2b2lkIDAgIT09IHIgPyByIDogZC55KSkpLCB0aGlzLl91bm1vZGlmaWVkID0gdSwgdGhpcy5fY29uc3RyYWluaW5nID0gITE7XG4gICAgICB9XG4gICAgfSwgVG8ucHJvdG90eXBlLl9jYWxjTWF0cmljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5oZWlnaHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNlbnRlck9mZnNldDtcbiAgICAgICAgdGhpcy5jYW1lcmFUb0NlbnRlckRpc3RhbmNlID0gLjUgLyBNYXRoLnRhbih0aGlzLl9mb3YgLyAyKSAqIHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgaSA9IE1hdGguUEkgLyAyICsgdGhpcy5fcGl0Y2gsXG4gICAgICAgICAgbyA9IHRoaXMuX2ZvdiAqICguNSArIGUueSAvIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICByID0gTWF0aC5zaW4obykgKiB0aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2UgLyBNYXRoLnNpbih0LmNsYW1wKE1hdGguUEkgLSBpIC0gbywgLjAxLCBNYXRoLlBJIC0gLjAxKSksXG4gICAgICAgICAgYSA9IHRoaXMucG9pbnQsXG4gICAgICAgICAgbiA9IGEueCxcbiAgICAgICAgICBzID0gYS55LFxuICAgICAgICAgIGwgPSAxLjAxICogKE1hdGguY29zKE1hdGguUEkgLyAyIC0gdGhpcy5fcGl0Y2gpICogciArIHRoaXMuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSksXG4gICAgICAgICAgYyA9IHRoaXMuaGVpZ2h0IC8gNTAsXG4gICAgICAgICAgdSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0LnBlcnNwZWN0aXZlKHUsIHRoaXMuX2ZvdiwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCBjLCBsKSwgdVs4XSA9IDIgKiAtZS54IC8gdGhpcy53aWR0aCwgdVs5XSA9IDIgKiBlLnkgLyB0aGlzLmhlaWdodCwgdC5zY2FsZSh1LCB1LCBbMSwgLTEsIDFdKSwgdC50cmFuc2xhdGUodSwgdSwgWzAsIDAsIC10aGlzLmNhbWVyYVRvQ2VudGVyRGlzdGFuY2VdKSwgdC5yb3RhdGVYKHUsIHUsIHRoaXMuX3BpdGNoKSwgdC5yb3RhdGVaKHUsIHUsIHRoaXMuYW5nbGUpLCB0LnRyYW5zbGF0ZSh1LCB1LCBbLW4sIC1zLCAwXSksIHRoaXMubWVyY2F0b3JNYXRyaXggPSB0LnNjYWxlKFtdLCB1LCBbdGhpcy53b3JsZFNpemUsIHRoaXMud29ybGRTaXplLCB0aGlzLndvcmxkU2l6ZV0pLCB0LnNjYWxlKHUsIHUsIFsxLCAxLCB0Lm1lcmNhdG9yWmZyb21BbHRpdHVkZSgxLCB0aGlzLmNlbnRlci5sYXQpICogdGhpcy53b3JsZFNpemUsIDFdKSwgdGhpcy5wcm9qTWF0cml4ID0gdSwgdGhpcy5pbnZQcm9qTWF0cml4ID0gdC5pbnZlcnQoW10sIHRoaXMucHJvak1hdHJpeCk7XG4gICAgICAgIHZhciBoID0gdGhpcy53aWR0aCAlIDIgLyAyLFxuICAgICAgICAgIHAgPSB0aGlzLmhlaWdodCAlIDIgLyAyLFxuICAgICAgICAgIGQgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgICBfID0gTWF0aC5zaW4odGhpcy5hbmdsZSksXG4gICAgICAgICAgZiA9IG4gLSBNYXRoLnJvdW5kKG4pICsgZCAqIGggKyBfICogcCxcbiAgICAgICAgICBtID0gcyAtIE1hdGgucm91bmQocykgKyBkICogcCArIF8gKiBoLFxuICAgICAgICAgIGcgPSBuZXcgRmxvYXQ2NEFycmF5KHUpO1xuICAgICAgICBpZiAodC50cmFuc2xhdGUoZywgZywgW2YgPiAuNSA/IGYgLSAxIDogZiwgbSA+IC41ID8gbSAtIDEgOiBtLCAwXSksIHRoaXMuYWxpZ25lZFByb2pNYXRyaXggPSBnLCB1ID0gdC5jcmVhdGUoKSwgdC5zY2FsZSh1LCB1LCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKSwgdC50cmFuc2xhdGUodSwgdSwgWzEsIC0xLCAwXSksIHRoaXMubGFiZWxQbGFuZU1hdHJpeCA9IHUsIHUgPSB0LmNyZWF0ZSgpLCB0LnNjYWxlKHUsIHUsIFsxLCAtMSwgMV0pLCB0LnRyYW5zbGF0ZSh1LCB1LCBbLTEsIC0xLCAwXSksIHQuc2NhbGUodSwgdSwgWzIgLyB0aGlzLndpZHRoLCAyIC8gdGhpcy5oZWlnaHQsIDFdKSwgdGhpcy5nbENvb3JkTWF0cml4ID0gdSwgdGhpcy5waXhlbE1hdHJpeCA9IHQubXVsdGlwbHkobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMubGFiZWxQbGFuZU1hdHJpeCwgdGhpcy5wcm9qTWF0cml4KSwgISh1ID0gdC5pbnZlcnQobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMucGl4ZWxNYXRyaXgpKSkgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGludmVydCBtYXRyaXhcIik7XG4gICAgICAgIHRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlID0gdSwgdGhpcy5fcG9zTWF0cml4Q2FjaGUgPSB7fSwgdGhpcy5fYWxpZ25lZFBvc01hdHJpeENhY2hlID0ge307XG4gICAgICB9XG4gICAgfSwgVG8ucHJvdG90eXBlLm1heFBpdGNoU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGl4ZWxNYXRyaXhJbnZlcnNlKSByZXR1cm4gMTtcbiAgICAgIHZhciBlID0gdGhpcy5wb2ludENvb3JkaW5hdGUobmV3IHQuUG9pbnQoMCwgMCkpLFxuICAgICAgICBpID0gW2UueCAqIHRoaXMud29ybGRTaXplLCBlLnkgKiB0aGlzLndvcmxkU2l6ZSwgMCwgMV07XG4gICAgICByZXR1cm4gdC50cmFuc2Zvcm1NYXQ0KGksIGksIHRoaXMucGl4ZWxNYXRyaXgpWzNdIC8gdGhpcy5jYW1lcmFUb0NlbnRlckRpc3RhbmNlO1xuICAgIH0sIFRvLnByb3RvdHlwZS5nZXRDYW1lcmFQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gTWF0aC50YW4odGhpcy5fcGl0Y2gpICogKHRoaXMuY2FtZXJhVG9DZW50ZXJEaXN0YW5jZSB8fCAxKTtcbiAgICAgIHJldHVybiB0aGlzLmNlbnRlclBvaW50LmFkZChuZXcgdC5Qb2ludCgwLCBlKSk7XG4gICAgfSwgVG8ucHJvdG90eXBlLmdldENhbWVyYVF1ZXJ5R2VvbWV0cnkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLmdldENhbWVyYVBvaW50KCk7XG4gICAgICBpZiAoMSA9PT0gZS5sZW5ndGgpIHJldHVybiBbZVswXSwgaV07XG4gICAgICBmb3IgKHZhciBvID0gaS54LCByID0gaS55LCBhID0gaS54LCBuID0gaS55LCBzID0gMCwgbCA9IGU7IHMgPCBsLmxlbmd0aDsgcyArPSAxKSB7XG4gICAgICAgIHZhciBjID0gbFtzXTtcbiAgICAgICAgbyA9IE1hdGgubWluKG8sIGMueCksIHIgPSBNYXRoLm1pbihyLCBjLnkpLCBhID0gTWF0aC5tYXgoYSwgYy54KSwgbiA9IE1hdGgubWF4KG4sIGMueSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25ldyB0LlBvaW50KG8sIHIpLCBuZXcgdC5Qb2ludChhLCByKSwgbmV3IHQuUG9pbnQoYSwgbiksIG5ldyB0LlBvaW50KG8sIG4pLCBuZXcgdC5Qb2ludChvLCByKV07XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVG8ucHJvdG90eXBlLCBFbyk7XG4gICAgdmFyIElvID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBpLCBvLCByLCBhO1xuICAgICAgdGhpcy5faGFzaE5hbWUgPSBlICYmIGVuY29kZVVSSUNvbXBvbmVudChlKSwgdC5iaW5kQWxsKFtcIl9nZXRDdXJyZW50SGFzaFwiLCBcIl9vbkhhc2hDaGFuZ2VcIiwgXCJfdXBkYXRlSGFzaFwiXSwgdGhpcyksIHRoaXMuX3VwZGF0ZUhhc2ggPSAoaSA9IHRoaXMuX3VwZGF0ZUhhc2hVbnRocm90dGxlZC5iaW5kKHRoaXMpLCBvID0gITEsIHIgPSBudWxsLCBhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByID0gbnVsbCwgbyAmJiAoaSgpLCByID0gc2V0VGltZW91dChhLCAzMDApLCBvID0gITEpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbyA9ICEwLCByIHx8IGEoKSwgcjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgSW8ucHJvdG90eXBlLmFkZFRvID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAgPSBlLCB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCB0aGlzLl9vbkhhc2hDaGFuZ2UsICExKSwgdGhpcy5fbWFwLm9uKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGVIYXNoKSwgdGhpcztcbiAgICB9LCBJby5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIHRoaXMuX29uSGFzaENoYW5nZSwgITEpLCB0aGlzLl9tYXAub2ZmKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGVIYXNoKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZUhhc2goKSksIGRlbGV0ZSB0aGlzLl9tYXAsIHRoaXM7XG4gICAgfSwgSW8ucHJvdG90eXBlLmdldEhhc2hTdHJpbmcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgIG8gPSBNYXRoLnJvdW5kKDEwMCAqIHRoaXMuX21hcC5nZXRab29tKCkpIC8gMTAwLFxuICAgICAgICByID0gTWF0aC5jZWlsKChvICogTWF0aC5MTjIgKyBNYXRoLmxvZyg1MTIgLyAzNjAgLyAuNSkpIC8gTWF0aC5MTjEwKSxcbiAgICAgICAgYSA9IE1hdGgucG93KDEwLCByKSxcbiAgICAgICAgbiA9IE1hdGgucm91bmQoaS5sbmcgKiBhKSAvIGEsXG4gICAgICAgIHMgPSBNYXRoLnJvdW5kKGkubGF0ICogYSkgLyBhLFxuICAgICAgICBsID0gdGhpcy5fbWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgYyA9IHRoaXMuX21hcC5nZXRQaXRjaCgpLFxuICAgICAgICB1ID0gXCJcIjtcbiAgICAgIGlmICh1ICs9IGUgPyBcIi9cIiArIG4gKyBcIi9cIiArIHMgKyBcIi9cIiArIG8gOiBvICsgXCIvXCIgKyBzICsgXCIvXCIgKyBuLCAobCB8fCBjKSAmJiAodSArPSBcIi9cIiArIE1hdGgucm91bmQoMTAgKiBsKSAvIDEwKSwgYyAmJiAodSArPSBcIi9cIiArIE1hdGgucm91bmQoYykpLCB0aGlzLl9oYXNoTmFtZSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuX2hhc2hOYW1lLFxuICAgICAgICAgIHAgPSAhMSxcbiAgICAgICAgICBkID0gdC53aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKS5zcGxpdChcIiZcIikubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHQuc3BsaXQoXCI9XCIpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGUgPT09IGggPyAocCA9ICEwLCBlICsgXCI9XCIgKyB1KSA6IHQ7XG4gICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHAgfHwgZC5wdXNoKGggKyBcIj1cIiArIHUpLCBcIiNcIiArIGQuam9pbihcIiZcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCIjXCIgKyB1O1xuICAgIH0sIElvLnByb3RvdHlwZS5fZ2V0Q3VycmVudEhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSxcbiAgICAgICAgaSA9IHRoaXMsXG4gICAgICAgIG8gPSB0LndpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc2hOYW1lID8gKG8uc3BsaXQoXCImXCIpLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5zcGxpdChcIj1cIik7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRbMF0gPT09IGkuX2hhc2hOYW1lICYmIChlID0gdCk7XG4gICAgICB9KSwgKGUgJiYgZVsxXSB8fCBcIlwiKS5zcGxpdChcIi9cIikpIDogby5zcGxpdChcIi9cIik7XG4gICAgfSwgSW8ucHJvdG90eXBlLl9vbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2dldEN1cnJlbnRIYXNoKCk7XG4gICAgICBpZiAodC5sZW5ndGggPj0gMyAmJiAhdC5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBpc05hTih0KTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5fbWFwLmRyYWdSb3RhdGUuaXNFbmFibGVkKCkgJiYgdGhpcy5fbWFwLnRvdWNoWm9vbVJvdGF0ZS5pc0VuYWJsZWQoKSA/ICsodFszXSB8fCAwKSA6IHRoaXMuX21hcC5nZXRCZWFyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuanVtcFRvKHtcbiAgICAgICAgICBjZW50ZXI6IFsrdFsyXSwgK3RbMV1dLFxuICAgICAgICAgIHpvb206ICt0WzBdLFxuICAgICAgICAgIGJlYXJpbmc6IGUsXG4gICAgICAgICAgcGl0Y2g6ICsodFs0XSB8fCAwKVxuICAgICAgICB9KSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgSW8ucHJvdG90eXBlLl91cGRhdGVIYXNoVW50aHJvdHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHQud2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvKCMuKyk/JC8sIHRoaXMuZ2V0SGFzaFN0cmluZygpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHQud2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHQud2luZG93Lmhpc3Rvcnkuc3RhdGUsIG51bGwsIGUpO1xuICAgICAgfSBjYXRjaCAodCkge31cbiAgICB9O1xuICAgIHZhciBQbyA9IHtcbiAgICAgICAgbGluZWFyaXR5OiAuMyxcbiAgICAgICAgZWFzaW5nOiB0LmJlemllcigwLCAwLCAuMywgMSlcbiAgICAgIH0sXG4gICAgICBTbyA9IHQuZXh0ZW5kKHtcbiAgICAgICAgZGVjZWxlcmF0aW9uOiAyNTAwLFxuICAgICAgICBtYXhTcGVlZDogMTQwMFxuICAgICAgfSwgUG8pLFxuICAgICAgQ28gPSB0LmV4dGVuZCh7XG4gICAgICAgIGRlY2VsZXJhdGlvbjogMjAsXG4gICAgICAgIG1heFNwZWVkOiAxNDAwXG4gICAgICB9LCBQbyksXG4gICAgICB6byA9IHQuZXh0ZW5kKHtcbiAgICAgICAgZGVjZWxlcmF0aW9uOiAxZTMsXG4gICAgICAgIG1heFNwZWVkOiAzNjBcbiAgICAgIH0sIFBvKSxcbiAgICAgIERvID0gdC5leHRlbmQoe1xuICAgICAgICBkZWNlbGVyYXRpb246IDFlMyxcbiAgICAgICAgbWF4U3BlZWQ6IDkwXG4gICAgICB9LCBQbyksXG4gICAgICBBbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX21hcCA9IHQsIHRoaXMuY2xlYXIoKTtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24gTW8odCwgZSkge1xuICAgICAgKCF0LmR1cmF0aW9uIHx8IHQuZHVyYXRpb24gPCBlLmR1cmF0aW9uKSAmJiAodC5kdXJhdGlvbiA9IGUuZHVyYXRpb24sIHQuZWFzaW5nID0gZS5lYXNpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMbyhlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IG8ubWF4U3BlZWQsXG4gICAgICAgIGEgPSBvLmxpbmVhcml0eSxcbiAgICAgICAgbiA9IG8uZGVjZWxlcmF0aW9uLFxuICAgICAgICBzID0gdC5jbGFtcChlICogYSAvIChpIC8gMWUzKSwgLXIsIHIpLFxuICAgICAgICBsID0gTWF0aC5hYnMocykgLyAobiAqIGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWFzaW5nOiBvLmVhc2luZyxcbiAgICAgICAgZHVyYXRpb246IDFlMyAqIGwsXG4gICAgICAgIGFtb3VudDogcyAqIChsIC8gMilcbiAgICAgIH07XG4gICAgfVxuICAgIEFvLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2luZXJ0aWFCdWZmZXIgPSBbXTtcbiAgICB9LCBBby5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpLCB0aGlzLl9pbmVydGlhQnVmZmVyLnB1c2goe1xuICAgICAgICB0aW1lOiB0LmJyb3dzZXIubm93KCksXG4gICAgICAgIHNldHRpbmdzOiBlXG4gICAgICB9KTtcbiAgICB9LCBBby5wcm90b3R5cGUuX2RyYWluSW5lcnRpYUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGUgPSB0aGlzLl9pbmVydGlhQnVmZmVyLCBpID0gdC5icm93c2VyLm5vdygpOyBlLmxlbmd0aCA+IDAgJiYgaSAtIGVbMF0udGltZSA+IDE2MDspIGUuc2hpZnQoKTtcbiAgICB9LCBBby5wcm90b3R5cGUuX29uTW92ZUVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcy5fZHJhaW5JbmVydGlhQnVmZmVyKCksICEodGhpcy5faW5lcnRpYUJ1ZmZlci5sZW5ndGggPCAyKSkge1xuICAgICAgICBmb3IgKHZhciBpID0ge1xuICAgICAgICAgICAgem9vbTogMCxcbiAgICAgICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgICAgICBwaXRjaDogMCxcbiAgICAgICAgICAgIHBhbjogbmV3IHQuUG9pbnQoMCwgMCksXG4gICAgICAgICAgICBwaW5jaEFyb3VuZDogdm9pZCAwLFxuICAgICAgICAgICAgYXJvdW5kOiB2b2lkIDBcbiAgICAgICAgICB9LCBvID0gMCwgciA9IHRoaXMuX2luZXJ0aWFCdWZmZXI7IG8gPCByLmxlbmd0aDsgbyArPSAxKSB7XG4gICAgICAgICAgdmFyIGEgPSByW29dLnNldHRpbmdzO1xuICAgICAgICAgIGkuem9vbSArPSBhLnpvb21EZWx0YSB8fCAwLCBpLmJlYXJpbmcgKz0gYS5iZWFyaW5nRGVsdGEgfHwgMCwgaS5waXRjaCArPSBhLnBpdGNoRGVsdGEgfHwgMCwgYS5wYW5EZWx0YSAmJiBpLnBhbi5fYWRkKGEucGFuRGVsdGEpLCBhLmFyb3VuZCAmJiAoaS5hcm91bmQgPSBhLmFyb3VuZCksIGEucGluY2hBcm91bmQgJiYgKGkucGluY2hBcm91bmQgPSBhLnBpbmNoQXJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IHRoaXMuX2luZXJ0aWFCdWZmZXJbdGhpcy5faW5lcnRpYUJ1ZmZlci5sZW5ndGggLSAxXS50aW1lIC0gdGhpcy5faW5lcnRpYUJ1ZmZlclswXS50aW1lLFxuICAgICAgICAgIHMgPSB7fTtcbiAgICAgICAgaWYgKGkucGFuLm1hZygpKSB7XG4gICAgICAgICAgdmFyIGwgPSBMbyhpLnBhbi5tYWcoKSwgbiwgdC5leHRlbmQoe30sIFNvLCBlIHx8IHt9KSk7XG4gICAgICAgICAgcy5vZmZzZXQgPSBpLnBhbi5tdWx0KGwuYW1vdW50IC8gaS5wYW4ubWFnKCkpLCBzLmNlbnRlciA9IHRoaXMuX21hcC50cmFuc2Zvcm0uY2VudGVyLCBNbyhzLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaS56b29tKSB7XG4gICAgICAgICAgdmFyIGMgPSBMbyhpLnpvb20sIG4sIENvKTtcbiAgICAgICAgICBzLnpvb20gPSB0aGlzLl9tYXAudHJhbnNmb3JtLnpvb20gKyBjLmFtb3VudCwgTW8ocywgYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkuYmVhcmluZykge1xuICAgICAgICAgIHZhciB1ID0gTG8oaS5iZWFyaW5nLCBuLCB6byk7XG4gICAgICAgICAgcy5iZWFyaW5nID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5iZWFyaW5nICsgdC5jbGFtcCh1LmFtb3VudCwgLTE3OSwgMTc5KSwgTW8ocywgdSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkucGl0Y2gpIHtcbiAgICAgICAgICB2YXIgaCA9IExvKGkucGl0Y2gsIG4sIERvKTtcbiAgICAgICAgICBzLnBpdGNoID0gdGhpcy5fbWFwLnRyYW5zZm9ybS5waXRjaCArIGguYW1vdW50LCBNbyhzLCBoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy56b29tIHx8IHMuYmVhcmluZykge1xuICAgICAgICAgIHZhciBwID0gdm9pZCAwID09PSBpLnBpbmNoQXJvdW5kID8gaS5hcm91bmQgOiBpLnBpbmNoQXJvdW5kO1xuICAgICAgICAgIHMuYXJvdW5kID0gcCA/IHRoaXMuX21hcC51bnByb2plY3QocCkgOiB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKSwgdC5leHRlbmQocywge1xuICAgICAgICAgIG5vTW92ZVN0YXJ0OiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBSbyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIG8obywgciwgYSwgbikge1xuICAgICAgICAgIHZvaWQgMCA9PT0gbiAmJiAobiA9IHt9KTtcbiAgICAgICAgICB2YXIgcyA9IGkubW91c2VQb3Moci5nZXRDYW52YXNDb250YWluZXIoKSwgYSksXG4gICAgICAgICAgICBsID0gci51bnByb2plY3Qocyk7XG4gICAgICAgICAgZS5jYWxsKHRoaXMsIG8sIHQuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBvaW50OiBzLFxuICAgICAgICAgICAgbG5nTGF0OiBsLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogYVxuICAgICAgICAgIH0sIG4pKSwgdGhpcy5fZGVmYXVsdFByZXZlbnRlZCA9ICExLCB0aGlzLnRhcmdldCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZSAmJiAoby5fX3Byb3RvX18gPSBlKSwgKG8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBvO1xuICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gby5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICB9LCByLmRlZmF1bHRQcmV2ZW50ZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLnByb3RvdHlwZSwgciksIG87XG4gICAgICB9KHQuRXZlbnQpLFxuICAgICAga28gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmdW5jdGlvbiBvKG8sIHIsIGEpIHtcbiAgICAgICAgICB2YXIgbiA9IFwidG91Y2hlbmRcIiA9PT0gbyA/IGEuY2hhbmdlZFRvdWNoZXMgOiBhLnRvdWNoZXMsXG4gICAgICAgICAgICBzID0gaS50b3VjaFBvcyhyLmdldENhbnZhc0NvbnRhaW5lcigpLCBuKSxcbiAgICAgICAgICAgIGwgPSBzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gci51bnByb2plY3QodCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGMgPSBzLnJlZHVjZShmdW5jdGlvbiAodCwgZSwgaSwgbykge1xuICAgICAgICAgICAgICByZXR1cm4gdC5hZGQoZS5kaXYoby5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0sIG5ldyB0LlBvaW50KDAsIDApKSxcbiAgICAgICAgICAgIHUgPSByLnVucHJvamVjdChjKTtcbiAgICAgICAgICBlLmNhbGwodGhpcywgbywge1xuICAgICAgICAgICAgcG9pbnRzOiBzLFxuICAgICAgICAgICAgcG9pbnQ6IGMsXG4gICAgICAgICAgICBsbmdMYXRzOiBsLFxuICAgICAgICAgICAgbG5nTGF0OiB1LFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogYVxuICAgICAgICAgIH0pLCB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITE7XG4gICAgICAgIH1cbiAgICAgICAgZSAmJiAoby5fX3Byb3RvX18gPSBlKSwgKG8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBvO1xuICAgICAgICB2YXIgciA9IHtcbiAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gby5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICB9LCByLmRlZmF1bHRQcmV2ZW50ZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLnByb3RvdHlwZSwgciksIG87XG4gICAgICB9KHQuRXZlbnQpLFxuICAgICAgQm8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmdW5jdGlvbiBlKGUsIGksIG8pIHtcbiAgICAgICAgICB0LmNhbGwodGhpcywgZSwge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb1xuICAgICAgICAgIH0pLCB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gITE7XG4gICAgICAgIH1cbiAgICAgICAgdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlO1xuICAgICAgICB2YXIgaSA9IHtcbiAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZS5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICB9LCBpLmRlZmF1bHRQcmV2ZW50ZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgaSksIGU7XG4gICAgICB9KHQuRXZlbnQpLFxuICAgICAgT28gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICB0aGlzLl9tYXAgPSB0LCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IGUuY2xpY2tUb2xlcmFuY2U7XG4gICAgICB9O1xuICAgIE9vLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9tb3VzZWRvd25Qb3M7XG4gICAgfSwgT28ucHJvdG90eXBlLndoZWVsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJlUHJldmVudGFibGUobmV3IEJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW91c2Vkb3duUG9zID0gZSwgdGhpcy5fZmlyZVByZXZlbnRhYmxlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5tb3VzZXVwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBSbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLl9tb3VzZWRvd25Qb3MgJiYgdGhpcy5fbW91c2Vkb3duUG9zLmRpc3QoZSkgPj0gdGhpcy5fY2xpY2tUb2xlcmFuY2UgfHwgdGhpcy5fbWFwLmZpcmUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLmRibGNsaWNrID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJlUHJldmVudGFibGUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLm1vdXNlb3ZlciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcgUm8odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcmVQcmV2ZW50YWJsZShuZXcga28odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcC5maXJlKG5ldyBrbyh0LnR5cGUsIHRoaXMuX21hcCwgdCkpO1xuICAgIH0sIE9vLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAuZmlyZShuZXcga28odC50eXBlLCB0aGlzLl9tYXAsIHQpKTtcbiAgICB9LCBPby5wcm90b3R5cGUudG91Y2hjYW5jZWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IGtvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgT28ucHJvdG90eXBlLl9maXJlUHJldmVudGFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKHRoaXMuX21hcC5maXJlKHQpLCB0LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybiB7fTtcbiAgICB9LCBPby5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIE9vLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBPby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge30sIE9vLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge307XG4gICAgdmFyIEZvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX21hcCA9IHQ7XG4gICAgfTtcbiAgICBGby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9kZWxheUNvbnRleHRNZW51ID0gITEsIGRlbGV0ZSB0aGlzLl9jb250ZXh0TWVudUV2ZW50O1xuICAgIH0sIEZvLnByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSk7XG4gICAgfSwgRm8ucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2RlbGF5Q29udGV4dE1lbnUgPSAhMDtcbiAgICB9LCBGby5wcm90b3R5cGUubW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2RlbGF5Q29udGV4dE1lbnUgPSAhMSwgdGhpcy5fY29udGV4dE1lbnVFdmVudCAmJiAodGhpcy5fbWFwLmZpcmUobmV3IFJvKFwiY29udGV4dG1lbnVcIiwgdGhpcy5fbWFwLCB0aGlzLl9jb250ZXh0TWVudUV2ZW50KSksIGRlbGV0ZSB0aGlzLl9jb250ZXh0TWVudUV2ZW50KTtcbiAgICB9LCBGby5wcm90b3R5cGUuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZGVsYXlDb250ZXh0TWVudSA/IHRoaXMuX2NvbnRleHRNZW51RXZlbnQgPSB0IDogdGhpcy5fbWFwLmZpcmUobmV3IFJvKHQudHlwZSwgdGhpcy5fbWFwLCB0KSksIHRoaXMuX21hcC5saXN0ZW5zKFwiY29udGV4dG1lbnVcIikgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIEZvLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgRm8ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIEZvLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7fSwgRm8ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB2YXIgVW8gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5fbWFwID0gdCwgdGhpcy5fZWwgPSB0LmdldENhbnZhc0NvbnRhaW5lcigpLCB0aGlzLl9jb250YWluZXIgPSB0LmdldENvbnRhaW5lcigpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IGUuY2xpY2tUb2xlcmFuY2UgfHwgMTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIE5vKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSB7fSwgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSBpW3Rbb10uaWRlbnRpZmllcl0gPSBlW29dO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIFVvLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9lbmFibGVkO1xuICAgIH0sIFVvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX2FjdGl2ZTtcbiAgICB9LCBVby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQoKSB8fCAodGhpcy5fZW5hYmxlZCA9ICEwKTtcbiAgICB9LCBVby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkKCkgJiYgKHRoaXMuX2VuYWJsZWQgPSAhMSk7XG4gICAgfSwgVW8ucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCgpICYmIHQuc2hpZnRLZXkgJiYgMCA9PT0gdC5idXR0b24gJiYgKGkuZGlzYWJsZURyYWcoKSwgdGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9sYXN0UG9zID0gZSwgdGhpcy5fYWN0aXZlID0gITApO1xuICAgIH0sIFVvLnByb3RvdHlwZS5tb3VzZW1vdmVXaW5kb3cgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB2YXIgbyA9IGU7XG4gICAgICAgIGlmICghKHRoaXMuX2xhc3RQb3MuZXF1YWxzKG8pIHx8ICF0aGlzLl9ib3ggJiYgby5kaXN0KHRoaXMuX3N0YXJ0UG9zKSA8IHRoaXMuX2NsaWNrVG9sZXJhbmNlKSkge1xuICAgICAgICAgIHZhciByID0gdGhpcy5fc3RhcnRQb3M7XG4gICAgICAgICAgdGhpcy5fbGFzdFBvcyA9IG8sIHRoaXMuX2JveCB8fCAodGhpcy5fYm94ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWJveHpvb20gbWFwYm94Z2wtYm94em9vbVwiLCB0aGlzLl9jb250YWluZXIpLCB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3Jvc3NoYWlyXCIsIFwibWFwYm94Z2wtY3Jvc3NoYWlyXCIpLCB0aGlzLl9maXJlRXZlbnQoXCJib3h6b29tc3RhcnRcIiwgdCkpO1xuICAgICAgICAgIHZhciBhID0gTWF0aC5taW4oci54LCBvLngpLFxuICAgICAgICAgICAgbiA9IE1hdGgubWF4KHIueCwgby54KSxcbiAgICAgICAgICAgIHMgPSBNYXRoLm1pbihyLnksIG8ueSksXG4gICAgICAgICAgICBsID0gTWF0aC5tYXgoci55LCBvLnkpO1xuICAgICAgICAgIGkuc2V0VHJhbnNmb3JtKHRoaXMuX2JveCwgXCJ0cmFuc2xhdGUoXCIgKyBhICsgXCJweCxcIiArIHMgKyBcInB4KVwiKSwgdGhpcy5fYm94LnN0eWxlLndpZHRoID0gbiAtIGEgKyBcInB4XCIsIHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSBsIC0gcyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFVvLnByb3RvdHlwZS5tb3VzZXVwV2luZG93ID0gZnVuY3Rpb24gKGUsIG8pIHtcbiAgICAgIHZhciByID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgMCA9PT0gZS5idXR0b24pIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICBuID0gbztcbiAgICAgICAgaWYgKHRoaXMucmVzZXQoKSwgaS5zdXBwcmVzc0NsaWNrKCksIGEueCAhPT0gbi54IHx8IGEueSAhPT0gbi55KSByZXR1cm4gdGhpcy5fbWFwLmZpcmUobmV3IHQuRXZlbnQoXCJib3h6b29tZW5kXCIsIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmZpdFNjcmVlbkNvb3JkaW5hdGVzKGEsIG4sIHIuX21hcC5nZXRCZWFyaW5nKCksIHtcbiAgICAgICAgICAgICAgbGluZWFyOiAhMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJib3h6b29tY2FuY2VsXCIsIGUpO1xuICAgICAgfVxuICAgIH0sIFVvLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSAmJiAyNyA9PT0gdC5rZXlDb2RlICYmICh0aGlzLnJlc2V0KCksIHRoaXMuX2ZpcmVFdmVudChcImJveHpvb21jYW5jZWxcIiwgdCkpO1xuICAgIH0sIFVvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3Jvc3NoYWlyXCIsIFwibWFwYm94Z2wtY3Jvc3NoYWlyXCIpLCB0aGlzLl9ib3ggJiYgKGkucmVtb3ZlKHRoaXMuX2JveCksIHRoaXMuX2JveCA9IG51bGwpLCBpLmVuYWJsZURyYWcoKSwgZGVsZXRlIHRoaXMuX3N0YXJ0UG9zLCBkZWxldGUgdGhpcy5fbGFzdFBvcztcbiAgICB9LCBVby5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUobmV3IHQuRXZlbnQoZSwge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBpXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICB2YXIgWm8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5yZXNldCgpLCB0aGlzLm51bVRvdWNoZXMgPSB0Lm51bVRvdWNoZXM7XG4gICAgfTtcbiAgICBaby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgdGhpcy5jZW50cm9pZCwgZGVsZXRlIHRoaXMuc3RhcnRUaW1lLCBkZWxldGUgdGhpcy50b3VjaGVzLCB0aGlzLmFib3J0ZWQgPSAhMTtcbiAgICB9LCBaby5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAodGhpcy5jZW50cm9pZCB8fCBvLmxlbmd0aCA+IHRoaXMubnVtVG91Y2hlcykgJiYgKHRoaXMuYWJvcnRlZCA9ICEwKSwgdGhpcy5hYm9ydGVkIHx8ICh2b2lkIDAgPT09IHRoaXMuc3RhcnRUaW1lICYmICh0aGlzLnN0YXJ0VGltZSA9IGUudGltZVN0YW1wKSwgby5sZW5ndGggPT09IHRoaXMubnVtVG91Y2hlcyAmJiAodGhpcy5jZW50cm9pZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBuZXcgdC5Qb2ludCgwLCAwKSwgbyA9IDAsIHIgPSBlOyBvIDwgci5sZW5ndGg7IG8gKz0gMSkgaS5fYWRkKHJbb10pO1xuICAgICAgICByZXR1cm4gaS5kaXYoZS5sZW5ndGgpO1xuICAgICAgfShpKSwgdGhpcy50b3VjaGVzID0gTm8obywgaSkpKTtcbiAgICB9LCBaby5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICghdGhpcy5hYm9ydGVkICYmIHRoaXMuY2VudHJvaWQpIHtcbiAgICAgICAgdmFyIG8gPSBObyhpLCBlKTtcbiAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnRvdWNoZXMpIHtcbiAgICAgICAgICB2YXIgYSA9IG9bcl07XG4gICAgICAgICAgKCFhIHx8IGEuZGlzdCh0aGlzLnRvdWNoZXNbcl0pID4gMzApICYmICh0aGlzLmFib3J0ZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBaby5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgaWYgKCghdGhpcy5jZW50cm9pZCB8fCB0LnRpbWVTdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gNTAwKSAmJiAodGhpcy5hYm9ydGVkID0gITApLCAwID09PSBpLmxlbmd0aCkge1xuICAgICAgICB2YXIgbyA9ICF0aGlzLmFib3J0ZWQgJiYgdGhpcy5jZW50cm9pZDtcbiAgICAgICAgaWYgKHRoaXMucmVzZXQoKSwgbykgcmV0dXJuIG87XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcW8gPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5zaW5nbGVUYXAgPSBuZXcgWm8odCksIHRoaXMubnVtVGFwcyA9IHQubnVtVGFwcywgdGhpcy5yZXNldCgpO1xuICAgIH07XG4gICAgcW8ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IDEgLyAwLCBkZWxldGUgdGhpcy5sYXN0VGFwLCB0aGlzLmNvdW50ID0gMCwgdGhpcy5zaW5nbGVUYXAucmVzZXQoKTtcbiAgICB9LCBxby5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLnNpbmdsZVRhcC50b3VjaHN0YXJ0KHQsIGUsIGkpO1xuICAgIH0sIHFvLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5zaW5nbGVUYXAudG91Y2htb3ZlKHQsIGUsIGkpO1xuICAgIH0sIHFvLnByb3RvdHlwZS50b3VjaGVuZCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuc2luZ2xlVGFwLnRvdWNoZW5kKHQsIGUsIGkpO1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgdmFyIHIgPSB0LnRpbWVTdGFtcCAtIHRoaXMubGFzdFRpbWUgPCA1MDAsXG4gICAgICAgICAgYSA9ICF0aGlzLmxhc3RUYXAgfHwgdGhpcy5sYXN0VGFwLmRpc3QobykgPCAzMDtcbiAgICAgICAgaWYgKHIgJiYgYSB8fCB0aGlzLnJlc2V0KCksIHRoaXMuY291bnQrKywgdGhpcy5sYXN0VGltZSA9IHQudGltZVN0YW1wLCB0aGlzLmxhc3RUYXAgPSBvLCB0aGlzLmNvdW50ID09PSB0aGlzLm51bVRhcHMpIHJldHVybiB0aGlzLnJlc2V0KCksIG87XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgam8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl96b29tSW4gPSBuZXcgcW8oe1xuICAgICAgICBudW1Ub3VjaGVzOiAxLFxuICAgICAgICBudW1UYXBzOiAyXG4gICAgICB9KSwgdGhpcy5fem9vbU91dCA9IG5ldyBxbyh7XG4gICAgICAgIG51bVRvdWNoZXM6IDIsXG4gICAgICAgIG51bVRhcHM6IDFcbiAgICAgIH0pLCB0aGlzLnJlc2V0KCk7XG4gICAgfTtcbiAgICBqby5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fem9vbUluLnJlc2V0KCksIHRoaXMuX3pvb21PdXQucmVzZXQoKTtcbiAgICB9LCBqby5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl96b29tSW4udG91Y2hzdGFydCh0LCBlLCBpKSwgdGhpcy5fem9vbU91dC50b3VjaHN0YXJ0KHQsIGUsIGkpO1xuICAgIH0sIGpvLnByb3RvdHlwZS50b3VjaG1vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fem9vbUluLnRvdWNobW92ZSh0LCBlLCBpKSwgdGhpcy5fem9vbU91dC50b3VjaG1vdmUodCwgZSwgaSk7XG4gICAgfSwgam8ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZhciBvID0gdGhpcyxcbiAgICAgICAgciA9IHRoaXMuX3pvb21Jbi50b3VjaGVuZCh0LCBlLCBpKSxcbiAgICAgICAgYSA9IHRoaXMuX3pvb21PdXQudG91Y2hlbmQodCwgZSwgaSk7XG4gICAgICByZXR1cm4gciA/ICh0aGlzLl9hY3RpdmUgPSAhMCwgdC5wcmV2ZW50RGVmYXVsdCgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG8ucmVzZXQoKTtcbiAgICAgIH0sIDApLCB7XG4gICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lYXNlVG8oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHpvb206IGUuZ2V0Wm9vbSgpICsgMSxcbiAgICAgICAgICAgIGFyb3VuZDogZS51bnByb2plY3QocilcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogYSA/ICh0aGlzLl9hY3RpdmUgPSAhMCwgdC5wcmV2ZW50RGVmYXVsdCgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG8ucmVzZXQoKTtcbiAgICAgIH0sIDApLCB7XG4gICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5lYXNlVG8oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHpvb206IGUuZ2V0Wm9vbSgpIC0gMSxcbiAgICAgICAgICAgIGFyb3VuZDogZS51bnByb2plY3QoYSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pIDogdm9pZCAwO1xuICAgIH0sIGpvLnByb3RvdHlwZS50b3VjaGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LCBqby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIGpvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgam8ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIGpvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcbiAgICB2YXIgVm8gPSB7XG4gICAgICAgIDA6IDEsXG4gICAgICAgIDI6IDJcbiAgICAgIH0sXG4gICAgICBHbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMucmVzZXQoKSwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgPSB0LmNsaWNrVG9sZXJhbmNlIHx8IDE7XG4gICAgICB9O1xuICAgIEdvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCB0aGlzLl9tb3ZlZCA9ICExLCBkZWxldGUgdGhpcy5fbGFzdFBvaW50LCBkZWxldGUgdGhpcy5fZXZlbnRCdXR0b247XG4gICAgfSwgR28ucHJvdG90eXBlLl9jb3JyZWN0QnV0dG9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBHby5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0sIEdvLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKCF0aGlzLl9sYXN0UG9pbnQpIHtcbiAgICAgICAgdmFyIG8gPSBpLm1vdXNlQnV0dG9uKHQpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0QnV0dG9uKHQsIG8pICYmICh0aGlzLl9sYXN0UG9pbnQgPSBlLCB0aGlzLl9ldmVudEJ1dHRvbiA9IG8pO1xuICAgICAgfVxuICAgIH0sIEdvLnByb3RvdHlwZS5tb3VzZW1vdmVXaW5kb3cgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9sYXN0UG9pbnQ7XG4gICAgICBpZiAoaSkgaWYgKHQucHJldmVudERlZmF1bHQoKSwgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSBWb1tlXTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdC5idXR0b25zIHx8ICh0LmJ1dHRvbnMgJiBpKSAhPT0gaTtcbiAgICAgIH0odCwgdGhpcy5fZXZlbnRCdXR0b24pKSB0aGlzLnJlc2V0KCk7ZWxzZSBpZiAodGhpcy5fbW92ZWQgfHwgIShlLmRpc3QoaSkgPCB0aGlzLl9jbGlja1RvbGVyYW5jZSkpIHJldHVybiB0aGlzLl9tb3ZlZCA9ICEwLCB0aGlzLl9sYXN0UG9pbnQgPSBlLCB0aGlzLl9tb3ZlKGksIGUpO1xuICAgIH0sIEdvLnByb3RvdHlwZS5tb3VzZXVwV2luZG93ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuX2xhc3RQb2ludCAmJiBpLm1vdXNlQnV0dG9uKHQpID09PSB0aGlzLl9ldmVudEJ1dHRvbiAmJiAodGhpcy5fbW92ZWQgJiYgaS5zdXBwcmVzc0NsaWNrKCksIHRoaXMucmVzZXQoKSk7XG4gICAgfSwgR28ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCBHby5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIEdvLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBHby5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG4gICAgdmFyIFdvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUubW91c2Vkb3duID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB0LnByb3RvdHlwZS5tb3VzZWRvd24uY2FsbCh0aGlzLCBlLCBpKSwgdGhpcy5fbGFzdFBvaW50ICYmICh0aGlzLl9hY3RpdmUgPSAhMCk7XG4gICAgICAgIH0sIGUucHJvdG90eXBlLl9jb3JyZWN0QnV0dG9uID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gMCA9PT0gZSAmJiAhdC5jdHJsS2V5O1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyb3VuZDogZSxcbiAgICAgICAgICAgIHBhbkRlbHRhOiBlLnN1Yih0KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIGU7XG4gICAgICB9KEdvKSxcbiAgICAgIFhvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX2NvcnJlY3RCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiAwID09PSBlICYmIHQuY3RybEtleSB8fCAyID09PSBlO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIGkgPSAuOCAqIChlLnggLSB0LngpO1xuICAgICAgICAgIGlmIChpKSByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICAgIGJlYXJpbmdEZWx0YTogaVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIGUucHJvdG90eXBlLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sIGU7XG4gICAgICB9KEdvKSxcbiAgICAgIEhvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUuX2NvcnJlY3RCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiAwID09PSBlICYmIHQuY3RybEtleSB8fCAyID09PSBlO1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgdmFyIGkgPSAtLjUgKiAoZS55IC0gdC55KTtcbiAgICAgICAgICBpZiAoaSkgcmV0dXJuIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgICBwaXRjaERlbHRhOiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZTtcbiAgICAgIH0oR28pLFxuICAgICAgS28gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLl9taW5Ub3VjaGVzID0gMSwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgPSB0LmNsaWNrVG9sZXJhbmNlIHx8IDEsIHRoaXMucmVzZXQoKTtcbiAgICAgIH07XG4gICAgS28ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITEsIHRoaXMuX3RvdWNoZXMgPSB7fSwgdGhpcy5fc3VtID0gbmV3IHQuUG9pbnQoMCwgMCk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybSh0LCBlLCBpKTtcbiAgICB9LCBLby5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgIShpLmxlbmd0aCA8IHRoaXMuX21pblRvdWNoZXMpKSByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9jYWxjdWxhdGVUcmFuc2Zvcm0odCwgZSwgaSk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybSh0LCBlLCBpKSwgdGhpcy5fYWN0aXZlICYmIGkubGVuZ3RoIDwgdGhpcy5fbWluVG91Y2hlcyAmJiB0aGlzLnJlc2V0KCk7XG4gICAgfSwgS28ucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sIEtvLnByb3RvdHlwZS5fY2FsY3VsYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgIG8ubGVuZ3RoID4gMCAmJiAodGhpcy5fYWN0aXZlID0gITApO1xuICAgICAgdmFyIHIgPSBObyhvLCBpKSxcbiAgICAgICAgYSA9IG5ldyB0LlBvaW50KDAsIDApLFxuICAgICAgICBuID0gbmV3IHQuUG9pbnQoMCwgMCksXG4gICAgICAgIHMgPSAwO1xuICAgICAgZm9yICh2YXIgbCBpbiByKSB7XG4gICAgICAgIHZhciBjID0gcltsXSxcbiAgICAgICAgICB1ID0gdGhpcy5fdG91Y2hlc1tsXTtcbiAgICAgICAgdSAmJiAoYS5fYWRkKGMpLCBuLl9hZGQoYy5zdWIodSkpLCBzKyssIHJbbF0gPSBjKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl90b3VjaGVzID0gciwgIShzIDwgdGhpcy5fbWluVG91Y2hlcykgJiYgbi5tYWcoKSkge1xuICAgICAgICB2YXIgaCA9IG4uZGl2KHMpO1xuICAgICAgICBpZiAodGhpcy5fc3VtLl9hZGQoaCksICEodGhpcy5fc3VtLm1hZygpIDwgdGhpcy5fY2xpY2tUb2xlcmFuY2UpKSByZXR1cm4ge1xuICAgICAgICAgIGFyb3VuZDogYS5kaXYocyksXG4gICAgICAgICAgcGFuRGVsdGE6IGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBLby5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIEtvLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgS28ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIEtvLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcbiAgICB2YXIgWW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBKbyh0LCBlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvID0gMDsgbyA8IHQubGVuZ3RoOyBvKyspIGlmICh0W29dLmlkZW50aWZpZXIgPT09IGkpIHJldHVybiBlW29dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRbyh0LCBlKSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2codCAvIGUpIC8gTWF0aC5MTjI7XG4gICAgfVxuICAgIFlvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCBkZWxldGUgdGhpcy5fZmlyc3RUd29Ub3VjaGVzO1xuICAgIH0sIFlvLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodCkge30sIFlvLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fZmlyc3RUd29Ub3VjaGVzIHx8IGkubGVuZ3RoIDwgMiB8fCAodGhpcy5fZmlyc3RUd29Ub3VjaGVzID0gW2lbMF0uaWRlbnRpZmllciwgaVsxXS5pZGVudGlmaWVyXSwgdGhpcy5fc3RhcnQoW2VbMF0sIGVbMV1dKSk7XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBpZiAodGhpcy5fZmlyc3RUd29Ub3VjaGVzKSB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl9maXJzdFR3b1RvdWNoZXMsXG4gICAgICAgICAgciA9IG9bMV0sXG4gICAgICAgICAgYSA9IEpvKGksIGUsIG9bMF0pLFxuICAgICAgICAgIG4gPSBKbyhpLCBlLCByKTtcbiAgICAgICAgaWYgKGEgJiYgbikge1xuICAgICAgICAgIHZhciBzID0gdGhpcy5fYXJvdW5kQ2VudGVyID8gbnVsbCA6IGEuYWRkKG4pLmRpdigyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbW92ZShbYSwgbl0sIHMsIHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQsIGUsIG8pIHtcbiAgICAgIGlmICh0aGlzLl9maXJzdFR3b1RvdWNoZXMpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLl9maXJzdFR3b1RvdWNoZXMsXG4gICAgICAgICAgYSA9IHJbMV0sXG4gICAgICAgICAgbiA9IEpvKG8sIGUsIHJbMF0pLFxuICAgICAgICAgIHMgPSBKbyhvLCBlLCBhKTtcbiAgICAgICAgbiAmJiBzIHx8ICh0aGlzLl9hY3RpdmUgJiYgaS5zdXBwcmVzc0NsaWNrKCksIHRoaXMucmVzZXQoKSk7XG4gICAgICB9XG4gICAgfSwgWW8ucHJvdG90eXBlLnRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sIFlvLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwLCB0aGlzLl9hcm91bmRDZW50ZXIgPSAhIXQgJiYgXCJjZW50ZXJcIiA9PT0gdC5hcm91bmQ7XG4gICAgfSwgWW8ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gITEsIHRoaXMucmVzZXQoKTtcbiAgICB9LCBZby5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSwgWW8ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9O1xuICAgIHZhciAkbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdCAmJiAoZS5fX3Byb3RvX18gPSB0KSwgKGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBlLCBlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKSwgZGVsZXRlIHRoaXMuX2Rpc3RhbmNlLCBkZWxldGUgdGhpcy5fc3RhcnREaXN0YW5jZTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9IHRbMF0uZGlzdCh0WzFdKTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9kaXN0YW5jZTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlID0gdFswXS5kaXN0KHRbMV0pLCB0aGlzLl9hY3RpdmUgfHwgIShNYXRoLmFicyhRbyh0aGlzLl9kaXN0YW5jZSwgdGhpcy5fc3RhcnREaXN0YW5jZSkpIDwgLjEpKSByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICB6b29tRGVsdGE6IFFvKHRoaXMuX2Rpc3RhbmNlLCBpKSxcbiAgICAgICAgICBwaW5jaEFyb3VuZDogZVxuICAgICAgICB9O1xuICAgICAgfSwgZTtcbiAgICB9KFlvKTtcbiAgICBmdW5jdGlvbiB0cih0LCBlKSB7XG4gICAgICByZXR1cm4gMTgwICogdC5hbmdsZVdpdGgoZSkgLyBNYXRoLlBJO1xuICAgIH1cbiAgICB2YXIgZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQgJiYgKGUuX19wcm90b19fID0gdCksIChlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gZSwgZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyksIGRlbGV0ZSB0aGlzLl9taW5EaWFtZXRlciwgZGVsZXRlIHRoaXMuX3N0YXJ0VmVjdG9yLCBkZWxldGUgdGhpcy5fdmVjdG9yO1xuICAgICAgfSwgZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRWZWN0b3IgPSB0aGlzLl92ZWN0b3IgPSB0WzBdLnN1Yih0WzFdKSwgdGhpcy5fbWluRGlhbWV0ZXIgPSB0WzBdLmRpc3QodFsxXSk7XG4gICAgICB9LCBlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fdmVjdG9yO1xuICAgICAgICBpZiAodGhpcy5fdmVjdG9yID0gdFswXS5zdWIodFsxXSksIHRoaXMuX2FjdGl2ZSB8fCAhdGhpcy5faXNCZWxvd1RocmVzaG9sZCh0aGlzLl92ZWN0b3IpKSByZXR1cm4gdGhpcy5fYWN0aXZlID0gITAsIHtcbiAgICAgICAgICBiZWFyaW5nRGVsdGE6IHRyKHRoaXMuX3ZlY3RvciwgaSksXG4gICAgICAgICAgcGluY2hBcm91bmQ6IGVcbiAgICAgICAgfTtcbiAgICAgIH0sIGUucHJvdG90eXBlLl9pc0JlbG93VGhyZXNob2xkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5fbWluRGlhbWV0ZXIgPSBNYXRoLm1pbih0aGlzLl9taW5EaWFtZXRlciwgdC5tYWcoKSk7XG4gICAgICAgIHZhciBlID0gMjUgLyAoTWF0aC5QSSAqIHRoaXMuX21pbkRpYW1ldGVyKSAqIDM2MCxcbiAgICAgICAgICBpID0gdHIodCwgdGhpcy5fc3RhcnRWZWN0b3IpO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoaSkgPCBlO1xuICAgICAgfSwgZTtcbiAgICB9KFlvKTtcbiAgICBmdW5jdGlvbiBpcih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModC55KSA+IE1hdGguYWJzKHQueCk7XG4gICAgfVxuICAgIHZhciBvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHQucHJvdG90eXBlLnJlc2V0LmNhbGwodGhpcyksIHRoaXMuX3ZhbGlkID0gdm9pZCAwLCBkZWxldGUgdGhpcy5fZmlyc3RNb3ZlLCBkZWxldGUgdGhpcy5fbGFzdFBvaW50cztcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl9sYXN0UG9pbnRzID0gdCwgaXIodFswXS5zdWIodFsxXSkpICYmICh0aGlzLl92YWxpZCA9ICExKTtcbiAgICAgICAgfSwgZS5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gdFswXS5zdWIodGhpcy5fbGFzdFBvaW50c1swXSksXG4gICAgICAgICAgICByID0gdFsxXS5zdWIodGhpcy5fbGFzdFBvaW50c1sxXSk7XG4gICAgICAgICAgaWYgKHRoaXMuX3ZhbGlkID0gdGhpcy5nZXN0dXJlQmVnaW5zVmVydGljYWxseShvLCByLCBpLnRpbWVTdGFtcCksIHRoaXMuX3ZhbGlkKSByZXR1cm4gdGhpcy5fbGFzdFBvaW50cyA9IHQsIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgICBwaXRjaERlbHRhOiAoby55ICsgci55KSAvIDIgKiAtLjVcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBlLnByb3RvdHlwZS5nZXN0dXJlQmVnaW5zVmVydGljYWxseSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdGhpcy5fdmFsaWQpIHJldHVybiB0aGlzLl92YWxpZDtcbiAgICAgICAgICB2YXIgbyA9IHQubWFnKCkgPj0gMixcbiAgICAgICAgICAgIHIgPSBlLm1hZygpID49IDI7XG4gICAgICAgICAgaWYgKG8gfHwgcikge1xuICAgICAgICAgICAgaWYgKCFvIHx8ICFyKSByZXR1cm4gdm9pZCAwID09PSB0aGlzLl9maXJzdE1vdmUgJiYgKHRoaXMuX2ZpcnN0TW92ZSA9IGkpLCBpIC0gdGhpcy5fZmlyc3RNb3ZlIDwgMTAwICYmIHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBhID0gdC55ID4gMCA9PSBlLnkgPiAwO1xuICAgICAgICAgICAgcmV0dXJuIGlyKHQpICYmIGlyKGUpICYmIGE7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBlO1xuICAgICAgfShZbyksXG4gICAgICByciA9IHtcbiAgICAgICAgcGFuU3RlcDogMTAwLFxuICAgICAgICBiZWFyaW5nU3RlcDogMTUsXG4gICAgICAgIHBpdGNoU3RlcDogMTBcbiAgICAgIH0sXG4gICAgICBhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBycjtcbiAgICAgICAgdGhpcy5fcGFuU3RlcCA9IHQucGFuU3RlcCwgdGhpcy5fYmVhcmluZ1N0ZXAgPSB0LmJlYXJpbmdTdGVwLCB0aGlzLl9waXRjaFN0ZXAgPSB0LnBpdGNoU3RlcCwgdGhpcy5fcm90YXRpb25EaXNhYmxlZCA9ICExO1xuICAgICAgfTtcbiAgICBmdW5jdGlvbiBucih0KSB7XG4gICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG4gICAgfVxuICAgIGFyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExO1xuICAgIH0sIGFyLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdGhpcztcbiAgICAgIGlmICghKHQuYWx0S2V5IHx8IHQuY3RybEtleSB8fCB0Lm1ldGFLZXkpKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBvID0gMCxcbiAgICAgICAgICByID0gMCxcbiAgICAgICAgICBhID0gMCxcbiAgICAgICAgICBuID0gMDtcbiAgICAgICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgIGNhc2UgMTcxOlxuICAgICAgICAgIGNhc2UgMTg3OlxuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4OTpcbiAgICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICBjYXNlIDE3MzpcbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICB0LnNoaWZ0S2V5ID8gbyA9IC0xIDogKHQucHJldmVudERlZmF1bHQoKSwgYSA9IC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICB0LnNoaWZ0S2V5ID8gbyA9IDEgOiAodC5wcmV2ZW50RGVmYXVsdCgpLCBhID0gMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgdC5zaGlmdEtleSA/IHIgPSAxIDogKHQucHJldmVudERlZmF1bHQoKSwgbiA9IC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICB0LnNoaWZ0S2V5ID8gciA9IC0xIDogKHQucHJldmVudERlZmF1bHQoKSwgbiA9IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb25EaXNhYmxlZCAmJiAobyA9IDAsIHIgPSAwKSwge1xuICAgICAgICAgIGNhbWVyYUFuaW1hdGlvbjogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHZhciBsID0gcy5nZXRab29tKCk7XG4gICAgICAgICAgICBzLmVhc2VUbyh7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICAgIGVhc2VJZDogXCJrZXlib2FyZEhhbmRsZXJcIixcbiAgICAgICAgICAgICAgZWFzaW5nOiBucixcbiAgICAgICAgICAgICAgem9vbTogaSA/IE1hdGgucm91bmQobCkgKyBpICogKHQuc2hpZnRLZXkgPyAyIDogMSkgOiBsLFxuICAgICAgICAgICAgICBiZWFyaW5nOiBzLmdldEJlYXJpbmcoKSArIG8gKiBlLl9iZWFyaW5nU3RlcCxcbiAgICAgICAgICAgICAgcGl0Y2g6IHMuZ2V0UGl0Y2goKSArIHIgKiBlLl9waXRjaFN0ZXAsXG4gICAgICAgICAgICAgIG9mZnNldDogWy1hICogZS5fcGFuU3RlcCwgLW4gKiBlLl9wYW5TdGVwXSxcbiAgICAgICAgICAgICAgY2VudGVyOiBzLmdldENlbnRlcigpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBhci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIGFyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgYXIucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIGFyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSwgYXIucHJvdG90eXBlLmRpc2FibGVSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSAhMDtcbiAgICB9LCBhci5wcm90b3R5cGUuZW5hYmxlUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITE7XG4gICAgfTtcbiAgICB2YXIgc3IgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdGhpcy5fbWFwID0gZSwgdGhpcy5fZWwgPSBlLmdldENhbnZhc0NvbnRhaW5lcigpLCB0aGlzLl9oYW5kbGVyID0gaSwgdGhpcy5fZGVsdGEgPSAwLCB0aGlzLl9kZWZhdWx0Wm9vbVJhdGUgPSAuMDEsIHRoaXMuX3doZWVsWm9vbVJhdGUgPSAxIC8gNDUwLCB0LmJpbmRBbGwoW1wiX29uVGltZW91dFwiXSwgdGhpcyk7XG4gICAgfTtcbiAgICBzci5wcm90b3R5cGUuc2V0Wm9vbVJhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fZGVmYXVsdFpvb21SYXRlID0gdDtcbiAgICB9LCBzci5wcm90b3R5cGUuc2V0V2hlZWxab29tUmF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl93aGVlbFpvb21SYXRlID0gdDtcbiAgICB9LCBzci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBzci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9hY3RpdmUgfHwgdm9pZCAwICE9PSB0aGlzLl9maW5pc2hUaW1lb3V0O1xuICAgIH0sIHNyLnByb3RvdHlwZS5pc1pvb21pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl96b29taW5nO1xuICAgIH0sIHNyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQoKSB8fCAodGhpcy5fZW5hYmxlZCA9ICEwLCB0aGlzLl9hcm91bmRDZW50ZXIgPSB0ICYmIFwiY2VudGVyXCIgPT09IHQuYXJvdW5kKTtcbiAgICB9LCBzci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNFbmFibGVkKCkgJiYgKHRoaXMuX2VuYWJsZWQgPSAhMSk7XG4gICAgfSwgc3IucHJvdG90eXBlLndoZWVsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgIHZhciBpID0gZS5kZWx0YU1vZGUgPT09IHQud2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUgPyA0MCAqIGUuZGVsdGFZIDogZS5kZWx0YVksXG4gICAgICAgICAgbyA9IHQuYnJvd3Nlci5ub3coKSxcbiAgICAgICAgICByID0gbyAtICh0aGlzLl9sYXN0V2hlZWxFdmVudFRpbWUgfHwgMCk7XG4gICAgICAgIHRoaXMuX2xhc3RXaGVlbEV2ZW50VGltZSA9IG8sIDAgIT09IGkgJiYgaSAlIDQuMDAwMjQ0MTQwNjI1ID09IDAgPyB0aGlzLl90eXBlID0gXCJ3aGVlbFwiIDogMCAhPT0gaSAmJiBNYXRoLmFicyhpKSA8IDQgPyB0aGlzLl90eXBlID0gXCJ0cmFja3BhZFwiIDogciA+IDQwMCA/ICh0aGlzLl90eXBlID0gbnVsbCwgdGhpcy5fbGFzdFZhbHVlID0gaSwgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fb25UaW1lb3V0LCA0MCwgZSkpIDogdGhpcy5fdHlwZSB8fCAodGhpcy5fdHlwZSA9IE1hdGguYWJzKHIgKiBpKSA8IDIwMCA/IFwidHJhY2twYWRcIiA6IFwid2hlZWxcIiwgdGhpcy5fdGltZW91dCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCwgaSArPSB0aGlzLl9sYXN0VmFsdWUpKSwgZS5zaGlmdEtleSAmJiBpICYmIChpIC89IDQpLCB0aGlzLl90eXBlICYmICh0aGlzLl9sYXN0V2hlZWxFdmVudCA9IGUsIHRoaXMuX2RlbHRhIC09IGksIHRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9zdGFydChlKSksIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LCBzci5wcm90b3R5cGUuX29uVGltZW91dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl90eXBlID0gXCJ3aGVlbFwiLCB0aGlzLl9kZWx0YSAtPSB0aGlzLl9sYXN0VmFsdWUsIHRoaXMuX2FjdGl2ZSB8fCB0aGlzLl9zdGFydCh0KTtcbiAgICB9LCBzci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLl9kZWx0YSkge1xuICAgICAgICB0aGlzLl9mcmFtZUlkICYmICh0aGlzLl9mcmFtZUlkID0gbnVsbCksIHRoaXMuX2FjdGl2ZSA9ICEwLCB0aGlzLmlzWm9vbWluZygpIHx8ICh0aGlzLl96b29taW5nID0gITApLCB0aGlzLl9maW5pc2hUaW1lb3V0ICYmIChjbGVhclRpbWVvdXQodGhpcy5fZmluaXNoVGltZW91dCksIGRlbGV0ZSB0aGlzLl9maW5pc2hUaW1lb3V0KTtcbiAgICAgICAgdmFyIG8gPSBpLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fYXJvdW5kID0gdC5MbmdMYXQuY29udmVydCh0aGlzLl9hcm91bmRDZW50ZXIgPyB0aGlzLl9tYXAuZ2V0Q2VudGVyKCkgOiB0aGlzLl9tYXAudW5wcm9qZWN0KG8pKSwgdGhpcy5fYXJvdW5kUG9pbnQgPSB0aGlzLl9tYXAudHJhbnNmb3JtLmxvY2F0aW9uUG9pbnQodGhpcy5fYXJvdW5kKSwgdGhpcy5fZnJhbWVJZCB8fCAodGhpcy5fZnJhbWVJZCA9ICEwLCB0aGlzLl9oYW5kbGVyLl90cmlnZ2VyUmVuZGVyRnJhbWUoKSk7XG4gICAgICB9XG4gICAgfSwgc3IucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQgJiYgKHRoaXMuX2ZyYW1lSWQgPSBudWxsLCB0aGlzLmlzQWN0aXZlKCkpKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fbWFwLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKDAgIT09IHRoaXMuX2RlbHRhKSB7XG4gICAgICAgICAgdmFyIG8gPSBcIndoZWVsXCIgPT09IHRoaXMuX3R5cGUgJiYgTWF0aC5hYnModGhpcy5fZGVsdGEpID4gNC4wMDAyNDQxNDA2MjUgPyB0aGlzLl93aGVlbFpvb21SYXRlIDogdGhpcy5fZGVmYXVsdFpvb21SYXRlLFxuICAgICAgICAgICAgciA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyh0aGlzLl9kZWx0YSAqIG8pKSk7XG4gICAgICAgICAgdGhpcy5fZGVsdGEgPCAwICYmIDAgIT09IHIgJiYgKHIgPSAxIC8gcik7XG4gICAgICAgICAgdmFyIGEgPSBcIm51bWJlclwiID09IHR5cGVvZiB0aGlzLl90YXJnZXRab29tID8gaS56b29tU2NhbGUodGhpcy5fdGFyZ2V0Wm9vbSkgOiBpLnNjYWxlO1xuICAgICAgICAgIHRoaXMuX3RhcmdldFpvb20gPSBNYXRoLm1pbihpLm1heFpvb20sIE1hdGgubWF4KGkubWluWm9vbSwgaS5zY2FsZVpvb20oYSAqIHIpKSksIFwid2hlZWxcIiA9PT0gdGhpcy5fdHlwZSAmJiAodGhpcy5fc3RhcnRab29tID0gaS56b29tLCB0aGlzLl9lYXNpbmcgPSB0aGlzLl9zbW9vdGhPdXRFYXNpbmcoMjAwKSksIHRoaXMuX2RlbHRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbixcbiAgICAgICAgICBzID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgdGhpcy5fdGFyZ2V0Wm9vbSA/IHRoaXMuX3RhcmdldFpvb20gOiBpLnpvb20sXG4gICAgICAgICAgbCA9IHRoaXMuX3N0YXJ0Wm9vbSxcbiAgICAgICAgICBjID0gdGhpcy5fZWFzaW5nLFxuICAgICAgICAgIHUgPSAhMTtcbiAgICAgICAgaWYgKFwid2hlZWxcIiA9PT0gdGhpcy5fdHlwZSAmJiBsICYmIGMpIHtcbiAgICAgICAgICB2YXIgaCA9IE1hdGgubWluKCh0LmJyb3dzZXIubm93KCkgLSB0aGlzLl9sYXN0V2hlZWxFdmVudFRpbWUpIC8gMjAwLCAxKSxcbiAgICAgICAgICAgIHAgPSBjKGgpO1xuICAgICAgICAgIG4gPSB0Lm51bWJlcihsLCBzLCBwKSwgaCA8IDEgPyB0aGlzLl9mcmFtZUlkIHx8ICh0aGlzLl9mcmFtZUlkID0gITApIDogdSA9ICEwO1xuICAgICAgICB9IGVsc2UgbiA9IHMsIHUgPSAhMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSA9ICEwLCB1ICYmICh0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fZmluaXNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUuX3pvb21pbmcgPSAhMSwgZS5faGFuZGxlci5fdHJpZ2dlclJlbmRlckZyYW1lKCksIGRlbGV0ZSBlLl90YXJnZXRab29tLCBkZWxldGUgZS5fZmluaXNoVGltZW91dDtcbiAgICAgICAgfSwgMjAwKSksIHtcbiAgICAgICAgICBub0luZXJ0aWE6ICEwLFxuICAgICAgICAgIG5lZWRzUmVuZGVyRnJhbWU6ICF1LFxuICAgICAgICAgIHpvb21EZWx0YTogbiAtIGkuem9vbSxcbiAgICAgICAgICBhcm91bmQ6IHRoaXMuX2Fyb3VuZFBvaW50LFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RXaGVlbEV2ZW50XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgc3IucHJvdG90eXBlLl9zbW9vdGhPdXRFYXNpbmcgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGkgPSB0LmVhc2U7XG4gICAgICBpZiAodGhpcy5fcHJldkVhc2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl9wcmV2RWFzZSxcbiAgICAgICAgICByID0gKHQuYnJvd3Nlci5ub3coKSAtIG8uc3RhcnQpIC8gby5kdXJhdGlvbixcbiAgICAgICAgICBhID0gby5lYXNpbmcociArIC4wMSkgLSBvLmVhc2luZyhyKSxcbiAgICAgICAgICBuID0gLjI3IC8gTWF0aC5zcXJ0KGEgKiBhICsgMWUtNCkgKiAuMDEsXG4gICAgICAgICAgcyA9IE1hdGguc3FydCguMDcyOSAtIG4gKiBuKTtcbiAgICAgICAgaSA9IHQuYmV6aWVyKG4sIHMsIC4yNSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcHJldkVhc2UgPSB7XG4gICAgICAgIHN0YXJ0OiB0LmJyb3dzZXIubm93KCksXG4gICAgICAgIGR1cmF0aW9uOiBlLFxuICAgICAgICBlYXNpbmc6IGlcbiAgICAgIH0sIGk7XG4gICAgfSwgc3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITE7XG4gICAgfTtcbiAgICB2YXIgbHIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5fY2xpY2tab29tID0gdCwgdGhpcy5fdGFwWm9vbSA9IGU7XG4gICAgfTtcbiAgICBsci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fY2xpY2tab29tLmVuYWJsZSgpLCB0aGlzLl90YXBab29tLmVuYWJsZSgpO1xuICAgIH0sIGxyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fY2xpY2tab29tLmRpc2FibGUoKSwgdGhpcy5fdGFwWm9vbS5kaXNhYmxlKCk7XG4gICAgfSwgbHIucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbGlja1pvb20uaXNFbmFibGVkKCkgJiYgdGhpcy5fdGFwWm9vbS5pc0VuYWJsZWQoKTtcbiAgICB9LCBsci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xpY2tab29tLmlzQWN0aXZlKCkgfHwgdGhpcy5fdGFwWm9vbS5pc0FjdGl2ZSgpO1xuICAgIH07XG4gICAgdmFyIGNyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG4gICAgY3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gITE7XG4gICAgfSwgY3IucHJvdG90eXBlLmRibGNsaWNrID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCksIHtcbiAgICAgICAgY2FtZXJhQW5pbWF0aW9uOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGkuZWFzZVRvKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICB6b29tOiBpLmdldFpvb20oKSArICh0LnNoaWZ0S2V5ID8gLTEgOiAxKSxcbiAgICAgICAgICAgIGFyb3VuZDogaS51bnByb2plY3QoZSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgY3IucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9LCBjci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSAhMSwgdGhpcy5yZXNldCgpO1xuICAgIH0sIGNyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LCBjci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH07XG4gICAgdmFyIHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fdGFwID0gbmV3IHFvKHtcbiAgICAgICAgbnVtVG91Y2hlczogMSxcbiAgICAgICAgbnVtVGFwczogMVxuICAgICAgfSksIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuICAgIHVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9ICExLCBkZWxldGUgdGhpcy5fc3dpcGVQb2ludCwgZGVsZXRlIHRoaXMuX3N3aXBlVG91Y2gsIGRlbGV0ZSB0aGlzLl90YXBUaW1lLCB0aGlzLl90YXAucmVzZXQoKTtcbiAgICB9LCB1ci5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB0aGlzLl9zd2lwZVBvaW50IHx8ICh0aGlzLl90YXBUaW1lICYmIHQudGltZVN0YW1wIC0gdGhpcy5fdGFwVGltZSA+IDUwMCAmJiB0aGlzLnJlc2V0KCksIHRoaXMuX3RhcFRpbWUgPyBpLmxlbmd0aCA+IDAgJiYgKHRoaXMuX3N3aXBlUG9pbnQgPSBlWzBdLCB0aGlzLl9zd2lwZVRvdWNoID0gaVswXS5pZGVudGlmaWVyKSA6IHRoaXMuX3RhcC50b3VjaHN0YXJ0KHQsIGUsIGkpKTtcbiAgICB9LCB1ci5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIGlmICh0aGlzLl90YXBUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9zd2lwZVBvaW50KSB7XG4gICAgICAgICAgaWYgKGlbMF0uaWRlbnRpZmllciAhPT0gdGhpcy5fc3dpcGVUb3VjaCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBvID0gZVswXSxcbiAgICAgICAgICAgIHIgPSBvLnkgLSB0aGlzLl9zd2lwZVBvaW50Lnk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N3aXBlUG9pbnQgPSBvLCB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2FjdGl2ZSA9ICEwLCB7XG4gICAgICAgICAgICB6b29tRGVsdGE6IHIgLyAxMjhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgdGhpcy5fdGFwLnRvdWNobW92ZSh0LCBlLCBpKTtcbiAgICB9LCB1ci5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fdGFwVGltZSA/IHRoaXMuX3N3aXBlUG9pbnQgJiYgMCA9PT0gaS5sZW5ndGggJiYgdGhpcy5yZXNldCgpIDogdGhpcy5fdGFwLnRvdWNoZW5kKHQsIGUsIGkpICYmICh0aGlzLl90YXBUaW1lID0gdC50aW1lU3RhbXApO1xuICAgIH0sIHVyLnByb3RvdHlwZS50b3VjaGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LCB1ci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICEwO1xuICAgIH0sIHVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9ICExLCB0aGlzLnJlc2V0KCk7XG4gICAgfSwgdXIucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sIHVyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfTtcbiAgICB2YXIgaHIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fZWwgPSB0LCB0aGlzLl9tb3VzZVBhbiA9IGUsIHRoaXMuX3RvdWNoUGFuID0gaTtcbiAgICB9O1xuICAgIGhyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5faW5lcnRpYU9wdGlvbnMgPSB0IHx8IHt9LCB0aGlzLl9tb3VzZVBhbi5lbmFibGUoKSwgdGhpcy5fdG91Y2hQYW4uZW5hYmxlKCksIHRoaXMuX2VsLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXRvdWNoLWRyYWctcGFuXCIsIFwibWFwYm94Z2wtdG91Y2gtZHJhZy1wYW5cIik7XG4gICAgfSwgaHIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9tb3VzZVBhbi5kaXNhYmxlKCksIHRoaXMuX3RvdWNoUGFuLmRpc2FibGUoKSwgdGhpcy5fZWwuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtdG91Y2gtZHJhZy1wYW5cIiwgXCJtYXBib3hnbC10b3VjaC1kcmFnLXBhblwiKTtcbiAgICB9LCBoci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlUGFuLmlzRW5hYmxlZCgpICYmIHRoaXMuX3RvdWNoUGFuLmlzRW5hYmxlZCgpO1xuICAgIH0sIGhyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZVBhbi5pc0FjdGl2ZSgpIHx8IHRoaXMuX3RvdWNoUGFuLmlzQWN0aXZlKCk7XG4gICAgfTtcbiAgICB2YXIgcHIgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgdGhpcy5fcGl0Y2hXaXRoUm90YXRlID0gdC5waXRjaFdpdGhSb3RhdGUsIHRoaXMuX21vdXNlUm90YXRlID0gZSwgdGhpcy5fbW91c2VQaXRjaCA9IGk7XG4gICAgfTtcbiAgICBwci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VSb3RhdGUuZW5hYmxlKCksIHRoaXMuX3BpdGNoV2l0aFJvdGF0ZSAmJiB0aGlzLl9tb3VzZVBpdGNoLmVuYWJsZSgpO1xuICAgIH0sIHByLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbW91c2VSb3RhdGUuZGlzYWJsZSgpLCB0aGlzLl9tb3VzZVBpdGNoLmRpc2FibGUoKTtcbiAgICB9LCBwci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdXNlUm90YXRlLmlzRW5hYmxlZCgpICYmICghdGhpcy5fcGl0Y2hXaXRoUm90YXRlIHx8IHRoaXMuX21vdXNlUGl0Y2guaXNFbmFibGVkKCkpO1xuICAgIH0sIHByLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3VzZVJvdGF0ZS5pc0FjdGl2ZSgpIHx8IHRoaXMuX21vdXNlUGl0Y2guaXNBY3RpdmUoKTtcbiAgICB9O1xuICAgIHZhciBkciA9IGZ1bmN0aW9uICh0LCBlLCBpLCBvKSB7XG4gICAgICB0aGlzLl9lbCA9IHQsIHRoaXMuX3RvdWNoWm9vbSA9IGUsIHRoaXMuX3RvdWNoUm90YXRlID0gaSwgdGhpcy5fdGFwRHJhZ1pvb20gPSBvLCB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gITEsIHRoaXMuX2VuYWJsZWQgPSAhMDtcbiAgICB9O1xuICAgIGRyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5fdG91Y2hab29tLmVuYWJsZSh0KSwgdGhpcy5fcm90YXRpb25EaXNhYmxlZCB8fCB0aGlzLl90b3VjaFJvdGF0ZS5lbmFibGUodCksIHRoaXMuX3RhcERyYWdab29tLmVuYWJsZSgpLCB0aGlzLl9lbC5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC10b3VjaC16b29tLXJvdGF0ZVwiLCBcIm1hcGJveGdsLXRvdWNoLXpvb20tcm90YXRlXCIpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fdG91Y2hab29tLmRpc2FibGUoKSwgdGhpcy5fdG91Y2hSb3RhdGUuZGlzYWJsZSgpLCB0aGlzLl90YXBEcmFnWm9vbS5kaXNhYmxlKCksIHRoaXMuX2VsLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLXRvdWNoLXpvb20tcm90YXRlXCIsIFwibWFwYm94Z2wtdG91Y2gtem9vbS1yb3RhdGVcIik7XG4gICAgfSwgZHIucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3VjaFpvb20uaXNFbmFibGVkKCkgJiYgKHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgfHwgdGhpcy5fdG91Y2hSb3RhdGUuaXNFbmFibGVkKCkpICYmIHRoaXMuX3RhcERyYWdab29tLmlzRW5hYmxlZCgpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3VjaFpvb20uaXNBY3RpdmUoKSB8fCB0aGlzLl90b3VjaFJvdGF0ZS5pc0FjdGl2ZSgpIHx8IHRoaXMuX3RhcERyYWdab29tLmlzQWN0aXZlKCk7XG4gICAgfSwgZHIucHJvdG90eXBlLmRpc2FibGVSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSAhMCwgdGhpcy5fdG91Y2hSb3RhdGUuZGlzYWJsZSgpO1xuICAgIH0sIGRyLnByb3RvdHlwZS5lbmFibGVSb3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSAhMSwgdGhpcy5fdG91Y2hab29tLmlzRW5hYmxlZCgpICYmIHRoaXMuX3RvdWNoUm90YXRlLmVuYWJsZSgpO1xuICAgIH07XG4gICAgdmFyIF9yID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuem9vbSB8fCB0LmRyYWcgfHwgdC5waXRjaCB8fCB0LnJvdGF0ZTtcbiAgICAgIH0sXG4gICAgICBmciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICYmIChlLl9fcHJvdG9fXyA9IHQpLCAoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IGUsIGU7XG4gICAgICB9KHQuRXZlbnQpO1xuICAgIGZ1bmN0aW9uIG1yKHQpIHtcbiAgICAgIHJldHVybiB0LnBhbkRlbHRhICYmIHQucGFuRGVsdGEubWFnKCkgfHwgdC56b29tRGVsdGEgfHwgdC5iZWFyaW5nRGVsdGEgfHwgdC5waXRjaERlbHRhO1xuICAgIH1cbiAgICB2YXIgZ3IgPSBmdW5jdGlvbiAoZSwgbykge1xuICAgICAgdGhpcy5fbWFwID0gZSwgdGhpcy5fZWwgPSB0aGlzLl9tYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCksIHRoaXMuX2hhbmRsZXJzID0gW10sIHRoaXMuX2hhbmRsZXJzQnlJZCA9IHt9LCB0aGlzLl9jaGFuZ2VzID0gW10sIHRoaXMuX2luZXJ0aWEgPSBuZXcgQW8oZSksIHRoaXMuX2JlYXJpbmdTbmFwID0gby5iZWFyaW5nU25hcCwgdGhpcy5fcHJldmlvdXNBY3RpdmVIYW5kbGVycyA9IHt9LCB0aGlzLl9ldmVudHNJblByb2dyZXNzID0ge30sIHRoaXMuX2FkZERlZmF1bHRIYW5kbGVycyhvKSwgdC5iaW5kQWxsKFtcImhhbmRsZUV2ZW50XCIsIFwiaGFuZGxlV2luZG93RXZlbnRcIl0sIHRoaXMpO1xuICAgICAgdmFyIHIgPSB0aGlzLl9lbDtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtbciwgXCJ0b3VjaHN0YXJ0XCIsIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH1dLCBbciwgXCJ0b3VjaG1vdmVcIiwge1xuICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgfV0sIFtyLCBcInRvdWNoZW5kXCIsIHZvaWQgMF0sIFtyLCBcInRvdWNoY2FuY2VsXCIsIHZvaWQgMF0sIFtyLCBcIm1vdXNlZG93blwiLCB2b2lkIDBdLCBbciwgXCJtb3VzZW1vdmVcIiwgdm9pZCAwXSwgW3IsIFwibW91c2V1cFwiLCB2b2lkIDBdLCBbdC53aW5kb3cuZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIHtcbiAgICAgICAgY2FwdHVyZTogITBcbiAgICAgIH1dLCBbdC53aW5kb3cuZG9jdW1lbnQsIFwibW91c2V1cFwiLCB2b2lkIDBdLCBbciwgXCJtb3VzZW92ZXJcIiwgdm9pZCAwXSwgW3IsIFwibW91c2VvdXRcIiwgdm9pZCAwXSwgW3IsIFwiZGJsY2xpY2tcIiwgdm9pZCAwXSwgW3IsIFwiY2xpY2tcIiwgdm9pZCAwXSwgW3IsIFwia2V5ZG93blwiLCB7XG4gICAgICAgIGNhcHR1cmU6ICExXG4gICAgICB9XSwgW3IsIFwia2V5dXBcIiwgdm9pZCAwXSwgW3IsIFwid2hlZWxcIiwge1xuICAgICAgICBwYXNzaXZlOiAhMVxuICAgICAgfV0sIFtyLCBcImNvbnRleHRtZW51XCIsIHZvaWQgMF0sIFt0LndpbmRvdywgXCJibHVyXCIsIHZvaWQgMF1dO1xuICAgICAgZm9yICh2YXIgYSA9IDAsIG4gPSB0aGlzLl9saXN0ZW5lcnM7IGEgPCBuLmxlbmd0aDsgYSArPSAxKSB7XG4gICAgICAgIHZhciBzID0gblthXSxcbiAgICAgICAgICBsID0gc1swXTtcbiAgICAgICAgaS5hZGRFdmVudExpc3RlbmVyKGwsIHNbMV0sIGwgPT09IHQud2luZG93LmRvY3VtZW50ID8gdGhpcy5oYW5kbGVXaW5kb3dFdmVudCA6IHRoaXMuaGFuZGxlRXZlbnQsIHNbMl0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZ3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBlID0gMCwgbyA9IHRoaXMuX2xpc3RlbmVyczsgZSA8IG8ubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgICAgdmFyIHIgPSBvW2VdLFxuICAgICAgICAgIGEgPSByWzBdO1xuICAgICAgICBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgclsxXSwgYSA9PT0gdC53aW5kb3cuZG9jdW1lbnQgPyB0aGlzLmhhbmRsZVdpbmRvd0V2ZW50IDogdGhpcy5oYW5kbGVFdmVudCwgclsyXSk7XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLl9hZGREZWZhdWx0SGFuZGxlcnMgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9tYXAsXG4gICAgICAgIGkgPSBlLmdldENhbnZhc0NvbnRhaW5lcigpO1xuICAgICAgdGhpcy5fYWRkKFwibWFwRXZlbnRcIiwgbmV3IE9vKGUsIHQpKTtcbiAgICAgIHZhciBvID0gZS5ib3hab29tID0gbmV3IFVvKGUsIHQpO1xuICAgICAgdGhpcy5fYWRkKFwiYm94Wm9vbVwiLCBvKTtcbiAgICAgIHZhciByID0gbmV3IGpvKCksXG4gICAgICAgIGEgPSBuZXcgY3IoKTtcbiAgICAgIGUuZG91YmxlQ2xpY2tab29tID0gbmV3IGxyKGEsIHIpLCB0aGlzLl9hZGQoXCJ0YXBab29tXCIsIHIpLCB0aGlzLl9hZGQoXCJjbGlja1pvb21cIiwgYSk7XG4gICAgICB2YXIgbiA9IG5ldyB1cigpO1xuICAgICAgdGhpcy5fYWRkKFwidGFwRHJhZ1pvb21cIiwgbik7XG4gICAgICB2YXIgcyA9IGUudG91Y2hQaXRjaCA9IG5ldyBvcigpO1xuICAgICAgdGhpcy5fYWRkKFwidG91Y2hQaXRjaFwiLCBzKTtcbiAgICAgIHZhciBsID0gbmV3IFhvKHQpLFxuICAgICAgICBjID0gbmV3IEhvKHQpO1xuICAgICAgZS5kcmFnUm90YXRlID0gbmV3IHByKHQsIGwsIGMpLCB0aGlzLl9hZGQoXCJtb3VzZVJvdGF0ZVwiLCBsLCBbXCJtb3VzZVBpdGNoXCJdKSwgdGhpcy5fYWRkKFwibW91c2VQaXRjaFwiLCBjLCBbXCJtb3VzZVJvdGF0ZVwiXSk7XG4gICAgICB2YXIgdSA9IG5ldyBXbyh0KSxcbiAgICAgICAgaCA9IG5ldyBLbyh0KTtcbiAgICAgIGUuZHJhZ1BhbiA9IG5ldyBocihpLCB1LCBoKSwgdGhpcy5fYWRkKFwibW91c2VQYW5cIiwgdSksIHRoaXMuX2FkZChcInRvdWNoUGFuXCIsIGgsIFtcInRvdWNoWm9vbVwiLCBcInRvdWNoUm90YXRlXCJdKTtcbiAgICAgIHZhciBwID0gbmV3IGVyKCksXG4gICAgICAgIGQgPSBuZXcgJG8oKTtcbiAgICAgIGUudG91Y2hab29tUm90YXRlID0gbmV3IGRyKGksIGQsIHAsIG4pLCB0aGlzLl9hZGQoXCJ0b3VjaFJvdGF0ZVwiLCBwLCBbXCJ0b3VjaFBhblwiLCBcInRvdWNoWm9vbVwiXSksIHRoaXMuX2FkZChcInRvdWNoWm9vbVwiLCBkLCBbXCJ0b3VjaFBhblwiLCBcInRvdWNoUm90YXRlXCJdKTtcbiAgICAgIHZhciBfID0gZS5zY3JvbGxab29tID0gbmV3IHNyKGUsIHRoaXMpO1xuICAgICAgdGhpcy5fYWRkKFwic2Nyb2xsWm9vbVwiLCBfLCBbXCJtb3VzZVBhblwiXSk7XG4gICAgICB2YXIgZiA9IGUua2V5Ym9hcmQgPSBuZXcgYXIoKTtcbiAgICAgIHRoaXMuX2FkZChcImtleWJvYXJkXCIsIGYpLCB0aGlzLl9hZGQoXCJibG9ja2FibGVNYXBFdmVudFwiLCBuZXcgRm8oZSkpO1xuICAgICAgZm9yICh2YXIgbSA9IDAsIGcgPSBbXCJib3hab29tXCIsIFwiZG91YmxlQ2xpY2tab29tXCIsIFwidGFwRHJhZ1pvb21cIiwgXCJ0b3VjaFBpdGNoXCIsIFwiZHJhZ1JvdGF0ZVwiLCBcImRyYWdQYW5cIiwgXCJ0b3VjaFpvb21Sb3RhdGVcIiwgXCJzY3JvbGxab29tXCIsIFwia2V5Ym9hcmRcIl07IG0gPCBnLmxlbmd0aDsgbSArPSAxKSB7XG4gICAgICAgIHZhciB2ID0gZ1ttXTtcbiAgICAgICAgdC5pbnRlcmFjdGl2ZSAmJiB0W3ZdICYmIGVbdl0uZW5hYmxlKHRbdl0pO1xuICAgICAgfVxuICAgIH0sIGdyLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goe1xuICAgICAgICBoYW5kbGVyTmFtZTogdCxcbiAgICAgICAgaGFuZGxlcjogZSxcbiAgICAgICAgYWxsb3dlZDogaVxuICAgICAgfSksIHRoaXMuX2hhbmRsZXJzQnlJZFt0XSA9IGU7XG4gICAgfSwgZ3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodCkge1xuICAgICAgaWYgKCF0aGlzLl91cGRhdGluZ0NhbWVyYSkge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgaSA9IHRoaXMuX2hhbmRsZXJzOyBlIDwgaS5sZW5ndGg7IGUgKz0gMSkgaVtlXS5oYW5kbGVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2luZXJ0aWEuY2xlYXIoKSwgdGhpcy5fZmlyZUV2ZW50cyh7fSwge30sIHQpLCB0aGlzLl9jaGFuZ2VzID0gW107XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgdCA9IDAsIGUgPSB0aGlzLl9oYW5kbGVyczsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGlmIChlW3RdLmhhbmRsZXIuaXNBY3RpdmUoKSkgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGdyLnByb3RvdHlwZS5pc1pvb21pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9ldmVudHNJblByb2dyZXNzLnpvb20gfHwgdGhpcy5fbWFwLnNjcm9sbFpvb20uaXNab29taW5nKCk7XG4gICAgfSwgZ3IucHJvdG90eXBlLmlzUm90YXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9ldmVudHNJblByb2dyZXNzLnJvdGF0ZTtcbiAgICB9LCBnci5wcm90b3R5cGUuaXNNb3ZpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihfcih0aGlzLl9ldmVudHNJblByb2dyZXNzKSkgfHwgdGhpcy5pc1pvb21pbmcoKTtcbiAgICB9LCBnci5wcm90b3R5cGUuX2Jsb2NrZWRCeUFjdGl2ZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICBmb3IgKHZhciBvIGluIHQpIGlmIChvICE9PSBpICYmICghZSB8fCBlLmluZGV4T2YobykgPCAwKSkgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGdyLnByb3RvdHlwZS5oYW5kbGVXaW5kb3dFdmVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmhhbmRsZUV2ZW50KHQsIHQudHlwZSArIFwiV2luZG93XCIpO1xuICAgIH0sIGdyLnByb3RvdHlwZS5fZ2V0TWFwVG91Y2hlcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gW10sIGkgPSAwLCBvID0gdDsgaSA8IG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHIgPSBvW2ldO1xuICAgICAgICB0aGlzLl9lbC5jb250YWlucyhyLnRhcmdldCkgJiYgZS5wdXNoKHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSwgZ3IucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGlmIChcImJsdXJcIiAhPT0gdC50eXBlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0aW5nQ2FtZXJhID0gITA7XG4gICAgICAgIGZvciAodmFyIG8gPSBcInJlbmRlckZyYW1lXCIgPT09IHQudHlwZSA/IHZvaWQgMCA6IHQsIHIgPSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlckZyYW1lOiAhMVxuICAgICAgICAgIH0sIGEgPSB7fSwgbiA9IHt9LCBzID0gdC50b3VjaGVzID8gdGhpcy5fZ2V0TWFwVG91Y2hlcyh0LnRvdWNoZXMpIDogdm9pZCAwLCBsID0gcyA/IGkudG91Y2hQb3ModGhpcy5fZWwsIHMpIDogaS5tb3VzZVBvcyh0aGlzLl9lbCwgdCksIGMgPSAwLCB1ID0gdGhpcy5faGFuZGxlcnM7IGMgPCB1Lmxlbmd0aDsgYyArPSAxKSB7XG4gICAgICAgICAgdmFyIGggPSB1W2NdLFxuICAgICAgICAgICAgcCA9IGguaGFuZGxlck5hbWUsXG4gICAgICAgICAgICBkID0gaC5oYW5kbGVyLFxuICAgICAgICAgICAgXyA9IGguYWxsb3dlZDtcbiAgICAgICAgICBpZiAoZC5pc0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdmFyIGYgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja2VkQnlBY3RpdmUobiwgXywgcCkgPyBkLnJlc2V0KCkgOiBkW2UgfHwgdC50eXBlXSAmJiAoZiA9IGRbZSB8fCB0LnR5cGVdKHQsIGwsIHMpLCB0aGlzLm1lcmdlSGFuZGxlclJlc3VsdChyLCBhLCBmLCBwLCBvKSwgZiAmJiBmLm5lZWRzUmVuZGVyRnJhbWUgJiYgdGhpcy5fdHJpZ2dlclJlbmRlckZyYW1lKCkpLCAoZiB8fCBkLmlzQWN0aXZlKCkpICYmIChuW3BdID0gZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtID0ge307XG4gICAgICAgIGZvciAodmFyIGcgaW4gdGhpcy5fcHJldmlvdXNBY3RpdmVIYW5kbGVycykgbltnXSB8fCAobVtnXSA9IG8pO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0FjdGl2ZUhhbmRsZXJzID0gbiwgKE9iamVjdC5rZXlzKG0pLmxlbmd0aCB8fCBtcihyKSkgJiYgKHRoaXMuX2NoYW5nZXMucHVzaChbciwgYSwgbV0pLCB0aGlzLl90cmlnZ2VyUmVuZGVyRnJhbWUoKSksIChPYmplY3Qua2V5cyhuKS5sZW5ndGggfHwgbXIocikpICYmIHRoaXMuX21hcC5fc3RvcCghMCksIHRoaXMuX3VwZGF0aW5nQ2FtZXJhID0gITE7XG4gICAgICAgIHZhciB2ID0gci5jYW1lcmFBbmltYXRpb247XG4gICAgICAgIHYgJiYgKHRoaXMuX2luZXJ0aWEuY2xlYXIoKSwgdGhpcy5fZmlyZUV2ZW50cyh7fSwge30sICEwKSwgdGhpcy5fY2hhbmdlcyA9IFtdLCB2KHRoaXMuX21hcCkpO1xuICAgICAgfSBlbHNlIHRoaXMuc3RvcCghMCk7XG4gICAgfSwgZ3IucHJvdG90eXBlLm1lcmdlSGFuZGxlclJlc3VsdCA9IGZ1bmN0aW9uIChlLCBpLCBvLCByLCBhKSB7XG4gICAgICBpZiAobykge1xuICAgICAgICB0LmV4dGVuZChlLCBvKTtcbiAgICAgICAgdmFyIG4gPSB7XG4gICAgICAgICAgaGFuZGxlck5hbWU6IHIsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogby5vcmlnaW5hbEV2ZW50IHx8IGFcbiAgICAgICAgfTtcbiAgICAgICAgdm9pZCAwICE9PSBvLnpvb21EZWx0YSAmJiAoaS56b29tID0gbiksIHZvaWQgMCAhPT0gby5wYW5EZWx0YSAmJiAoaS5kcmFnID0gbiksIHZvaWQgMCAhPT0gby5waXRjaERlbHRhICYmIChpLnBpdGNoID0gbiksIHZvaWQgMCAhPT0gby5iZWFyaW5nRGVsdGEgJiYgKGkucm90YXRlID0gbik7XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLl9hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBlID0ge30sIGkgPSB7fSwgbyA9IHt9LCByID0gMCwgYSA9IHRoaXMuX2NoYW5nZXM7IHIgPCBhLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgIHZhciBuID0gYVtyXSxcbiAgICAgICAgICBzID0gblswXSxcbiAgICAgICAgICBsID0gblsxXSxcbiAgICAgICAgICBjID0gblsyXTtcbiAgICAgICAgcy5wYW5EZWx0YSAmJiAoZS5wYW5EZWx0YSA9IChlLnBhbkRlbHRhIHx8IG5ldyB0LlBvaW50KDAsIDApKS5fYWRkKHMucGFuRGVsdGEpKSwgcy56b29tRGVsdGEgJiYgKGUuem9vbURlbHRhID0gKGUuem9vbURlbHRhIHx8IDApICsgcy56b29tRGVsdGEpLCBzLmJlYXJpbmdEZWx0YSAmJiAoZS5iZWFyaW5nRGVsdGEgPSAoZS5iZWFyaW5nRGVsdGEgfHwgMCkgKyBzLmJlYXJpbmdEZWx0YSksIHMucGl0Y2hEZWx0YSAmJiAoZS5waXRjaERlbHRhID0gKGUucGl0Y2hEZWx0YSB8fCAwKSArIHMucGl0Y2hEZWx0YSksIHZvaWQgMCAhPT0gcy5hcm91bmQgJiYgKGUuYXJvdW5kID0gcy5hcm91bmQpLCB2b2lkIDAgIT09IHMucGluY2hBcm91bmQgJiYgKGUucGluY2hBcm91bmQgPSBzLnBpbmNoQXJvdW5kKSwgcy5ub0luZXJ0aWEgJiYgKGUubm9JbmVydGlhID0gcy5ub0luZXJ0aWEpLCB0LmV4dGVuZChpLCBsKSwgdC5leHRlbmQobywgYyk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVNYXBUcmFuc2Zvcm0oZSwgaSwgbyksIHRoaXMuX2NoYW5nZXMgPSBbXTtcbiAgICB9LCBnci5wcm90b3R5cGUuX3VwZGF0ZU1hcFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuX21hcCxcbiAgICAgICAgciA9IG8udHJhbnNmb3JtO1xuICAgICAgaWYgKCFtcih0KSkgcmV0dXJuIHRoaXMuX2ZpcmVFdmVudHMoZSwgaSwgITApO1xuICAgICAgdmFyIGEgPSB0LnBhbkRlbHRhLFxuICAgICAgICBuID0gdC56b29tRGVsdGEsXG4gICAgICAgIHMgPSB0LmJlYXJpbmdEZWx0YSxcbiAgICAgICAgbCA9IHQucGl0Y2hEZWx0YSxcbiAgICAgICAgYyA9IHQuYXJvdW5kLFxuICAgICAgICB1ID0gdC5waW5jaEFyb3VuZDtcbiAgICAgIHZvaWQgMCAhPT0gdSAmJiAoYyA9IHUpLCBvLl9zdG9wKCEwKSwgYyA9IGMgfHwgby50cmFuc2Zvcm0uY2VudGVyUG9pbnQ7XG4gICAgICB2YXIgaCA9IHIucG9pbnRMb2NhdGlvbihhID8gYy5zdWIoYSkgOiBjKTtcbiAgICAgIHMgJiYgKHIuYmVhcmluZyArPSBzKSwgbCAmJiAoci5waXRjaCArPSBsKSwgbiAmJiAoci56b29tICs9IG4pLCByLnNldExvY2F0aW9uQXRQb2ludChoLCBjKSwgdGhpcy5fbWFwLl91cGRhdGUoKSwgdC5ub0luZXJ0aWEgfHwgdGhpcy5faW5lcnRpYS5yZWNvcmQodCksIHRoaXMuX2ZpcmVFdmVudHMoZSwgaSwgITApO1xuICAgIH0sIGdyLnByb3RvdHlwZS5fZmlyZUV2ZW50cyA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICB2YXIgciA9IHRoaXMsXG4gICAgICAgIGEgPSBfcih0aGlzLl9ldmVudHNJblByb2dyZXNzKSxcbiAgICAgICAgbiA9IF9yKGUpLFxuICAgICAgICBzID0ge307XG4gICAgICBmb3IgKHZhciBsIGluIGUpIHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3NbbF0gfHwgKHNbbCArIFwic3RhcnRcIl0gPSBlW2xdLm9yaWdpbmFsRXZlbnQpLCB0aGlzLl9ldmVudHNJblByb2dyZXNzW2xdID0gZVtsXTtcbiAgICAgIGZvciAodmFyIGMgaW4gIWEgJiYgbiAmJiB0aGlzLl9maXJlRXZlbnQoXCJtb3Zlc3RhcnRcIiwgbi5vcmlnaW5hbEV2ZW50KSwgcykgdGhpcy5fZmlyZUV2ZW50KGMsIHNbY10pO1xuICAgICAgZm9yICh2YXIgdSBpbiBuICYmIHRoaXMuX2ZpcmVFdmVudChcIm1vdmVcIiwgbi5vcmlnaW5hbEV2ZW50KSwgZSkgdGhpcy5fZmlyZUV2ZW50KHUsIGVbdV0ub3JpZ2luYWxFdmVudCk7XG4gICAgICB2YXIgaCxcbiAgICAgICAgcCA9IHt9O1xuICAgICAgZm9yICh2YXIgZCBpbiB0aGlzLl9ldmVudHNJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fZXZlbnRzSW5Qcm9ncmVzc1tkXSxcbiAgICAgICAgICBmID0gXy5oYW5kbGVyTmFtZSxcbiAgICAgICAgICBtID0gXy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLl9oYW5kbGVyc0J5SWRbZl0uaXNBY3RpdmUoKSB8fCAoZGVsZXRlIHRoaXMuX2V2ZW50c0luUHJvZ3Jlc3NbZF0sIHBbZCArIFwiZW5kXCJdID0gaCA9IGlbZl0gfHwgbSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBnIGluIHApIHRoaXMuX2ZpcmVFdmVudChnLCBwW2ddKTtcbiAgICAgIHZhciB2ID0gX3IodGhpcy5fZXZlbnRzSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAobyAmJiAoYSB8fCBuKSAmJiAhdikge1xuICAgICAgICB0aGlzLl91cGRhdGluZ0NhbWVyYSA9ICEwO1xuICAgICAgICB2YXIgeSA9IHRoaXMuX2luZXJ0aWEuX29uTW92ZUVuZCh0aGlzLl9tYXAuZHJhZ1Bhbi5faW5lcnRpYU9wdGlvbnMpLFxuICAgICAgICAgIHggPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIDAgIT09IHQgJiYgLXIuX2JlYXJpbmdTbmFwIDwgdCAmJiB0IDwgci5fYmVhcmluZ1NuYXA7XG4gICAgICAgICAgfTtcbiAgICAgICAgeSA/ICh4KHkuYmVhcmluZyB8fCB0aGlzLl9tYXAuZ2V0QmVhcmluZygpKSAmJiAoeS5iZWFyaW5nID0gMCksIHRoaXMuX21hcC5lYXNlVG8oeSwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGhcbiAgICAgICAgfSkpIDogKHRoaXMuX21hcC5maXJlKG5ldyB0LkV2ZW50KFwibW92ZWVuZFwiLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogaFxuICAgICAgICB9KSksIHgodGhpcy5fbWFwLmdldEJlYXJpbmcoKSkgJiYgdGhpcy5fbWFwLnJlc2V0Tm9ydGgoKSksIHRoaXMuX3VwZGF0aW5nQ2FtZXJhID0gITE7XG4gICAgICB9XG4gICAgfSwgZ3IucHJvdG90eXBlLl9maXJlRXZlbnQgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgdGhpcy5fbWFwLmZpcmUobmV3IHQuRXZlbnQoZSwgaSA/IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogaVxuICAgICAgfSA6IHt9KSk7XG4gICAgfSwgZ3IucHJvdG90eXBlLl9yZXF1ZXN0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLnRyaWdnZXJSZXBhaW50KCksIHRoaXMuX21hcC5fcmVuZGVyVGFza1F1ZXVlLmFkZChmdW5jdGlvbiAoZSkge1xuICAgICAgICBkZWxldGUgdC5fZnJhbWVJZCwgdC5oYW5kbGVFdmVudChuZXcgZnIoXCJyZW5kZXJGcmFtZVwiLCB7XG4gICAgICAgICAgdGltZVN0YW1wOiBlXG4gICAgICAgIH0pKSwgdC5fYXBwbHlDaGFuZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9LCBnci5wcm90b3R5cGUuX3RyaWdnZXJSZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZvaWQgMCA9PT0gdGhpcy5fZnJhbWVJZCAmJiAodGhpcy5fZnJhbWVJZCA9IHRoaXMuX3JlcXVlc3RGcmFtZSgpKTtcbiAgICB9O1xuICAgIHZhciB2ciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGkoaSwgbykge1xuICAgICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5fbW92aW5nID0gITEsIHRoaXMuX3pvb21pbmcgPSAhMSwgdGhpcy50cmFuc2Zvcm0gPSBpLCB0aGlzLl9iZWFyaW5nU25hcCA9IG8uYmVhcmluZ1NuYXAsIHQuYmluZEFsbChbXCJfcmVuZGVyRnJhbWVDYWxsYmFja1wiXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKGkuX19wcm90b19fID0gZSksIChpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gaSwgaS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdC5MbmdMYXQodGhpcy50cmFuc2Zvcm0uY2VudGVyLmxuZywgdGhpcy50cmFuc2Zvcm0uY2VudGVyLmxhdCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICAgIGNlbnRlcjogdFxuICAgICAgICAgIH0sIGUpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5wYW5CeSA9IGZ1bmN0aW9uIChlLCBpLCBvKSB7XG4gICAgICAgICAgcmV0dXJuIGUgPSB0LlBvaW50LmNvbnZlcnQoZSkubXVsdCgtMSksIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB0LmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IGVcbiAgICAgICAgICB9LCBpKSwgbyk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnBhblRvID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lYXNlVG8odC5leHRlbmQoe1xuICAgICAgICAgICAgY2VudGVyOiBlXG4gICAgICAgICAgfSwgaSksIG8pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS56b29tO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5qdW1wVG8oe1xuICAgICAgICAgICAgem9vbTogdFxuICAgICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh0LmV4dGVuZCh7XG4gICAgICAgICAgICB6b29tOiBlXG4gICAgICAgICAgfSwgaSksIG8pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS56b29tSW4gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnpvb21Ubyh0aGlzLmdldFpvb20oKSArIDEsIHQsIGUpLCB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS56b29tT3V0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgLSAxLCB0LCBlKSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0QmVhcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uYmVhcmluZztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0QmVhcmluZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICAgIGJlYXJpbmc6IHRcbiAgICAgICAgICB9LCBlKSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGFkZGluZztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuc2V0UGFkZGluZyA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICAgIHBhZGRpbmc6IHRcbiAgICAgICAgICB9LCBlKSwgdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucm90YXRlVG8gPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh0LmV4dGVuZCh7XG4gICAgICAgICAgICBiZWFyaW5nOiBlXG4gICAgICAgICAgfSwgaSksIG8pO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5yZXNldE5vcnRoID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVUbygwLCB0LmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogMWUzXG4gICAgICAgICAgfSwgZSksIGkpLCB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5yZXNldE5vcnRoUGl0Y2ggPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh0LmV4dGVuZCh7XG4gICAgICAgICAgICBiZWFyaW5nOiAwLFxuICAgICAgICAgICAgcGl0Y2g6IDAsXG4gICAgICAgICAgICBkdXJhdGlvbjogMWUzXG4gICAgICAgICAgfSwgZSksIGkpLCB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zbmFwVG9Ob3J0aCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0QmVhcmluZygpKSA8IHRoaXMuX2JlYXJpbmdTbmFwID8gdGhpcy5yZXNldE5vcnRoKHQsIGUpIDogdGhpcztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuZ2V0UGl0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdGNoO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zZXRQaXRjaCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanVtcFRvKHtcbiAgICAgICAgICAgIHBpdGNoOiB0XG4gICAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmNhbWVyYUZvckJvdW5kcyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgZSA9IHQuTG5nTGF0Qm91bmRzLmNvbnZlcnQoZSk7XG4gICAgICAgICAgdmFyIG8gPSBpICYmIGkuYmVhcmluZyB8fCAwO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYW1lcmFGb3JCb3hBbmRCZWFyaW5nKGUuZ2V0Tm9ydGhXZXN0KCksIGUuZ2V0U291dGhFYXN0KCksIG8sIGkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fY2FtZXJhRm9yQm94QW5kQmVhcmluZyA9IGZ1bmN0aW9uIChlLCBpLCBvLCByKSB7XG4gICAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiAociA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICAgIHBhZGRpbmc6IGEsXG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMudHJhbnNmb3JtLm1heFpvb21cbiAgICAgICAgICB9LCByKSkucGFkZGluZykge1xuICAgICAgICAgICAgdmFyIG4gPSByLnBhZGRpbmc7XG4gICAgICAgICAgICByLnBhZGRpbmcgPSB7XG4gICAgICAgICAgICAgIHRvcDogbixcbiAgICAgICAgICAgICAgYm90dG9tOiBuLFxuICAgICAgICAgICAgICByaWdodDogbixcbiAgICAgICAgICAgICAgbGVmdDogblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5wYWRkaW5nID0gdC5leHRlbmQoYSwgci5wYWRkaW5nKTtcbiAgICAgICAgICB2YXIgcyA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgbCA9IHMucGFkZGluZyxcbiAgICAgICAgICAgIGMgPSBzLnByb2plY3QodC5MbmdMYXQuY29udmVydChlKSksXG4gICAgICAgICAgICB1ID0gcy5wcm9qZWN0KHQuTG5nTGF0LmNvbnZlcnQoaSkpLFxuICAgICAgICAgICAgaCA9IGMucm90YXRlKC1vICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgICBwID0gdS5yb3RhdGUoLW8gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgICAgIGQgPSBuZXcgdC5Qb2ludChNYXRoLm1heChoLngsIHAueCksIE1hdGgubWF4KGgueSwgcC55KSksXG4gICAgICAgICAgICBfID0gbmV3IHQuUG9pbnQoTWF0aC5taW4oaC54LCBwLngpLCBNYXRoLm1pbihoLnksIHAueSkpLFxuICAgICAgICAgICAgZiA9IGQuc3ViKF8pLFxuICAgICAgICAgICAgbSA9IChzLndpZHRoIC0gKGwubGVmdCArIGwucmlnaHQgKyByLnBhZGRpbmcubGVmdCArIHIucGFkZGluZy5yaWdodCkpIC8gZi54LFxuICAgICAgICAgICAgZyA9IChzLmhlaWdodCAtIChsLnRvcCArIGwuYm90dG9tICsgci5wYWRkaW5nLnRvcCArIHIucGFkZGluZy5ib3R0b20pKSAvIGYueTtcbiAgICAgICAgICBpZiAoIShnIDwgMCB8fCBtIDwgMCkpIHtcbiAgICAgICAgICAgIHZhciB2ID0gTWF0aC5taW4ocy5zY2FsZVpvb20ocy5zY2FsZSAqIE1hdGgubWluKG0sIGcpKSwgci5tYXhab29tKSxcbiAgICAgICAgICAgICAgeSA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIHIub2Zmc2V0LnggPyBuZXcgdC5Qb2ludChyLm9mZnNldC54LCByLm9mZnNldC55KSA6IHQuUG9pbnQuY29udmVydChyLm9mZnNldCksXG4gICAgICAgICAgICAgIHggPSBuZXcgdC5Qb2ludCgoci5wYWRkaW5nLmxlZnQgLSByLnBhZGRpbmcucmlnaHQpIC8gMiwgKHIucGFkZGluZy50b3AgLSByLnBhZGRpbmcuYm90dG9tKSAvIDIpLnJvdGF0ZShvICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgICAgICAgIGIgPSB5LmFkZCh4KS5tdWx0KHMuc2NhbGUgLyBzLnpvb21TY2FsZSh2KSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjZW50ZXI6IHMudW5wcm9qZWN0KGMuYWRkKHUpLmRpdigyKS5zdWIoYikpLFxuICAgICAgICAgICAgICB6b29tOiB2LFxuICAgICAgICAgICAgICBiZWFyaW5nOiBvXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0Lndhcm5PbmNlKFwiTWFwIGNhbm5vdCBmaXQgd2l0aGluIGNhbnZhcyB3aXRoIHRoZSBnaXZlbiBib3VuZHMsIHBhZGRpbmcsIGFuZC9vciBvZmZzZXQuXCIpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5maXRCb3VuZHMgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maXRJbnRlcm5hbCh0aGlzLmNhbWVyYUZvckJvdW5kcyh0LCBlKSwgZSwgaSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmZpdFNjcmVlbkNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGUsIGksIG8sIHIsIGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZml0SW50ZXJuYWwodGhpcy5fY2FtZXJhRm9yQm94QW5kQmVhcmluZyh0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHQuUG9pbnQuY29udmVydChlKSksIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24odC5Qb2ludC5jb252ZXJ0KGkpKSwgbywgciksIHIsIGEpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fZml0SW50ZXJuYWwgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHJldHVybiBlID8gKGRlbGV0ZSAoaSA9IHQuZXh0ZW5kKGUsIGkpKS5wYWRkaW5nLCBpLmxpbmVhciA/IHRoaXMuZWFzZVRvKGksIG8pIDogdGhpcy5mbHlUbyhpLCBvKSkgOiB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5qdW1wVG8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIHZhciBvID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICByID0gITEsXG4gICAgICAgICAgICBhID0gITEsXG4gICAgICAgICAgICBuID0gITE7XG4gICAgICAgICAgcmV0dXJuIFwiem9vbVwiIGluIGUgJiYgby56b29tICE9PSArZS56b29tICYmIChyID0gITAsIG8uem9vbSA9ICtlLnpvb20pLCB2b2lkIDAgIT09IGUuY2VudGVyICYmIChvLmNlbnRlciA9IHQuTG5nTGF0LmNvbnZlcnQoZS5jZW50ZXIpKSwgXCJiZWFyaW5nXCIgaW4gZSAmJiBvLmJlYXJpbmcgIT09ICtlLmJlYXJpbmcgJiYgKGEgPSAhMCwgby5iZWFyaW5nID0gK2UuYmVhcmluZyksIFwicGl0Y2hcIiBpbiBlICYmIG8ucGl0Y2ggIT09ICtlLnBpdGNoICYmIChuID0gITAsIG8ucGl0Y2ggPSArZS5waXRjaCksIG51bGwgPT0gZS5wYWRkaW5nIHx8IG8uaXNQYWRkaW5nRXF1YWwoZS5wYWRkaW5nKSB8fCAoby5wYWRkaW5nID0gZS5wYWRkaW5nKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZXN0YXJ0XCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwibW92ZVwiLCBpKSksIHIgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiem9vbXN0YXJ0XCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwiem9vbVwiLCBpKSkuZmlyZShuZXcgdC5FdmVudChcInpvb21lbmRcIiwgaSkpLCBhICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZXN0YXJ0XCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwicm90YXRlXCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwicm90YXRlZW5kXCIsIGkpKSwgbiAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJwaXRjaHN0YXJ0XCIsIGkpKS5maXJlKG5ldyB0LkV2ZW50KFwicGl0Y2hcIiwgaSkpLmZpcmUobmV3IHQuRXZlbnQoXCJwaXRjaGVuZFwiLCBpKSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm1vdmVlbmRcIiwgaSkpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5lYXNlVG8gPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHZhciBvID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9zdG9wKCExLCBlLmVhc2VJZCksICghMSA9PT0gKGUgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHQuZWFzZVxuICAgICAgICAgIH0sIGUpKS5hbmltYXRlIHx8ICFlLmVzc2VudGlhbCAmJiB0LmJyb3dzZXIucHJlZmVyc1JlZHVjZWRNb3Rpb24pICYmIChlLmR1cmF0aW9uID0gMCk7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIGEgPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIG4gPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHMgPSB0aGlzLmdldFBpdGNoKCksXG4gICAgICAgICAgICBsID0gdGhpcy5nZXRQYWRkaW5nKCksXG4gICAgICAgICAgICBjID0gXCJ6b29tXCIgaW4gZSA/ICtlLnpvb20gOiBhLFxuICAgICAgICAgICAgdSA9IFwiYmVhcmluZ1wiIGluIGUgPyB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKGUuYmVhcmluZywgbikgOiBuLFxuICAgICAgICAgICAgaCA9IFwicGl0Y2hcIiBpbiBlID8gK2UucGl0Y2ggOiBzLFxuICAgICAgICAgICAgcCA9IFwicGFkZGluZ1wiIGluIGUgPyBlLnBhZGRpbmcgOiByLnBhZGRpbmcsXG4gICAgICAgICAgICBkID0gdC5Qb2ludC5jb252ZXJ0KGUub2Zmc2V0KSxcbiAgICAgICAgICAgIF8gPSByLmNlbnRlclBvaW50LmFkZChkKSxcbiAgICAgICAgICAgIGYgPSByLnBvaW50TG9jYXRpb24oXyksXG4gICAgICAgICAgICBtID0gdC5MbmdMYXQuY29udmVydChlLmNlbnRlciB8fCBmKTtcbiAgICAgICAgICB0aGlzLl9ub3JtYWxpemVDZW50ZXIobSk7XG4gICAgICAgICAgdmFyIGcsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgeSA9IHIucHJvamVjdChmKSxcbiAgICAgICAgICAgIHggPSByLnByb2plY3QobSkuc3ViKHkpLFxuICAgICAgICAgICAgYiA9IHIuem9vbVNjYWxlKGMgLSBhKTtcbiAgICAgICAgICBlLmFyb3VuZCAmJiAoZyA9IHQuTG5nTGF0LmNvbnZlcnQoZS5hcm91bmQpLCB2ID0gci5sb2NhdGlvblBvaW50KGcpKTtcbiAgICAgICAgICB2YXIgdyA9IHtcbiAgICAgICAgICAgIG1vdmluZzogdGhpcy5fbW92aW5nLFxuICAgICAgICAgICAgem9vbWluZzogdGhpcy5fem9vbWluZyxcbiAgICAgICAgICAgIHJvdGF0aW5nOiB0aGlzLl9yb3RhdGluZyxcbiAgICAgICAgICAgIHBpdGNoaW5nOiB0aGlzLl9waXRjaGluZ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3pvb21pbmcgPSB0aGlzLl96b29taW5nIHx8IGMgIT09IGEsIHRoaXMuX3JvdGF0aW5nID0gdGhpcy5fcm90YXRpbmcgfHwgbiAhPT0gdSwgdGhpcy5fcGl0Y2hpbmcgPSB0aGlzLl9waXRjaGluZyB8fCBoICE9PSBzLCB0aGlzLl9wYWRkaW5nID0gIXIuaXNQYWRkaW5nRXF1YWwocCksIHRoaXMuX2Vhc2VJZCA9IGUuZWFzZUlkLCB0aGlzLl9wcmVwYXJlRWFzZShpLCBlLm5vTW92ZVN0YXJ0LCB3KSwgdGhpcy5fZWFzZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKG8uX3pvb21pbmcgJiYgKHIuem9vbSA9IHQubnVtYmVyKGEsIGMsIGUpKSwgby5fcm90YXRpbmcgJiYgKHIuYmVhcmluZyA9IHQubnVtYmVyKG4sIHUsIGUpKSwgby5fcGl0Y2hpbmcgJiYgKHIucGl0Y2ggPSB0Lm51bWJlcihzLCBoLCBlKSksIG8uX3BhZGRpbmcgJiYgKHIuaW50ZXJwb2xhdGVQYWRkaW5nKGwsIHAsIGUpLCBfID0gci5jZW50ZXJQb2ludC5hZGQoZCkpLCBnKSByLnNldExvY2F0aW9uQXRQb2ludChnLCB2KTtlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSByLnpvb21TY2FsZShyLnpvb20gLSBhKSxcbiAgICAgICAgICAgICAgICBtID0gYyA+IGEgPyBNYXRoLm1pbigyLCBiKSA6IE1hdGgubWF4KC41LCBiKSxcbiAgICAgICAgICAgICAgICB3ID0gTWF0aC5wb3cobSwgMSAtIGUpLFxuICAgICAgICAgICAgICAgIFQgPSByLnVucHJvamVjdCh5LmFkZCh4Lm11bHQoZSAqIHcpKS5tdWx0KGYpKTtcbiAgICAgICAgICAgICAgci5zZXRMb2NhdGlvbkF0UG9pbnQoci5yZW5kZXJXb3JsZENvcGllcyA/IFQud3JhcCgpIDogVCwgXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLl9maXJlTW92ZUV2ZW50cyhpKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgby5fYWZ0ZXJFYXNlKGksIHQpO1xuICAgICAgICAgIH0sIGUpLCB0aGlzO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fcHJlcGFyZUVhc2UgPSBmdW5jdGlvbiAoZSwgaSwgbykge1xuICAgICAgICAgIHZvaWQgMCA9PT0gbyAmJiAobyA9IHt9KSwgdGhpcy5fbW92aW5nID0gITAsIGkgfHwgby5tb3ZpbmcgfHwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZXN0YXJ0XCIsIGUpKSwgdGhpcy5fem9vbWluZyAmJiAhby56b29taW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInpvb21zdGFydFwiLCBlKSksIHRoaXMuX3JvdGF0aW5nICYmICFvLnJvdGF0aW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZXN0YXJ0XCIsIGUpKSwgdGhpcy5fcGl0Y2hpbmcgJiYgIW8ucGl0Y2hpbmcgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicGl0Y2hzdGFydFwiLCBlKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9maXJlTW92ZUV2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZVwiLCBlKSksIHRoaXMuX3pvb21pbmcgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiem9vbVwiLCBlKSksIHRoaXMuX3JvdGF0aW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJvdGF0ZVwiLCBlKSksIHRoaXMuX3BpdGNoaW5nICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInBpdGNoXCIsIGUpKTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX2FmdGVyRWFzZSA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9lYXNlSWQgfHwgIWkgfHwgdGhpcy5fZWFzZUlkICE9PSBpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZWFzZUlkO1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLl96b29taW5nLFxuICAgICAgICAgICAgICByID0gdGhpcy5fcm90YXRpbmcsXG4gICAgICAgICAgICAgIGEgPSB0aGlzLl9waXRjaGluZztcbiAgICAgICAgICAgIHRoaXMuX21vdmluZyA9ICExLCB0aGlzLl96b29taW5nID0gITEsIHRoaXMuX3JvdGF0aW5nID0gITEsIHRoaXMuX3BpdGNoaW5nID0gITEsIHRoaXMuX3BhZGRpbmcgPSAhMSwgbyAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ6b29tZW5kXCIsIGUpKSwgciAmJiB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJyb3RhdGVlbmRcIiwgZSkpLCBhICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInBpdGNoZW5kXCIsIGUpKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZWVuZFwiLCBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBpLnByb3RvdHlwZS5mbHlUbyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICAgIGlmICghZS5lc3NlbnRpYWwgJiYgdC5icm93c2VyLnByZWZlcnNSZWR1Y2VkTW90aW9uKSB7XG4gICAgICAgICAgICB2YXIgciA9IHQucGljayhlLCBbXCJjZW50ZXJcIiwgXCJ6b29tXCIsIFwiYmVhcmluZ1wiLCBcInBpdGNoXCIsIFwiYXJvdW5kXCJdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmp1bXBUbyhyLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdG9wKCksIGUgPSB0LmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIHNwZWVkOiAxLjIsXG4gICAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICAgIGVhc2luZzogdC5lYXNlXG4gICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG4gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIHMgPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLmdldFBpdGNoKCksXG4gICAgICAgICAgICBjID0gdGhpcy5nZXRQYWRkaW5nKCksXG4gICAgICAgICAgICB1ID0gXCJ6b29tXCIgaW4gZSA/IHQuY2xhbXAoK2Uuem9vbSwgYS5taW5ab29tLCBhLm1heFpvb20pIDogbixcbiAgICAgICAgICAgIGggPSBcImJlYXJpbmdcIiBpbiBlID8gdGhpcy5fbm9ybWFsaXplQmVhcmluZyhlLmJlYXJpbmcsIHMpIDogcyxcbiAgICAgICAgICAgIHAgPSBcInBpdGNoXCIgaW4gZSA/ICtlLnBpdGNoIDogbCxcbiAgICAgICAgICAgIGQgPSBcInBhZGRpbmdcIiBpbiBlID8gZS5wYWRkaW5nIDogYS5wYWRkaW5nLFxuICAgICAgICAgICAgXyA9IGEuem9vbVNjYWxlKHUgLSBuKSxcbiAgICAgICAgICAgIGYgPSB0LlBvaW50LmNvbnZlcnQoZS5vZmZzZXQpLFxuICAgICAgICAgICAgbSA9IGEuY2VudGVyUG9pbnQuYWRkKGYpLFxuICAgICAgICAgICAgZyA9IGEucG9pbnRMb2NhdGlvbihtKSxcbiAgICAgICAgICAgIHYgPSB0LkxuZ0xhdC5jb252ZXJ0KGUuY2VudGVyIHx8IGcpO1xuICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZUNlbnRlcih2KTtcbiAgICAgICAgICB2YXIgeSA9IGEucHJvamVjdChnKSxcbiAgICAgICAgICAgIHggPSBhLnByb2plY3Qodikuc3ViKHkpLFxuICAgICAgICAgICAgYiA9IGUuY3VydmUsXG4gICAgICAgICAgICB3ID0gTWF0aC5tYXgoYS53aWR0aCwgYS5oZWlnaHQpLFxuICAgICAgICAgICAgVCA9IHcgLyBfLFxuICAgICAgICAgICAgRSA9IHgubWFnKCk7XG4gICAgICAgICAgaWYgKFwibWluWm9vbVwiIGluIGUpIHtcbiAgICAgICAgICAgIHZhciBJID0gdC5jbGFtcChNYXRoLm1pbihlLm1pblpvb20sIG4sIHUpLCBhLm1pblpvb20sIGEubWF4Wm9vbSksXG4gICAgICAgICAgICAgIFAgPSB3IC8gYS56b29tU2NhbGUoSSAtIG4pO1xuICAgICAgICAgICAgYiA9IE1hdGguc3FydChQIC8gRSAqIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgUyA9IGIgKiBiO1xuICAgICAgICAgIGZ1bmN0aW9uIEModCkge1xuICAgICAgICAgICAgdmFyIGUgPSAoVCAqIFQgLSB3ICogdyArICh0ID8gLTEgOiAxKSAqIFMgKiBTICogRSAqIEUpIC8gKDIgKiAodCA/IFQgOiB3KSAqIFMgKiBFKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyhNYXRoLnNxcnQoZSAqIGUgKyAxKSAtIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB6KHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5leHAodCkgLSBNYXRoLmV4cCgtdCkpIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gRCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKE1hdGguZXhwKHQpICsgTWF0aC5leHAoLXQpKSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBBID0gQygwKSxcbiAgICAgICAgICAgIE0gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gRChBKSAvIEQoQSArIGIgKiB0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBMID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHcgKiAoKEQoQSkgKiAoeihlID0gQSArIGIgKiB0KSAvIEQoZSkpIC0geihBKSkgLyBTKSAvIEU7XG4gICAgICAgICAgICAgIHZhciBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFIgPSAoQygxKSAtIEEpIC8gYjtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoRSkgPCAxZS02IHx8ICFpc0Zpbml0ZShSKSkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHcgLSBUKSA8IDFlLTYpIHJldHVybiB0aGlzLmVhc2VUbyhlLCBpKTtcbiAgICAgICAgICAgIHZhciBrID0gVCA8IHcgPyAtMSA6IDE7XG4gICAgICAgICAgICBSID0gTWF0aC5hYnMoTWF0aC5sb2coVCAvIHcpKSAvIGIsIEwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSwgTSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmV4cChrICogYiAqIHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUuZHVyYXRpb24gPSBcImR1cmF0aW9uXCIgaW4gZSA/ICtlLmR1cmF0aW9uIDogMWUzICogUiAvIChcInNjcmVlblNwZWVkXCIgaW4gZSA/ICtlLnNjcmVlblNwZWVkIC8gYiA6ICtlLnNwZWVkKSwgZS5tYXhEdXJhdGlvbiAmJiBlLmR1cmF0aW9uID4gZS5tYXhEdXJhdGlvbiAmJiAoZS5kdXJhdGlvbiA9IDApLCB0aGlzLl96b29taW5nID0gITAsIHRoaXMuX3JvdGF0aW5nID0gcyAhPT0gaCwgdGhpcy5fcGl0Y2hpbmcgPSBwICE9PSBsLCB0aGlzLl9wYWRkaW5nID0gIWEuaXNQYWRkaW5nRXF1YWwoZCksIHRoaXMuX3ByZXBhcmVFYXNlKGksICExKSwgdGhpcy5fZWFzZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBlICogUixcbiAgICAgICAgICAgICAgXyA9IDEgLyBNKHIpO1xuICAgICAgICAgICAgYS56b29tID0gMSA9PT0gZSA/IHUgOiBuICsgYS5zY2FsZVpvb20oXyksIG8uX3JvdGF0aW5nICYmIChhLmJlYXJpbmcgPSB0Lm51bWJlcihzLCBoLCBlKSksIG8uX3BpdGNoaW5nICYmIChhLnBpdGNoID0gdC5udW1iZXIobCwgcCwgZSkpLCBvLl9wYWRkaW5nICYmIChhLmludGVycG9sYXRlUGFkZGluZyhjLCBkLCBlKSwgbSA9IGEuY2VudGVyUG9pbnQuYWRkKGYpKTtcbiAgICAgICAgICAgIHZhciBnID0gMSA9PT0gZSA/IHYgOiBhLnVucHJvamVjdCh5LmFkZCh4Lm11bHQoTChyKSkpLm11bHQoXykpO1xuICAgICAgICAgICAgYS5zZXRMb2NhdGlvbkF0UG9pbnQoYS5yZW5kZXJXb3JsZENvcGllcyA/IGcud3JhcCgpIDogZywgbSksIG8uX2ZpcmVNb3ZlRXZlbnRzKGkpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvLl9hZnRlckVhc2UoaSk7XG4gICAgICAgICAgfSwgZSksIHRoaXM7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmlzRWFzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhIXRoaXMuX2Vhc2VGcmFtZUlkO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wKCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZWFzZUZyYW1lSWQgJiYgKHRoaXMuX2NhbmNlbFJlbmRlckZyYW1lKHRoaXMuX2Vhc2VGcmFtZUlkKSwgZGVsZXRlIHRoaXMuX2Vhc2VGcmFtZUlkLCBkZWxldGUgdGhpcy5fb25FYXNlRnJhbWUpLCB0aGlzLl9vbkVhc2VFbmQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fb25FYXNlRW5kO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29uRWFzZUVuZCwgaS5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgIHZhciBvID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgICAgIG8gJiYgby5zdG9wKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9lYXNlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICAhMSA9PT0gby5hbmltYXRlIHx8IDAgPT09IG8uZHVyYXRpb24gPyAoZSgxKSwgaSgpKSA6ICh0aGlzLl9lYXNlU3RhcnQgPSB0LmJyb3dzZXIubm93KCksIHRoaXMuX2Vhc2VPcHRpb25zID0gbywgdGhpcy5fb25FYXNlRnJhbWUgPSBlLCB0aGlzLl9vbkVhc2VFbmQgPSBpLCB0aGlzLl9lYXNlRnJhbWVJZCA9IHRoaXMuX3JlcXVlc3RSZW5kZXJGcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNhbGxiYWNrKSk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLl9yZW5kZXJGcmFtZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gTWF0aC5taW4oKHQuYnJvd3Nlci5ub3coKSAtIHRoaXMuX2Vhc2VTdGFydCkgLyB0aGlzLl9lYXNlT3B0aW9ucy5kdXJhdGlvbiwgMSk7XG4gICAgICAgICAgdGhpcy5fb25FYXNlRnJhbWUodGhpcy5fZWFzZU9wdGlvbnMuZWFzaW5nKGUpKSwgZSA8IDEgPyB0aGlzLl9lYXNlRnJhbWVJZCA9IHRoaXMuX3JlcXVlc3RSZW5kZXJGcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNhbGxiYWNrKSA6IHRoaXMuc3RvcCgpO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5fbm9ybWFsaXplQmVhcmluZyA9IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgZSA9IHQud3JhcChlLCAtMTgwLCAxODApO1xuICAgICAgICAgIHZhciBvID0gTWF0aC5hYnMoZSAtIGkpO1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhlIC0gMzYwIC0gaSkgPCBvICYmIChlIC09IDM2MCksIE1hdGguYWJzKGUgKyAzNjAgLSBpKSA8IG8gJiYgKGUgKz0gMzYwKSwgZTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUuX25vcm1hbGl6ZUNlbnRlciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICBpZiAoZS5yZW5kZXJXb3JsZENvcGllcyAmJiAhZS5sbmdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIGkgPSB0LmxuZyAtIGUuY2VudGVyLmxuZztcbiAgICAgICAgICAgIHQubG5nICs9IGkgPiAxODAgPyAtMzYwIDogaSA8IC0xODAgPyAzNjAgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgaTtcbiAgICAgIH0odC5FdmVudGVkKSxcbiAgICAgIHlyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0ge30pLCB0aGlzLm9wdGlvbnMgPSBlLCB0LmJpbmRBbGwoW1wiX3RvZ2dsZUF0dHJpYnV0aW9uXCIsIFwiX3VwZGF0ZUVkaXRMaW5rXCIsIFwiX3VwZGF0ZURhdGFcIiwgXCJfdXBkYXRlQ29tcGFjdFwiXSwgdGhpcyk7XG4gICAgICB9O1xuICAgIHlyLnByb3RvdHlwZS5nZXREZWZhdWx0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJib3R0b20tcmlnaHRcIjtcbiAgICB9LCB5ci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmNvbXBhY3Q7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwID0gdCwgdGhpcy5fY29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWN0cmwgbWFwbGlicmVnbC1jdHJsLWF0dHJpYiBtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtYXR0cmliXCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uID0gaS5jcmVhdGUoXCJidXR0b25cIiwgXCJtYXBsaWJyZWdsLWN0cmwtYXR0cmliLWJ1dHRvbiBtYXBib3hnbC1jdHJsLWF0dHJpYi1idXR0b25cIiwgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5fY29tcGFjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fdG9nZ2xlQXR0cmlidXRpb24pLCB0aGlzLl9jb21wYWN0QnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl9zZXRFbGVtZW50VGl0bGUodGhpcy5fY29tcGFjdEJ1dHRvbiwgXCJUb2dnbGVBdHRyaWJ1dGlvblwiKSwgdGhpcy5faW5uZXJDb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybC1hdHRyaWItaW5uZXIgbWFwYm94Z2wtY3RybC1hdHRyaWItaW5uZXJcIiwgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5faW5uZXJDb250YWluZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImxpc3RcIiksIGUgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWNvbXBhY3RcIiwgXCJtYXBib3hnbC1jb21wYWN0XCIpLCB0aGlzLl91cGRhdGVBdHRyaWJ1dGlvbnMoKSwgdGhpcy5fdXBkYXRlRWRpdExpbmsoKSwgdGhpcy5fbWFwLm9uKFwic3R5bGVkYXRhXCIsIHRoaXMuX3VwZGF0ZURhdGEpLCB0aGlzLl9tYXAub24oXCJzb3VyY2VkYXRhXCIsIHRoaXMuX3VwZGF0ZURhdGEpLCB0aGlzLl9tYXAub24oXCJtb3ZlZW5kXCIsIHRoaXMuX3VwZGF0ZUVkaXRMaW5rKSwgdm9pZCAwID09PSBlICYmICh0aGlzLl9tYXAub24oXCJyZXNpemVcIiwgdGhpcy5fdXBkYXRlQ29tcGFjdCksIHRoaXMuX3VwZGF0ZUNvbXBhY3QoKSksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LCB5ci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwic3R5bGVkYXRhXCIsIHRoaXMuX3VwZGF0ZURhdGEpLCB0aGlzLl9tYXAub2ZmKFwic291cmNlZGF0YVwiLCB0aGlzLl91cGRhdGVEYXRhKSwgdGhpcy5fbWFwLm9mZihcIm1vdmVlbmRcIiwgdGhpcy5fdXBkYXRlRWRpdExpbmspLCB0aGlzLl9tYXAub2ZmKFwicmVzaXplXCIsIHRoaXMuX3VwZGF0ZUNvbXBhY3QpLCB0aGlzLl9tYXAgPSB2b2lkIDAsIHRoaXMuX2F0dHJpYkhUTUwgPSB2b2lkIDA7XG4gICAgfSwgeXIucHJvdG90eXBlLl9zZXRFbGVtZW50VGl0bGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiQXR0cmlidXRpb25Db250cm9sLlwiICsgZSk7XG4gICAgICB0LnRpdGxlID0gaSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGkpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5fdG9nZ2xlQXR0cmlidXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwibWFwbGlicmVnbC1jb21wYWN0LXNob3dcIikgfHwgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcIm1hcGJveGdsLWNvbXBhY3Qtc2hvd1wiKSA/ICh0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY29tcGFjdC1zaG93XCIsIFwibWFwYm94Z2wtY29tcGFjdC1zaG93XCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpKSA6ICh0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY29tcGFjdC1zaG93XCIsIFwibWFwYm94Z2wtY29tcGFjdC1zaG93XCIpLCB0aGlzLl9jb21wYWN0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIikpO1xuICAgIH0sIHlyLnByb3RvdHlwZS5fdXBkYXRlRWRpdExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuX2VkaXRMaW5rO1xuICAgICAgZSB8fCAoZSA9IHRoaXMuX2VkaXRMaW5rID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIubWFwYm94LWltcHJvdmUtbWFwXCIpKTtcbiAgICAgIHZhciBpID0gW3tcbiAgICAgICAga2V5OiBcIm93bmVyXCIsXG4gICAgICAgIHZhbHVlOiB0aGlzLnN0eWxlT3duZXJcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlkXCIsXG4gICAgICAgIHZhbHVlOiB0aGlzLnN0eWxlSWRcbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFjY2Vzc190b2tlblwiLFxuICAgICAgICB2YWx1ZTogdGhpcy5fbWFwLl9yZXF1ZXN0TWFuYWdlci5fY3VzdG9tQWNjZXNzVG9rZW4gfHwgdC5jb25maWcuQUNDRVNTX1RPS0VOXG4gICAgICB9XTtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciBvID0gaS5yZWR1Y2UoZnVuY3Rpb24gKHQsIGUsIG8pIHtcbiAgICAgICAgICByZXR1cm4gZS52YWx1ZSAmJiAodCArPSBlLmtleSArIFwiPVwiICsgZS52YWx1ZSArIChvIDwgaS5sZW5ndGggLSAxID8gXCImXCIgOiBcIlwiKSksIHQ7XG4gICAgICAgIH0sIFwiP1wiKTtcbiAgICAgICAgZS5ocmVmID0gdC5jb25maWcuRkVFREJBQ0tfVVJMICsgXCIvXCIgKyBvICsgKHRoaXMuX21hcC5faGFzaCA/IHRoaXMuX21hcC5faGFzaC5nZXRIYXNoU3RyaW5nKCEwKSA6IFwiXCIpLCBlLnJlbCA9IFwibm9vcGVuZXIgbm9mb2xsb3dcIiwgdGhpcy5fc2V0RWxlbWVudFRpdGxlKGUsIFwiTWFwRmVlZGJhY2tcIik7XG4gICAgICB9XG4gICAgfSwgeXIucHJvdG90eXBlLl91cGRhdGVEYXRhID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICF0IHx8IFwibWV0YWRhdGFcIiAhPT0gdC5zb3VyY2VEYXRhVHlwZSAmJiBcInZpc2liaWxpdHlcIiAhPT0gdC5zb3VyY2VEYXRhVHlwZSAmJiBcInN0eWxlXCIgIT09IHQuZGF0YVR5cGUgfHwgKHRoaXMuX3VwZGF0ZUF0dHJpYnV0aW9ucygpLCB0aGlzLl91cGRhdGVFZGl0TGluaygpKTtcbiAgICB9LCB5ci5wcm90b3R5cGUuX3VwZGF0ZUF0dHJpYnV0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXN0b21BdHRyaWJ1dGlvbiAmJiAoQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuY3VzdG9tQXR0cmlidXRpb24pID8gdCA9IHQuY29uY2F0KHRoaXMub3B0aW9ucy5jdXN0b21BdHRyaWJ1dGlvbi5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgdCA/IFwiXCIgOiB0O1xuICAgICAgICB9KSkgOiBcInN0cmluZ1wiID09IHR5cGVvZiB0aGlzLm9wdGlvbnMuY3VzdG9tQXR0cmlidXRpb24gJiYgdC5wdXNoKHRoaXMub3B0aW9ucy5jdXN0b21BdHRyaWJ1dGlvbikpLCB0aGlzLl9tYXAuc3R5bGUuc3R5bGVzaGVldCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5fbWFwLnN0eWxlLnN0eWxlc2hlZXQ7XG4gICAgICAgICAgdGhpcy5zdHlsZU93bmVyID0gZS5vd25lciwgdGhpcy5zdHlsZUlkID0gZS5pZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IHRoaXMuX21hcC5zdHlsZS5zb3VyY2VDYWNoZXM7XG4gICAgICAgIGZvciAodmFyIG8gaW4gaSkge1xuICAgICAgICAgIHZhciByID0gaVtvXTtcbiAgICAgICAgICBpZiAoci51c2VkKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHIuZ2V0U291cmNlKCk7XG4gICAgICAgICAgICBhLmF0dHJpYnV0aW9uICYmIHQuaW5kZXhPZihhLmF0dHJpYnV0aW9uKSA8IDAgJiYgdC5wdXNoKGEuYXR0cmlidXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0LnNvcnQoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdC5sZW5ndGggLSBlLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuID0gKHQgPSB0LmZpbHRlcihmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIGZvciAodmFyIG8gPSBpICsgMTsgbyA8IHQubGVuZ3RoOyBvKyspIGlmICh0W29dLmluZGV4T2YoZSkgPj0gMCkgcmV0dXJuICExO1xuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgfSkpLmpvaW4oXCIgfCBcIik7XG4gICAgICAgIG4gIT09IHRoaXMuX2F0dHJpYkhUTUwgJiYgKHRoaXMuX2F0dHJpYkhUTUwgPSBuLCB0Lmxlbmd0aCA/ICh0aGlzLl9pbm5lckNvbnRhaW5lci5pbm5lckhUTUwgPSBuLCB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtYXR0cmliLWVtcHR5XCIsIFwibWFwYm94Z2wtYXR0cmliLWVtcHR5XCIpKSA6IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1hdHRyaWItZW1wdHlcIiwgXCJtYXBib3hnbC1hdHRyaWItZW1wdHlcIiksIHRoaXMuX2VkaXRMaW5rID0gbnVsbCk7XG4gICAgICB9XG4gICAgfSwgeXIucHJvdG90eXBlLl91cGRhdGVDb21wYWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fbWFwLmdldENhbnZhc0NvbnRhaW5lcigpLm9mZnNldFdpZHRoIDw9IDY0MCA/IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jb21wYWN0XCIsIFwibWFwYm94Z2wtY29tcGFjdFwiKSA6IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jb21wYWN0XCIsIFwibWFwbGlicmVnbC1jb21wYWN0LXNob3dcIiwgXCJtYXBib3hnbC1jb21wYWN0XCIsIFwibWFwYm94Z2wtY29tcGFjdC1zaG93XCIpO1xuICAgIH07XG4gICAgdmFyIHhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdC5iaW5kQWxsKFtcIl91cGRhdGVMb2dvXCJdLCB0aGlzKSwgdC5iaW5kQWxsKFtcIl91cGRhdGVDb21wYWN0XCJdLCB0aGlzKTtcbiAgICB9O1xuICAgIHhyLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLl9tYXAgPSB0LCB0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybCBtYXBib3hnbC1jdHJsXCIpO1xuICAgICAgdmFyIGUgPSBpLmNyZWF0ZShcImFcIiwgXCJtYXBsaWJyZWdsLWN0cmwtbG9nbyBtYXBib3hnbC1jdHJsLWxvZ29cIik7XG4gICAgICByZXR1cm4gZS50YXJnZXQgPSBcIl9ibGFua1wiLCBlLnJlbCA9IFwibm9vcGVuZXIgbm9mb2xsb3dcIiwgZS5ocmVmID0gXCJodHRwczovL21hcGxpYnJlLm9yZy9cIiwgZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRoaXMuX21hcC5fZ2V0VUlTdHJpbmcoXCJMb2dvQ29udHJvbC5UaXRsZVwiKSksIGUuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXIgbm9mb2xsb3dcIiksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChlKSwgdGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgdGhpcy5fbWFwLm9uKFwic291cmNlZGF0YVwiLCB0aGlzLl91cGRhdGVMb2dvKSwgdGhpcy5fdXBkYXRlTG9nbygpLCB0aGlzLl9tYXAub24oXCJyZXNpemVcIiwgdGhpcy5fdXBkYXRlQ29tcGFjdCksIHRoaXMuX3VwZGF0ZUNvbXBhY3QoKSwgdGhpcy5fY29udGFpbmVyO1xuICAgIH0sIHhyLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGkucmVtb3ZlKHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX21hcC5vZmYoXCJzb3VyY2VkYXRhXCIsIHRoaXMuX3VwZGF0ZUxvZ28pLCB0aGlzLl9tYXAub2ZmKFwicmVzaXplXCIsIHRoaXMuX3VwZGF0ZUNvbXBhY3QpO1xuICAgIH0sIHhyLnByb3RvdHlwZS5nZXREZWZhdWx0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJib3R0b20tbGVmdFwiO1xuICAgIH0sIHhyLnByb3RvdHlwZS5fdXBkYXRlTG9nbyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0ICYmIFwibWV0YWRhdGFcIiAhPT0gdC5zb3VyY2VEYXRhVHlwZSB8fCAodGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9sb2dvUmVxdWlyZWQoKSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiKTtcbiAgICB9LCB4ci5wcm90b3R5cGUuX2xvZ29SZXF1aXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLl9tYXAuc3R5bGUuc291cmNlQ2FjaGVzO1xuICAgICAgICBmb3IgKHZhciBlIGluIHQpIGlmICh0W2VdLmdldFNvdXJjZSgpLm1hcGJveF9sb2dvKSByZXR1cm4gITA7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCB4ci5wcm90b3R5cGUuX3VwZGF0ZUNvbXBhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2NvbnRhaW5lci5jaGlsZHJlbjtcbiAgICAgIGlmICh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgZSA9IHRbMF07XG4gICAgICAgIHRoaXMuX21hcC5nZXRDYW52YXNDb250YWluZXIoKS5vZmZzZXRXaWR0aCA8IDI1MCA/IGUuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY29tcGFjdFwiLCBcIm1hcGJveGdsLWNvbXBhY3RcIikgOiBlLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWNvbXBhY3RcIiwgXCJtYXBib3hnbC1jb21wYWN0XCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGJyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fcXVldWUgPSBbXSwgdGhpcy5faWQgPSAwLCB0aGlzLl9jbGVhcmVkID0gITEsIHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcgPSAhMTtcbiAgICB9O1xuICAgIGJyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSArK3RoaXMuX2lkO1xuICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICBjYWxsYmFjazogdCxcbiAgICAgICAgaWQ6IGUsXG4gICAgICAgIGNhbmNlbGxlZDogITFcbiAgICAgIH0pLCBlO1xuICAgIH0sIGJyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgZm9yICh2YXIgZSA9IHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcsIGkgPSAwLCBvID0gZSA/IHRoaXMuX3F1ZXVlLmNvbmNhdChlKSA6IHRoaXMuX3F1ZXVlOyBpIDwgby5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgciA9IG9baV07XG4gICAgICAgIGlmIChyLmlkID09PSB0KSByZXR1cm4gdm9pZCAoci5jYW5jZWxsZWQgPSAhMCk7XG4gICAgICB9XG4gICAgfSwgYnIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSAwKTtcbiAgICAgIHZhciBlID0gdGhpcy5fY3VycmVudGx5UnVubmluZyA9IHRoaXMuX3F1ZXVlO1xuICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBvID0gZTsgaSA8IG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHIgPSBvW2ldO1xuICAgICAgICBpZiAoIXIuY2FuY2VsbGVkICYmIChyLmNhbGxiYWNrKHQpLCB0aGlzLl9jbGVhcmVkKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhcmVkID0gITEsIHRoaXMuX2N1cnJlbnRseVJ1bm5pbmcgPSAhMTtcbiAgICB9LCBici5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50bHlSdW5uaW5nICYmICh0aGlzLl9jbGVhcmVkID0gITApLCB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH07XG4gICAgdmFyIHdyID0ge1xuICAgICAgICBcIkF0dHJpYnV0aW9uQ29udHJvbC5Ub2dnbGVBdHRyaWJ1dGlvblwiOiBcIlRvZ2dsZSBhdHRyaWJ1dGlvblwiLFxuICAgICAgICBcIkF0dHJpYnV0aW9uQ29udHJvbC5NYXBGZWVkYmFja1wiOiBcIk1hcCBmZWVkYmFja1wiLFxuICAgICAgICBcIkZ1bGxzY3JlZW5Db250cm9sLkVudGVyXCI6IFwiRW50ZXIgZnVsbHNjcmVlblwiLFxuICAgICAgICBcIkZ1bGxzY3JlZW5Db250cm9sLkV4aXRcIjogXCJFeGl0IGZ1bGxzY3JlZW5cIixcbiAgICAgICAgXCJHZW9sb2NhdGVDb250cm9sLkZpbmRNeUxvY2F0aW9uXCI6IFwiRmluZCBteSBsb2NhdGlvblwiLFxuICAgICAgICBcIkdlb2xvY2F0ZUNvbnRyb2wuTG9jYXRpb25Ob3RBdmFpbGFibGVcIjogXCJMb2NhdGlvbiBub3QgYXZhaWxhYmxlXCIsXG4gICAgICAgIFwiTG9nb0NvbnRyb2wuVGl0bGVcIjogXCJNYXBib3ggbG9nb1wiLFxuICAgICAgICBcIk5hdmlnYXRpb25Db250cm9sLlJlc2V0QmVhcmluZ1wiOiBcIlJlc2V0IGJlYXJpbmcgdG8gbm9ydGhcIixcbiAgICAgICAgXCJOYXZpZ2F0aW9uQ29udHJvbC5ab29tSW5cIjogXCJab29tIGluXCIsXG4gICAgICAgIFwiTmF2aWdhdGlvbkNvbnRyb2wuWm9vbU91dFwiOiBcIlpvb20gb3V0XCIsXG4gICAgICAgIFwiU2NhbGVDb250cm9sLkZlZXRcIjogXCJmdFwiLFxuICAgICAgICBcIlNjYWxlQ29udHJvbC5NZXRlcnNcIjogXCJtXCIsXG4gICAgICAgIFwiU2NhbGVDb250cm9sLktpbG9tZXRlcnNcIjogXCJrbVwiLFxuICAgICAgICBcIlNjYWxlQ29udHJvbC5NaWxlc1wiOiBcIm1pXCIsXG4gICAgICAgIFwiU2NhbGVDb250cm9sLk5hdXRpY2FsTWlsZXNcIjogXCJubVwiXG4gICAgICB9LFxuICAgICAgVHIgPSB0LndpbmRvdy5IVE1MSW1hZ2VFbGVtZW50LFxuICAgICAgRXIgPSB0LndpbmRvdy5IVE1MRWxlbWVudCxcbiAgICAgIElyID0gdC53aW5kb3cuSW1hZ2VCaXRtYXAsXG4gICAgICBQciA9IHtcbiAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICAgIHpvb206IDAsXG4gICAgICAgIGJlYXJpbmc6IDAsXG4gICAgICAgIHBpdGNoOiAwLFxuICAgICAgICBtaW5ab29tOiAtMixcbiAgICAgICAgbWF4Wm9vbTogMjIsXG4gICAgICAgIG1pblBpdGNoOiAwLFxuICAgICAgICBtYXhQaXRjaDogNjAsXG4gICAgICAgIGludGVyYWN0aXZlOiAhMCxcbiAgICAgICAgc2Nyb2xsWm9vbTogITAsXG4gICAgICAgIGJveFpvb206ICEwLFxuICAgICAgICBkcmFnUm90YXRlOiAhMCxcbiAgICAgICAgZHJhZ1BhbjogITAsXG4gICAgICAgIGtleWJvYXJkOiAhMCxcbiAgICAgICAgZG91YmxlQ2xpY2tab29tOiAhMCxcbiAgICAgICAgdG91Y2hab29tUm90YXRlOiAhMCxcbiAgICAgICAgdG91Y2hQaXRjaDogITAsXG4gICAgICAgIGJlYXJpbmdTbmFwOiA3LFxuICAgICAgICBjbGlja1RvbGVyYW5jZTogMyxcbiAgICAgICAgcGl0Y2hXaXRoUm90YXRlOiAhMCxcbiAgICAgICAgaGFzaDogITEsXG4gICAgICAgIGF0dHJpYnV0aW9uQ29udHJvbDogITAsXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ICExLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ICExLFxuICAgICAgICB0cmFja1Jlc2l6ZTogITAsXG4gICAgICAgIHJlbmRlcldvcmxkQ29waWVzOiAhMCxcbiAgICAgICAgcmVmcmVzaEV4cGlyZWRUaWxlczogITAsXG4gICAgICAgIG1heFRpbGVDYWNoZVNpemU6IG51bGwsXG4gICAgICAgIGxvY2FsSWRlb2dyYXBoRm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gICAgICAgIHRyYW5zZm9ybVJlcXVlc3Q6IG51bGwsXG4gICAgICAgIGFjY2Vzc1Rva2VuOiBudWxsLFxuICAgICAgICBmYWRlRHVyYXRpb246IDMwMCxcbiAgICAgICAgY3Jvc3NTb3VyY2VDb2xsaXNpb25zOiAhMFxuICAgICAgfSxcbiAgICAgIFNyID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgZnVuY3Rpb24gcihlKSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgIGlmIChudWxsICE9IChlID0gdC5leHRlbmQoe30sIFByLCBlKSkubWluWm9vbSAmJiBudWxsICE9IGUubWF4Wm9vbSAmJiBlLm1pblpvb20gPiBlLm1heFpvb20pIHRocm93IG5ldyBFcnJvcihcIm1heFpvb20gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluWm9vbVwiKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBlLm1pblBpdGNoICYmIG51bGwgIT0gZS5tYXhQaXRjaCAmJiBlLm1pblBpdGNoID4gZS5tYXhQaXRjaCkgdGhyb3cgbmV3IEVycm9yKFwibWF4UGl0Y2ggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluUGl0Y2hcIik7XG4gICAgICAgICAgaWYgKG51bGwgIT0gZS5taW5QaXRjaCAmJiBlLm1pblBpdGNoIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibWluUGl0Y2ggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMFwiKTtcbiAgICAgICAgICBpZiAobnVsbCAhPSBlLm1heFBpdGNoICYmIGUubWF4UGl0Y2ggPiA2MCkgdGhyb3cgbmV3IEVycm9yKFwibWF4UGl0Y2ggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNjBcIik7XG4gICAgICAgICAgdmFyIHIgPSBuZXcgVG8oZS5taW5ab29tLCBlLm1heFpvb20sIGUubWluUGl0Y2gsIGUubWF4UGl0Y2gsIGUucmVuZGVyV29ybGRDb3BpZXMpO1xuICAgICAgICAgIGlmIChvLmNhbGwodGhpcywgciwgZSksIHRoaXMuX2ludGVyYWN0aXZlID0gZS5pbnRlcmFjdGl2ZSwgdGhpcy5fbWF4VGlsZUNhY2hlU2l6ZSA9IGUubWF4VGlsZUNhY2hlU2l6ZSwgdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IGUuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCwgdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZS5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsIHRoaXMuX2FudGlhbGlhcyA9IGUuYW50aWFsaWFzLCB0aGlzLl90cmFja1Jlc2l6ZSA9IGUudHJhY2tSZXNpemUsIHRoaXMuX2JlYXJpbmdTbmFwID0gZS5iZWFyaW5nU25hcCwgdGhpcy5fcmVmcmVzaEV4cGlyZWRUaWxlcyA9IGUucmVmcmVzaEV4cGlyZWRUaWxlcywgdGhpcy5fZmFkZUR1cmF0aW9uID0gZS5mYWRlRHVyYXRpb24sIHRoaXMuX2Nyb3NzU291cmNlQ29sbGlzaW9ucyA9IGUuY3Jvc3NTb3VyY2VDb2xsaXNpb25zLCB0aGlzLl9jcm9zc0ZhZGluZ0ZhY3RvciA9IDEsIHRoaXMuX2NvbGxlY3RSZXNvdXJjZVRpbWluZyA9IGUuY29sbGVjdFJlc291cmNlVGltaW5nLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUgPSBuZXcgYnIoKSwgdGhpcy5fY29udHJvbHMgPSBbXSwgdGhpcy5fbWFwSWQgPSB0LnVuaXF1ZUlkKCksIHRoaXMuX2xvY2FsZSA9IHQuZXh0ZW5kKHt9LCB3ciwgZS5sb2NhbGUpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IGUuY2xpY2tUb2xlcmFuY2UsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gbmV3IHQuUmVxdWVzdE1hbmFnZXIoZS50cmFuc2Zvcm1SZXF1ZXN0LCBlLmFjY2Vzc1Rva2VuKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZS5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb250YWluZXIgPSB0LndpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlLmNvbnRhaW5lciksICF0aGlzLl9jb250YWluZXIpIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciAnXCIgKyBlLmNvbnRhaW5lciArIFwiJyBub3QgZm91bmQuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShlLmNvbnRhaW5lciBpbnN0YW5jZW9mIEVyKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlOiAnY29udGFpbmVyJyBtdXN0IGJlIGEgU3RyaW5nIG9yIEhUTUxFbGVtZW50LlwiKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGUuY29udGFpbmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZS5tYXhCb3VuZHMgJiYgdGhpcy5zZXRNYXhCb3VuZHMoZS5tYXhCb3VuZHMpLCB0LmJpbmRBbGwoW1wiX29uV2luZG93T25saW5lXCIsIFwiX29uV2luZG93UmVzaXplXCIsIFwiX29uTWFwU2Nyb2xsXCIsIFwiX2NvbnRleHRMb3N0XCIsIFwiX2NvbnRleHRSZXN0b3JlZFwiXSwgdGhpcyksIHRoaXMuX3NldHVwQ29udGFpbmVyKCksIHRoaXMuX3NldHVwUGFpbnRlcigpLCB2b2lkIDAgPT09IHRoaXMucGFpbnRlcikgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgV2ViR0wuXCIpO1xuICAgICAgICAgIHRoaXMub24oXCJtb3ZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpLl91cGRhdGUoITEpO1xuICAgICAgICAgIH0pLCB0aGlzLm9uKFwibW92ZWVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaS5fdXBkYXRlKCExKTtcbiAgICAgICAgICB9KSwgdGhpcy5vbihcInpvb21cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGkuX3VwZGF0ZSghMCk7XG4gICAgICAgICAgfSksIHZvaWQgMCAhPT0gdC53aW5kb3cgJiYgKHQud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgdGhpcy5fb25XaW5kb3dPbmxpbmUsICExKSwgdC53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgITEpLCB0LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUsICExKSksIHRoaXMuaGFuZGxlcnMgPSBuZXcgZ3IodGhpcywgZSksIHRoaXMuX2hhc2ggPSBlLmhhc2ggJiYgbmV3IElvKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuaGFzaCAmJiBlLmhhc2ggfHwgdm9pZCAwKS5hZGRUbyh0aGlzKSwgdGhpcy5faGFzaCAmJiB0aGlzLl9oYXNoLl9vbkhhc2hDaGFuZ2UoKSB8fCAodGhpcy5qdW1wVG8oe1xuICAgICAgICAgICAgY2VudGVyOiBlLmNlbnRlcixcbiAgICAgICAgICAgIHpvb206IGUuem9vbSxcbiAgICAgICAgICAgIGJlYXJpbmc6IGUuYmVhcmluZyxcbiAgICAgICAgICAgIHBpdGNoOiBlLnBpdGNoXG4gICAgICAgICAgfSksIGUuYm91bmRzICYmICh0aGlzLnJlc2l6ZSgpLCB0aGlzLmZpdEJvdW5kcyhlLmJvdW5kcywgdC5leHRlbmQoe30sIGUuZml0Qm91bmRzT3B0aW9ucywge1xuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KSkpKSwgdGhpcy5yZXNpemUoKSwgdGhpcy5fbG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5ID0gZS5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHksIGUuc3R5bGUgJiYgdGhpcy5zZXRTdHlsZShlLnN0eWxlLCB7XG4gICAgICAgICAgICBsb2NhbElkZW9ncmFwaEZvbnRGYW1pbHk6IGUubG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5XG4gICAgICAgICAgfSksIGUuYXR0cmlidXRpb25Db250cm9sICYmIHRoaXMuYWRkQ29udHJvbChuZXcgeXIoe1xuICAgICAgICAgICAgY3VzdG9tQXR0cmlidXRpb246IGUuY3VzdG9tQXR0cmlidXRpb25cbiAgICAgICAgICB9KSksIHRoaXMuYWRkQ29udHJvbChuZXcgeHIoKSwgZS5sb2dvUG9zaXRpb24pLCB0aGlzLm9uKFwic3R5bGUubG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpLnRyYW5zZm9ybS51bm1vZGlmaWVkICYmIGkuanVtcFRvKGkuc3R5bGUuc3R5bGVzaGVldCk7XG4gICAgICAgICAgfSksIHRoaXMub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpLl91cGRhdGUoXCJzdHlsZVwiID09PSBlLmRhdGFUeXBlKSwgaS5maXJlKG5ldyB0LkV2ZW50KGUuZGF0YVR5cGUgKyBcImRhdGFcIiwgZSkpO1xuICAgICAgICAgIH0pLCB0aGlzLm9uKFwiZGF0YWxvYWRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGkuZmlyZShuZXcgdC5FdmVudChlLmRhdGFUeXBlICsgXCJkYXRhbG9hZGluZ1wiLCBlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbyAmJiAoci5fX3Byb3RvX18gPSBvKSwgKHIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShvICYmIG8ucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSByO1xuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICBzaG93VGlsZUJvdW5kYXJpZXM6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3dQYWRkaW5nOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaG93Q29sbGlzaW9uQm94ZXM6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNob3dPdmVyZHJhd0luc3BlY3Rvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVwYWludDoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVydGljZXM6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByLnByb3RvdHlwZS5fZ2V0TWFwSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcElkO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBpICYmIChpID0gZS5nZXREZWZhdWx0UG9zaXRpb24gPyBlLmdldERlZmF1bHRQb3NpdGlvbigpIDogXCJ0b3AtcmlnaHRcIiksICFlIHx8ICFlLm9uQWRkKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCB0byBtYXAuYWRkQ29udHJvbCgpLiBBcmd1bWVudCBtdXN0IGJlIGEgY29udHJvbCB3aXRoIG9uQWRkIGFuZCBvblJlbW92ZSBtZXRob2RzLlwiKSkpO1xuICAgICAgICAgIHZhciBvID0gZS5vbkFkZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLl9jb250cm9scy5wdXNoKGUpO1xuICAgICAgICAgIHZhciByID0gdGhpcy5fY29udHJvbFBvc2l0aW9uc1tpXTtcbiAgICAgICAgICByZXR1cm4gLTEgIT09IGkuaW5kZXhPZihcImJvdHRvbVwiKSA/IHIuaW5zZXJ0QmVmb3JlKG8sIHIuZmlyc3RDaGlsZCkgOiByLmFwcGVuZENoaWxkKG8pLCB0aGlzO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgIWUub25SZW1vdmUpIHJldHVybiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IHRvIG1hcC5yZW1vdmVDb250cm9sKCkuIEFyZ3VtZW50IG11c3QgYmUgYSBjb250cm9sIHdpdGggb25BZGQgYW5kIG9uUmVtb3ZlIG1ldGhvZHMuXCIpKSk7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9jb250cm9scy5pbmRleE9mKGUpO1xuICAgICAgICAgIHJldHVybiBpID4gLTEgJiYgdGhpcy5fY29udHJvbHMuc3BsaWNlKGksIDEpLCBlLm9uUmVtb3ZlKHRoaXMpLCB0aGlzO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5oYXNDb250cm9sID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udHJvbHMuaW5kZXhPZih0KSA+IC0xO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fY29udGFpbmVyRGltZW5zaW9ucygpLFxuICAgICAgICAgICAgbyA9IGlbMF0sXG4gICAgICAgICAgICByID0gaVsxXTtcbiAgICAgICAgICB0aGlzLl9yZXNpemVDYW52YXMobywgciksIHRoaXMudHJhbnNmb3JtLnJlc2l6ZShvLCByKSwgdGhpcy5wYWludGVyLnJlc2l6ZShvLCByKTtcbiAgICAgICAgICB2YXIgYSA9ICF0aGlzLl9tb3Zpbmc7XG4gICAgICAgICAgcmV0dXJuIGEgJiYgKHRoaXMuc3RvcCgpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJtb3Zlc3RhcnRcIiwgZSkpLmZpcmUobmV3IHQuRXZlbnQoXCJtb3ZlXCIsIGUpKSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJlc2l6ZVwiLCBlKSksIGEgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibW92ZWVuZFwiLCBlKSksIHRoaXM7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uZ2V0Qm91bmRzKCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldE1heEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uZ2V0TWF4Qm91bmRzKCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldE1heEJvdW5kcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNldE1heEJvdW5kcyh0LkxuZ0xhdEJvdW5kcy5jb252ZXJ0KGUpKSwgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldE1pblpvb20gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICgodCA9IG51bGwgPT0gdCA/IC0yIDogdCkgPj0gLTIgJiYgdCA8PSB0aGlzLnRyYW5zZm9ybS5tYXhab29tKSByZXR1cm4gdGhpcy50cmFuc2Zvcm0ubWluWm9vbSA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLmdldFpvb20oKSA8IHQgJiYgdGhpcy5zZXRab29tKHQpLCB0aGlzO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pblpvb20gbXVzdCBiZSBiZXR3ZWVuIC0yIGFuZCB0aGUgY3VycmVudCBtYXhab29tLCBpbmNsdXNpdmVcIik7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldE1pblpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1pblpvb207XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldE1heFpvb20gPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICgodCA9IG51bGwgPT0gdCA/IDIyIDogdCkgPj0gdGhpcy50cmFuc2Zvcm0ubWluWm9vbSkgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1heFpvb20gPSB0LCB0aGlzLl91cGRhdGUoKSwgdGhpcy5nZXRab29tKCkgPiB0ICYmIHRoaXMuc2V0Wm9vbSh0KSwgdGhpcztcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhab29tIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IG1pblpvb21cIik7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldE1heFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1heFpvb207XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldE1pblBpdGNoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAoKHQgPSBudWxsID09IHQgPyAwIDogdCkgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJtaW5QaXRjaCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICAgICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSB0aGlzLnRyYW5zZm9ybS5tYXhQaXRjaCkgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1pblBpdGNoID0gdCwgdGhpcy5fdXBkYXRlKCksIHRoaXMuZ2V0UGl0Y2goKSA8IHQgJiYgdGhpcy5zZXRQaXRjaCh0KSwgdGhpcztcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW5QaXRjaCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgdGhlIGN1cnJlbnQgbWF4UGl0Y2gsIGluY2x1c2l2ZVwiKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZ2V0TWluUGl0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1pblBpdGNoO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5zZXRNYXhQaXRjaCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKCh0ID0gbnVsbCA9PSB0ID8gNjAgOiB0KSA+IDYwKSB0aHJvdyBuZXcgRXJyb3IoXCJtYXhQaXRjaCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2MFwiKTtcbiAgICAgICAgICBpZiAodCA+PSB0aGlzLnRyYW5zZm9ybS5taW5QaXRjaCkgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1heFBpdGNoID0gdCwgdGhpcy5fdXBkYXRlKCksIHRoaXMuZ2V0UGl0Y2goKSA+IHQgJiYgdGhpcy5zZXRQaXRjaCh0KSwgdGhpcztcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXhQaXRjaCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCBtaW5QaXRjaFwiKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZ2V0TWF4UGl0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLm1heFBpdGNoO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5nZXRSZW5kZXJXb3JsZENvcGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVuZGVyV29ybGRDb3BpZXM7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldFJlbmRlcldvcmxkQ29waWVzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVuZGVyV29ybGRDb3BpZXMgPSB0LCB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2F0aW9uUG9pbnQodC5MbmdMYXQuY29udmVydChlKSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnVucHJvamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvaW50TG9jYXRpb24odC5Qb2ludC5jb252ZXJ0KGUpKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuaXNNb3ZpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21vdmluZyB8fCB0aGlzLmhhbmRsZXJzLmlzTW92aW5nKCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmlzWm9vbWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fem9vbWluZyB8fCB0aGlzLmhhbmRsZXJzLmlzWm9vbWluZygpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5pc1JvdGF0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGluZyB8fCB0aGlzLmhhbmRsZXJzLmlzUm90YXRpbmcoKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX2NyZWF0ZURlbGVnYXRlZExpc3RlbmVyID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyxcbiAgICAgICAgICAgIHIgPSB0aGlzO1xuICAgICAgICAgIGlmIChcIm1vdXNlZW50ZXJcIiA9PT0gdCB8fCBcIm1vdXNlb3ZlclwiID09PSB0KSB7XG4gICAgICAgICAgICB2YXIgYSA9ICExO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbGF5ZXI6IGUsXG4gICAgICAgICAgICAgIGxpc3RlbmVyOiBpLFxuICAgICAgICAgICAgICBkZWxlZ2F0ZXM6IHtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbiA9IHIuZ2V0TGF5ZXIoZSkgPyByLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhvLnBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyczogW2VdXG4gICAgICAgICAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgbi5sZW5ndGggPyBhIHx8IChhID0gITAsIGkuY2FsbChyLCBuZXcgUm8odCwgciwgby5vcmlnaW5hbEV2ZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBuXG4gICAgICAgICAgICAgICAgICB9KSkpIDogYSA9ICExO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGEgPSAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcIm1vdXNlbGVhdmVcIiA9PT0gdCB8fCBcIm1vdXNlb3V0XCIgPT09IHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gITE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBsYXllcjogZSxcbiAgICAgICAgICAgICAgbGlzdGVuZXI6IGksXG4gICAgICAgICAgICAgIGRlbGVnYXRlczoge1xuICAgICAgICAgICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgIChyLmdldExheWVyKGUpID8gci5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoby5wb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBsYXllcnM6IFtlXVxuICAgICAgICAgICAgICAgICAgfSkgOiBbXSkubGVuZ3RoID8gbiA9ICEwIDogbiAmJiAobiA9ICExLCBpLmNhbGwociwgbmV3IFJvKHQsIHIsIG8ub3JpZ2luYWxFdmVudCkpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgbiAmJiAobiA9ICExLCBpLmNhbGwociwgbmV3IFJvKHQsIHIsIGUub3JpZ2luYWxFdmVudCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXllcjogZSxcbiAgICAgICAgICAgIGxpc3RlbmVyOiBpLFxuICAgICAgICAgICAgZGVsZWdhdGVzOiAobyA9IHt9LCBvW3RdID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgdmFyIG8gPSByLmdldExheWVyKGUpID8gci5xdWVyeVJlbmRlcmVkRmVhdHVyZXModC5wb2ludCwge1xuICAgICAgICAgICAgICAgIGxheWVyczogW2VdXG4gICAgICAgICAgICAgIH0pIDogW107XG4gICAgICAgICAgICAgIG8ubGVuZ3RoICYmICh0LmZlYXR1cmVzID0gbywgaS5jYWxsKHIsIHQpLCBkZWxldGUgdC5mZWF0dXJlcyk7XG4gICAgICAgICAgICB9LCBvKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBpKSByZXR1cm4gby5wcm90b3R5cGUub24uY2FsbCh0aGlzLCB0LCBlKTtcbiAgICAgICAgICB2YXIgciA9IHRoaXMuX2NyZWF0ZURlbGVnYXRlZExpc3RlbmVyKHQsIGUsIGkpO1xuICAgICAgICAgIGZvciAodmFyIGEgaW4gdGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzID0gdGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzIHx8IHt9LCB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnNbdF0gPSB0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnNbdF0gfHwgW10sIHRoaXMuX2RlbGVnYXRlZExpc3RlbmVyc1t0XS5wdXNoKHIpLCByLmRlbGVnYXRlcykgdGhpcy5vbihhLCByLmRlbGVnYXRlc1thXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGkpIHJldHVybiBvLnByb3RvdHlwZS5vbmNlLmNhbGwodGhpcywgdCwgZSk7XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLl9jcmVhdGVEZWxlZ2F0ZWRMaXN0ZW5lcih0LCBlLCBpKTtcbiAgICAgICAgICBmb3IgKHZhciBhIGluIHIuZGVsZWdhdGVzKSB0aGlzLm9uY2UoYSwgci5kZWxlZ2F0ZXNbYV0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBpID8gby5wcm90b3R5cGUub2ZmLmNhbGwodGhpcywgdCwgZSkgOiAodGhpcy5fZGVsZWdhdGVkTGlzdGVuZXJzICYmIHRoaXMuX2RlbGVnYXRlZExpc3RlbmVyc1t0XSAmJiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG9bdF0sIG4gPSAwOyBuIDwgYS5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICB2YXIgcyA9IGFbbl07XG4gICAgICAgICAgICAgIGlmIChzLmxheWVyID09PSBlICYmIHMubGlzdGVuZXIgPT09IGkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsIGluIHMuZGVsZWdhdGVzKSByLm9mZihsLCBzLmRlbGVnYXRlc1tsXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc3BsaWNlKG4sIDEpLCByO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSh0aGlzLl9kZWxlZ2F0ZWRMaXN0ZW5lcnMpLCB0aGlzKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUucXVlcnlSZW5kZXJlZEZlYXR1cmVzID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGUpIHJldHVybiBbXTtcbiAgICAgICAgICB2YXIgbztcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBpIHx8IHZvaWQgMCA9PT0gZSB8fCBlIGluc3RhbmNlb2YgdC5Qb2ludCB8fCBBcnJheS5pc0FycmF5KGUpIHx8IChpID0gZSwgZSA9IHZvaWQgMCksIGkgPSBpIHx8IHt9LCAoZSA9IGUgfHwgW1swLCAwXSwgW3RoaXMudHJhbnNmb3JtLndpZHRoLCB0aGlzLnRyYW5zZm9ybS5oZWlnaHRdXSkgaW5zdGFuY2VvZiB0LlBvaW50IHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIGVbMF0pIG8gPSBbdC5Qb2ludC5jb252ZXJ0KGUpXTtlbHNlIHtcbiAgICAgICAgICAgIHZhciByID0gdC5Qb2ludC5jb252ZXJ0KGVbMF0pLFxuICAgICAgICAgICAgICBhID0gdC5Qb2ludC5jb252ZXJ0KGVbMV0pO1xuICAgICAgICAgICAgbyA9IFtyLCBuZXcgdC5Qb2ludChhLngsIHIueSksIGEsIG5ldyB0LlBvaW50KHIueCwgYS55KSwgcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhvLCBpLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnF1ZXJ5U291cmNlRmVhdHVyZXMgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5U291cmNlRmVhdHVyZXModCwgZSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gITEgIT09IChpID0gdC5leHRlbmQoe30sIHtcbiAgICAgICAgICAgIGxvY2FsSWRlb2dyYXBoRm9udEZhbWlseTogdGhpcy5fbG9jYWxJZGVvZ3JhcGhGb250RmFtaWx5XG4gICAgICAgICAgfSwgaSkpLmRpZmYgJiYgaS5sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPT09IHRoaXMuX2xvY2FsSWRlb2dyYXBoRm9udEZhbWlseSAmJiB0aGlzLnN0eWxlICYmIGUgPyAodGhpcy5fZGlmZlN0eWxlKGUsIGkpLCB0aGlzKSA6ICh0aGlzLl9sb2NhbElkZW9ncmFwaEZvbnRGYW1pbHkgPSBpLmxvY2FsSWRlb2dyYXBoRm9udEZhbWlseSwgdGhpcy5fdXBkYXRlU3R5bGUoZSwgaSkpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm1SZXF1ZXN0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1hbmFnZXIuc2V0VHJhbnNmb3JtUmVxdWVzdCh0KSwgdGhpcztcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX2dldFVJU3RyaW5nID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuX2xvY2FsZVt0XTtcbiAgICAgICAgICBpZiAobnVsbCA9PSBlKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIFVJIHN0cmluZyAnXCIgKyB0ICsgXCInXCIpO1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlICYmICh0aGlzLnN0eWxlLnNldEV2ZW50ZWRQYXJlbnQobnVsbCksIHRoaXMuc3R5bGUuX3JlbW92ZSgpKSwgdCA/ICh0aGlzLnN0eWxlID0gbmV3IGplKHRoaXMsIGUgfHwge30pLCB0aGlzLnN0eWxlLnNldEV2ZW50ZWRQYXJlbnQodGhpcywge1xuICAgICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVcbiAgICAgICAgICB9KSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IHRoaXMuc3R5bGUubG9hZFVSTCh0KSA6IHRoaXMuc3R5bGUubG9hZEpTT04odCksIHRoaXMpIDogKGRlbGV0ZSB0aGlzLnN0eWxlLCB0aGlzKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX2xhenlJbml0RW1wdHlTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlIHx8ICh0aGlzLnN0eWxlID0gbmV3IGplKHRoaXMsIHt9KSwgdGhpcy5zdHlsZS5zZXRFdmVudGVkUGFyZW50KHRoaXMsIHtcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlXG4gICAgICAgICAgfSksIHRoaXMuc3R5bGUubG9hZEVtcHR5KCkpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fZGlmZlN0eWxlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5fcmVxdWVzdE1hbmFnZXIubm9ybWFsaXplU3R5bGVVUkwoZSksXG4gICAgICAgICAgICAgIGEgPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci50cmFuc2Zvcm1SZXF1ZXN0KHIsIHQuUmVzb3VyY2VUeXBlLlN0eWxlKTtcbiAgICAgICAgICAgIHQuZ2V0SlNPTihhLCBmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgICBlID8gby5maXJlKG5ldyB0LkVycm9yRXZlbnQoZSkpIDogciAmJiBvLl91cGRhdGVEaWZmKHIsIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgdGhpcy5fdXBkYXRlRGlmZihlLCBpKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX3VwZGF0ZURpZmYgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldFN0YXRlKGUpICYmIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICAgICAgdC53YXJuT25jZShcIlVuYWJsZSB0byBwZXJmb3JtIHN0eWxlIGRpZmY6IFwiICsgKG8ubWVzc2FnZSB8fCBvLmVycm9yIHx8IG8pICsgXCIuICBSZWJ1aWxkaW5nIHRoZSBzdHlsZSBmcm9tIHNjcmF0Y2guXCIpLCB0aGlzLl91cGRhdGVTdHlsZShlLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0eWxlKSByZXR1cm4gdGhpcy5zdHlsZS5zZXJpYWxpemUoKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuaXNTdHlsZUxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA/IHRoaXMuc3R5bGUubG9hZGVkKCkgOiB0Lndhcm5PbmNlKFwiVGhlcmUgaXMgbm8gc3R5bGUgYWRkZWQgdG8gdGhlIG1hcC5cIik7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmFkZFNvdXJjZSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xhenlJbml0RW1wdHlTdHlsZSgpLCB0aGlzLnN0eWxlLmFkZFNvdXJjZSh0LCBlKSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuaXNTb3VyY2VMb2FkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLnNvdXJjZUNhY2hlc1tlXTtcbiAgICAgICAgICBpZiAodm9pZCAwICE9PSBpKSByZXR1cm4gaS5sb2FkZWQoKTtcbiAgICAgICAgICB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzb3VyY2Ugd2l0aCBJRCAnXCIgKyBlICsgXCInXCIpKSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmFyZVRpbGVzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLnNvdXJjZUNhY2hlcztcbiAgICAgICAgICBmb3IgKHZhciBlIGluIHQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdFtlXS5fdGlsZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBvIGluIGkpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSBpW29dO1xuICAgICAgICAgICAgICBpZiAoXCJsb2FkZWRcIiAhPT0gci5zdGF0ZSAmJiBcImVycm9yZWRcIiAhPT0gci5zdGF0ZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmFkZFNvdXJjZVR5cGUgPSBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5hZGRTb3VyY2VUeXBlKHQsIGUsIGkpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnJlbW92ZVNvdXJjZSh0KSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRTb3VyY2UodCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKGUsIGksIG8pIHtcbiAgICAgICAgICB2b2lkIDAgPT09IG8gJiYgKG8gPSB7fSk7XG4gICAgICAgICAgdmFyIHIgPSBvLnBpeGVsUmF0aW87XG4gICAgICAgICAgdm9pZCAwID09PSByICYmIChyID0gMSk7XG4gICAgICAgICAgdmFyIGEgPSBvLnNkZjtcbiAgICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMSk7XG4gICAgICAgICAgdmFyIG4gPSBvLnN0cmV0Y2hYLFxuICAgICAgICAgICAgcyA9IG8uc3RyZXRjaFksXG4gICAgICAgICAgICBsID0gby5jb250ZW50O1xuICAgICAgICAgIGlmICh0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgaSBpbnN0YW5jZW9mIFRyIHx8IElyICYmIGkgaW5zdGFuY2VvZiBJcikge1xuICAgICAgICAgICAgdmFyIGMgPSB0LmJyb3dzZXIuZ2V0SW1hZ2VEYXRhKGkpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5hZGRJbWFnZShlLCB7XG4gICAgICAgICAgICAgIGRhdGE6IG5ldyB0LlJHQkFJbWFnZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjLmhlaWdodFxuICAgICAgICAgICAgICB9LCBjLmRhdGEpLFxuICAgICAgICAgICAgICBwaXhlbFJhdGlvOiByLFxuICAgICAgICAgICAgICBzdHJldGNoWDogbixcbiAgICAgICAgICAgICAgc3RyZXRjaFk6IHMsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGwsXG4gICAgICAgICAgICAgIHNkZjogYSxcbiAgICAgICAgICAgICAgdmVyc2lvbjogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGkud2lkdGggfHwgdm9pZCAwID09PSBpLmhlaWdodCkgcmV0dXJuIHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzIHRvIG1hcC5hZGRJbWFnZSgpLiBUaGUgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYW4gYEhUTUxJbWFnZUVsZW1lbnRgLCBgSW1hZ2VEYXRhYCwgYEltYWdlQml0bWFwYCwgb3Igb2JqZWN0IHdpdGggYHdpZHRoYCwgYGhlaWdodGAsIGFuZCBgZGF0YWAgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIGZvcm1hdCBhcyBgSW1hZ2VEYXRhYFwiKSkpO1xuICAgICAgICAgICAgdmFyIHUgPSBpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5hZGRJbWFnZShlLCB7XG4gICAgICAgICAgICAgIGRhdGE6IG5ldyB0LlJHQkFJbWFnZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGkud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpLmhlaWdodFxuICAgICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheShpLmRhdGEpKSxcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogcixcbiAgICAgICAgICAgICAgc3RyZXRjaFg6IG4sXG4gICAgICAgICAgICAgIHN0cmV0Y2hZOiBzLFxuICAgICAgICAgICAgICBjb250ZW50OiBsLFxuICAgICAgICAgICAgICBzZGY6IGEsXG4gICAgICAgICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgICAgICAgIHVzZXJJbWFnZTogdVxuICAgICAgICAgICAgfSksIHUub25BZGQgJiYgdS5vbkFkZCh0aGlzLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnVwZGF0ZUltYWdlID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuc3R5bGUuZ2V0SW1hZ2UoZSk7XG4gICAgICAgICAgaWYgKCFvKSByZXR1cm4gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiVGhlIG1hcCBoYXMgbm8gaW1hZ2Ugd2l0aCB0aGF0IGlkLiBJZiB5b3UgYXJlIGFkZGluZyBhIG5ldyBpbWFnZSB1c2UgYG1hcC5hZGRJbWFnZSguLi4pYCBpbnN0ZWFkLlwiKSkpO1xuICAgICAgICAgIHZhciByID0gaSBpbnN0YW5jZW9mIFRyIHx8IElyICYmIGkgaW5zdGFuY2VvZiBJciA/IHQuYnJvd3Nlci5nZXRJbWFnZURhdGEoaSkgOiBpLFxuICAgICAgICAgICAgYSA9IHIud2lkdGgsXG4gICAgICAgICAgICBuID0gci5oZWlnaHQsXG4gICAgICAgICAgICBzID0gci5kYXRhO1xuICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGEgfHwgdm9pZCAwID09PSBuID8gdGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgdG8gbWFwLnVwZGF0ZUltYWdlKCkuIFRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhbiBgSFRNTEltYWdlRWxlbWVudGAsIGBJbWFnZURhdGFgLCBgSW1hZ2VCaXRtYXBgLCBvciBvYmplY3Qgd2l0aCBgd2lkdGhgLCBgaGVpZ2h0YCwgYW5kIGBkYXRhYCBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgZm9ybWF0IGFzIGBJbWFnZURhdGFgXCIpKSkgOiBhICE9PSBvLmRhdGEud2lkdGggfHwgbiAhPT0gby5kYXRhLmhlaWdodCA/IHRoaXMuZmlyZShuZXcgdC5FcnJvckV2ZW50KG5ldyBFcnJvcihcIlRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB1cGRhdGVkIGltYWdlIG11c3QgYmUgdGhhdCBzYW1lIGFzIHRoZSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoZSBpbWFnZVwiKSkpIDogKG8uZGF0YS5yZXBsYWNlKHMsICEoaSBpbnN0YW5jZW9mIFRyIHx8IElyICYmIGkgaW5zdGFuY2VvZiBJcikpLCB2b2lkIHRoaXMuc3R5bGUudXBkYXRlSW1hZ2UoZSwgbykpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5oYXNJbWFnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUgPyAhIXRoaXMuc3R5bGUuZ2V0SW1hZ2UoZSkgOiAodGhpcy5maXJlKG5ldyB0LkVycm9yRXZlbnQobmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBpbWFnZSBpZFwiKSkpLCAhMSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlbW92ZUltYWdlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZUltYWdlKHQpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHQuZ2V0SW1hZ2UodGhpcy5fcmVxdWVzdE1hbmFnZXIudHJhbnNmb3JtUmVxdWVzdChlLCB0LlJlc291cmNlVHlwZS5JbWFnZSksIGkpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5saXN0SW1hZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmxpc3RJbWFnZXMoKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5hZGRMYXllcih0LCBlKSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUubW92ZUxheWVyID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5tb3ZlTGF5ZXIodCwgZSksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5yZW1vdmVMYXllcih0KSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZ2V0TGF5ZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldExheWVyKHQpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5zZXRMYXllclpvb21SYW5nZSA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuc2V0TGF5ZXJab29tUmFuZ2UodCwgZSwgaSksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldEZpbHRlciA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gaSAmJiAoaSA9IHt9KSwgdGhpcy5zdHlsZS5zZXRGaWx0ZXIodCwgZSwgaSksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0RmlsdGVyKHQpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5zZXRQYWludFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBvICYmIChvID0ge30pLCB0aGlzLnN0eWxlLnNldFBhaW50UHJvcGVydHkodCwgZSwgaSwgbyksIHRoaXMuX3VwZGF0ZSghMCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldFBhaW50UHJvcGVydHkgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldFBhaW50UHJvcGVydHkodCwgZSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldExheW91dFByb3BlcnR5ID0gZnVuY3Rpb24gKHQsIGUsIGksIG8pIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBvICYmIChvID0ge30pLCB0aGlzLnN0eWxlLnNldExheW91dFByb3BlcnR5KHQsIGUsIGksIG8pLCB0aGlzLl91cGRhdGUoITApO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5nZXRMYXlvdXRQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5b3V0UHJvcGVydHkodCwgZSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnNldExpZ2h0ID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0ge30pLCB0aGlzLl9sYXp5SW5pdEVtcHR5U3R5bGUoKSwgdGhpcy5zdHlsZS5zZXRMaWdodCh0LCBlKSwgdGhpcy5fdXBkYXRlKCEwKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZ2V0TGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGlnaHQoKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuc2V0RmVhdHVyZVN0YXRlID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5zZXRGZWF0dXJlU3RhdGUodCwgZSksIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlU3RhdGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnJlbW92ZUZlYXR1cmVTdGF0ZSh0LCBlKSwgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldEZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0RmVhdHVyZVN0YXRlKHQpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5nZXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuZ2V0Q2FudmFzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNDb250YWluZXI7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLmdldENhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fY29udGFpbmVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IDAsXG4gICAgICAgICAgICBlID0gMDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyICYmICh0ID0gdGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDQwMCwgZSA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMzAwKSwgW3QsIGVdO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fc2V0dXBDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgICAgdC5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1tYXBcIiwgXCJtYXBib3hnbC1tYXBcIik7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLl9jYW52YXNDb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY2FudmFzLWNvbnRhaW5lciBtYXBib3hnbC1jYW52YXMtY29udGFpbmVyXCIsIHQpO1xuICAgICAgICAgIHRoaXMuX2ludGVyYWN0aXZlICYmIGUuY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtaW50ZXJhY3RpdmVcIiwgXCJtYXBib3hnbC1pbnRlcmFjdGl2ZVwiKSwgdGhpcy5fY2FudmFzID0gaS5jcmVhdGUoXCJjYW52YXNcIiwgXCJtYXBsaWJyZWdsLWNhbnZhcyBtYXBib3hnbC1jYW52YXNcIiwgZSksIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLl9jb250ZXh0TG9zdCwgITEpLCB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuX2NvbnRleHRSZXN0b3JlZCwgITEpLCB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpLCB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIk1hcFwiKSwgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJyZWdpb25cIik7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLl9jb250YWluZXJEaW1lbnNpb25zKCk7XG4gICAgICAgICAgdGhpcy5fcmVzaXplQ2FudmFzKG9bMF0sIG9bMV0pO1xuICAgICAgICAgIHZhciByID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jb250cm9sLWNvbnRhaW5lciBtYXBib3hnbC1jb250cm9sLWNvbnRhaW5lclwiLCB0KSxcbiAgICAgICAgICAgIGEgPSB0aGlzLl9jb250cm9sUG9zaXRpb25zID0ge307XG4gICAgICAgICAgW1widG9wLWxlZnRcIiwgXCJ0b3AtcmlnaHRcIiwgXCJib3R0b20tbGVmdFwiLCBcImJvdHRvbS1yaWdodFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBhW3RdID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWN0cmwtXCIgKyB0ICsgXCIgbWFwYm94Z2wtY3RybC1cIiArIHQsIHIpO1xuICAgICAgICAgIH0pLCB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLl9vbk1hcFNjcm9sbCwgITEpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fcmVzaXplQ2FudmFzID0gZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICB2YXIgbyA9IHQuYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gbyAqIGUsIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBvICogaSwgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gZSArIFwicHhcIiwgdGhpcy5fY2FudmFzLnN0eWxlLmhlaWdodCA9IGkgKyBcInB4XCI7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLl9zZXR1cFBhaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGkgPSB0LmV4dGVuZCh7fSwgZS53ZWJHTENvbnRleHRBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRoaXMuX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQsXG4gICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICAgICAgICBhbnRpYWxpYXM6IHRoaXMuX2FudGlhbGlhcyB8fCAhMVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBpKSB8fCB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBpKTtcbiAgICAgICAgICBvID8gKHRoaXMucGFpbnRlciA9IG5ldyB5byhvLCB0aGlzLnRyYW5zZm9ybSksIHQud2VicFN1cHBvcnRlZC50ZXN0U3VwcG9ydChvKSkgOiB0aGlzLmZpcmUobmV3IHQuRXJyb3JFdmVudChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTFwiKSkpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fY29udGV4dExvc3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZnJhbWUgJiYgKHRoaXMuX2ZyYW1lLmNhbmNlbCgpLCB0aGlzLl9mcmFtZSA9IG51bGwpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLl9jb250ZXh0UmVzdG9yZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpLCB0aGlzLnJlc2l6ZSgpLCB0aGlzLl91cGRhdGUoKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX29uTWFwU2Nyb2xsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpZiAodC50YXJnZXQgPT09IHRoaXMuX2NvbnRhaW5lcikgcmV0dXJuIHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgPSAwLCB0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDAsICExO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLl9zdHlsZURpcnR5ICYmICF0aGlzLl9zb3VyY2VzRGlydHkgJiYgISF0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUubG9hZGVkKCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlID8gKHRoaXMuX3N0eWxlRGlydHkgPSB0aGlzLl9zdHlsZURpcnR5IHx8IHQsIHRoaXMuX3NvdXJjZXNEaXJ0eSA9ICEwLCB0aGlzLnRyaWdnZXJSZXBhaW50KCksIHRoaXMpIDogdGhpcztcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX3JlcXVlc3RSZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9yZW5kZXJUYXNrUXVldWUuYWRkKHQpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fY2FuY2VsUmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlclRhc2tRdWV1ZS5yZW1vdmUodCk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbyA9IHRoaXMsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIGEgPSB0aGlzLnBhaW50ZXIuY29udGV4dC5leHRUaW1lclF1ZXJ5O1xuICAgICAgICAgIGlmICh0aGlzLmxpc3RlbnMoXCJncHUtdGltaW5nLWZyYW1lXCIpICYmIChpID0gYS5jcmVhdGVRdWVyeUVYVCgpLCBhLmJlZ2luUXVlcnlFWFQoYS5USU1FX0VMQVBTRURfRVhULCBpKSwgciA9IHQuYnJvd3Nlci5ub3coKSksIHRoaXMucGFpbnRlci5jb250ZXh0LnNldERpcnR5KCksIHRoaXMucGFpbnRlci5zZXRCYXNlU3RhdGUoKSwgdGhpcy5fcmVuZGVyVGFza1F1ZXVlLnJ1bihlKSwgIXRoaXMuX3JlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBuID0gITE7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zdHlsZURpcnR5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSAhMTtcbiAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnRyYW5zZm9ybS56b29tLFxuICAgICAgICAgICAgICAgIGwgPSB0LmJyb3dzZXIubm93KCk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuem9vbUhpc3RvcnkudXBkYXRlKHMsIGwpO1xuICAgICAgICAgICAgICB2YXIgYyA9IG5ldyB0LkV2YWx1YXRpb25QYXJhbWV0ZXJzKHMsIHtcbiAgICAgICAgICAgICAgICAgIG5vdzogbCxcbiAgICAgICAgICAgICAgICAgIGZhZGVEdXJhdGlvbjogdGhpcy5fZmFkZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgem9vbUhpc3Rvcnk6IHRoaXMuc3R5bGUuem9vbUhpc3RvcnksXG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLnN0eWxlLmdldFRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHUgPSBjLmNyb3NzRmFkaW5nRmFjdG9yKCk7XG4gICAgICAgICAgICAgIDEgPT09IHUgJiYgdSA9PT0gdGhpcy5fY3Jvc3NGYWRpbmdGYWN0b3IgfHwgKG4gPSAhMCwgdGhpcy5fY3Jvc3NGYWRpbmdGYWN0b3IgPSB1KSwgdGhpcy5zdHlsZS51cGRhdGUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zb3VyY2VzRGlydHkgJiYgKHRoaXMuX3NvdXJjZXNEaXJ0eSA9ICExLCB0aGlzLnN0eWxlLl91cGRhdGVTb3VyY2VzKHRoaXMudHJhbnNmb3JtKSksIHRoaXMuX3BsYWNlbWVudERpcnR5ID0gdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLl91cGRhdGVQbGFjZW1lbnQodGhpcy5wYWludGVyLnRyYW5zZm9ybSwgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMsIHRoaXMuX2ZhZGVEdXJhdGlvbiwgdGhpcy5fY3Jvc3NTb3VyY2VDb2xsaXNpb25zKSwgdGhpcy5wYWludGVyLnJlbmRlcih0aGlzLnN0eWxlLCB7XG4gICAgICAgICAgICAgIHNob3dUaWxlQm91bmRhcmllczogdGhpcy5zaG93VGlsZUJvdW5kYXJpZXMsXG4gICAgICAgICAgICAgIHNob3dPdmVyZHJhd0luc3BlY3RvcjogdGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yLFxuICAgICAgICAgICAgICByb3RhdGluZzogdGhpcy5pc1JvdGF0aW5nKCksXG4gICAgICAgICAgICAgIHpvb21pbmc6IHRoaXMuaXNab29taW5nKCksXG4gICAgICAgICAgICAgIG1vdmluZzogdGhpcy5pc01vdmluZygpLFxuICAgICAgICAgICAgICBmYWRlRHVyYXRpb246IHRoaXMuX2ZhZGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgc2hvd1BhZGRpbmc6IHRoaXMuc2hvd1BhZGRpbmcsXG4gICAgICAgICAgICAgIGdwdVRpbWluZzogISF0aGlzLmxpc3RlbnMoXCJncHUtdGltaW5nLWxheWVyXCIpXG4gICAgICAgICAgICB9KSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwicmVuZGVyXCIpKSwgdGhpcy5sb2FkZWQoKSAmJiAhdGhpcy5fbG9hZGVkICYmICh0aGlzLl9sb2FkZWQgPSAhMCwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwibG9hZFwiKSkpLCB0aGlzLnN0eWxlICYmICh0aGlzLnN0eWxlLmhhc1RyYW5zaXRpb25zKCkgfHwgbikgJiYgKHRoaXMuX3N0eWxlRGlydHkgPSAhMCksIHRoaXMuc3R5bGUgJiYgIXRoaXMuX3BsYWNlbWVudERpcnR5ICYmIHRoaXMuc3R5bGUuX3JlbGVhc2VTeW1ib2xGYWRlVGlsZXMoKSwgdGhpcy5saXN0ZW5zKFwiZ3B1LXRpbWluZy1mcmFtZVwiKSkge1xuICAgICAgICAgICAgICB2YXIgaCA9IHQuYnJvd3Nlci5ub3coKSAtIHI7XG4gICAgICAgICAgICAgIGEuZW5kUXVlcnlFWFQoYS5USU1FX0VMQVBTRURfRVhULCBpKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhLmdldFF1ZXJ5T2JqZWN0RVhUKGksIGEuUVVFUllfUkVTVUxUX0VYVCkgLyAxZTY7XG4gICAgICAgICAgICAgICAgYS5kZWxldGVRdWVyeUVYVChpKSwgby5maXJlKG5ldyB0LkV2ZW50KFwiZ3B1LXRpbWluZy1mcmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICBjcHVUaW1lOiBoLFxuICAgICAgICAgICAgICAgICAgZ3B1VGltZTogZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVucyhcImdwdS10aW1pbmctbGF5ZXJcIikpIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhaW50ZXIuY29sbGVjdEdwdVRpbWVycygpO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IG8ucGFpbnRlci5xdWVyeUdwdVRpbWVycyhwKTtcbiAgICAgICAgICAgICAgICBvLmZpcmUobmV3IHQuRXZlbnQoXCJncHUtdGltaW5nLWxheWVyXCIsIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyVGltZXM6IGVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5fc291cmNlc0RpcnR5IHx8IHRoaXMuX3N0eWxlRGlydHkgfHwgdGhpcy5fcGxhY2VtZW50RGlydHk7XG4gICAgICAgICAgICByZXR1cm4gZCB8fCB0aGlzLl9yZXBhaW50ID8gdGhpcy50cmlnZ2VyUmVwYWludCgpIDogIXRoaXMuaXNNb3ZpbmcoKSAmJiB0aGlzLmxvYWRlZCgpICYmIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImlkbGVcIikpLCAhdGhpcy5fbG9hZGVkIHx8IHRoaXMuX2Z1bGx5TG9hZGVkIHx8IGQgfHwgKHRoaXMuX2Z1bGx5TG9hZGVkID0gITApLCB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2hhc2ggJiYgdGhpcy5faGFzaC5yZW1vdmUoKTtcbiAgICAgICAgICBmb3IgKHZhciBlID0gMCwgaSA9IHRoaXMuX2NvbnRyb2xzOyBlIDwgaS5sZW5ndGg7IGUgKz0gMSkgaVtlXS5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgICB0aGlzLl9jb250cm9scyA9IFtdLCB0aGlzLl9mcmFtZSAmJiAodGhpcy5fZnJhbWUuY2FuY2VsKCksIHRoaXMuX2ZyYW1lID0gbnVsbCksIHRoaXMuX3JlbmRlclRhc2tRdWV1ZS5jbGVhcigpLCB0aGlzLnBhaW50ZXIuZGVzdHJveSgpLCB0aGlzLmhhbmRsZXJzLmRlc3Ryb3koKSwgZGVsZXRlIHRoaXMuaGFuZGxlcnMsIHRoaXMuc2V0U3R5bGUobnVsbCksIHZvaWQgMCAhPT0gdC53aW5kb3cgJiYgKHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUsICExKSwgdC53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uV2luZG93UmVzaXplLCAhMSksIHQud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgdGhpcy5fb25XaW5kb3dPbmxpbmUsICExKSk7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzLnBhaW50ZXIuY29udGV4dC5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik7XG4gICAgICAgICAgbyAmJiBvLmxvc2VDb250ZXh0KCksIENyKHRoaXMuX2NhbnZhc0NvbnRhaW5lciksIENyKHRoaXMuX2NvbnRyb2xDb250YWluZXIpLCB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtbWFwXCIsIFwibWFwYm94Z2wtbWFwXCIpLCB0aGlzLl9yZW1vdmVkID0gITAsIHRoaXMuZmlyZShuZXcgdC5FdmVudChcInJlbW92ZVwiKSk7XG4gICAgICAgIH0sIHIucHJvdG90eXBlLnRyaWdnZXJSZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICB0aGlzLnN0eWxlICYmICF0aGlzLl9mcmFtZSAmJiAodGhpcy5fZnJhbWUgPSB0LmJyb3dzZXIuZnJhbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGUuX2ZyYW1lID0gbnVsbCwgZS5fcmVuZGVyKHQpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgci5wcm90b3R5cGUuX29uV2luZG93T25saW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fb25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX3RyYWNrUmVzaXplICYmIHRoaXMucmVzaXplKHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgICB9KS5fdXBkYXRlKCk7XG4gICAgICAgIH0sIGEuc2hvd1RpbGVCb3VuZGFyaWVzLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gISF0aGlzLl9zaG93VGlsZUJvdW5kYXJpZXM7XG4gICAgICAgIH0sIGEuc2hvd1RpbGVCb3VuZGFyaWVzLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzICE9PSB0ICYmICh0aGlzLl9zaG93VGlsZUJvdW5kYXJpZXMgPSB0LCB0aGlzLl91cGRhdGUoKSk7XG4gICAgICAgIH0sIGEuc2hvd1BhZGRpbmcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhIXRoaXMuX3Nob3dQYWRkaW5nO1xuICAgICAgICB9LCBhLnNob3dQYWRkaW5nLnNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5fc2hvd1BhZGRpbmcgIT09IHQgJiYgKHRoaXMuX3Nob3dQYWRkaW5nID0gdCwgdGhpcy5fdXBkYXRlKCkpO1xuICAgICAgICB9LCBhLnNob3dDb2xsaXNpb25Cb3hlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzO1xuICAgICAgICB9LCBhLnNob3dDb2xsaXNpb25Cb3hlcy5zZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX3Nob3dDb2xsaXNpb25Cb3hlcyAhPT0gdCAmJiAodGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzID0gdCwgdCA/IHRoaXMuc3R5bGUuX2dlbmVyYXRlQ29sbGlzaW9uQm94ZXMoKSA6IHRoaXMuX3VwZGF0ZSgpKTtcbiAgICAgICAgfSwgYS5zaG93T3ZlcmRyYXdJbnNwZWN0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAhIXRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvcjtcbiAgICAgICAgfSwgYS5zaG93T3ZlcmRyYXdJbnNwZWN0b3Iuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgIT09IHQgJiYgKHRoaXMuX3Nob3dPdmVyZHJhd0luc3BlY3RvciA9IHQsIHRoaXMuX3VwZGF0ZSgpKTtcbiAgICAgICAgfSwgYS5yZXBhaW50LmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gISF0aGlzLl9yZXBhaW50O1xuICAgICAgICB9LCBhLnJlcGFpbnQuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl9yZXBhaW50ICE9PSB0ICYmICh0aGlzLl9yZXBhaW50ID0gdCwgdGhpcy50cmlnZ2VyUmVwYWludCgpKTtcbiAgICAgICAgfSwgYS52ZXJ0aWNlcy5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5fdmVydGljZXM7XG4gICAgICAgIH0sIGEudmVydGljZXMuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IHQsIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9LCByLnByb3RvdHlwZS5fc2V0Q2FjaGVMaW1pdHMgPSBmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHQuc2V0Q2FjaGVMaW1pdHMoZSwgaSk7XG4gICAgICAgIH0sIGEudmVyc2lvbi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHQudmVyc2lvbjtcbiAgICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoci5wcm90b3R5cGUsIGEpLCByO1xuICAgICAgfSh2cik7XG4gICAgZnVuY3Rpb24gQ3IodCkge1xuICAgICAgdC5wYXJlbnROb2RlICYmIHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KTtcbiAgICB9XG4gICAgdmFyIHpyID0ge1xuICAgICAgICBzaG93Q29tcGFzczogITAsXG4gICAgICAgIHNob3dab29tOiAhMCxcbiAgICAgICAgdmlzdWFsaXplUGl0Y2g6ICExXG4gICAgICB9LFxuICAgICAgRHIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCB6ciwgZSksIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1ncm91cCBtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtZ3JvdXBcIiksIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLnNob3dab29tICYmICh0LmJpbmRBbGwoW1wiX3NldEJ1dHRvblRpdGxlXCIsIFwiX3VwZGF0ZVpvb21CdXR0b25zXCJdLCB0aGlzKSwgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwibWFwbGlicmVnbC1jdHJsLXpvb20taW4gbWFwYm94Z2wtY3RybC16b29tLWluXCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG8uX21hcC56b29tSW4oe30sIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGkuY3JlYXRlKFwic3BhblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1pY29uIG1hcGJveGdsLWN0cmwtaWNvblwiLCB0aGlzLl96b29tSW5CdXR0b24pLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcIm1hcGxpYnJlZ2wtY3RybC16b29tLW91dCBtYXBib3hnbC1jdHJsLXpvb20tb3V0XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG8uX21hcC56b29tT3V0KHt9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBsaWJyZWdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLWljb25cIiwgdGhpcy5fem9vbU91dEJ1dHRvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApKSwgdGhpcy5vcHRpb25zLnNob3dDb21wYXNzICYmICh0LmJpbmRBbGwoW1wiX3JvdGF0ZUNvbXBhc3NBcnJvd1wiXSwgdGhpcyksIHRoaXMuX2NvbXBhc3MgPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJtYXBsaWJyZWdsLWN0cmwtY29tcGFzcyBtYXBib3hnbC1jdHJsLWNvbXBhc3NcIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBvLm9wdGlvbnMudmlzdWFsaXplUGl0Y2ggPyBvLl9tYXAucmVzZXROb3J0aFBpdGNoKHt9LCB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB0XG4gICAgICAgICAgfSkgOiBvLl9tYXAucmVzZXROb3J0aCh7fSwge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgdGhpcy5fY29tcGFzc0ljb24gPSBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBsaWJyZWdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLWljb25cIiwgdGhpcy5fY29tcGFzcyksIHRoaXMuX2NvbXBhc3NJY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSk7XG4gICAgICB9O1xuICAgIERyLnByb3RvdHlwZS5fdXBkYXRlWm9vbUJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgIGUgPSB0ID09PSB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpLFxuICAgICAgICBpID0gdCA9PT0gdGhpcy5fbWFwLmdldE1pblpvb20oKTtcbiAgICAgIHRoaXMuX3pvb21JbkJ1dHRvbi5kaXNhYmxlZCA9IGUsIHRoaXMuX3pvb21PdXRCdXR0b24uZGlzYWJsZWQgPSBpLCB0aGlzLl96b29tSW5CdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCBlLnRvU3RyaW5nKCkpLCB0aGlzLl96b29tT3V0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgaS50b1N0cmluZygpKTtcbiAgICB9LCBEci5wcm90b3R5cGUuX3JvdGF0ZUNvbXBhc3NBcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoID8gXCJzY2FsZShcIiArIDEgLyBNYXRoLnBvdyhNYXRoLmNvcyh0aGlzLl9tYXAudHJhbnNmb3JtLnBpdGNoICogKE1hdGguUEkgLyAxODApKSwgLjUpICsgXCIpIHJvdGF0ZVgoXCIgKyB0aGlzLl9tYXAudHJhbnNmb3JtLnBpdGNoICsgXCJkZWcpIHJvdGF0ZVooXCIgKyB0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICogKDE4MCAvIE1hdGguUEkpICsgXCJkZWcpXCIgOiBcInJvdGF0ZShcIiArIHRoaXMuX21hcC50cmFuc2Zvcm0uYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkgKyBcImRlZylcIjtcbiAgICAgIHRoaXMuX2NvbXBhc3NJY29uLnN0eWxlLnRyYW5zZm9ybSA9IHQ7XG4gICAgfSwgRHIucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAgPSB0LCB0aGlzLm9wdGlvbnMuc2hvd1pvb20gJiYgKHRoaXMuX3NldEJ1dHRvblRpdGxlKHRoaXMuX3pvb21JbkJ1dHRvbiwgXCJab29tSW5cIiksIHRoaXMuX3NldEJ1dHRvblRpdGxlKHRoaXMuX3pvb21PdXRCdXR0b24sIFwiWm9vbU91dFwiKSwgdGhpcy5fbWFwLm9uKFwiem9vbVwiLCB0aGlzLl91cGRhdGVab29tQnV0dG9ucyksIHRoaXMuX3VwZGF0ZVpvb21CdXR0b25zKCkpLCB0aGlzLm9wdGlvbnMuc2hvd0NvbXBhc3MgJiYgKHRoaXMuX3NldEJ1dHRvblRpdGxlKHRoaXMuX2NvbXBhc3MsIFwiUmVzZXRCZWFyaW5nXCIpLCB0aGlzLm9wdGlvbnMudmlzdWFsaXplUGl0Y2ggJiYgdGhpcy5fbWFwLm9uKFwicGl0Y2hcIiwgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KSwgdGhpcy5fbWFwLm9uKFwicm90YXRlXCIsIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdyksIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdygpLCB0aGlzLl9oYW5kbGVyID0gbmV3IEFyKHRoaXMuX21hcCwgdGhpcy5fY29tcGFzcywgdGhpcy5vcHRpb25zLnZpc3VhbGl6ZVBpdGNoKSksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LCBEci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLm9wdGlvbnMuc2hvd1pvb20gJiYgdGhpcy5fbWFwLm9mZihcInpvb21cIiwgdGhpcy5fdXBkYXRlWm9vbUJ1dHRvbnMpLCB0aGlzLm9wdGlvbnMuc2hvd0NvbXBhc3MgJiYgKHRoaXMub3B0aW9ucy52aXN1YWxpemVQaXRjaCAmJiB0aGlzLl9tYXAub2ZmKFwicGl0Y2hcIiwgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KSwgdGhpcy5fbWFwLm9mZihcInJvdGF0ZVwiLCB0aGlzLl9yb3RhdGVDb21wYXNzQXJyb3cpLCB0aGlzLl9oYW5kbGVyLm9mZigpLCBkZWxldGUgdGhpcy5faGFuZGxlciksIGRlbGV0ZSB0aGlzLl9tYXA7XG4gICAgfSwgRHIucHJvdG90eXBlLl9jcmVhdGVCdXR0b24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIG8gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCB0LCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgcmV0dXJuIG8udHlwZSA9IFwiYnV0dG9uXCIsIG8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUpLCBvO1xuICAgIH0sIERyLnByb3RvdHlwZS5fc2V0QnV0dG9uVGl0bGUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiTmF2aWdhdGlvbkNvbnRyb2wuXCIgKyBlKTtcbiAgICAgIHQudGl0bGUgPSBpLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgaSk7XG4gICAgfTtcbiAgICB2YXIgQXIgPSBmdW5jdGlvbiAoZSwgbywgcikge1xuICAgICAgdm9pZCAwID09PSByICYmIChyID0gITEpLCB0aGlzLl9jbGlja1RvbGVyYW5jZSA9IDEwLCB0aGlzLmVsZW1lbnQgPSBvLCB0aGlzLm1vdXNlUm90YXRlID0gbmV3IFhvKHtcbiAgICAgICAgY2xpY2tUb2xlcmFuY2U6IGUuZHJhZ1JvdGF0ZS5fbW91c2VSb3RhdGUuX2NsaWNrVG9sZXJhbmNlXG4gICAgICB9KSwgdGhpcy5tYXAgPSBlLCByICYmICh0aGlzLm1vdXNlUGl0Y2ggPSBuZXcgSG8oe1xuICAgICAgICBjbGlja1RvbGVyYW5jZTogZS5kcmFnUm90YXRlLl9tb3VzZVBpdGNoLl9jbGlja1RvbGVyYW5jZVxuICAgICAgfSkpLCB0LmJpbmRBbGwoW1wibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiLCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiLCBcInJlc2V0XCJdLCB0aGlzKSwgaS5hZGRFdmVudExpc3RlbmVyKG8sIFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duKSwgaS5hZGRFdmVudExpc3RlbmVyKG8sIFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgIH0pLCBpLmFkZEV2ZW50TGlzdGVuZXIobywgXCJ0b3VjaG1vdmVcIiwgdGhpcy50b3VjaG1vdmUpLCBpLmFkZEV2ZW50TGlzdGVuZXIobywgXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKSwgaS5hZGRFdmVudExpc3RlbmVyKG8sIFwidG91Y2hjYW5jZWxcIiwgdGhpcy5yZXNldCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBNcihlLCBpLCBvKSB7XG4gICAgICBpZiAoZSA9IG5ldyB0LkxuZ0xhdChlLmxuZywgZS5sYXQpLCBpKSB7XG4gICAgICAgIHZhciByID0gbmV3IHQuTG5nTGF0KGUubG5nIC0gMzYwLCBlLmxhdCksXG4gICAgICAgICAgYSA9IG5ldyB0LkxuZ0xhdChlLmxuZyArIDM2MCwgZS5sYXQpLFxuICAgICAgICAgIG4gPSBvLmxvY2F0aW9uUG9pbnQoZSkuZGlzdFNxcihpKTtcbiAgICAgICAgby5sb2NhdGlvblBvaW50KHIpLmRpc3RTcXIoaSkgPCBuID8gZSA9IHIgOiBvLmxvY2F0aW9uUG9pbnQoYSkuZGlzdFNxcihpKSA8IG4gJiYgKGUgPSBhKTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBNYXRoLmFicyhlLmxuZyAtIG8uY2VudGVyLmxuZykgPiAxODA7KSB7XG4gICAgICAgIHZhciBzID0gby5sb2NhdGlvblBvaW50KGUpO1xuICAgICAgICBpZiAocy54ID49IDAgJiYgcy55ID49IDAgJiYgcy54IDw9IG8ud2lkdGggJiYgcy55IDw9IG8uaGVpZ2h0KSBicmVhaztcbiAgICAgICAgZS5sbmcgPiBvLmNlbnRlci5sbmcgPyBlLmxuZyAtPSAzNjAgOiBlLmxuZyArPSAzNjA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgQXIucHJvdG90eXBlLmRvd24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdGhpcy5tb3VzZVJvdGF0ZS5tb3VzZWRvd24odCwgZSksIHRoaXMubW91c2VQaXRjaCAmJiB0aGlzLm1vdXNlUGl0Y2gubW91c2Vkb3duKHQsIGUpLCBpLmRpc2FibGVEcmFnKCk7XG4gICAgfSwgQXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLm1hcCxcbiAgICAgICAgbyA9IHRoaXMubW91c2VSb3RhdGUubW91c2Vtb3ZlV2luZG93KHQsIGUpO1xuICAgICAgaWYgKG8gJiYgby5iZWFyaW5nRGVsdGEgJiYgaS5zZXRCZWFyaW5nKGkuZ2V0QmVhcmluZygpICsgby5iZWFyaW5nRGVsdGEpLCB0aGlzLm1vdXNlUGl0Y2gpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm1vdXNlUGl0Y2gubW91c2Vtb3ZlV2luZG93KHQsIGUpO1xuICAgICAgICByICYmIHIucGl0Y2hEZWx0YSAmJiBpLnNldFBpdGNoKGkuZ2V0UGl0Y2goKSArIHIucGl0Y2hEZWx0YSk7XG4gICAgICB9XG4gICAgfSwgQXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5lbGVtZW50O1xuICAgICAgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogITFcbiAgICAgIH0pLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaG1vdmVcIiwgdGhpcy50b3VjaG1vdmUpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIFwidG91Y2hjYW5jZWxcIiwgdGhpcy5yZXNldCksIHRoaXMub2ZmVGVtcCgpO1xuICAgIH0sIEFyLnByb3RvdHlwZS5vZmZUZW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgaS5lbmFibGVEcmFnKCksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LndpbmRvdywgXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodC53aW5kb3csIFwibW91c2V1cFwiLCB0aGlzLm1vdXNldXApO1xuICAgIH0sIEFyLnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5kb3duKHQuZXh0ZW5kKHt9LCBlLCB7XG4gICAgICAgIGN0cmxLZXk6ICEwLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBpLm1vdXNlUG9zKHRoaXMuZWxlbWVudCwgZSkpLCBpLmFkZEV2ZW50TGlzdGVuZXIodC53aW5kb3csIFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlKSwgaS5hZGRFdmVudExpc3RlbmVyKHQud2luZG93LCBcIm1vdXNldXBcIiwgdGhpcy5tb3VzZXVwKTtcbiAgICB9LCBBci5wcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMubW92ZSh0LCBpLm1vdXNlUG9zKHRoaXMuZWxlbWVudCwgdCkpO1xuICAgIH0sIEFyLnByb3RvdHlwZS5tb3VzZXVwID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMubW91c2VSb3RhdGUubW91c2V1cFdpbmRvdyh0KSwgdGhpcy5tb3VzZVBpdGNoICYmIHRoaXMubW91c2VQaXRjaC5tb3VzZXVwV2luZG93KHQpLCB0aGlzLm9mZlRlbXAoKTtcbiAgICB9LCBBci5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAxICE9PSB0LnRhcmdldFRvdWNoZXMubGVuZ3RoID8gdGhpcy5yZXNldCgpIDogKHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbGFzdFBvcyA9IGkudG91Y2hQb3ModGhpcy5lbGVtZW50LCB0LnRhcmdldFRvdWNoZXMpWzBdLCB0aGlzLmRvd24oe1xuICAgICAgICB0eXBlOiBcIm1vdXNlZG93blwiLFxuICAgICAgICBidXR0b246IDAsXG4gICAgICAgIGN0cmxLZXk6ICEwLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX3N0YXJ0UG9zKSk7XG4gICAgfSwgQXIucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAxICE9PSB0LnRhcmdldFRvdWNoZXMubGVuZ3RoID8gdGhpcy5yZXNldCgpIDogKHRoaXMuX2xhc3RQb3MgPSBpLnRvdWNoUG9zKHRoaXMuZWxlbWVudCwgdC50YXJnZXRUb3VjaGVzKVswXSwgdGhpcy5tb3ZlKHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9sYXN0UG9zKSk7XG4gICAgfSwgQXIucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIDAgPT09IHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggJiYgdGhpcy5fc3RhcnRQb3MgJiYgdGhpcy5fbGFzdFBvcyAmJiB0aGlzLl9zdGFydFBvcy5kaXN0KHRoaXMuX2xhc3RQb3MpIDwgdGhpcy5fY2xpY2tUb2xlcmFuY2UgJiYgdGhpcy5lbGVtZW50LmNsaWNrKCksIHRoaXMucmVzZXQoKTtcbiAgICB9LCBBci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLm1vdXNlUm90YXRlLnJlc2V0KCksIHRoaXMubW91c2VQaXRjaCAmJiB0aGlzLm1vdXNlUGl0Y2gucmVzZXQoKSwgZGVsZXRlIHRoaXMuX3N0YXJ0UG9zLCBkZWxldGUgdGhpcy5fbGFzdFBvcywgdGhpcy5vZmZUZW1wKCk7XG4gICAgfTtcbiAgICB2YXIgTHIgPSB7XG4gICAgICBjZW50ZXI6IFwidHJhbnNsYXRlKC01MCUsLTUwJSlcIixcbiAgICAgIHRvcDogXCJ0cmFuc2xhdGUoLTUwJSwwKVwiLFxuICAgICAgXCJ0b3AtbGVmdFwiOiBcInRyYW5zbGF0ZSgwLDApXCIsXG4gICAgICBcInRvcC1yaWdodFwiOiBcInRyYW5zbGF0ZSgtMTAwJSwwKVwiLFxuICAgICAgYm90dG9tOiBcInRyYW5zbGF0ZSgtNTAlLC0xMDAlKVwiLFxuICAgICAgXCJib3R0b20tbGVmdFwiOiBcInRyYW5zbGF0ZSgwLC0xMDAlKVwiLFxuICAgICAgXCJib3R0b20tcmlnaHRcIjogXCJ0cmFuc2xhdGUoLTEwMCUsLTEwMCUpXCIsXG4gICAgICBsZWZ0OiBcInRyYW5zbGF0ZSgwLC01MCUpXCIsXG4gICAgICByaWdodDogXCJ0cmFuc2xhdGUoLTEwMCUsLTUwJSlcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gUnIodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSB0LmNsYXNzTGlzdDtcbiAgICAgIGZvciAodmFyIHIgaW4gTHIpIG8ucmVtb3ZlKFwibWFwbGlicmVnbC1cIiArIGkgKyBcIi1hbmNob3ItXCIgKyByLCBcIm1hcGJveGdsLVwiICsgaSArIFwiLWFuY2hvci1cIiArIHIpO1xuICAgICAgby5hZGQoXCJtYXBsaWJyZWdsLVwiICsgaSArIFwiLWFuY2hvci1cIiArIGUsIFwibWFwYm94Z2wtXCIgKyBpICsgXCItYW5jaG9yLVwiICsgZSk7XG4gICAgfVxuICAgIHZhciBrcixcbiAgICAgIEJyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZnVuY3Rpb24gbyhvLCByKSB7XG4gICAgICAgICAgaWYgKGUuY2FsbCh0aGlzKSwgKG8gaW5zdGFuY2VvZiB0LndpbmRvdy5IVE1MRWxlbWVudCB8fCByKSAmJiAobyA9IHQuZXh0ZW5kKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG9cbiAgICAgICAgICB9LCByKSksIHQuYmluZEFsbChbXCJfdXBkYXRlXCIsIFwiX29uTW92ZVwiLCBcIl9vblVwXCIsIFwiX2FkZERyYWdIYW5kbGVyXCIsIFwiX29uTWFwQ2xpY2tcIiwgXCJfb25LZXlQcmVzc1wiXSwgdGhpcyksIHRoaXMuX2FuY2hvciA9IG8gJiYgby5hbmNob3IgfHwgXCJjZW50ZXJcIiwgdGhpcy5fY29sb3IgPSBvICYmIG8uY29sb3IgfHwgXCIjM0ZCMUNFXCIsIHRoaXMuX3NjYWxlID0gbyAmJiBvLnNjYWxlIHx8IDEsIHRoaXMuX2RyYWdnYWJsZSA9IG8gJiYgby5kcmFnZ2FibGUgfHwgITEsIHRoaXMuX2NsaWNrVG9sZXJhbmNlID0gbyAmJiBvLmNsaWNrVG9sZXJhbmNlIHx8IDAsIHRoaXMuX2lzRHJhZ2dpbmcgPSAhMSwgdGhpcy5fc3RhdGUgPSBcImluYWN0aXZlXCIsIHRoaXMuX3JvdGF0aW9uID0gbyAmJiBvLnJvdGF0aW9uIHx8IDAsIHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50ID0gbyAmJiBvLnJvdGF0aW9uQWxpZ25tZW50IHx8IFwiYXV0b1wiLCB0aGlzLl9waXRjaEFsaWdubWVudCA9IG8gJiYgby5waXRjaEFsaWdubWVudCAmJiBcImF1dG9cIiAhPT0gby5waXRjaEFsaWdubWVudCA/IG8ucGl0Y2hBbGlnbm1lbnQgOiB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCwgbyAmJiBvLmVsZW1lbnQpIHRoaXMuX2VsZW1lbnQgPSBvLmVsZW1lbnQsIHRoaXMuX29mZnNldCA9IHQuUG9pbnQuY29udmVydChvICYmIG8ub2Zmc2V0IHx8IFswLCAwXSk7ZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0TWFya2VyID0gITAsIHRoaXMuX2VsZW1lbnQgPSBpLmNyZWF0ZShcImRpdlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiTWFwIG1hcmtlclwiKTtcbiAgICAgICAgICAgIHZhciBhID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRpc3BsYXlcIiwgXCJibG9ja1wiKSwgYS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBcIjQxcHhcIiksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBcIjI3cHhcIiksIGEuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ2aWV3Qm94XCIsIFwiMCAwIDI3IDQxXCIpO1xuICAgICAgICAgICAgdmFyIG4gPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgICAgbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZVwiLCBcIm5vbmVcIiksIG4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2Utd2lkdGhcIiwgXCIxXCIpLCBuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIiksIG4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgICAgICAgdmFyIHMgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgICAgICAgICB2YXIgbCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgICBsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDMuMCwgMjkuMClcIiksIGwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiIzAwMDAwMFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLCB1ID0gW3tcbiAgICAgICAgICAgICAgICByeDogXCIxMC41XCIsXG4gICAgICAgICAgICAgICAgcnk6IFwiNS4yNTAwMjI3M1wiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByeDogXCIxMC41XCIsXG4gICAgICAgICAgICAgICAgcnk6IFwiNS4yNTAwMjI3M1wiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByeDogXCI5LjVcIixcbiAgICAgICAgICAgICAgICByeTogXCI0Ljc3Mjc1MDA3XCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJ4OiBcIjguNVwiLFxuICAgICAgICAgICAgICAgIHJ5OiBcIjQuMjk1NDk5MzZcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcng6IFwiNy41XCIsXG4gICAgICAgICAgICAgICAgcnk6IFwiMy44MTgyMjMwOFwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByeDogXCI2LjVcIixcbiAgICAgICAgICAgICAgICByeTogXCIzLjM0MDk0Njc5XCJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJ4OiBcIjUuNVwiLFxuICAgICAgICAgICAgICAgIHJ5OiBcIjIuODYzNjcwNTFcIlxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcng6IFwiNC41XCIsXG4gICAgICAgICAgICAgICAgcnk6IFwiMi4zODYzNjg2NFwiXG4gICAgICAgICAgICAgIH1dOyBjIDwgdS5sZW5ndGg7IGMgKz0gMSkge1xuICAgICAgICAgICAgICB2YXIgaCA9IHVbY10sXG4gICAgICAgICAgICAgICAgcCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImVsbGlwc2VcIik7XG4gICAgICAgICAgICAgIHAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJvcGFjaXR5XCIsIFwiMC4wNFwiKSwgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN4XCIsIFwiMTAuNVwiKSwgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIFwiNS44MDAyOTAwOFwiKSwgcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJ4XCIsIGgucngpLCBwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwicnlcIiwgaC5yeSksIGwuYXBwZW5kQ2hpbGQocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgICBkLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLl9jb2xvcik7XG4gICAgICAgICAgICB2YXIgXyA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIik7XG4gICAgICAgICAgICBfLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIk0yNywxMy41IEMyNywxOS4wNzQ2NDQgMjAuMjUwMDAxLDI3LjAwMDAwMiAxNC43NSwzNC41MDAwMDIgQzE0LjAxNjY2NSwzNS41MDAwMDQgMTIuOTgzMzM1LDM1LjUwMDAwNCAxMi4yNSwzNC41MDAwMDIgQzYuNzQ5OTk5MywyNy4wMDAwMDIgMCwxOS4yMjI1NjIgMCwxMy41IEMwLDYuMDQ0MTU1OSA2LjA0NDE1NTksMCAxMy41LDAgQzIwLjk1NTg0NCwwIDI3LDYuMDQ0MTU1OSAyNywxMy41IFpcIiksIGQuYXBwZW5kQ2hpbGQoXyk7XG4gICAgICAgICAgICB2YXIgZiA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgICBmLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwib3BhY2l0eVwiLCBcIjAuMjVcIiksIGYuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiIzAwMDAwMFwiKTtcbiAgICAgICAgICAgIHZhciBtID0gaS5jcmVhdGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKTtcbiAgICAgICAgICAgIG0uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIFwiTTEzLjUsMCBDNi4wNDQxNTU5LDAgMCw2LjA0NDE1NTkgMCwxMy41IEMwLDE5LjIyMjU2MiA2Ljc0OTk5OTMsMjcgMTIuMjUsMzQuNSBDMTMsMzUuNTIyNzI3IDE0LjAxNjY2NCwzNS41MDAwMDQgMTQuNzUsMzQuNSBDMjAuMjUwMDAxLDI3IDI3LDE5LjA3NDY0NCAyNywxMy41IEMyNyw2LjA0NDE1NTkgMjAuOTU1ODQ0LDAgMTMuNSwwIFogTTEzLjUsMSBDMjAuNDE1NDA0LDEgMjYsNi41ODQ1OTYgMjYsMTMuNSBDMjYsMTUuODk4NjU3IDI0LjQ5NTU4NCwxOS4xODE0MzEgMjIuMjIwNzAzLDIyLjczODI4MSBDMTkuOTQ1ODIzLDI2LjI5NTEzMiAxNi43MDUxMTksMzAuMTQyMTY3IDEzLjk0MzM1OSwzMy45MDgyMDMgQzEzLjc0MzQ0NSwzNC4xODA4MTQgMTMuNjEyNzE1LDM0LjMyMjczOCAxMy41LDM0LjQ0MTQwNiBDMTMuMzg3Mjg1LDM0LjMyMjczOCAxMy4yNTY1NTUsMzQuMTgwODE0IDEzLjA1NjY0MSwzMy45MDgyMDMgQzEwLjI4NDQ4MSwzMC4xMjc5ODUgNy40MTQ4Njg0LDI2LjMxNDE1OSA1LjAxNTYyNSwyMi43NzM0MzggQzIuNjE2MzgxNiwxOS4yMzI3MTUgMSwxNS45NTM1MzggMSwxMy41IEMxLDYuNTg0NTk2IDYuNTg0NTk2LDEgMTMuNSwxIFpcIiksIGYuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgICAgICB2YXIgZyA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gICAgICAgICAgICBnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDYuMCwgNy4wKVwiKSwgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCIjRkZGRkZGXCIpO1xuICAgICAgICAgICAgdmFyIHYgPSBpLmNyZWF0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICAgICAgICAgICAgdi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSg4LjAsIDguMClcIik7XG4gICAgICAgICAgICB2YXIgeSA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcbiAgICAgICAgICAgIHkuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiIzAwMDAwMFwiKSwgeS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9wYWNpdHlcIiwgXCIwLjI1XCIpLCB5LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgXCI1LjVcIiksIHkuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBcIjUuNVwiKSwgeS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgXCI1LjQ5OTk5NjJcIik7XG4gICAgICAgICAgICB2YXIgeCA9IGkuY3JlYXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcbiAgICAgICAgICAgIHguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwiI0ZGRkZGRlwiKSwgeC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN4XCIsIFwiNS41XCIpLCB4LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3lcIiwgXCI1LjVcIiksIHguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyXCIsIFwiNS40OTk5OTYyXCIpLCB2LmFwcGVuZENoaWxkKHkpLCB2LmFwcGVuZENoaWxkKHgpLCBzLmFwcGVuZENoaWxkKGwpLCBzLmFwcGVuZENoaWxkKGQpLCBzLmFwcGVuZENoaWxkKGYpLCBzLmFwcGVuZENoaWxkKGcpLCBzLmFwcGVuZENoaWxkKHYpLCBhLmFwcGVuZENoaWxkKHMpLCBhLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIDQxICogdGhpcy5fc2NhbGUgKyBcInB4XCIpLCBhLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgMjcgKiB0aGlzLl9zY2FsZSArIFwicHhcIiksIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQoYSksIHRoaXMuX29mZnNldCA9IHQuUG9pbnQuY29udmVydChvICYmIG8ub2Zmc2V0IHx8IFswLCAtMTRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1tYXJrZXJcIiwgXCJtYXBib3hnbC1tYXJrZXJcIiksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0pLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9KSwgUnIodGhpcy5fZWxlbWVudCwgdGhpcy5fYW5jaG9yLCBcIm1hcmtlclwiKSwgdGhpcy5fcG9wdXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlICYmIChvLl9fcHJvdG9fXyA9IGUpLCAoby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IG8sIG8ucHJvdG90eXBlLmFkZFRvID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoKSwgdGhpcy5fbWFwID0gdCwgdC5nZXRDYW52YXNDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSwgdC5vbihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdC5vbihcIm1vdmVlbmRcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5zZXREcmFnZ2FibGUodGhpcy5fZHJhZ2dhYmxlKSwgdGhpcy5fdXBkYXRlKCksIHRoaXMuX21hcC5vbihcImNsaWNrXCIsIHRoaXMuX29uTWFwQ2xpY2spLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hcCAmJiAodGhpcy5fbWFwLm9mZihcImNsaWNrXCIsIHRoaXMuX29uTWFwQ2xpY2spLCB0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLl9tYXAub2ZmKFwibW92ZWVuZFwiLCB0aGlzLl91cGRhdGUpLCB0aGlzLl9tYXAub2ZmKFwibW91c2Vkb3duXCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSwgdGhpcy5fbWFwLm9mZihcInRvdWNoc3RhcnRcIiwgdGhpcy5fYWRkRHJhZ0hhbmRsZXIpLCB0aGlzLl9tYXAub2ZmKFwibW91c2V1cFwiLCB0aGlzLl9vblVwKSwgdGhpcy5fbWFwLm9mZihcInRvdWNoZW5kXCIsIHRoaXMuX29uVXApLCB0aGlzLl9tYXAub2ZmKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW92ZSksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgZGVsZXRlIHRoaXMuX21hcCksIGkucmVtb3ZlKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5yZW1vdmUoKSwgdGhpcztcbiAgICAgICAgfSwgby5wcm90b3R5cGUuZ2V0TG5nTGF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9sbmdMYXQ7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnNldExuZ0xhdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdCA9IHQuTG5nTGF0LmNvbnZlcnQoZSksIHRoaXMuX3BvcyA9IG51bGwsIHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLnNldExuZ0xhdCh0aGlzLl9sbmdMYXQpLCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgICAgfSwgby5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuc2V0UG9wdXAgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0aGlzLl9wb3B1cCAmJiAodGhpcy5fcG9wdXAucmVtb3ZlKCksIHRoaXMuX3BvcHVwID0gbnVsbCwgdGhpcy5fZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyksIHRoaXMuX29yaWdpbmFsVGFiSW5kZXggfHwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSksIHQpIHtcbiAgICAgICAgICAgIGlmICghKFwib2Zmc2V0XCIgaW4gdC5vcHRpb25zKSkge1xuICAgICAgICAgICAgICB2YXIgZSA9IE1hdGguc3FydChNYXRoLnBvdygxMy41LCAyKSAvIDIpO1xuICAgICAgICAgICAgICB0Lm9wdGlvbnMub2Zmc2V0ID0gdGhpcy5fZGVmYXVsdE1hcmtlciA/IHtcbiAgICAgICAgICAgICAgICB0b3A6IFswLCAwXSxcbiAgICAgICAgICAgICAgICBcInRvcC1sZWZ0XCI6IFswLCAwXSxcbiAgICAgICAgICAgICAgICBcInRvcC1yaWdodFwiOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgYm90dG9tOiBbMCwgLTM4LjFdLFxuICAgICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogW2UsIC0xICogKDI0LjYgKyBlKV0sXG4gICAgICAgICAgICAgICAgXCJib3R0b20tcmlnaHRcIjogWy1lLCAtMSAqICgyNC42ICsgZSldLFxuICAgICAgICAgICAgICAgIGxlZnQ6IFsxMy41LCAtMjQuNl0sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IFstMTMuNSwgLTI0LjZdXG4gICAgICAgICAgICAgIH0gOiB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wb3B1cCA9IHQsIHRoaXMuX2xuZ0xhdCAmJiB0aGlzLl9wb3B1cC5zZXRMbmdMYXQodGhpcy5fbG5nTGF0KSwgdGhpcy5fb3JpZ2luYWxUYWJJbmRleCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiksIHRoaXMuX29yaWdpbmFsVGFiSW5kZXggfHwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIiksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIHRoaXMuX29uS2V5UHJlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgby5wcm90b3R5cGUuX29uS2V5UHJlc3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gdC5jb2RlLFxuICAgICAgICAgICAgaSA9IHQuY2hhckNvZGUgfHwgdC5rZXlDb2RlO1xuICAgICAgICAgIFwiU3BhY2VcIiAhPT0gZSAmJiBcIkVudGVyXCIgIT09IGUgJiYgMzIgIT09IGkgJiYgMTMgIT09IGkgfHwgdGhpcy50b2dnbGVQb3B1cCgpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fb25NYXBDbGljayA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSB0Lm9yaWdpbmFsRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgaSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5fcG9wdXAgJiYgKGUgPT09IGkgfHwgaS5jb250YWlucyhlKSkgJiYgdGhpcy50b2dnbGVQb3B1cCgpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5nZXRQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXA7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnRvZ2dsZVBvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gdGhpcy5fcG9wdXA7XG4gICAgICAgICAgcmV0dXJuIHQgPyAodC5pc09wZW4oKSA/IHQucmVtb3ZlKCkgOiB0LmFkZFRvKHRoaXMuX21hcCksIHRoaXMpIDogdGhpcztcbiAgICAgICAgfSwgby5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnRyYW5zZm9ybS5yZW5kZXJXb3JsZENvcGllcyAmJiAodGhpcy5fbG5nTGF0ID0gTXIodGhpcy5fbG5nTGF0LCB0aGlzLl9wb3MsIHRoaXMuX21hcC50cmFuc2Zvcm0pKSwgdGhpcy5fcG9zID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5fbG5nTGF0KS5fYWRkKHRoaXMuX29mZnNldCk7XG4gICAgICAgICAgICB2YXIgZSA9IFwiXCI7XG4gICAgICAgICAgICBcInZpZXdwb3J0XCIgPT09IHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50IHx8IFwiYXV0b1wiID09PSB0aGlzLl9yb3RhdGlvbkFsaWdubWVudCA/IGUgPSBcInJvdGF0ZVooXCIgKyB0aGlzLl9yb3RhdGlvbiArIFwiZGVnKVwiIDogXCJtYXBcIiA9PT0gdGhpcy5fcm90YXRpb25BbGlnbm1lbnQgJiYgKGUgPSBcInJvdGF0ZVooXCIgKyAodGhpcy5fcm90YXRpb24gLSB0aGlzLl9tYXAuZ2V0QmVhcmluZygpKSArIFwiZGVnKVwiKTtcbiAgICAgICAgICAgIHZhciBvID0gXCJcIjtcbiAgICAgICAgICAgIFwidmlld3BvcnRcIiA9PT0gdGhpcy5fcGl0Y2hBbGlnbm1lbnQgfHwgXCJhdXRvXCIgPT09IHRoaXMuX3BpdGNoQWxpZ25tZW50ID8gbyA9IFwicm90YXRlWCgwZGVnKVwiIDogXCJtYXBcIiA9PT0gdGhpcy5fcGl0Y2hBbGlnbm1lbnQgJiYgKG8gPSBcInJvdGF0ZVgoXCIgKyB0aGlzLl9tYXAuZ2V0UGl0Y2goKSArIFwiZGVnKVwiKSwgdCAmJiBcIm1vdmVlbmRcIiAhPT0gdC50eXBlIHx8ICh0aGlzLl9wb3MgPSB0aGlzLl9wb3Mucm91bmQoKSksIGkuc2V0VHJhbnNmb3JtKHRoaXMuX2VsZW1lbnQsIExyW3RoaXMuX2FuY2hvcl0gKyBcIiB0cmFuc2xhdGUoXCIgKyB0aGlzLl9wb3MueCArIFwicHgsIFwiICsgdGhpcy5fcG9zLnkgKyBcInB4KSBcIiArIG8gKyBcIiBcIiArIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgby5wcm90b3R5cGUuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnNldE9mZnNldCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCA9IHQuUG9pbnQuY29udmVydChlKSwgdGhpcy5fdXBkYXRlKCksIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICghdGhpcy5faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSB8fCB0aGlzLl9tYXAuX2NsaWNrVG9sZXJhbmNlO1xuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGUucG9pbnQuZGlzdCh0aGlzLl9wb2ludGVyZG93blBvcykgPj0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyAmJiAodGhpcy5fcG9zID0gZS5wb2ludC5zdWIodGhpcy5fcG9zaXRpb25EZWx0YSksIHRoaXMuX2xuZ0xhdCA9IHRoaXMuX21hcC51bnByb2plY3QodGhpcy5fcG9zKSwgdGhpcy5zZXRMbmdMYXQodGhpcy5fbG5nTGF0KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIsIFwicGVuZGluZ1wiID09PSB0aGlzLl9zdGF0ZSAmJiAodGhpcy5fc3RhdGUgPSBcImFjdGl2ZVwiLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJkcmFnc3RhcnRcIikpKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZHJhZ1wiKSkpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fb25VcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIiwgdGhpcy5fcG9zaXRpb25EZWx0YSA9IG51bGwsIHRoaXMuX3BvaW50ZXJkb3duUG9zID0gbnVsbCwgdGhpcy5faXNEcmFnZ2luZyA9ICExLCB0aGlzLl9tYXAub2ZmKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW92ZSksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgXCJhY3RpdmVcIiA9PT0gdGhpcy5fc3RhdGUgJiYgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiZHJhZ2VuZFwiKSksIHRoaXMuX3N0YXRlID0gXCJpbmFjdGl2ZVwiO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fYWRkRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuY29udGFpbnModC5vcmlnaW5hbEV2ZW50LnRhcmdldCkgJiYgKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fcG9zaXRpb25EZWx0YSA9IHQucG9pbnQuc3ViKHRoaXMuX3BvcykuYWRkKHRoaXMuX29mZnNldCksIHRoaXMuX3BvaW50ZXJkb3duUG9zID0gdC5wb2ludCwgdGhpcy5fc3RhdGUgPSBcInBlbmRpbmdcIiwgdGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW92ZSksIHRoaXMuX21hcC5vbihcInRvdWNobW92ZVwiLCB0aGlzLl9vbk1vdmUpLCB0aGlzLl9tYXAub25jZShcIm1vdXNldXBcIiwgdGhpcy5fb25VcCksIHRoaXMuX21hcC5vbmNlKFwidG91Y2hlbmRcIiwgdGhpcy5fb25VcCkpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5zZXREcmFnZ2FibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kcmFnZ2FibGUgPSAhIXQsIHRoaXMuX21hcCAmJiAodCA/ICh0aGlzLl9tYXAub24oXCJtb3VzZWRvd25cIiwgdGhpcy5fYWRkRHJhZ0hhbmRsZXIpLCB0aGlzLl9tYXAub24oXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSkgOiAodGhpcy5fbWFwLm9mZihcIm1vdXNlZG93blwiLCB0aGlzLl9hZGREcmFnSGFuZGxlciksIHRoaXMuX21hcC5vZmYoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2FkZERyYWdIYW5kbGVyKSkpLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5pc0RyYWdnYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ2dhYmxlO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uID0gdCB8fCAwLCB0aGlzLl91cGRhdGUoKSwgdGhpcztcbiAgICAgICAgfSwgby5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5zZXRSb3RhdGlvbkFsaWdubWVudCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uQWxpZ25tZW50ID0gdCB8fCBcImF1dG9cIiwgdGhpcy5fdXBkYXRlKCksIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLmdldFJvdGF0aW9uQWxpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbkFsaWdubWVudDtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuc2V0UGl0Y2hBbGlnbm1lbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9waXRjaEFsaWdubWVudCA9IHQgJiYgXCJhdXRvXCIgIT09IHQgPyB0IDogdGhpcy5fcm90YXRpb25BbGlnbm1lbnQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5nZXRQaXRjaEFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcGl0Y2hBbGlnbm1lbnQ7XG4gICAgICAgIH0sIG87XG4gICAgICB9KHQuRXZlbnRlZCksXG4gICAgICBPciA9IHtcbiAgICAgICAgcG9zaXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiAhMSxcbiAgICAgICAgICBtYXhpbXVtQWdlOiAwLFxuICAgICAgICAgIHRpbWVvdXQ6IDZlM1xuICAgICAgICB9LFxuICAgICAgICBmaXRCb3VuZHNPcHRpb25zOiB7XG4gICAgICAgICAgbWF4Wm9vbTogMTVcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2tVc2VyTG9jYXRpb246ICExLFxuICAgICAgICBzaG93QWNjdXJhY3lDaXJjbGU6ICEwLFxuICAgICAgICBzaG93VXNlckxvY2F0aW9uOiAhMFxuICAgICAgfSxcbiAgICAgIEZyID0gMCxcbiAgICAgIFVyID0gITEsXG4gICAgICBOciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGZ1bmN0aW9uIG8oaSkge1xuICAgICAgICAgIGUuY2FsbCh0aGlzKSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIE9yLCBpKSwgdC5iaW5kQWxsKFtcIl9vblN1Y2Nlc3NcIiwgXCJfb25FcnJvclwiLCBcIl9vblpvb21cIiwgXCJfZmluaXNoXCIsIFwiX3NldHVwVUlcIiwgXCJfdXBkYXRlQ2FtZXJhXCIsIFwiX3VwZGF0ZU1hcmtlclwiXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKG8uX19wcm90b19fID0gZSksIChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbywgby5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBvO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAgPSBlLCB0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtY3RybCBtYXBsaWJyZWdsLWN0cmwtZ3JvdXAgbWFwYm94Z2wtY3RybCBtYXBib3hnbC1jdHJsLWdyb3VwXCIpLCBvID0gdGhpcy5fc2V0dXBVSSwgdm9pZCAwICE9PSBrciA/IG8oa3IpIDogdm9pZCAwICE9PSB0LndpbmRvdy5uYXZpZ2F0b3IucGVybWlzc2lvbnMgPyB0LndpbmRvdy5uYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xuICAgICAgICAgICAgbmFtZTogXCJnZW9sb2NhdGlvblwiXG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgbyhrciA9IFwiZGVuaWVkXCIgIT09IHQuc3RhdGUpO1xuICAgICAgICAgIH0pIDogbyhrciA9ICEhdC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uKSwgdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2b2lkIDAgIT09IHRoaXMuX2dlb2xvY2F0aW9uV2F0Y2hJRCAmJiAodC53aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEKSwgdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEID0gdm9pZCAwKSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5fdXNlckxvY2F0aW9uRG90TWFya2VyICYmIHRoaXMuX3VzZXJMb2NhdGlvbkRvdE1hcmtlci5yZW1vdmUoKSwgdGhpcy5vcHRpb25zLnNob3dBY2N1cmFjeUNpcmNsZSAmJiB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlciAmJiB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlci5yZW1vdmUoKSwgaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgdGhpcy5fbWFwLm9mZihcInpvb21cIiwgdGhpcy5fb25ab29tKSwgdGhpcy5fbWFwID0gdm9pZCAwLCBGciA9IDAsIFVyID0gITE7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl9pc091dE9mTWFwTWF4Qm91bmRzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuX21hcC5nZXRNYXhCb3VuZHMoKSxcbiAgICAgICAgICAgIGkgPSB0LmNvb3JkcztcbiAgICAgICAgICByZXR1cm4gZSAmJiAoaS5sb25naXR1ZGUgPCBlLmdldFdlc3QoKSB8fCBpLmxvbmdpdHVkZSA+IGUuZ2V0RWFzdCgpIHx8IGkubGF0aXR1ZGUgPCBlLmdldFNvdXRoKCkgfHwgaS5sYXRpdHVkZSA+IGUuZ2V0Tm9ydGgoKSk7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl9zZXRFcnJvclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcIldBSVRJTkdfQUNUSVZFXCI6XG4gICAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkFDVElWRV9FUlJPUlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgICB0aGlzLl93YXRjaFN0YXRlID0gXCJBQ1RJVkVfRVJST1JcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZS1lcnJvclwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCQUNLR1JPVU5EXCI6XG4gICAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkJBQ0tHUk9VTkRfRVJST1JcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZC1lcnJvclwiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl9vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc091dE9mTWFwTWF4Qm91bmRzKGUpKSByZXR1cm4gdGhpcy5fc2V0RXJyb3JTdGF0ZSgpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJvdXRvZm1heGJvdW5kc1wiLCBlKSksIHRoaXMuX3VwZGF0ZU1hcmtlcigpLCB2b2lkIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFja1VzZXJMb2NhdGlvbikgc3dpdGNoICh0aGlzLl9sYXN0S25vd25Qb3NpdGlvbiA9IGUsIHRoaXMuX3dhdGNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIldBSVRJTkdfQUNUSVZFXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZFX0VSUk9SXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0xPQ0tcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlLWVycm9yXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIkJBQ0tHUk9VTkRcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZC1lcnJvclwiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIFwiT0ZGXCIgIT09IHRoaXMuX3dhdGNoU3RhdGUgJiYgdGhpcy5fdXBkYXRlTWFya2VyKGUpLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgXCJBQ1RJVkVfTE9DS1wiICE9PSB0aGlzLl93YXRjaFN0YXRlIHx8IHRoaXMuX3VwZGF0ZUNhbWVyYShlKSwgdGhpcy5vcHRpb25zLnNob3dVc2VyTG9jYXRpb24gJiYgdGhpcy5fZG90RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC11c2VyLWxvY2F0aW9uLWRvdC1zdGFsZVwiLCBcIm1hcGJveGdsLXVzZXItbG9jYXRpb24tZG90LXN0YWxlXCIpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJnZW9sb2NhdGVcIiwgZSkpLCB0aGlzLl9maW5pc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGVDYW1lcmEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpID0gbmV3IHQuTG5nTGF0KGUuY29vcmRzLmxvbmdpdHVkZSwgZS5jb29yZHMubGF0aXR1ZGUpLFxuICAgICAgICAgICAgbyA9IGUuY29vcmRzLmFjY3VyYWN5LFxuICAgICAgICAgICAgciA9IHRoaXMuX21hcC5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBhID0gdC5leHRlbmQoe1xuICAgICAgICAgICAgICBiZWFyaW5nOiByXG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZml0Qm91bmRzT3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhpLnRvQm91bmRzKG8pLCBhLCB7XG4gICAgICAgICAgICBnZW9sb2NhdGVTb3VyY2U6ICEwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGVNYXJrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG5ldyB0LkxuZ0xhdChlLmNvb3Jkcy5sb25naXR1ZGUsIGUuY29vcmRzLmxhdGl0dWRlKTtcbiAgICAgICAgICAgIHRoaXMuX2FjY3VyYWN5Q2lyY2xlTWFya2VyLnNldExuZ0xhdChpKS5hZGRUbyh0aGlzLl9tYXApLCB0aGlzLl91c2VyTG9jYXRpb25Eb3RNYXJrZXIuc2V0TG5nTGF0KGkpLmFkZFRvKHRoaXMuX21hcCksIHRoaXMuX2FjY3VyYWN5ID0gZS5jb29yZHMuYWNjdXJhY3ksIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIHRoaXMub3B0aW9ucy5zaG93QWNjdXJhY3lDaXJjbGUgJiYgdGhpcy5fdXBkYXRlQ2lyY2xlUmFkaXVzKCk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMuX3VzZXJMb2NhdGlvbkRvdE1hcmtlci5yZW1vdmUoKSwgdGhpcy5fYWNjdXJhY3lDaXJjbGVNYXJrZXIucmVtb3ZlKCk7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl91cGRhdGVDaXJjbGVSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLl9tYXAuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgLyAyLFxuICAgICAgICAgICAgZSA9IHRoaXMuX21hcC51bnByb2plY3QoWzAsIHRdKSxcbiAgICAgICAgICAgIGkgPSB0aGlzLl9tYXAudW5wcm9qZWN0KFsxLCB0XSksXG4gICAgICAgICAgICBvID0gZS5kaXN0YW5jZVRvKGkpLFxuICAgICAgICAgICAgciA9IE1hdGguY2VpbCgyICogdGhpcy5fYWNjdXJhY3kgLyBvKTtcbiAgICAgICAgICB0aGlzLl9jaXJjbGVFbGVtZW50LnN0eWxlLndpZHRoID0gciArIFwicHhcIiwgdGhpcy5fY2lyY2xlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSByICsgXCJweFwiO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fb25ab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93VXNlckxvY2F0aW9uICYmIHRoaXMub3B0aW9ucy5zaG93QWNjdXJhY3lDaXJjbGUgJiYgdGhpcy5fdXBkYXRlQ2lyY2xlUmFkaXVzKCk7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uKSBpZiAoMSA9PT0gZS5jb2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3dhdGNoU3RhdGUgPSBcIk9GRlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kLWVycm9yXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uZGlzYWJsZWQgPSAhMDtcbiAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiR2VvbG9jYXRlQ29udHJvbC5Mb2NhdGlvbk5vdEF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnRpdGxlID0gaSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgaSksIHZvaWQgMCAhPT0gdGhpcy5fZ2VvbG9jYXRpb25XYXRjaElEICYmIHRoaXMuX2NsZWFyV2F0Y2goKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICgzID09PSBlLmNvZGUgJiYgVXIpIHJldHVybjtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0RXJyb3JTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXCJPRkZcIiAhPT0gdGhpcy5fd2F0Y2hTdGF0ZSAmJiB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLl9kb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tZG90LXN0YWxlXCIsIFwibWFwYm94Z2wtdXNlci1sb2NhdGlvbi1kb3Qtc3RhbGVcIiksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcImVycm9yXCIsIGUpKSwgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvLnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX3RpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dElkKSwgdGhpcy5fdGltZW91dElkID0gdm9pZCAwO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fc2V0dXBVSSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgICAgIGlmICh0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0pLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCBcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUgbWFwYm94Z2wtY3RybC1nZW9sb2NhdGVcIiwgdGhpcy5fY29udGFpbmVyKSwgaS5jcmVhdGUoXCJzcGFuXCIsIFwibWFwbGlicmVnbC1jdHJsLWljb24gbWFwYm94Z2wtY3RybC1pY29uXCIsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbikuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24udHlwZSA9IFwiYnV0dG9uXCIsICExID09PSBlKSB7XG4gICAgICAgICAgICB0Lndhcm5PbmNlKFwiR2VvbG9jYXRpb24gc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlIHNvIHRoZSBHZW9sb2NhdGVDb250cm9sIHdpbGwgYmUgZGlzYWJsZWQuXCIpO1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiR2VvbG9jYXRlQ29udHJvbC5Mb2NhdGlvbk5vdEF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5kaXNhYmxlZCA9ICEwLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24udGl0bGUgPSByLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCByKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKFwiR2VvbG9jYXRlQ29udHJvbC5GaW5kTXlMb2NhdGlvblwiKTtcbiAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi50aXRsZSA9IGEsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgKHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXByZXNzZWRcIiwgXCJmYWxzZVwiKSwgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiT0ZGXCIpLCB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiAodGhpcy5fZG90RWxlbWVudCA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC11c2VyLWxvY2F0aW9uLWRvdCBtYXBib3hnbC11c2VyLWxvY2F0aW9uLWRvdFwiKSwgdGhpcy5fdXNlckxvY2F0aW9uRG90TWFya2VyID0gbmV3IEJyKHRoaXMuX2RvdEVsZW1lbnQpLCB0aGlzLl9jaXJjbGVFbGVtZW50ID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXVzZXItbG9jYXRpb24tYWNjdXJhY3ktY2lyY2xlIG1hcGJveGdsLXVzZXItbG9jYXRpb24tYWNjdXJhY3ktY2lyY2xlXCIpLCB0aGlzLl9hY2N1cmFjeUNpcmNsZU1hcmtlciA9IG5ldyBCcih7XG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLl9jaXJjbGVFbGVtZW50LFxuICAgICAgICAgICAgcGl0Y2hBbGlnbm1lbnQ6IFwibWFwXCJcbiAgICAgICAgICB9KSwgdGhpcy5vcHRpb25zLnRyYWNrVXNlckxvY2F0aW9uICYmICh0aGlzLl93YXRjaFN0YXRlID0gXCJPRkZcIiksIHRoaXMuX21hcC5vbihcInpvb21cIiwgdGhpcy5fb25ab29tKSksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50cmlnZ2VyLmJpbmQodGhpcykpLCB0aGlzLl9zZXR1cCA9ICEwLCB0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24gJiYgdGhpcy5fbWFwLm9uKFwibW92ZXN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLmdlb2xvY2F0ZVNvdXJjZSB8fCBcIkFDVElWRV9MT0NLXCIgIT09IG8uX3dhdGNoU3RhdGUgfHwgZS5vcmlnaW5hbEV2ZW50ICYmIFwicmVzaXplXCIgPT09IGUub3JpZ2luYWxFdmVudC50eXBlIHx8IChvLl93YXRjaFN0YXRlID0gXCJCQUNLR1JPVU5EXCIsIG8uX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgby5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZVwiKSwgby5maXJlKG5ldyB0LkV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25lbmRcIikpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3NldHVwKSByZXR1cm4gdC53YXJuT25jZShcIkdlb2xvY2F0ZSBjb250cm9sIHRyaWdnZXJlZCBiZWZvcmUgYWRkZWQgdG8gYSBtYXBcIiksICExO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2tVc2VyTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiV0FJVElOR19BQ1RJVkVcIiwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwidHJhY2t1c2VybG9jYXRpb25zdGFydFwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJXQUlUSU5HX0FDVElWRVwiOlxuICAgICAgICAgICAgICBjYXNlIFwiQUNUSVZFX0xPQ0tcIjpcbiAgICAgICAgICAgICAgY2FzZSBcIkFDVElWRV9FUlJPUlwiOlxuICAgICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICAgICAgICAgIEZyLS0sIFVyID0gITEsIHRoaXMuX3dhdGNoU3RhdGUgPSBcIk9GRlwiLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYmFja2dyb3VuZFwiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kLWVycm9yXCIpLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ0cmFja3VzZXJsb2NhdGlvbmVuZFwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJCQUNLR1JPVU5EXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hTdGF0ZSA9IFwiQUNUSVZFX0xPQ0tcIiwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpLCB0aGlzLl9sYXN0S25vd25Qb3NpdGlvbiAmJiB0aGlzLl91cGRhdGVDYW1lcmEodGhpcy5fbGFzdEtub3duUG9zaXRpb24pLCB0aGlzLmZpcmUobmV3IHQuRXZlbnQoXCJ0cmFja3VzZXJsb2NhdGlvbnN0YXJ0XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fd2F0Y2hTdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiV0FJVElOR19BQ1RJVkVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfTE9DS1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJBQ1RJVkVfRVJST1JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9sb2NhdGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGxpYnJlZ2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiLCBcIm1hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiksIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJCQUNLR1JPVU5EXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmRcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiQkFDS0dST1VORF9FUlJPUlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3JcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1iYWNrZ3JvdW5kLWVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwiT0ZGXCIgPT09IHRoaXMuX3dhdGNoU3RhdGUgJiYgdm9pZCAwICE9PSB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQpIHRoaXMuX2NsZWFyV2F0Y2goKTtlbHNlIGlmICh2b2lkIDAgPT09IHRoaXMuX2dlb2xvY2F0aW9uV2F0Y2hJRCkge1xuICAgICAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLWN0cmwtZ2VvbG9jYXRlLXdhaXRpbmdcIiwgXCJtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIpLCB0aGlzLl9nZW9sb2NhdGVCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiKSwgKytGciA+IDEgPyAoZSA9IHtcbiAgICAgICAgICAgICAgICBtYXhpbXVtQWdlOiA2ZTUsXG4gICAgICAgICAgICAgICAgdGltZW91dDogMFxuICAgICAgICAgICAgICB9LCBVciA9ICEwKSA6IChlID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uT3B0aW9ucywgVXIgPSAhMSksIHRoaXMuX2dlb2xvY2F0aW9uV2F0Y2hJRCA9IHQud2luZG93Lm5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKHRoaXMuX29uU3VjY2VzcywgdGhpcy5fb25FcnJvciwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHQud2luZG93Lm5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24odGhpcy5fb25TdWNjZXNzLCB0aGlzLl9vbkVycm9yLCB0aGlzLm9wdGlvbnMucG9zaXRpb25PcHRpb25zKSwgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9maW5pc2gsIDFlNCk7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fY2xlYXJXYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0LndpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQpLCB0aGlzLl9nZW9sb2NhdGlvbldhdGNoSUQgPSB2b2lkIDAsIHRoaXMuX2dlb2xvY2F0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwibWFwbGlicmVnbC1jdHJsLWdlb2xvY2F0ZS13YWl0aW5nXCIsIFwibWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZ1wiKSwgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpLCB0aGlzLm9wdGlvbnMuc2hvd1VzZXJMb2NhdGlvbiAmJiB0aGlzLl91cGRhdGVNYXJrZXIobnVsbCk7XG4gICAgICAgIH0sIG87XG4gICAgICB9KHQuRXZlbnRlZCksXG4gICAgICBaciA9IHtcbiAgICAgICAgbWF4V2lkdGg6IDEwMCxcbiAgICAgICAgdW5pdDogXCJtZXRyaWNcIlxuICAgICAgfSxcbiAgICAgIHFyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIFpyLCBlKSwgdC5iaW5kQWxsKFtcIl9vbk1vdmVcIiwgXCJzZXRVbml0XCJdLCB0aGlzKTtcbiAgICAgIH07XG4gICAgZnVuY3Rpb24ganIodCwgZSwgaSkge1xuICAgICAgdmFyIG8gPSBpICYmIGkubWF4V2lkdGggfHwgMTAwLFxuICAgICAgICByID0gdC5fY29udGFpbmVyLmNsaWVudEhlaWdodCAvIDIsXG4gICAgICAgIGEgPSB0LnVucHJvamVjdChbMCwgcl0pLFxuICAgICAgICBuID0gdC51bnByb2plY3QoW28sIHJdKSxcbiAgICAgICAgcyA9IGEuZGlzdGFuY2VUbyhuKTtcbiAgICAgIGlmIChpICYmIFwiaW1wZXJpYWxcIiA9PT0gaS51bml0KSB7XG4gICAgICAgIHZhciBsID0gMy4yODA4ICogcztcbiAgICAgICAgbCA+IDUyODAgPyBWcihlLCBvLCBsIC8gNTI4MCwgdC5fZ2V0VUlTdHJpbmcoXCJTY2FsZUNvbnRyb2wuTWlsZXNcIikpIDogVnIoZSwgbywgbCwgdC5fZ2V0VUlTdHJpbmcoXCJTY2FsZUNvbnRyb2wuRmVldFwiKSk7XG4gICAgICB9IGVsc2UgaSAmJiBcIm5hdXRpY2FsXCIgPT09IGkudW5pdCA/IFZyKGUsIG8sIHMgLyAxODUyLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5OYXV0aWNhbE1pbGVzXCIpKSA6IHMgPj0gMWUzID8gVnIoZSwgbywgcyAvIDFlMywgdC5fZ2V0VUlTdHJpbmcoXCJTY2FsZUNvbnRyb2wuS2lsb21ldGVyc1wiKSkgOiBWcihlLCBvLCBzLCB0Ll9nZXRVSVN0cmluZyhcIlNjYWxlQ29udHJvbC5NZXRlcnNcIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWcih0LCBlLCBpLCBvKSB7XG4gICAgICB2YXIgcixcbiAgICAgICAgYSxcbiAgICAgICAgbixcbiAgICAgICAgcyA9IChyID0gaSwgKGEgPSBNYXRoLnBvdygxMCwgKFwiXCIgKyBNYXRoLmZsb29yKHIpKS5sZW5ndGggLSAxKSkgKiAobiA9IChuID0gciAvIGEpID49IDEwID8gMTAgOiBuID49IDUgPyA1IDogbiA+PSAzID8gMyA6IG4gPj0gMiA/IDIgOiBuID49IDEgPyAxIDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IE1hdGgucG93KDEwLCBNYXRoLmNlaWwoLU1hdGgubG9nKHQpIC8gTWF0aC5MTjEwKSk7XG4gICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodCAqIGUpIC8gZTtcbiAgICAgICAgfShuKSkpO1xuICAgICAgdC5zdHlsZS53aWR0aCA9IGUgKiAocyAvIGkpICsgXCJweFwiLCB0LmlubmVySFRNTCA9IHMgKyBcIiZuYnNwO1wiICsgbztcbiAgICB9XG4gICAgcXIucHJvdG90eXBlLmdldERlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcImJvdHRvbS1sZWZ0XCI7XG4gICAgfSwgcXIucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBqcih0aGlzLl9tYXAsIHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zKTtcbiAgICB9LCBxci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA9IHQsIHRoaXMuX2NvbnRhaW5lciA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1jdHJsIG1hcGxpYnJlZ2wtY3RybC1zY2FsZSBtYXBib3hnbC1jdHJsIG1hcGJveGdsLWN0cmwtc2NhbGVcIiwgdC5nZXRDb250YWluZXIoKSksIHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fb25Nb3ZlKSwgdGhpcy5fb25Nb3ZlKCksIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LCBxci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250YWluZXIpLCB0aGlzLl9tYXAub2ZmKFwibW92ZVwiLCB0aGlzLl9vbk1vdmUpLCB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgfSwgcXIucHJvdG90eXBlLnNldFVuaXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVuaXQgPSB0LCBqcih0aGlzLl9tYXAsIHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIHZhciBHciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9mdWxsc2NyZWVuID0gITEsIGUgJiYgZS5jb250YWluZXIgJiYgKGUuY29udGFpbmVyIGluc3RhbmNlb2YgdC53aW5kb3cuSFRNTEVsZW1lbnQgPyB0aGlzLl9jb250YWluZXIgPSBlLmNvbnRhaW5lciA6IHQud2Fybk9uY2UoXCJGdWxsIHNjcmVlbiBjb250cm9sICdjb250YWluZXInIG11c3QgYmUgYSBET00gZWxlbWVudC5cIikpLCB0LmJpbmRBbGwoW1wiX29uQ2xpY2tGdWxsc2NyZWVuXCIsIFwiX2NoYW5nZUljb25cIl0sIHRoaXMpLCBcIm9uZnVsbHNjcmVlbmNoYW5nZVwiIGluIHQud2luZG93LmRvY3VtZW50ID8gdGhpcy5fZnVsbHNjcmVlbmNoYW5nZSA9IFwiZnVsbHNjcmVlbmNoYW5nZVwiIDogXCJvbm1vemZ1bGxzY3JlZW5jaGFuZ2VcIiBpbiB0LndpbmRvdy5kb2N1bWVudCA/IHRoaXMuX2Z1bGxzY3JlZW5jaGFuZ2UgPSBcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIiA6IFwib253ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIgaW4gdC53aW5kb3cuZG9jdW1lbnQgPyB0aGlzLl9mdWxsc2NyZWVuY2hhbmdlID0gXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIgOiBcIm9ubXNmdWxsc2NyZWVuY2hhbmdlXCIgaW4gdC53aW5kb3cuZG9jdW1lbnQgJiYgKHRoaXMuX2Z1bGxzY3JlZW5jaGFuZ2UgPSBcIk1TRnVsbHNjcmVlbkNoYW5nZVwiKTtcbiAgICB9O1xuICAgIEdyLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwID0gZSwgdGhpcy5fY29udGFpbmVyIHx8ICh0aGlzLl9jb250YWluZXIgPSB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkpLCB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLWN0cmwgbWFwbGlicmVnbC1jdHJsLWdyb3VwIG1hcGJveGdsLWN0cmwgbWFwYm94Z2wtY3RybC1ncm91cFwiKSwgdGhpcy5fY2hlY2tGdWxsc2NyZWVuU3VwcG9ydCgpID8gdGhpcy5fc2V0dXBVSSgpIDogKHRoaXMuX2NvbnRyb2xDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiLCB0Lndhcm5PbmNlKFwiVGhpcyBkZXZpY2UgZG9lcyBub3Qgc3VwcG9ydCBmdWxsc2NyZWVuIG1vZGUuXCIpKSwgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcbiAgICB9LCBHci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKSwgdGhpcy5fbWFwID0gbnVsbCwgdC53aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9mdWxsc2NyZWVuY2hhbmdlLCB0aGlzLl9jaGFuZ2VJY29uKTtcbiAgICB9LCBHci5wcm90b3R5cGUuX2NoZWNrRnVsbHNjcmVlblN1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISEodC53aW5kb3cuZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHwgdC53aW5kb3cuZG9jdW1lbnQubW96RnVsbFNjcmVlbkVuYWJsZWQgfHwgdC53aW5kb3cuZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZCB8fCB0LndpbmRvdy5kb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCk7XG4gICAgfSwgR3IucHJvdG90eXBlLl9zZXR1cFVJID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uID0gaS5jcmVhdGUoXCJidXR0b25cIiwgXCJtYXBsaWJyZWdsLWN0cmwtZnVsbHNjcmVlbiBtYXBib3hnbC1jdHJsLWZ1bGxzY3JlZW5cIiwgdGhpcy5fY29udHJvbENvbnRhaW5lcik7XG4gICAgICBpLmNyZWF0ZShcInNwYW5cIiwgXCJtYXBsaWJyZWdsLWN0cmwtaWNvbiBtYXBib3hnbC1jdHJsLWljb25cIiwgZSkuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCBlLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLl91cGRhdGVUaXRsZSgpLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9vbkNsaWNrRnVsbHNjcmVlbiksIHQud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZnVsbHNjcmVlbmNoYW5nZSwgdGhpcy5fY2hhbmdlSWNvbik7XG4gICAgfSwgR3IucHJvdG90eXBlLl91cGRhdGVUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fZ2V0VGl0bGUoKTtcbiAgICAgIHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZnVsbHNjcmVlbkJ1dHRvbi50aXRsZSA9IHQ7XG4gICAgfSwgR3IucHJvdG90eXBlLl9nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuX2dldFVJU3RyaW5nKHRoaXMuX2lzRnVsbHNjcmVlbigpID8gXCJGdWxsc2NyZWVuQ29udHJvbC5FeGl0XCIgOiBcIkZ1bGxzY3JlZW5Db250cm9sLkVudGVyXCIpO1xuICAgIH0sIEdyLnByb3RvdHlwZS5faXNGdWxsc2NyZWVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Z1bGxzY3JlZW47XG4gICAgfSwgR3IucHJvdG90eXBlLl9jaGFuZ2VJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgKHQud2luZG93LmRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IHQud2luZG93LmRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IHQud2luZG93LmRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8IHQud2luZG93LmRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQpID09PSB0aGlzLl9jb250YWluZXIgIT09IHRoaXMuX2Z1bGxzY3JlZW4gJiYgKHRoaXMuX2Z1bGxzY3JlZW4gPSAhdGhpcy5fZnVsbHNjcmVlbiwgdGhpcy5fZnVsbHNjcmVlbkJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwibWFwbGlicmVnbC1jdHJsLXNocmlua1wiKSwgdGhpcy5fZnVsbHNjcmVlbkJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwibWFwYm94Z2wtY3RybC1zaHJpbmtcIiksIHRoaXMuX2Z1bGxzY3JlZW5CdXR0b24uY2xhc3NMaXN0LnRvZ2dsZShcIm1hcGxpYnJlZ2wtY3RybC1mdWxsc2NyZWVuXCIpLCB0aGlzLl9mdWxsc2NyZWVuQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJtYXBib3hnbC1jdHJsLWZ1bGxzY3JlZW5cIiksIHRoaXMuX3VwZGF0ZVRpdGxlKCkpO1xuICAgIH0sIEdyLnByb3RvdHlwZS5fb25DbGlja0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9pc0Z1bGxzY3JlZW4oKSA/IHQud2luZG93LmRvY3VtZW50LmV4aXRGdWxsc2NyZWVuID8gdC53aW5kb3cuZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKSA6IHQud2luZG93LmRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4gPyB0LndpbmRvdy5kb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCkgOiB0LndpbmRvdy5kb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuID8gdC53aW5kb3cuZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpIDogdC53aW5kb3cuZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbiAmJiB0LndpbmRvdy5kb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKCkgOiB0aGlzLl9jb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4gPyB0aGlzLl9jb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oKSA6IHRoaXMuX2NvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/IHRoaXMuX2NvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpIDogdGhpcy5fY29udGFpbmVyLm1zUmVxdWVzdEZ1bGxzY3JlZW4gPyB0aGlzLl9jb250YWluZXIubXNSZXF1ZXN0RnVsbHNjcmVlbigpIDogdGhpcy5fY29udGFpbmVyLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuICYmIHRoaXMuX2NvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIH07XG4gICAgdmFyIFdyID0ge1xuICAgICAgICBjbG9zZUJ1dHRvbjogITAsXG4gICAgICAgIGNsb3NlT25DbGljazogITAsXG4gICAgICAgIGZvY3VzQWZ0ZXJPcGVuOiAhMCxcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLFxuICAgICAgICBtYXhXaWR0aDogXCIyNDBweFwiXG4gICAgICB9LFxuICAgICAgWHIgPSBbXCJhW2hyZWZdXCIsIFwiW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PSctMSddKVwiLCBcIltjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSdmYWxzZSddKVwiLCBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIiwgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIiwgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCJdLmpvaW4oXCIsIFwiKSxcbiAgICAgIEhyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZnVuY3Rpb24gbyhpKSB7XG4gICAgICAgICAgZS5jYWxsKHRoaXMpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZChPYmplY3QuY3JlYXRlKFdyKSwgaSksIHQuYmluZEFsbChbXCJfdXBkYXRlXCIsIFwiX29uQ2xvc2VcIiwgXCJyZW1vdmVcIiwgXCJfb25Nb3VzZU1vdmVcIiwgXCJfb25Nb3VzZVVwXCIsIFwiX29uRHJhZ1wiXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgJiYgKG8uX19wcm90b19fID0gZSksIChvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gbywgby5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAgJiYgdGhpcy5yZW1vdmUoKSwgdGhpcy5fbWFwID0gZSwgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiB0aGlzLl9tYXAub24oXCJjbGlja1wiLCB0aGlzLl9vbkNsb3NlKSwgdGhpcy5vcHRpb25zLmNsb3NlT25Nb3ZlICYmIHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fb25DbG9zZSksIHRoaXMuX21hcC5vbihcInJlbW92ZVwiLCB0aGlzLnJlbW92ZSksIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9mb2N1c0ZpcnN0RWxlbWVudCgpLCB0aGlzLl90cmFja1BvaW50ZXIgPyAodGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKSwgdGhpcy5fbWFwLm9uKFwibW91c2V1cFwiLCB0aGlzLl9vbk1vdXNlVXApLCB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiwgXCJtYXBib3hnbC1wb3B1cC10cmFjay1wb2ludGVyXCIpLCB0aGlzLl9tYXAuX2NhbnZhc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC10cmFjay1wb2ludGVyXCIsIFwibWFwYm94Z2wtdHJhY2stcG9pbnRlclwiKSkgOiB0aGlzLl9tYXAub24oXCJtb3ZlXCIsIHRoaXMuX3VwZGF0ZSksIHRoaXMuZmlyZShuZXcgdC5FdmVudChcIm9wZW5cIikpLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5fbWFwO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgJiYgaS5yZW1vdmUodGhpcy5fY29udGVudCksIHRoaXMuX2NvbnRhaW5lciAmJiAoaS5yZW1vdmUodGhpcy5fY29udGFpbmVyKSwgZGVsZXRlIHRoaXMuX2NvbnRhaW5lciksIHRoaXMuX21hcCAmJiAodGhpcy5fbWFwLm9mZihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9mZihcIm1vdmVcIiwgdGhpcy5fb25DbG9zZSksIHRoaXMuX21hcC5vZmYoXCJjbGlja1wiLCB0aGlzLl9vbkNsb3NlKSwgdGhpcy5fbWFwLm9mZihcInJlbW92ZVwiLCB0aGlzLnJlbW92ZSksIHRoaXMuX21hcC5vZmYoXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZU1vdmUpLCB0aGlzLl9tYXAub2ZmKFwibW91c2V1cFwiLCB0aGlzLl9vbk1vdXNlVXApLCB0aGlzLl9tYXAub2ZmKFwiZHJhZ1wiLCB0aGlzLl9vbkRyYWcpLCBkZWxldGUgdGhpcy5fbWFwKSwgdGhpcy5maXJlKG5ldyB0LkV2ZW50KFwiY2xvc2VcIikpLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5nZXRMbmdMYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdDtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuc2V0TG5nTGF0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG5nTGF0ID0gdC5MbmdMYXQuY29udmVydChlKSwgdGhpcy5fcG9zID0gbnVsbCwgdGhpcy5fdHJhY2tQb2ludGVyID0gITEsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzLl9tYXAgJiYgKHRoaXMuX21hcC5vbihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZSksIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIm1hcGxpYnJlZ2wtcG9wdXAtdHJhY2stcG9pbnRlclwiLCBcIm1hcGJveGdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiksIHRoaXMuX21hcC5fY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJtYXBsaWJyZWdsLXRyYWNrLXBvaW50ZXJcIiwgXCJtYXBib3hnbC10cmFjay1wb2ludGVyXCIpKSwgdGhpcztcbiAgICAgICAgfSwgby5wcm90b3R5cGUudHJhY2tQb2ludGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFja1BvaW50ZXIgPSAhMCwgdGhpcy5fcG9zID0gbnVsbCwgdGhpcy5fdXBkYXRlKCksIHRoaXMuX21hcCAmJiAodGhpcy5fbWFwLm9mZihcIm1vdmVcIiwgdGhpcy5fdXBkYXRlKSwgdGhpcy5fbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTW91c2VNb3ZlKSwgdGhpcy5fbWFwLm9uKFwiZHJhZ1wiLCB0aGlzLl9vbkRyYWcpLCB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBsaWJyZWdsLXBvcHVwLXRyYWNrLXBvaW50ZXJcIiwgXCJtYXBib3hnbC1wb3B1cC10cmFjay1wb2ludGVyXCIpLCB0aGlzLl9tYXAuX2NhbnZhc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC10cmFjay1wb2ludGVyXCIsIFwibWFwYm94Z2wtdHJhY2stcG9pbnRlclwiKSksIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RE9NQ29udGVudCh0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlKSk7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnNldEhUTUwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbyA9IHQud2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIHIgPSB0LndpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICBmb3IgKHIuaW5uZXJIVE1MID0gZTsgaSA9IHIuZmlyc3RDaGlsZDspIG8uYXBwZW5kQ2hpbGQoaSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RE9NQ29udGVudChvKTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuZ2V0TWF4V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuc3R5bGUubWF4V2lkdGg7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnNldE1heFdpZHRoID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1heFdpZHRoID0gdCwgdGhpcy5fdXBkYXRlKCksIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLnNldERPTUNvbnRlbnQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0aGlzLl9jb250ZW50KSBmb3IgKDsgdGhpcy5fY29udGVudC5oYXNDaGlsZE5vZGVzKCk7KSB0aGlzLl9jb250ZW50LmZpcnN0Q2hpbGQgJiYgdGhpcy5fY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50LmZpcnN0Q2hpbGQpO2Vsc2UgdGhpcy5fY29udGVudCA9IGkuY3JlYXRlKFwiZGl2XCIsIFwibWFwbGlicmVnbC1wb3B1cC1jb250ZW50IG1hcGJveGdsLXBvcHVwLWNvbnRlbnRcIiwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZCh0KSwgdGhpcy5fY3JlYXRlQ2xvc2VCdXR0b24oKSwgdGhpcy5fdXBkYXRlKCksIHRoaXMuX2ZvY3VzRmlyc3RFbGVtZW50KCksIHRoaXM7XG4gICAgICAgIH0sIG8ucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHQpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuc2V0T2Zmc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9mZnNldCA9IHQsIHRoaXMuX3VwZGF0ZSgpLCB0aGlzO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS50b2dnbGVDbGFzc05hbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHJldHVybiB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnRvZ2dsZSh0KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuX2NyZWF0ZUNsb3NlQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbiAmJiAodGhpcy5fY2xvc2VCdXR0b24gPSBpLmNyZWF0ZShcImJ1dHRvblwiLCBcIm1hcGxpYnJlZ2wtcG9wdXAtY2xvc2UtYnV0dG9uIG1hcGJveGdsLXBvcHVwLWNsb3NlLWJ1dHRvblwiLCB0aGlzLl9jb250ZW50KSwgdGhpcy5fY2xvc2VCdXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMuX2Nsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJDbG9zZSBwb3B1cFwiKSwgdGhpcy5fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gXCImIzIxNTtcIiwgdGhpcy5fY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xvc2UpKTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuX29uTW91c2VVcCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlKHQucG9pbnQpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZSh0LnBvaW50KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlKHQucG9pbnQpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRoaXMuX21hcCAmJiAodGhpcy5fbG5nTGF0IHx8IHRoaXMuX3RyYWNrUG9pbnRlcikgJiYgdGhpcy5fY29udGVudCAmJiAodGhpcy5fY29udGFpbmVyIHx8ICh0aGlzLl9jb250YWluZXIgPSBpLmNyZWF0ZShcImRpdlwiLCBcIm1hcGxpYnJlZ2wtcG9wdXAgbWFwYm94Z2wtcG9wdXBcIiwgdGhpcy5fbWFwLmdldENvbnRhaW5lcigpKSwgdGhpcy5fdGlwID0gaS5jcmVhdGUoXCJkaXZcIiwgXCJtYXBsaWJyZWdsLXBvcHVwLXRpcCBtYXBib3hnbC1wb3B1cC10aXBcIiwgdGhpcy5fY29udGFpbmVyKSwgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICYmIHRoaXMub3B0aW9ucy5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBvLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0KTtcbiAgICAgICAgICB9KSwgdGhpcy5fdHJhY2tQb2ludGVyICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwbGlicmVnbC1wb3B1cC10cmFjay1wb2ludGVyXCIsIFwibWFwYm94Z2wtcG9wdXAtdHJhY2stcG9pbnRlclwiKSksIHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiB0aGlzLl9jb250YWluZXIuc3R5bGUubWF4V2lkdGggIT09IHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiAodGhpcy5fY29udGFpbmVyLnN0eWxlLm1heFdpZHRoID0gdGhpcy5vcHRpb25zLm1heFdpZHRoKSwgdGhpcy5fbWFwLnRyYW5zZm9ybS5yZW5kZXJXb3JsZENvcGllcyAmJiAhdGhpcy5fdHJhY2tQb2ludGVyICYmICh0aGlzLl9sbmdMYXQgPSBNcih0aGlzLl9sbmdMYXQsIHRoaXMuX3BvcywgdGhpcy5fbWFwLnRyYW5zZm9ybSkpLCAhdGhpcy5fdHJhY2tQb2ludGVyIHx8IGUpKSB7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuX3BvcyA9IHRoaXMuX3RyYWNrUG9pbnRlciAmJiBlID8gZSA6IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2xuZ0xhdCksXG4gICAgICAgICAgICAgIGEgPSB0aGlzLm9wdGlvbnMuYW5jaG9yLFxuICAgICAgICAgICAgICBuID0gZnVuY3Rpb24gZShpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoLjUgKiBNYXRoLnBvdyhpLCAyKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjogbmV3IHQuUG9pbnQoMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgdG9wOiBuZXcgdC5Qb2ludCgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICBcInRvcC1sZWZ0XCI6IG5ldyB0LlBvaW50KG8sIG8pLFxuICAgICAgICAgICAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IG5ldyB0LlBvaW50KC1vLCBvKSxcbiAgICAgICAgICAgICAgICAgICAgICBib3R0b206IG5ldyB0LlBvaW50KDAsIC1pKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IG5ldyB0LlBvaW50KG8sIC1vKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImJvdHRvbS1yaWdodFwiOiBuZXcgdC5Qb2ludCgtbywgLW8pLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5ldyB0LlBvaW50KGksIDApLFxuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXcgdC5Qb2ludCgtaSwgMClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpIGluc3RhbmNlb2YgdC5Qb2ludCB8fCBBcnJheS5pc0FycmF5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdC5Qb2ludC5jb252ZXJ0KGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIGNlbnRlcjogcixcbiAgICAgICAgICAgICAgICAgICAgICB0b3A6IHIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0b3AtbGVmdFwiOiByLFxuICAgICAgICAgICAgICAgICAgICAgIFwidG9wLXJpZ2h0XCI6IHIsXG4gICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYm90dG9tLWxlZnRcIjogcixcbiAgICAgICAgICAgICAgICAgICAgICBcImJvdHRvbS1yaWdodFwiOiByLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHIsXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjogdC5Qb2ludC5jb252ZXJ0KGkuY2VudGVyIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdC5Qb2ludC5jb252ZXJ0KGkudG9wIHx8IFswLCAwXSksXG4gICAgICAgICAgICAgICAgICAgIFwidG9wLWxlZnRcIjogdC5Qb2ludC5jb252ZXJ0KGlbXCJ0b3AtbGVmdFwiXSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgICAgICBcInRvcC1yaWdodFwiOiB0LlBvaW50LmNvbnZlcnQoaVtcInRvcC1yaWdodFwiXSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHQuUG9pbnQuY29udmVydChpLmJvdHRvbSB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgICAgICBcImJvdHRvbS1sZWZ0XCI6IHQuUG9pbnQuY29udmVydChpW1wiYm90dG9tLWxlZnRcIl0gfHwgWzAsIDBdKSxcbiAgICAgICAgICAgICAgICAgICAgXCJib3R0b20tcmlnaHRcIjogdC5Qb2ludC5jb252ZXJ0KGlbXCJib3R0b20tcmlnaHRcIl0gfHwgWzAsIDBdKSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdC5Qb2ludC5jb252ZXJ0KGkubGVmdCB8fCBbMCwgMF0pLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdC5Qb2ludC5jb252ZXJ0KGkucmlnaHQgfHwgWzAsIDBdKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUobmV3IHQuUG9pbnQoMCwgMCkpO1xuICAgICAgICAgICAgICB9KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICAgIHZhciBzLFxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgIHMgPSByLnkgKyBuLmJvdHRvbS55IDwgYyA/IFtcInRvcFwiXSA6IHIueSA+IHRoaXMuX21hcC50cmFuc2Zvcm0uaGVpZ2h0IC0gYyA/IFtcImJvdHRvbVwiXSA6IFtdLCByLnggPCBsIC8gMiA/IHMucHVzaChcImxlZnRcIikgOiByLnggPiB0aGlzLl9tYXAudHJhbnNmb3JtLndpZHRoIC0gbCAvIDIgJiYgcy5wdXNoKFwicmlnaHRcIiksIGEgPSAwID09PSBzLmxlbmd0aCA/IFwiYm90dG9tXCIgOiBzLmpvaW4oXCItXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUgPSByLmFkZChuW2FdKS5yb3VuZCgpO1xuICAgICAgICAgICAgaS5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCBMclthXSArIFwiIHRyYW5zbGF0ZShcIiArIHUueCArIFwicHgsXCIgKyB1LnkgKyBcInB4KVwiKSwgUnIodGhpcy5fY29udGFpbmVyLCBhLCBcInBvcHVwXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgby5wcm90b3R5cGUuX2ZvY3VzRmlyc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9jdXNBZnRlck9wZW4gJiYgdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFhyKTtcbiAgICAgICAgICAgIHQgJiYgdC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgby5wcm90b3R5cGUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSwgbztcbiAgICAgIH0odC5FdmVudGVkKSxcbiAgICAgIEtyID0ge1xuICAgICAgICB2ZXJzaW9uOiB0LnZlcnNpb24sXG4gICAgICAgIHN1cHBvcnRlZDogZSxcbiAgICAgICAgc2V0UlRMVGV4dFBsdWdpbjogdC5zZXRSVExUZXh0UGx1Z2luLFxuICAgICAgICBnZXRSVExUZXh0UGx1Z2luU3RhdHVzOiB0LmdldFJUTFRleHRQbHVnaW5TdGF0dXMsXG4gICAgICAgIE1hcDogU3IsXG4gICAgICAgIE5hdmlnYXRpb25Db250cm9sOiBEcixcbiAgICAgICAgR2VvbG9jYXRlQ29udHJvbDogTnIsXG4gICAgICAgIEF0dHJpYnV0aW9uQ29udHJvbDogeXIsXG4gICAgICAgIFNjYWxlQ29udHJvbDogcXIsXG4gICAgICAgIEZ1bGxzY3JlZW5Db250cm9sOiBHcixcbiAgICAgICAgUG9wdXA6IEhyLFxuICAgICAgICBNYXJrZXI6IEJyLFxuICAgICAgICBTdHlsZTogamUsXG4gICAgICAgIExuZ0xhdDogdC5MbmdMYXQsXG4gICAgICAgIExuZ0xhdEJvdW5kczogdC5MbmdMYXRCb3VuZHMsXG4gICAgICAgIFBvaW50OiB0LlBvaW50LFxuICAgICAgICBNZXJjYXRvckNvb3JkaW5hdGU6IHQuTWVyY2F0b3JDb29yZGluYXRlLFxuICAgICAgICBFdmVudGVkOiB0LkV2ZW50ZWQsXG4gICAgICAgIGNvbmZpZzogdC5jb25maWcsXG4gICAgICAgIHByZXdhcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBGdCgpLmFjcXVpcmUoUnQpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclByZXdhcm1lZFJlc291cmNlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0ID0gQnQ7XG4gICAgICAgICAgdCAmJiAodC5pc1ByZWxvYWRlZCgpICYmIDEgPT09IHQubnVtQWN0aXZlKCkgPyAodC5yZWxlYXNlKFJ0KSwgQnQgPSBudWxsKSA6IGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBjbGVhciBXZWJXb3JrZXJzIHNpbmNlIHRoZXJlIGFyZSBhY3RpdmUgTWFwIGluc3RhbmNlcyB0aGF0IHN0aWxsIHJlZmVyZW5jZSBpdC4gVGhlIHByZS13YXJtZWQgV2ViV29ya2VyIHBvb2wgY2FuIG9ubHkgYmUgY2xlYXJlZCB3aGVuIGFsbCBtYXAgaW5zdGFuY2VzIGhhdmUgYmVlbiByZW1vdmVkIHdpdGggbWFwLnJlbW92ZSgpXCIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAgIHJldHVybiB0LmNvbmZpZy5BQ0NFU1NfVE9LRU47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBhY2Nlc3NUb2tlbihlKSB7XG4gICAgICAgICAgdC5jb25maWcuQUNDRVNTX1RPS0VOID0gZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGJhc2VBcGlVcmwoKSB7XG4gICAgICAgICAgcmV0dXJuIHQuY29uZmlnLkFQSV9VUkw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBiYXNlQXBpVXJsKGUpIHtcbiAgICAgICAgICB0LmNvbmZpZy5BUElfVVJMID0gZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHdvcmtlckNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBrdC53b3JrZXJDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHdvcmtlckNvdW50KHQpIHtcbiAgICAgICAgICBrdC53b3JrZXJDb3VudCA9IHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBtYXhQYXJhbGxlbEltYWdlUmVxdWVzdHMoKSB7XG4gICAgICAgICAgcmV0dXJuIHQuY29uZmlnLk1BWF9QQVJBTExFTF9JTUFHRV9SRVFVRVNUUztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG1heFBhcmFsbGVsSW1hZ2VSZXF1ZXN0cyhlKSB7XG4gICAgICAgICAgdC5jb25maWcuTUFYX1BBUkFMTEVMX0lNQUdFX1JFUVVFU1RTID0gZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJTdG9yYWdlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHQuY2xlYXJUaWxlQ2FjaGUoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtlclVybDogXCJcIixcbiAgICAgICAgYWRkUHJvdG9jb2w6IGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgdC5jb25maWcuUkVHSVNURVJFRF9QUk9UT0NPTFNbZV0gPSBpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVQcm90b2NvbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBkZWxldGUgdC5jb25maWcuUkVHSVNURVJFRF9QUk9UT0NPTFNbZV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgcmV0dXJuIEtyO1xuICB9KTtcblxuICAvL1xuXG4gIHJldHVybiBtYXBsaWJyZWdsO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40111\n')}}]);